{
  "golf_examples": [
    {
      "id": 0,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 9,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 18,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 27,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 36,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 57,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  \u00b7 exact Subsingleton.allEq ..\r\n",
      "body": "```suggestion\r\n  \u00b7 exact Subsingleton.allEq ..\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 62,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  simp [\u2190 degree_preimage_nsmul, hn]\r\n",
      "body": "You are missing the following lemmas\r\n```lean\r\nopen scoped Pointwise in\r\nlemma exists_le_degree_eq {\u03c3 : Type*} (f : \u03c3 \u2192\u2080 \u2115) (n : \u2115) (hn : n \u2264 f.degree) :\r\n    \u2203 g \u2264 f, g.degree = n := by\r\n  induction n with\r\n  | zero => simp [degree_eq_zero_iff]\r\n  | succ n IH =>\r\n    obtain \u27e8g, hgf, rfl\u27e9 := IH (by lia)\r\n    obtain \u27e8f, rfl\u27e9 := le_iff_exists_add.mp hgf\r\n    obtain \u27e8i, hi\u27e9 : f.support.Nonempty := by aesop\r\n    exact \u27e8g + .single i 1, add_le_add_right (by simp; grind) _, by simp\u27e9\r\n\r\nopen scoped Poi",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "exact",
          "grind",
          "obtain",
          "induction",
          "simp_all",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 63,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  \u00b7 simp [hn]\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [hn]\r\n```\r\nIf you add this as a simp lemma\r\n```lean\r\n@[simp]\r\nlemma Set.Ici_zero {\u03b1 : Type*} [AddZeroClass \u03b1] [Preorder \u03b1] [CanonicallyOrderedAdd \u03b1] :\r\n    Set.Ici (0 : \u03b1) = Set.univ := by aesop\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 70,
      "before_code": "hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\nend Dense",
      "suggestion": "  \u27e8fun h \u21a6 by simpa using congr($h\u15ee), fun h \u21a6 congr($h\u15ee)\u27e9\n",
      "body": "```suggestion\n  \u27e8fun h \u21a6 by simpa using congr($h\u15ee), fun h \u21a6 congr($h\u15ee)\u27e9\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "congr"
        ],
        "new_tactics": [
          "simpa",
          "congr"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "inner_zero_right",
          "end",
          "Dense",
          "eq_of_inner_right"
        ]
      }
    },
    {
      "id": 71,
      "before_code": "hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\nend Dense",
      "suggestion": "theorem orthogonal_injective [CompleteSpace E] :\n    Function.Injective (fun K : ClosedSubmodule \ud835\udd5c E \u21a6 K\u15ee) :=\n  (orthogonal_eq_orthogonal_iff \u00b7 \u00b7 |>.mp)\n\n/-- The sup of two orthogonal subspaces equals the subspace orthogonal\nto the inf. -/\ntheorem sup_orthogonal [CompleteSpace E] (K\u2081 K\u2082 : ClosedSubmodule \ud835\udd5c E) :\n    K\u2081\u15ee \u2294 K\u2082\u15ee = (K\u2081 \u2293 K\u2082)\u15ee := by\n  simpa using congr($(inf_orthogonal K\u2081\u15ee K\u2082\u15ee)\u15ee).symm\n",
      "body": "Here's a another `simpa` proof, and let's have this `orthogonal_injective` lemma too.\n```suggestion\ntheorem orthogonal_injective [CompleteSpace E] :\n    Function.Injective (fun K : ClosedSubmodule \ud835\udd5c E \u21a6 K\u15ee) :=\n  (orthogonal_eq_orthogonal_iff \u00b7 \u00b7 |>.mp)\n\n/-- The sup of two orthogonal subspaces equals the subspace orthogonal\nto the inf. -/\ntheorem sup_orthogonal [CompleteSpace E] (K\u2081 K\u2082 : ClosedSubmodule \ud835\udd5c E) :\n    K\u2081\u15ee \u2294 K\u2082\u15ee = (K\u2081 \u2293 K\u2082)\u15ee := by\n  simpa using congr($(inf_orthogonal K\u2081\u15ee K\u2082\u15ee)\u15ee).symm\n`",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "congr",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "congr"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "inner_zero_right",
          "end",
          "Dense",
          "eq_of_inner_right"
        ]
      }
    },
    {
      "id": 72,
      "before_code": "theorem continuous_closure : Continuous (Closeds.closure (\u03b1 := \u03b1)) :=\n  uniformContinuous_closure.continuous",
      "suggestion": "instance [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) where\n  isCompact_univ := by simpa [gi.l_surjective.range_eq]\n    using isCompact_univ.image continuous_closure\n",
      "body": "```suggestion\ninstance [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) where\n  isCompact_univ := by simpa [gi.l_surjective.range_eq]\n    using isCompact_univ.image continuous_closure\n```",
      "path": "Mathlib/Topology/UniformSpace/Closeds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "theorem",
          "closure",
          "continuous_closure",
          "continuous",
          "Closeds",
          "Continuous",
          "uniformContinuous_closure"
        ]
      }
    },
    {
      "id": 78,
      "before_code": "instance isRegularEpi_of_extremalEpi (f : X \u27f6 Y) [ExtremalEpi f] : IsRegularEpi f :=\n  \u27e8\u27e8regularEpiOfExtremalEpi f\u27e9\u27e9",
      "suggestion": "noncomputable def frobeniusMorphism :\n  underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n  (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip.lift\n    ((ofLE _ _ (inf_le_right A' ((Subobject.pullback f).obj B'))) \u226b (pullback\u03c0 _ _))\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))) \u226b (imageFactorisation f A').F.e)\n    (by simp [\u2190 imageFactorisation_F_m, (isPullback _ _).w])\n\nlemma frobeniusMorphism_isPullback :\n  IsPullback (frobeniusMorphism f A' B')\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))))\n    ((ofLE _ _ (inf_le_left ((\u00abexists\u00bb f).obj A') B')))\n    (imageFactorisation _ _).F.e := by\n  apply IsPullback.of_right (t := (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip)\n    (p := by simp [frobeniusMorphism])\n  simpa [frobeniusMorphism, IsPullback.lift_fst, \u2190 imageFactorisation_F_m,\n    (isPullback f B').paste_horiz_iff ] using\n    (inf_isPullback A' ((Subobject.pullback f).obj B')).flip\n\ninstance : IsRegula",
      "body": "```suggestion\nnoncomputable def frobeniusMorphism :\n  underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n  (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip.lift\n    ((ofLE _ _ (inf_le_right A' ((Subobject.pullback f).obj B'))) \u226b (pullback\u03c0 _ _))\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))) \u226b (imageFactorisation f A').F.e)\n    (by simp [\u2190 imageFactorisation_F_m, (isPullback _ _).w])\n\nlemma frobeniusMorphism_isPullback :\n  IsPullbac",
      "path": "Mathlib/CategoryTheory/RegularCategory/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "rw",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "IsRegularEpi",
          "regularEpiOfExtremalEpi",
          "isRegularEpi_of_extremalEpi",
          "instance",
          "ExtremalEpi"
        ]
      }
    },
    {
      "id": 81,
      "before_code": "p.darts[i].snd = p.support.tail[i]'(by grind) := by\n  grind [map_snd_darts]",
      "suggestion": "lemma support_getElem_zero (p : G.Walk u v) : p.support[0] = u := by cases p <;> simp\n",
      "body": "```suggestion\nlemma support_getElem_zero (p : G.Walk u v) : p.support[0] = u := by cases p <;> simp\n```\nThis seems to work for me",
      "path": "Mathlib/Combinatorics/SimpleGraph/Walks/Basic.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "grind"
        ],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support",
          "map_snd_darts",
          "grind",
          "tail",
          "snd",
          "darts"
        ]
      }
    },
    {
      "id": 82,
      "before_code": "Sbtw R w x y :=\n  \u27e8h\u2081.wbtw.trans_right_left h\u2082.wbtw, h\u2081.ne_left, h\u2082.left_ne\u27e9",
      "suggestion": "\r\n    \u00b7 constructor\r\n      \u00b7 apply div_nonneg (mul_nonneg ht\u2081.1 ht\u2082.1)\r\n        nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n      \u00b7 apply div_le_one_of_le\u2080\r\n        \u00b7 grind\r\n        \u00b7 nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n",
      "body": "```suggestion\r\n    \u00b7 constructor\r\n      \u00b7 apply div_nonneg (mul_nonneg ht\u2081.1 ht\u2082.1)\r\n        nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n      \u00b7 apply div_le_one_of_le\u2080\r\n        \u00b7 grind\r\n        \u00b7 nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n```",
      "path": "Mathlib/Analysis/Convex/Between.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "nlinarith",
          "apply",
          "grind",
          "constructor"
        ],
        "body_tactics": [
          "nlinarith",
          "apply",
          "grind",
          "constructor"
        ],
        "new_tactics": [
          "nlinarith",
          "apply",
          "grind",
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "wbtw",
          "trans_right_left",
          "Sbtw",
          "ne_left",
          "left_ne"
        ]
      }
    },
    {
      "id": 91,
      "before_code": "\u03c9ScottContinuous.of_monotone_map_\u03c9Sup\n    \u27e8fun _ _ h \u21a6 hf.monotone h a, fun c \u21a6 congr_fun (hf.map_\u03c9Sup c) a\u27e9",
      "suggestion": "\r\nlemma \u03c9ScottContinuous.apply (x : \u03b1) : \u03c9ScottContinuous (fun f : \u2200 x, \u03b2 x \u21a6 f x) :=\r\n",
      "body": "```suggestion\r\nlemma \u03c9ScottContinuous.apply (x : \u03b1) : \u03c9ScottContinuous (fun f : \u2200 x, \u03b2 x \u21a6 f x) :=\r\n```",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "monotone",
          "congr_fun"
        ]
      }
    },
    {
      "id": 94,
      "before_code": "simpa [map_coe, OrderHom.coe_mk, Set.range_comp]\n    using hf (by simp) (Set.range_nonempty _) (isChain_range c).directedOn (isLUB_range_\u03c9Sup c)",
      "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```\r\nThis way, the `fun_id` lemma is also tagged with fun_prop.",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "OrderHom",
          "range_comp",
          "map_coe",
          "coe_mk",
          "Set",
          "directedOn",
          "simpa",
          "simp",
          "range_nonempty",
          "isChain_range",
          "using"
        ]
      }
    },
    {
      "id": 95,
      "before_code": "inter_eq_self_of_subset_right (Ici_subset_Ici.2 hab)]\n  exact isLeast_Ici\n\n@[simp] lemma ScottContinuousOn.id : ScottContinuousOn D (id : \u03b1 \u2192 \u03b1) := by simp [ScottContinuousOn]\n\nvariable {g : \u03b1 \u2192 \u03b2}\n\nlemma ScottContinuousOn.prodMk (hD : \u2200 a b : \u03b1, a \u2264 b \u2192 {a, b} \u2208 D)",
      "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```",
      "path": "Mathlib/Order/ScottContinuity.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "continuity",
          "set_theory"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "Ici_subset_Ici",
          "inter_eq_self_of_subset_right",
          "lemma",
          "variable",
          "exact",
          "ScottContinuousOn",
          "hab",
          "isLeast_Ici",
          "simp",
          "prodMk"
        ]
      }
    },
    {
      "id": 97,
      "before_code": "theorem \u03c9Sup_zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : \u03c9Sup (c\u2080.zip c\u2081) = (\u03c9Sup c\u2080, \u03c9Sup c\u2081) := rfl",
      "suggestion": "    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n",
      "body": "Something like\n```suggestion\n    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n```\nshould work, and then you can remove the `by exact` and (probably) format everything on one line.",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "rfl",
          "Chain",
          "zip",
          "theorem"
        ]
      }
    },
    {
      "id": 114,
      "before_code": "* `s`: a reference to the mutable `AtomM` state, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options",
      "suggestion": "\r\n  Reason: it would cause `simp` to cache results too aggressively.\r\n",
      "body": "```suggestion\r\n  Reason: it would cause `simp` to cache results too aggressively.\r\n```",
      "path": "Mathlib/Util/AtomM/Recurse.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "persisting",
          "ordering",
          "This",
          "cfg",
          "options",
          "consistently",
          "used",
          "configuration",
          "mutable",
          "ensures",
          "that",
          "across",
          "for",
          "state",
          "AtomM",
          "calls",
          "atom",
          "reference"
        ]
      }
    },
    {
      "id": 116,
      "before_code": "obtain \u27e8s, rfl\u27e9 := hN\n    induction s using Finset.induction with\n    | empty =>\n      rw [Finset.coe_empty, Submodule.span_empty, \u2190 Submodule.span_zero_singleton]\n      exact h\u2081 _\n    | insert _ _ _ ih =>\n      rw [Finset.coe_insert, Submodule.span_insert]\n      exact h\u2082 _ _ (h\u2081 _) ih\n\ntheorem fg_restrictScalars {R S M : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommMonoid M] [Module S M] [Module R M] [IsScalarTower R S M] (N : Submodule S M)\n    (hfin : N.FG) (h : Function.Surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).FG := by\n  obtain \u27e8X, rfl\u27e9 := hfin\n  use X\n  exact (Submodule.restrictScalars_span R S h (X : Set M)).symm\n\nlemma FG.of_restrictScalars (R) {A M} [Semiring R] [Semiring A] [AddCommMonoid M]\n    [SMul R A] [Module R M] [Module A M] [IsScalarTower R A M] (S : Submodule A M)\n    (hS : (S.restrictScalars R).FG) : S.FG := by\n  obtain \u27e8s, e\u27e9 := hS\n  refine \u27e8s, Submodule.restrictScalars_injective R _ _ (le_antisymm ?_ ?_)\u27e9\n  \u00b7 change Submodule.span A s \u2264 S\n    have := Submodule.span_le.mp e.le\n    rwa [Submodule.span_le]\n  \u00b7 rw [\u2190 e]\n    exact Submodule.span_le_restrictScalars _ _ _\n\ntheorem FG.stabilizes_of_iSup_eq {M' : Submodule R M} (hM' : M'.FG) (N : \u2115 \u2192o Submodule R M)\n    (H : iSup N = M') : \u2203 n, M' = N n := by\n  obtain \u27e8S, hS\u27e9 := hM'\n  have : \u2200 s : S, \u2203 n, (s : M) \u2208 N n := fun s =>\n    (Submodule.mem_iSup_of_chain N s).mp\n      (by\n        rw [H, \u2190 hS]\n        exact Submodule.subset_span s.2)",
      "suggestion": "\r\n  have (s : S) : \u2203 n, (s : M) \u2208 N n :=\r\n    (mem_iSup_of_chain N s).mp (by simpa [H, \u2190 hS] using subset_span s.prop)\r\n",
      "body": "```suggestion\r\n  have (s : S) : \u2203 n, (s : M) \u2208 N n :=\r\n    (mem_iSup_of_chain N s).mp (by simpa [H, \u2190 hS] using subset_span s.prop)\r\n```",
      "path": "Mathlib/RingTheory/Finiteness/Basic.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "induction"
        ],
        "suggestion_tactics": [
          "simpa",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "have"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "refine",
          "exact",
          "obtain",
          "induction",
          "rw"
        ],
        "topics": [
          "function",
          "nat",
          "algebra",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Module",
          "lemma",
          "rwa",
          "fg_restrictScalars",
          "le_antisymm",
          "Type",
          "change",
          "obtain",
          "of_restrictScalars",
          "Function",
          "span_zero_singleton",
          "coe_empty",
          "empty",
          "insert",
          "restrictScalars",
          "symm",
          "refine",
          "span_insert",
          "Finset",
          "have",
          "Submodule",
          "span_empty",
          "mem_iSup_of_chain",
          "span_le_restrictScalars",
          "CommSemiring",
          "restrictScalars_injective",
          "hfin",
          "span",
          "stabilizes_of_iSup_eq",
          "Semiring",
          "induction",
          "rfl",
          "use",
          "subset_span",
          "AddCommMonoid",
          "theorem",
          "IsScalarTower",
          "exact",
          "Set",
          "iSup",
          "coe_insert",
          "restrictScalars_span",
          "SMul",
          "algebraMap",
          "Algebra",
          "Surjective",
          "span_le",
          "using"
        ]
      }
    },
    {
      "id": 124,
      "before_code": "namespace Complex\n\n/-- If `f` is complex differentiable on an open disc with center `c` and radius `R > 0` and is\ncontinuous on its closure, then `f' c` can be represented as an integral over the corresponding\ncircle.\n\nTODO: add a version for `w \u2208 Metric.ball c R`.\n\nTODO: add a version for higher derivatives. -/\ntheorem deriv_eq_smul_circleIntegral [CompleteSpace F] {R : \u211d} {c : \u2102} {f : \u2102 \u2192 F} (hR : 0 < R)\n    (hf : DiffContOnCl \u2102 f (ball c R)) :\n    deriv f c = (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e z in C(c, R), (z - c) ^ (-2 : \u2124) \u2022 f z := by\n  lift R to \u211d\u22650 using hR.le\n  refine (hf.hasFPowerSeriesOnBall hR).hasFPowerSeriesAt.deriv.trans ?_\n  simp only [cauchyPowerSeries_apply, one_div, zpow_neg, pow_one, smul_smul, zpow_two, mul_inv]\n\ntheorem norm_deriv_le_aux [CompleteSpace F] {c : \u2102} {R C : \u211d} {f : \u2102 \u2192 F} (hR : 0 < R)\n    (hf : DiffContOnCl \u2102 f (ball c R)) (hC : \u2200 z \u2208 sphere c R, \u2016f z\u2016 \u2264 C) :\n    \u2016deriv f c\u2016 \u2264 C / R := by\n  have : \u2200 z \u2208 sphere c R, \u2016(z - c) ^ (-2 : \u2124) \u2022 f z\u2016 \u2264 C / (R * R) :=\n    fun z (hz : \u2016z - c\u2016 = R) => by\n    simpa [-mul_inv_rev, norm_smul, hz, zpow_two, \u2190 div_eq_inv_mul] using\n      (div_le_div_iff_of_pos_right (mul_pos hR hR)).2 (hC z hz)",
      "suggestion": "\r\n    rw [\u2190 inv_smul_smul\u2080 two_pi_I_ne_zero (deriv f c)]\r\n    simp [\u2190 (DiffContOnCl.deriv_eq_smul_circleIntegral hR hf), zpow_ofNat]\r\n",
      "body": "alternative proof (matter of taste really):\r\n```suggestion\r\n    rw [\u2190 inv_smul_smul\u2080 two_pi_I_ne_zero (deriv f c)]\r\n    simp [\u2190 (DiffContOnCl.deriv_eq_smul_circleIntegral hR hf), zpow_ofNat]\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "refine",
          "have",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simpa",
          "have",
          "refine"
        ],
        "topics": [
          "continuity",
          "real",
          "complex",
          "norm",
          "differentiability",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "CompleteSpace",
          "norm_deriv_le_aux",
          "its",
          "closure",
          "complex",
          "deriv_eq_smul_circleIntegral",
          "Metric",
          "lift",
          "represented",
          "open",
          "center",
          "TODO",
          "circle",
          "add",
          "derivatives",
          "mul_inv",
          "refine",
          "Complex",
          "div_eq_inv_mul",
          "norm_smul",
          "corresponding",
          "have",
          "mul_inv_rev",
          "differentiable",
          "zpow_neg",
          "smul_smul",
          "pow_one",
          "for",
          "hasFPowerSeriesOnBall",
          "can",
          "radius",
          "hasFPowerSeriesAt",
          "then",
          "deriv",
          "over",
          "simp",
          "cauchyPowerSeries_apply",
          "zpow_two",
          "version",
          "disc",
          "namespace",
          "only",
          "div_le_div_iff_of_pos_right",
          "mul_pos",
          "DiffContOnCl",
          "theorem",
          "sphere",
          "higher",
          "continuous",
          "simpa"
        ]
      }
    },
    {
      "id": 125,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n        rw [\u2190 (DiffContOnCl.circleIntegral_one_div_sub_center_pow_smul hR n hf)]\r\n",
      "body": "Please keep indentation consistent inside `calc` blocks, it aids readability. \r\n\r\nIf you're using `congr` followed by `exact`, it's worth trying whether `rw` (or `simp_rw`, `simp only` etc) can do it in one line:\r\n```suggestion\r\n        rw [\u2190 (DiffContOnCl.circleIntegral_one_div_sub_center_pow_smul hR n hf)]\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 126,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n      rw [RCLike.norm_nsmul (K := \u2102), nsmul_eq_mul, mul_le_mul_iff_right\u2080 (by positivity)]\r\n      exact circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const hR.le hp\r\n",
      "body": "```suggestion\r\n      rw [RCLike.norm_nsmul (K := \u2102), nsmul_eq_mul, mul_le_mul_iff_right\u2080 (by positivity)]\r\n      exact circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const hR.le hp\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 127,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n  have hp (z) (hz : \u2016z - c\u2016 = R) : \u2016(z - c)\u207b\u00b9 ^ (n + 1) \u2022 f z\u2016 \u2264 C / (R ^ n  * R) := by\r\n    simpa [norm_smul, hz, \u2190 div_eq_inv_mul]\r\n      using (div_le_div_iff_of_pos_right (mul_pos (pow_pos hR n) hR)).2 (hC z hz)\r\n",
      "body": "You can introduce variables in a `have` statement, just like you can for theorems; then you don't need to intro them manually in the proof. Also, technically the `simp` here is non-terminal, which is against mathlib rules; but you can combine the `simp` and the following `exact` into a single statement with `simpa using`:\r\n```suggestion\r\n  have hp (z) (hz : \u2016z - c\u2016 = R) : \u2016(z - c)\u207b\u00b9 ^ (n + 1) \u2022 f z\u2016 \u2264 C / (R ^ n  * R) := by\r\n    simpa [norm_smul, hz, \u2190 div_eq_inv_mul]\r\n      using (div_le_div_if",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 137,
      "before_code": "case g2 => simp [Equiv.toPEquiv_apply]\n  case g3 => simp [Equiv.toPEquiv_apply, \u2190 Equiv.eq_symm_apply]",
      "suggestion": "\r\nlemma rowStochastic_inf_colStochastic :\r\n    rowStochastic R n \u2293 colStochastic R n = doublyStochastic R n := by\r\n  ext M\r\n  simp only [rowStochastic, colStochastic, Submonoid.mem_inf, Submonoid.mem_mk, Subsemigroup.mem_mk,\r\n    Set.mem_setOf_eq, doublyStochastic]\r\n  grind\r\n",
      "body": "I would phrase this as an equality of submonoids. Also, `grind` is a pretty nice tactic. I suggest that you try to play around with it and read about it to learn its power.\r\n\r\nCan you also move this much closer to the top of the file and use it to golf some of the other results in this file? (e.g., `convex_doublyStochastic` and `permMatrix_mem_doublyStochastic`)\r\n```suggestion\r\nlemma rowStochastic_inf_colStochastic :\r\n    rowStochastic R n \u2293 colStochastic R n = doublyStochastic R n := by\r\n  ext ",
      "path": "Mathlib/Data/Matrix/DoublyStochastic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "grind",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "grind",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "eq_symm_apply",
          "Equiv",
          "case",
          "simp",
          "toPEquiv_apply"
        ]
      }
    },
    {
      "id": 142,
      "before_code": "simp only [mem_adjoin_iff_div, Algebra.adjoin_singleton_eq_range_aeval,\n    AlgHom.mem_range, exists_exists_eq_and]",
      "suggestion": "\r\ntheorem forall_mem_adjoin_smul_eq_self_iff {M : Type*} [Group M] [MulSemiringAction M E]\r\n    [SMulCommClass M F E] (m : M) :\r\n    (\u2200 x \u2208 adjoin F S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) := by\r\n  refine \u27e8fun h x hx \u21a6 h _ <| mem_adjoin_of_mem F hx, fun h x hx \u21a6 ?_\u27e9\r\n  induction hx using adjoin_induction F <;> simp_all [smul_inv\u2080']\r\n",
      "body": "Here is an almost working suggestion:\r\n```suggestion\r\ntheorem forall_mem_adjoin_smul_eq_self_iff {M : Type*} [Group M] [MulSemiringAction M E]\r\n    [SMulCommClass M F E] (m : M) :\r\n    (\u2200 x \u2208 adjoin F S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) := by\r\n  refine \u27e8fun h x hx \u21a6 h _ <| mem_adjoin_of_mem F hx, fun h x hx \u21a6 ?_\u27e9\r\n  induction hx using adjoin_induction F <;> simp_all [smul_inv\u2080']\r\n```\r\nThe problem is that this requires `M` to be a group because [smul_inv\u2080'](https://leanprover-community.github.io",
      "path": "Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "induction",
          "simp_all"
        ],
        "body_tactics": [
          "refine",
          "induction",
          "simp_all"
        ],
        "new_tactics": [
          "simp_all",
          "induction",
          "refine"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "mem_adjoin_iff_div",
          "mem_range",
          "exists_exists_eq_and",
          "simp",
          "AlgHom",
          "adjoin_singleton_eq_range_aeval",
          "Algebra",
          "only"
        ]
      }
    },
    {
      "id": 161,
      "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
      "suggestion": "  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n",
      "body": "```suggestion\n  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n```",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "nullMeasurable",
          "g_mble",
          "Set",
          "Countable",
          "Measurable"
        ]
      }
    },
    {
      "id": 162,
      "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
      "suggestion": "  apply ae_sum_iff.2 (fun n \u21a6 (hD n s hs).trans ?_)\n",
      "body": "```suggestion\n  apply ae_sum_iff.2 (fun n \u21a6 (hD n s hs).trans ?_)\n```",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "nullMeasurable",
          "g_mble",
          "Set",
          "Countable",
          "Measurable"
        ]
      }
    },
    {
      "id": 181,
      "before_code": "apply nontrivial h1\n  simp [ENat.card_eq_coe_natCard \u03b1, h2]",
      "suggestion": "\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Set.ncard_eq_zero, \u2190 card_coe_set_eq, Combination.card, Nat.choose_eq_zero_iff]\r\n",
      "body": "We just seem to be missing an instance `Finite (Combination \u03b1 n)`. Can you add it?\r\n```suggestion\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Set.ncard_eq_zero, \u2190 card_coe_set_eq, Combination.card, Nat.choose_eq_zero_iff]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "have"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "card_eq_coe_natCard",
          "simp",
          "nontrivial",
          "ENat"
        ]
      }
    },
    {
      "id": 182,
      "before_code": "apply nontrivial h1\n  simp [ENat.card_eq_coe_natCard \u03b1, h2]",
      "suggestion": "\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Finite.one_lt_card_iff_nontrivial, Combination.card, Nat.one_lt_iff_ne_zero_and_ne_one,\r\n    ne_eq, Nat.choose_eq_zero_iff, ne_eq, Nat.choose_eq_one_iff]\r\n  grind\r\n",
      "body": "```suggestion\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Finite.one_lt_card_iff_nontrivial, Combination.card, Nat.one_lt_iff_ne_zero_and_ne_one,\r\n    ne_eq, Nat.choose_eq_zero_iff, ne_eq, Nat.choose_eq_one_iff]\r\n  grind\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "rw",
          "have"
        ],
        "body_tactics": [
          "grind",
          "rw",
          "have"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "apply",
          "card_eq_coe_natCard",
          "simp",
          "nontrivial",
          "ENat"
        ]
      }
    },
    {
      "id": 184,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  have : Finite \u03b1 := Nat.finite_of_card_ne_zero (Nat.ne_zero_of_lt hn)\r\n",
      "body": "I think it's slightly cleaner to inline here.\r\n```suggestion\r\n  have : Finite \u03b1 := Nat.finite_of_card_ne_zero (Nat.ne_zero_of_lt hn)\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 185,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  have : IsPretransitive (Equiv.Perm \u03b1) (n.Combination \u03b1) := Combination.isPretransitive \u03b1\r\n  -- The type on which the group acts is nontrivial.\r\n  have : Nontrivial (n.Combination \u03b1) := Combination.nontrivial' h_one_le hn\r\n",
      "body": "```suggestion\r\n  have : IsPretransitive (Equiv.Perm \u03b1) (n.Combination \u03b1) := Combination.isPretransitive \u03b1\r\n  -- The type on which the group acts is nontrivial.\r\n  have : Nontrivial (n.Combination \u03b1) := Combination.nontrivial' h_one_le hn\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 186,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  \u00b7 rw [Set.nonempty_compl, ne_eq, Set.eq_univ_iff_ncard, ncard_eq]\r\n    exact hn.ne\r\n",
      "body": "```suggestion\r\n  \u00b7 rw [Set.nonempty_compl, ne_eq, Set.eq_univ_iff_ncard, ncard_eq]\r\n    exact hn.ne\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 187,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  apply isPretransitive_of_isMultiplyPretransitive\r\n  rcases eq_or_ne n 0 with rfl | hn0\r\n  \u00b7 infer_instance\r\n  rcases eq_or_ne n 1 with rfl | hn1\r\n  \u00b7 rw [is_one_pretransitive_iff]\r\n    exact alternatingGroup.isPretransitive_of_three_le_card \u03b1 h\u03b1\r\n  have := alternatingGroup.isMultiplyPretransitive \u03b1\r\n  apply isMultiplyPretransitive_of_le (n := Nat.card \u03b1 - 2) <;> grind\r\n",
      "body": "```suggestion\r\n  apply isPretransitive_of_isMultiplyPretransitive\r\n  rcases eq_or_ne n 0 with rfl | hn0\r\n  \u00b7 infer_instance\r\n  rcases eq_or_ne n 1 with rfl | hn1\r\n  \u00b7 rw [is_one_pretransitive_iff]\r\n    exact alternatingGroup.isPretransitive_of_three_le_card \u03b1 h\u03b1\r\n  have := alternatingGroup.isMultiplyPretransitive \u03b1\r\n  apply isMultiplyPretransitive_of_le (n := Nat.card \u03b1 - 2) <;> grind\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "apply",
          "exact",
          "grind",
          "cases",
          "have",
          "rw"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "grind",
          "cases",
          "have",
          "rw"
        ],
        "new_tactics": [
          "apply",
          "grind",
          "cases",
          "have",
          "rw"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 188,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n    by_cases hn' : n \u2264 Nat.card \u03b1\r\n    \u00b7 apply IsPretransitive.of_surjective_map\r\n        (compl_bijective (alternatingGroup \u03b1) \u03b1 _).surjective this\r\n      aesop\r\n",
      "body": "I think `by_cases` makes more sense than `wlog` here.\r\n```suggestion\r\n    by_cases hn' : n \u2264 Nat.card \u03b1\r\n    \u00b7 apply IsPretransitive.of_surjective_map\r\n        (compl_bijective (alternatingGroup \u03b1) \u03b1 _).surjective this\r\n      aesop\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop"
        ],
        "body_tactics": [
          "apply",
          "aesop"
        ],
        "new_tactics": [
          "apply",
          "aesop"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 190,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  rw [\u2190 isCoatom_stabilizer_iff_preprimitive _ s, stabilizer_coe]\r\n  apply alternatingGroup.isCoatom_stabilizer\r\n  \u00b7 rw [Combination.coe_nonempty_iff]\r\n    exact le_trans (by norm_num) h_three_le\r\n  \u00b7 simp [Set.nonempty_compl, Set.eq_univ_iff_ncard, ncard_eq, hn.ne]\r\n  \u00b7 simpa [ncard_eq]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 isCoatom_stabilizer_iff_preprimitive _ s, stabilizer_coe]\r\n  apply alternatingGroup.isCoatom_stabilizer\r\n  \u00b7 rw [Combination.coe_nonempty_iff]\r\n    exact le_trans (by norm_num) h_three_le\r\n  \u00b7 simp [Set.nonempty_compl, Set.eq_univ_iff_ncard, ncard_eq, hn.ne]\r\n  \u00b7 simpa [ncard_eq]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "norm_num",
          "apply",
          "exact",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "norm_num",
          "apply",
          "exact",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "norm_num",
          "apply",
          "simpa",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 196,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j :=\n  \u27e8fun hsum i j \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mp (by simpa using hsum) i j,\n    fun heq \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mpr (by simpa using heq)\u27e9\n",
      "body": "```suggestion\n    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j :=\n  \u27e8fun hsum i j \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mp (by simpa using hsum) i j,\n    fun heq \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mpr (by simpa using heq)\u27e9\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 197,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    simp_rw [\u2190 heq 0]\n    simp [\u2190 Finset.mul_sum, Fin.sum_univ_eq_sum_range, h\u03b6.geom_sum_eq_zero hprime.one_lt]\n",
      "body": "```suggestion\n    simp_rw [\u2190 heq 0]\n    simp [\u2190 Finset.mul_sum, Fin.sum_univ_eq_sum_range, h\u03b6.geom_sum_eq_zero hprime.one_lt]\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 198,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pred_eq_of_pos hprime.pos\n    -- Derive a vanishing relation with coefficients `\u03b1\u1d62 - \u03b1_{p-1}` and exponents `< n`.\n    have : \u2211 i \u2208 Finset.range (n + 1), \u03b1Nat i * \u03b6 ^ i = 0 := by\n      simpa [show n + 1 = p by omega, \u2190 Fin.sum_univ_eq_sum_range, h\u03b1Nat_val]\n    have : \u2211 i \u2208 Finset.range n, \u03b1Nat i * \u03b6 ^ i - \u03b1Nat n * \u2211 i \u2208 Finset.range n, \u03b6 ^ i = 0 := by\n      rw [Finset.sum_range_succ] at this\n      -- Use the standard relation for primitive roots: `\u03b6^{p-1} = -\u2211_{i<p-1} \u03b6^i`.\n      grind [h\u03b6.pow_sub_one_eq hprime.one_lt]\n    have h",
      "body": "Attempted golfing\n\n```suggestion\n  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pr",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "body_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "new_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_omega",
          "cleanup_simp",
          "use_simpa",
          "use_grind",
          "use_ring"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 200,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j := by\n  simpa using sum_eq_zero_iff_eq_coeff h\u03b6 (Int.cast \u2218 \u03b1)\n",
      "body": "```suggestion\n    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j := by\n  simpa using sum_eq_zero_iff_eq_coeff h\u03b6 (Int.cast \u2218 \u03b1)\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 210,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "  \u00b7 rw [mem_preimage, piecewise_apply, \u2190 mem_preimage] at hx\n    exact mem_iUnion_of_mem (hs.index x) (mem_inter (hs.mem_index x) hx)\n  \u00b7 rw [\u2190 hi, \u2190 (mem_iff_index_eq hs).mp ha.1] at ha\n    simp_all [piecewise_apply]\n",
      "body": "You can drop some stuff here:\n\n```suggestion\n  \u00b7 rw [mem_preimage, piecewise_apply, \u2190 mem_preimage] at hx\n    exact mem_iUnion_of_mem (hs.index x) (mem_inter (hs.mem_index x) hx)\n  \u00b7 rw [\u2190 hi, \u2190 (mem_iff_index_eq hs).mp ha.1] at ha\n    simp_all [piecewise_apply]\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp_all"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 211,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "    simp only [hs.mem_iff_index_eq] at ha1\n",
      "body": "```suggestion\n    simp only [hs.mem_iff_index_eq] at ha1\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 212,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    obtain \u27e8e, -\u27e9 := exists_true_iff_nonempty.mpr (nonempty_equiv_of_countable (\u03b1 := \u2115) (\u03b2 := \u03b9))\n",
      "body": "```suggestion\n    obtain \u27e8e, -\u27e9 := exists_true_iff_nonempty.mpr (nonempty_equiv_of_countable (\u03b1 := \u2115) (\u03b2 := \u03b9))\n```\nThis removes the `True` hypothesis from the context.",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 213,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    have he := e.bijective\n",
      "body": "```suggestion\n    have he := e.bijective\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 215,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    \u00b7 exact .biUnion (to_countable _) fun _ _ \u21a6 hm _\n",
      "body": "`measurability` tends to be a bit slow so I suggest you replace it with this.\n```suggestion\n    \u00b7 exact .biUnion (to_countable _) fun _ _ \u21a6 hm _\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "measurability"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 216,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "  \u00b7 refine \u27e8fun n => SimpleFunc.indexedPartitionPiecewise hs hm (fun i => (hf i).approx n),\n      fun x => ?_\u27e9\n    simp [SimpleFunc.indexedPartitionPiecewise, IndexedPartition.piecewise_apply,\n      StronglyMeasurable.tendsto_approx]\n  simp only [not_finite_iff_infinite] at Fi\n",
      "body": "When you have small subgoals followed a main one, it's ok to not put a dot before the last one, so as to avoid too much indentation.\n```suggestion\n  \u00b7 refine \u27e8fun n => SimpleFunc.indexedPartitionPiecewise hs hm (fun i => (hf i).approx n),\n      fun x => ?_\u27e9\n    simp [SimpleFunc.indexedPartitionPiecewise, IndexedPartition.piecewise_apply,\n      StronglyMeasurable.tendsto_approx]\n  simp only [not_finite_iff_infinite] at Fi\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 217,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    simp only [SimpleFunc.indexedPartitionPiecewise, SimpleFunc.coe_mk,\n",
      "body": "Again here no need for the dot.\n```suggestion\n    simp only [SimpleFunc.indexedPartitionPiecewise, SimpleFunc.coe_mk,\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 218,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "        have : y = (\u27e8y, by lia\u27e9 : Fin (b + 1)).1 := rfl\n",
      "body": "`linarith` should also be replaced by `lia`, can you do so in the rest of the proof as well?\n```suggestion\n        have : y = (\u27e8y, by lia\u27e9 : Fin (b + 1)).1 := rfl\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have",
          "linarith"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 219,
      "before_code": "@SeparatesPoints _ m' := @SeparatesPoints.mk _ m' fun _ _ hxy \u21a6\n    @SeparatesPoints.separates _ m hsep _ _ fun _ hs \u21a6 hxy _ (h _ hs)",
      "suggestion": "    \u00b7 absurd hx\n      simp [\u2190 mem_preimage, h']\n    \u00b7 absurd hy\n      simp [\u2190 mem_preimage, h']\n  obtain h' | h' := isEmpty_or_nonempty \u03b1\n  \u00b7 use (Classical.ofNonempty : \u03b2), funext (by simp)\n  \u00b7 use f (Classical.ofNonempty : \u03b1), funext (fun x \u21a6 h _ _)\n",
      "body": "I think it's better not to use semicolons here. Also you can avoid `swap` by doing the following (or doing ` by_cases! h' : IsEmpty \u03b1` instead, or just not using `swap` because both proofs are one-liners):\n```suggestion\n    \u00b7 absurd hx\n      simp [\u2190 mem_preimage, h']\n    \u00b7 absurd hy\n      simp [\u2190 mem_preimage, h']\n  obtain h' | h' := isEmpty_or_nonempty \u03b1\n  \u00b7 use (Classical.ofNonempty : \u03b2), funext (by simp)\n  \u00b7 use f (Classical.ofNonempty : \u03b1), funext (fun x \u21a6 h _ _)\n```",
      "path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "SeparatesPoints",
          "hxy",
          "separates",
          "hsep"
        ]
      }
    },
    {
      "id": 247,
      "before_code": "I.map (algebraMap R' R) ^ Module.finrank (FractionRing R) (FractionRing S) := by\n  rw [\u2190 relNorm_algebraMap, Ideal.map_map, IsScalarTower.algebraMap_eq R' R S]",
      "suggestion": "  have h\u2080 : \u2200 Q \u2208 (p.primesOver S).toFinset,\n      relNorm R Q ^ ramificationIdx (algebraMap R S) p Q = p ^ ((p.ramificationIdxIn S) * s) := by\n    intro Q hQ\n",
      "body": "```suggestion\n  have h\u2080 : \u2200 Q \u2208 (p.primesOver S).toFinset,\n      relNorm R Q ^ ramificationIdx (algebraMap R S) p Q = p ^ ((p.ramificationIdxIn S) * s) := by\n    intro Q hQ\n```\nseems closer to standard mathematical notation",
      "path": "Mathlib/RingTheory/Ideal/Norm/RelNorm.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have",
          "intro"
        ],
        "body_tactics": [
          "have",
          "intro"
        ],
        "new_tactics": [
          "have",
          "intro"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "Ideal",
          "IsScalarTower",
          "map_map",
          "finrank",
          "relNorm_algebraMap",
          "FractionRing",
          "map",
          "algebraMap",
          "algebraMap_eq"
        ]
      }
    },
    {
      "id": 273,
      "before_code": "intro S\u2081 hS\u2081 S\u2082 hS\u2082\n  exact Submodule.finite_sup S\u2081 S\u2082",
      "suggestion": "theorem span_submodule_fg_of_fg {S : Submodule R M} (hS : S.FG) :\n    (span A S : Submodule A M).FG := by\n  obtain \u27e8t, ht\u27e9 := hS\n  use t\n  rw [\u2190 ht, span_span_of_tower]\n",
      "body": "```suggestion\ntheorem span_submodule_fg_of_fg {S : Submodule R M} (hS : S.FG) :\n    (span A S : Submodule A M).FG := by\n  obtain \u27e8t, ht\u27e9 := hS\n  use t\n  rw [\u2190 ht, span_span_of_tower]\n```",
      "path": "Mathlib/RingTheory/Finiteness/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "obtain",
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Submodule",
          "intro",
          "finite_sup"
        ]
      }
    },
    {
      "id": 309,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "\r\n  have ha : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\r\n",
      "body": "I'd be inclined to inline this\r\n```suggestion\r\n  have ha : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 310,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "\r\n  \u00b7 rw [Finset.coe_image]\r\n    exact h_dis.image\r\n",
      "body": "```suggestion\r\n  \u00b7 rw [Finset.coe_image]\r\n    exact h_dis.image\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 313,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "\r\n    \u00b7 simp only [K, coe_biUnion]\r\n      refine (h'I.mono_on ?_).biUnion hJdisj\r\n      simp\r\n      grind\r\n",
      "body": "```suggestion\r\n    \u00b7 simp only [K, coe_biUnion]\r\n      refine (h'I.mono_on ?_).biUnion hJdisj\r\n      simp\r\n      grind\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "grind",
          "refine",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "simp",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 315,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n",
      "body": "```suggestion\n  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n```\na little golf",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "refine",
          "simp",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 316,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    have : s = \u22c3 t \u2208 J', s \u2229 t := by\n      simp_rw [\u2190 Finset.set_biUnion_coe, \u2190 inter_iUnion, left_eq_inter, \u2190 sUnion_eq_biUnion, \u2190 h]\n      exact subset_sUnion_of_mem hs\n",
      "body": "```suggestion\n    have : s = \u22c3 t \u2208 J', s \u2229 t := by\n      simp_rw [\u2190 Finset.set_biUnion_coe, \u2190 inter_iUnion, left_eq_inter, \u2190 sUnion_eq_biUnion, \u2190 h]\n      exact subset_sUnion_of_mem hs\n```\nI still think this is longer than it should be :(",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "exact",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 317,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "      simp_rw [\u2190 Finset.set_biUnion_coe, \u2190 iUnion_inter, right_eq_inter, \u2190 sUnion_eq_biUnion, h]\n      exact subset_sUnion_of_mem ht\n",
      "body": "```suggestion\n      simp_rw [\u2190 Finset.set_biUnion_coe, \u2190 iUnion_inter, right_eq_inter, \u2190 sUnion_eq_biUnion, h]\n      exact subset_sUnion_of_mem ht\n```\nas before",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 318,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    \u00b7 exact hJ'disj.mono fun _ \u21a6 by simp\n",
      "body": "```suggestion\n    \u00b7 exact hJ'disj.mono fun _ \u21a6 by simp\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 319,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    \u00b7 exact hJdisj.mono fun _ \u21a6 by simp\n",
      "body": "```suggestion\n    \u00b7 exact hJdisj.mono fun _ \u21a6 by simp\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 320,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "      exact subset_sUnion_of_mem ha\n",
      "body": "```suggestion\n      exact subset_sUnion_of_mem ha\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 321,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "      exact subset_sUnion_of_mem ha\n",
      "body": "```suggestion\n      exact subset_sUnion_of_mem ha\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 324,
      "before_code": "module\n\npublic import Mathlib.Analysis.SpecialFunctions.Log.Basic",
      "suggestion": "\r\n",
      "body": "This import is redundant, let's not annoy Sebastian by making him do even more `shake` work :)\r\n```suggestion\r\n```",
      "path": "Mathlib/NumberTheory/Height/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "Basic",
          "import",
          "Mathlib",
          "public",
          "module",
          "Log",
          "Analysis",
          "SpecialFunctions"
        ]
      }
    },
    {
      "id": 330,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n\n/-- An antitone, bounded below sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddBelow_antitone {f : \u2115 \u2192 \u211d} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9\n\n/-- An antitone sequence `f : \u2115 \u2192 \u211d\u22650` has a finite limit. -/\ntheorem tendsto_of_antitone {f : \u2115 \u2192 \u211d\u22650} (h_ant : Antitone f) :\n    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := by\n  have h_bdd_0 : (0 : \u211d) \u2208 lowerBounds (Set.range fun n : \u2115 => (f n : \u211d)) := by\n    rintro r \u27e8n, hn\u27e9\n    simp_rw [\u2190 hn]\n    exact NNReal.coe_nonneg _\n  obtain \u27e8L, hL\u27e9 := Real.tendsto_of_bddBelow_antitone \u27e80, h_bdd_0\u27e9 h_ant\n  have hL0 : 0 \u2264 L :=\n    haveI h_glb : IsGLB (Set.range fun n => (f n : \u211d)) L := isGLB_of_tendsto_atTop h_ant hL\n    (le_isGLB_iff h_glb).mpr h_bdd_0\n  exact \u27e8\u27e8L, hL0\u27e9, NNReal.tendsto_coe.mp hL\u27e9",
      "suggestion": "    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := \u27e8iInf f, tendsto_atTop_ciInf h_ant (by simp)\u27e9\n",
      "body": "```suggestion\n    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := \u27e8iInf f, tendsto_atTop_ciInf h_ant (by simp)\u27e9\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "lowerBounds",
          "mpr",
          "antitone",
          "rintro",
          "obtain",
          "hL0",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "have",
          "isGLB_of_tendsto_atTop",
          "exists_isLUB",
          "Antitone",
          "simp_rw",
          "h_mon",
          "range",
          "Real",
          "exists_isGLB",
          "Tendsto",
          "sequence",
          "IsGLB",
          "tendsto_of_bddAbove_monotone",
          "le_isGLB_iff",
          "tendsto_atTop_isLUB",
          "BddBelow",
          "tendsto_coe",
          "above",
          "bounded",
          "NNReal",
          "h_bdd",
          "below",
          "tendsto_atTop_isGLB",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set",
          "coe_nonneg",
          "h_bdd_0",
          "tendsto_of_bddBelow_antitone",
          "h_glb",
          "tendsto_of_antitone",
          "h_ant",
          "haveI"
        ]
      }
    },
    {
      "id": 334,
      "before_code": "section Monotone",
      "suggestion": "  obtain rfl : iSup f = B := h_lub.csSup_eq (range_nonempty f)\n",
      "body": "This is a fun trick:\n```suggestion\n  obtain rfl : iSup f = B := h_lub.csSup_eq (range_nonempty f)\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Monotone",
          "section"
        ]
      }
    },
    {
      "id": 336,
      "before_code": "section Monotone",
      "suggestion": "\r\n/-- A monotone, bounded above sequence `f : \u03b9 \u2192 \u211d` on `s` has the finite\r\nlimit `sSup (f '' s)`. -/\r\ntheorem _root_.Real.tendsto_csSup_of_bddAbove_monotoneOn_Ici {f : \u03b9 \u2192 \u211d} {k : \u2115}\r\n    (h_bdd : BddAbove (f '' s)) (h_mon : MonotoneOn f s) :\r\n    Tendsto f atTop (\ud835\udcdd (sSup (f '' s))) := by\r\n  rw [\u2190 range_add_eq_image_Ici] at h_bdd\r\n  rw [Ici, \u2190 monotone_add_nat_iff_monotoneOn_nat_Ici] at h_mon\r\n  rw [\u2190 tendsto_add_atTop_iff_nat k, \u2190 range_add_eq_image_Ici, sSup_range]\r\n  exact Real.tendsto_ciSup_of_bddAbove_monotone h_bdd h_mon\r\n\r\n/-- An antitone, bounded below sequence `f : \u03b9 \u2192 \u211d` on `s` has the finite\r\nlimit `sInf (f '' s)`. -/\r\ntheorem _root_.Real.tendsto_csInf_of_bddBelow_antitoneOn_Ici {f : \u03b9 \u2192 \u211d} {k : \u2115}\r\n    (h_bdd : BddBelow (f '' s)) (h_ant : AntitoneOn f s) :\r\n    Tendsto f atTop (\ud835\udcdd (sInf (f '' s))) := by\r\n  rw [\u2190 range_add_eq_image_Ici] at h_bdd\r\n  rw [Ici, \u2190 antitone_add_nat_iff_antitoneOn_nat_Ici] at h_ant\r\n  rw [\u2190 tendsto_add_atTop_iff_nat k, \u2190 range_add_eq_image_Ici, sIn",
      "body": "but you can generalise to\r\n```suggestion\r\n/-- A monotone, bounded above sequence `f : \u03b9 \u2192 \u211d` on `s` has the finite\r\nlimit `sSup (f '' s)`. -/\r\ntheorem _root_.Real.tendsto_csSup_of_bddAbove_monotoneOn_Ici {f : \u03b9 \u2192 \u211d} {k : \u2115}\r\n    (h_bdd : BddAbove (f '' s)) (h_mon : MonotoneOn f s) :\r\n    Tendsto f atTop (\ud835\udcdd (sSup (f '' s))) := by\r\n  rw [\u2190 range_add_eq_image_Ici] at h_bdd\r\n  rw [Ici, \u2190 monotone_add_nat_iff_monotoneOn_nat_Ici] at h_mon\r\n  rw [\u2190 tendsto_add_atTop_iff_nat k, \u2190 range_add_eq_image_Ici,",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Monotone",
          "section"
        ]
      }
    },
    {
      "id": 340,
      "before_code": "SchwartzMap.bilinLeftCLM (ContinuousLinearMap.lsmul \ud835\udd5c \ud835\udd5c).flip hg\n  else 0",
      "suggestion": "@[simp]\ntheorem smulLeftCLM_apply {g : E \u2192 \ud835\udd5c} (hg : g.HasTemperateGrowth) (f : \ud835\udce2(E, F)) :\n",
      "body": "Can we give this lemma the `simp` instead of `smulLeftCLM_apply_apply`:\n```suggestion\n@[simp]\ntheorem smulLeftCLM_apply {g : E \u2192 \ud835\udd5c} (hg : g.HasTemperateGrowth) (f : \ud835\udce2(E, F)) :\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simp"
        ],
        "keywords": [
          "SchwartzMap",
          "else",
          "ContinuousLinearMap",
          "lsmul",
          "flip",
          "bilinLeftCLM"
        ]
      }
    },
    {
      "id": 346,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "/-- Composition of intertwining maps. -/\ndef llcomp : IntertwiningMap \u03c3 \u03c4 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c3 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c4 where\n  toFun f :=\n    { toFun g :=\n      { toLinearMap := f.toLinearMap.comp g.toLinearMap\n        isIntertwining' := by simp [f.isIntertwining, g.isIntertwining] }\n      map_add' _ _ := by ext; simp [map_add]\n      map_smul' _ _ := by ext; simp }\n  map_add' _ _ := by ext; simp\n  map_smul' _ _ := by ext; simp\n\nvariable {\u03c1 \u03c3 \u03c4} in\n/-- Composition of intertwining maps.\n\nA convenience variant of `IntertwiningMap.llcomp` for use in dot notation. -/\ndef comp (f : IntertwiningMap \u03c3 \u03c4) (g : IntertwiningMap \u03c1 \u03c3) : IntertwiningMap \u03c1 \u03c4 :=\n  llcomp _ _ _ f g\n",
      "body": "How about we also capture the fact that this operation is bilinear as follows:\n```suggestion\n/-- Composition of intertwining maps. -/\ndef llcomp : IntertwiningMap \u03c3 \u03c4 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c3 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c4 where\n  toFun f :=\n    { toFun g :=\n      { toLinearMap := f.toLinearMap.comp g.toLinearMap\n        isIntertwining' := by simp [f.isIntertwining, g.isIntertwining] }\n      map_add' _ _ := by ext; simp [map_add]\n      map_smul' _ _ := by ext; simp }\n  map_add' _ _ := by ext; simp\n ",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 350,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "  Algebra.ofModule (fun a f g => rfl) (fun a f g => by ext; simp)\n",
      "body": "If we add `mul_apply` above, this can be just:\n```suggestion\n  Algebra.ofModule (fun a f g => rfl) (fun a f g => by ext; simp)\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 353,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "  have : IsSimpleModule k[G] \u03c1.asModule :=\n    (irreducible_iff_isSimpleModule_asModule \u03c1).mp inferInstance\n",
      "body": "The `I` in `haveI` is for \"inline\" and we don't need this.\n```suggestion\n  have : IsSimpleModule k[G] \u03c1.asModule :=\n    (irreducible_iff_isSimpleModule_asModule \u03c1).mp inferInstance\n```\nsimilarly several times below",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 355,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "      | succ n ih => simp only [pow_succ, coe_mul, show f ^ (n + 1) = f ^ n * f from rfl, ih])\n",
      "body": "```suggestion\n      | succ n ih => simp only [pow_succ, coe_mul, show f ^ (n + 1) = f ^ n * f from rfl, ih])\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 358,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "theorem algebraMap_intertwiningMap_bijective_of_isAlgClosed :\n    Bijective (algebraMap k (IntertwiningMap \u03c1 \u03c1)) := by\n  have : Bijective (algebraMap k (Module.End k[G] \u03c1.asModule)) :=\n    IsSimpleModule.algebraMap_end_bijective_of_isAlgClosed k\n  exact (Bijective.of_comp_iff' (IntertwiningMap.equivAlgEnd \u03c1).bijective _).1 this\n",
      "body": "```suggestion\ntheorem algebraMap_intertwiningMap_bijective_of_isAlgClosed :\n    Bijective (algebraMap k (IntertwiningMap \u03c1 \u03c1)) := by\n  have : Bijective (algebraMap k (Module.End k[G] \u03c1.asModule)) :=\n    IsSimpleModule.algebraMap_end_bijective_of_isAlgClosed k\n  exact (Bijective.of_comp_iff' (IntertwiningMap.equivAlgEnd \u03c1).bijective _).1 this\n```",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 359,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "include \u03c1 in\nvariable (\u03c1) in\ntheorem finrank_eq_one_of_isMulCommutative [IsMulCommutative G] :\n    Module.finrank k V = 1 := by\n  have : IsMulCommutative k[G] := \u27e8\u27e8mul_comm\u27e9\u27e9\n",
      "body": "```suggestion\ninclude \u03c1 in\nvariable (\u03c1) in\ntheorem finrank_eq_one_of_isMulCommutative [IsMulCommutative G] :\n    Module.finrank k V = 1 := by\n  have : IsMulCommutative k[G] := \u27e8\u27e8mul_comm\u27e9\u27e9\n```",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 373,
      "before_code": "g_an.continuousAt.continuousWithinAt.tendsto.norm\n    have : Tendsto (fun z \u21a6 z - x) (\ud835\udcdd[\u2260] x) (\ud835\udcdd[\u2260] 0) := by\n      refine tendsto_nhdsWithin_iff.2 \u27e8?_, ?_\u27e9\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) ({x}\u1d9c) x :=\n          ContinuousAt.continuousWithinAt (by fun_prop)",
      "suggestion": "\r\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) {x}\u1d9c x := by fun_prop\r\n",
      "body": "```suggestion\r\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) {x}\u1d9c x := by fun_prop\r\n```\r\nWhy the brackets?",
      "path": "Mathlib/Analysis/Meromorphic/Order.lean",
      "tags": {
        "before_tactics": [
          "fun_prop",
          "refine",
          "have"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "have"
        ],
        "body_tactics": [
          "fun_prop",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "continuity",
          "norm"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "ContinuousWithinAt",
          "tendsto",
          "refine",
          "tendsto_nhdsWithin_iff",
          "continuousAt",
          "ContinuousAt",
          "have",
          "Tendsto",
          "norm",
          "continuousWithinAt",
          "g_an",
          "fun_prop"
        ]
      }
    },
    {
      "id": 374,
      "before_code": "have : x = (fun \u03b5 : \u211d => mulExpNegMulSq \u03b5 x) 0 := by\n    simp only [mulExpNegMulSq, zero_mul, neg_zero, exp_zero, mul_one]\n  nth_rw 2 [this]\n  apply Continuous.tendsto (Continuous.mul continuous_const (by fun_prop))",
      "suggestion": "\r\n  apply Continuous.tendsto (by fun_prop)\r\n",
      "body": "Unnecessary diff? or maybe\r\n```suggestion\r\n  apply Continuous.tendsto (by fun_prop)\r\n```\r\nworks?",
      "path": "Mathlib/Analysis/SpecialFunctions/MulExpNegMulSq.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "have",
          "simp",
          "fun_prop"
        ],
        "suggestion_tactics": [
          "apply",
          "fun_prop"
        ],
        "body_tactics": [
          "apply",
          "fun_prop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "have"
        ],
        "topics": [
          "continuity",
          "real",
          "list"
        ],
        "transforms": [
          "remove_redundant",
          "use_fun_prop"
        ],
        "keywords": [
          "apply",
          "nth_rw",
          "tendsto",
          "have",
          "this",
          "exp_zero",
          "mulExpNegMulSq",
          "continuous_const",
          "mul_one",
          "neg_zero",
          "simp",
          "Continuous",
          "fun_prop",
          "zero_mul",
          "mul",
          "only"
        ]
      }
    },
    {
      "id": 375,
      "before_code": "apply ((continuous_sub_right _).smul P.differentiable_\u039b\u2080.continuous).tendsto\n  \u00b7 rw [(by rw [sub_self, zero_smul] : \ud835\udcdd 0 = \ud835\udcdd ((P.k - P.k : \u2102) \u2022 (1 / P.k : \u2102) \u2022 P.f\u2080))]\n    refine (continuous_sub_right _).continuousAt.smul (ContinuousAt.smul ?_ continuousAt_const)\n    exact continuousAt_const.div continuousAt_id (ofReal_ne_zero.mpr P.hk.ne')",
      "suggestion": "\r\n    have := ofReal_ne_zero.mpr P.hk.ne'\r\n",
      "body": "```suggestion\r\n    have := ofReal_ne_zero.mpr P.hk.ne'\r\n```",
      "path": "Mathlib/NumberTheory/LSeries/AbstractFuncEq.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "apply",
          "rw",
          "refine"
        ],
        "topics": [
          "continuity",
          "complex",
          "differentiability",
          "list"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "smul",
          "mpr",
          "tendsto",
          "refine",
          "ofReal_ne_zero",
          "exact",
          "zero_smul",
          "sub_self",
          "continuousAt",
          "ContinuousAt",
          "continuous",
          "div",
          "continuousAt_id",
          "continuous_sub_right",
          "continuousAt_const"
        ]
      }
    },
    {
      "id": 378,
      "before_code": "prime_factors_unique (fun x hx => UniqueFactorizationMonoid.irreducible_iff_prime.mp (hf x hx))\n    (fun x hx => UniqueFactorizationMonoid.irreducible_iff_prime.mp (hg x hx)) h",
      "suggestion": "  \u00b7 simp_all\n",
      "body": "```suggestion\n  \u00b7 simp_all\n```",
      "path": "Mathlib/RingTheory/UniqueFactorizationDomain/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "irreducible_iff_prime",
          "UniqueFactorizationMonoid",
          "prime_factors_unique"
        ]
      }
    },
    {
      "id": 381,
      "before_code": "theorem self_symm_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : X \u2245 Z) : \u03b1 \u226a\u226b \u03b1.symm \u226a\u226b \u03b2 = \u03b2 := by\n  rw [\u2190 trans_assoc, self_symm_id, refl_trans]\n\ntheorem inv_comp_eq (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_inv_comp (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f :=\n  (inv_comp_eq \u03b1.symm).symm\n\ntheorem comp_inv_eq (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b \u03b1.inv = g \u2194 f = g \u226b \u03b1.hom :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_comp_inv (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b \u03b1.inv \u2194 g \u226b \u03b1.hom = f :=\n  (comp_inv_eq \u03b1.symm).symm\n\ntheorem inv_eq_inv (f g : X \u2245 Y) : f.inv = g.inv \u2194 f.hom = g.hom :=\n  have : \u2200 {X Y : C} (f g : X \u2245 Y), f.hom = g.hom \u2192 f.inv = g.inv := fun f g h => by rw [ext h]\n  \u27e8this f.symm g.symm, this f g\u27e9\n\ntheorem hom_comp_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : \u03b1.hom \u226b f = \ud835\udfd9 X \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_inv_comp, comp_id]\n\ntheorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_comp_inv, id_comp]\n\ntheorem inv_comp_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : \u03b1.inv \u226b f = \ud835\udfd9 Y \u2194 f = \u03b1.hom :=\n  hom_comp_eq_id \u03b1.symm\n\ntheorem comp_inv_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : f \u226b \u03b1.inv = \ud835\udfd9 X \u2194 f = \u03b1.hom :=\n  comp_hom_eq_id \u03b1.symm\n\ntheorem hom_eq_inv (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 X) : \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv := by\n  rw [\u2190 symm_inv, inv_eq_inv \u03b1.symm \u03b2, eq_comm]\n  rfl\n\nattribute [local grind] Function.LeftInverse Function.RightInverse\n\n/-- The bijection `(Z \u27f6 X) \u2243 (Z \u27f6 Y)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homToEquiv (\u03b1 : X \u2245 Y) {Z : C} : (Z \u27f6 X) \u2243 (Z \u27f6 Y) where\n  toFun f := f \u226b \u03b1.hom\n  invFun g := g \u226b \u03b1.inv\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\n/-- The bijection `(X \u27f6 Z) \u2243 (Y \u27f6 Z)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homFromEquiv (\u03b1 : X \u2245 Y) {Z : C} : (X \u27f6 Z) \u2243 (Y \u27f6 Z) where\n  toFun f := \u03b1.inv \u226b f\n  invFun g := \u03b1.hom \u226b g\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\nend Iso\n\n/-- The `IsIso` t",
      "suggestion": "\r\n@[aesop apply safe (rule_sets := [CategoryTheory]), to_dual (reorder := X Y) eq_inv_of_inv_hom_id]\r\n",
      "body": "```suggestion\r\n@[aesop apply safe (rule_sets := [CategoryTheory]), to_dual (reorder := X Y) eq_inv_of_inv_hom_id]\r\n```",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "aesop",
          "ext",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop"
        ],
        "body_tactics": [
          "apply",
          "aesop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory",
          "function"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "symm_inv",
          "IsIso",
          "note",
          "lean",
          "typeclass",
          "open",
          "epi_of_iso",
          "eq_comm",
          "been",
          "trans_assoc",
          "have",
          "inv_hom_id",
          "Prop",
          "failing",
          "priority",
          "Epi",
          "Iso",
          "inv_comp_eq_id",
          "Mono",
          "inverse",
          "out",
          "def",
          "comp_inv_eq",
          "right_inv",
          "simps",
          "that",
          "had",
          "right_cancellation",
          "simp",
          "choose",
          "rfl",
          "theorem",
          "Category",
          "left",
          "Reinterpret",
          "reassoc",
          "left_inv",
          "inv_hom_id_assoc",
          "eq_inv_comp",
          "end",
          "existence",
          "comp_id",
          "safe",
          "self_symm_id_assoc",
          "isomorphism",
          "CategoryTheory",
          "when",
          "asIso",
          "Function",
          "homFromEquiv"
        ]
      }
    },
    {
      "id": 397,
      "before_code": "(isPrimitive_def _).1 (1 : DirichletCharacter R n).primitiveCharacter_isPrimitive,\n      conductor_one hn]",
      "suggestion": "    obtain \u27e8_, \u03c7\u2081, h\u03c7\u2081\u27e9 := factorsThrough_gcd \u03c7\u2080 \u03c7.primitiveCharacter this\n",
      "body": "```suggestion\n    obtain \u27e8_, \u03c7\u2081, h\u03c7\u2081\u27e9 := factorsThrough_gcd \u03c7\u2080 \u03c7.primitiveCharacter this\n```",
      "path": "Mathlib/NumberTheory/DirichletCharacter/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isPrimitive_def",
          "DirichletCharacter",
          "primitiveCharacter_isPrimitive",
          "conductor_one"
        ]
      }
    },
    {
      "id": 415,
      "before_code": "public import Mathlib.CategoryTheory.Functor.Category\npublic import Mathlib.CategoryTheory.Iso",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis import should now be redundant",
      "path": "Mathlib/CategoryTheory/NatIso.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "import",
          "Mathlib",
          "public",
          "Functor",
          "Category",
          "CategoryTheory",
          "Iso"
        ]
      }
    },
    {
      "id": 432,
      "before_code": "/-! ### Cliques -/",
      "suggestion": "\r\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) (hc : G.Colorable n) :\r\n    s.card \u2264 n := by\r\n  simpa using hc.card_le_of_pairwise_adj _ <| s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n",
      "body": "```suggestion\r\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) (hc : G.Colorable n) :\r\n    s.card \u2264 n := by\r\n  simpa using hc.card_le_of_pairwise_adj _ <| s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Cliques"
        ]
      }
    },
    {
      "id": 433,
      "before_code": "/-! ### Cliques -/\n\n\ntheorem IsClique.card_le_of_coloring {s : Finset V} (h : G.IsClique s) [Fintype \u03b1]\n    (C : G.Coloring \u03b1) : s.card \u2264 Fintype.card \u03b1 := by\n  rw [isClique_iff_induce_eq] at h\n  have f : G.induce \u2191s \u21aag G := Embedding.comap (Function.Embedding.subtype fun x => x \u2208 \u2191s) G\n  rw [h] at f\n  convert Fintype.card_le_of_injective _ (C.comp f.toHom).injective_of_top_hom using 1\n  simp\n\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) {n : \u2115}\n    (hc : G.Colorable n) : s.card \u2264 n := by\n  convert h.card_le_of_coloring hc.some\n  simp",
      "suggestion": "\r\n  exact h.card_le_of_colorable C.colorable\r\n",
      "body": "```suggestion\r\n  exact h.card_le_of_colorable C.colorable\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "topics": [
          "finset",
          "function",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "convert",
          "Cliques",
          "Function",
          "Colorable",
          "injective_of_top_hom",
          "toHom",
          "using",
          "Finset",
          "Coloring",
          "card_le_of_colorable",
          "have",
          "card_le_of_coloring",
          "subtype",
          "Embedding",
          "IsClique",
          "comp",
          "simp",
          "induce",
          "card_le_of_injective",
          "card",
          "theorem",
          "isClique_iff_induce_eq",
          "Fintype",
          "comap",
          "some"
        ]
      }
    },
    {
      "id": 434,
      "before_code": "/-! ### Cliques -/\n\n\ntheorem IsClique.card_le_of_coloring {s : Finset V} (h : G.IsClique s) [Fintype \u03b1]\n    (C : G.Coloring \u03b1) : s.card \u2264 Fintype.card \u03b1 := by\n  rw [isClique_iff_induce_eq] at h\n  have f : G.induce \u2191s \u21aag G := Embedding.comap (Function.Embedding.subtype fun x => x \u2208 \u2191s) G\n  rw [h] at f\n  convert Fintype.card_le_of_injective _ (C.comp f.toHom).injective_of_top_hom using 1\n  simp\n\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) {n : \u2115}\n    (hc : G.Colorable n) : s.card \u2264 n := by\n  convert h.card_le_of_coloring hc.some\n  simp\n\ntheorem IsClique.card_le_chromaticNumber {s : Finset V} (h : G.IsClique s) :\n    s.card \u2264 G.chromaticNumber := by\n  obtain (hc | hc) := eq_or_ne G.chromaticNumber \u22a4\n  \u00b7 rw [hc]\n    exact le_top\n  \u00b7 have hc' := hc\n    rw [chromaticNumber_ne_top_iff_exists] at hc'\n    obtain \u27e8n, c\u27e9 := hc'\n    rw [\u2190 ENat.coe_toNat_eq_self] at hc\n    rw [\u2190 hc, Nat.cast_le]\n    exact h.card_le_of_colorable (colorable_chromaticNumber c)",
      "suggestion": "\r\n    s.card \u2264 G.chromaticNumber := by\r\n  simpa using card_le_chromaticNumber_of_pairwise_adj _ <|\r\n    s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n",
      "body": "```suggestion\r\n    s.card \u2264 G.chromaticNumber := by\r\n  simpa using card_le_chromaticNumber_of_pairwise_adj _ <|\r\n    s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "topics": [
          "nat",
          "order",
          "function",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "convert",
          "Cliques",
          "chromaticNumber_ne_top_iff_exists",
          "cast_le",
          "chromaticNumber",
          "obtain",
          "Function",
          "Colorable",
          "toHom",
          "injective_of_top_hom",
          "using",
          "Nat",
          "Finset",
          "Coloring",
          "card_le_of_colorable",
          "have",
          "le_top",
          "card_le_of_coloring",
          "subtype",
          "card_le_chromaticNumber",
          "Embedding",
          "IsClique",
          "ENat",
          "comap",
          "comp",
          "colorable_chromaticNumber",
          "simp",
          "induce",
          "card_le_of_injective",
          "card",
          "theorem",
          "exact",
          "isClique_iff_induce_eq",
          "Fintype",
          "eq_or_ne",
          "coe_toNat_eq_self",
          "some"
        ]
      }
    },
    {
      "id": 449,
      "before_code": "set f' := fun i => (f i : M\u2081 i \u2192\u2097[R] M\u2081' i)\n  rw [\u2190 zero_compLinearMap f', compLinearMap_inj f' fun i => (f i).surjective]",
      "suggestion": "\r\ndef compMultilinearMap (g : MultilinearMap R M\u2081 M\u2082) (f : (i : \u03b9) \u2192 MultilinearMap R (N i) (M\u2081 i)) :\r\n    MultilinearMap R (fun j : \u03a3 i, \u03b2 i \u21a6 N j.fst j.snd) M\u2082 where\r\n  toFun m := g fun i \u21a6 f i (Sigma.curry m i)\r\n  map_update_add' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n  map_update_smul' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n",
      "body": "A few changes and we can do it in a single `intro; classical; simp`:\r\n\r\n* `DecidableEq` is not needed to define `toFun`, so we should add this assumption (with `classical`) only for the proofs.\r\n* We only need to introduce `hDecEqSigma`, the rest is handled by `simp`. Might as well put the hypothesis before the colon (but I would also accept `intro` here).\r\n* `simp only` can do all the rewriting if we hint it what to exactly rewrite. In particular, breaking `[Sigma.apply_curry_update .., Sigma.c",
      "path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "function"
        ],
        "transforms": [
          "cleanup_simp",
          "line_break",
          "remove_redundant"
        ],
        "keywords": [
          "compLinearMap_inj",
          "zero_compLinearMap",
          "surjective",
          "set"
        ]
      }
    },
    {
      "id": 483,
      "before_code": "\u03bcH[d] (K.orthogonalProjection '' s) \u2264 \u03bcH[d] s := by\n  simpa using K.lipschitzWith_orthogonalProjection.hausdorffMeasure_image_le hs s",
      "suggestion": "\r\n    apply iInf_le_of_le fun _ => {x}\r\n    simpa using hs\r\n",
      "body": "```suggestion\r\n    apply iInf_le_of_le fun _ => {x}\r\n    simpa using hs\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply"
        ],
        "body_tactics": [
          "simpa",
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "orthogonalProjection",
          "simpa",
          "hausdorffMeasure_image_le",
          "lipschitzWith_orthogonalProjection",
          "using"
        ]
      }
    },
    {
      "id": 485,
      "before_code": "\u03bcH[d] (K.orthogonalProjection '' s) \u2264 \u03bcH[d] s := by\n  simpa using K.lipschitzWith_orthogonalProjection.hausdorffMeasure_image_le hs s",
      "suggestion": "\r\n    have h_isolated (x) (hx : x \u2208 E) : \u2203 U : Set X,\r\n    IsOpen U \u2227 x \u2208 U \u2227 U \u2229 E = {x} := by\r\n",
      "body": "```suggestion\r\n    have h_isolated (x) (hx : x \u2208 E) : \u2203 U : Set X,\r\n    IsOpen U \u2227 x \u2208 U \u2227 U \u2229 E = {x} := by\r\n```\r\nYou don't need to intro if you use this syntax.",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have",
          "intro"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "orthogonalProjection",
          "simpa",
          "hausdorffMeasure_image_le",
          "lipschitzWith_orthogonalProjection",
          "using"
        ]
      }
    },
    {
      "id": 488,
      "before_code": "theorem restrict_Ico_eq_restrict_Ioc : \u03bc.restrict (Ico a b) = \u03bc.restrict (Ioc a b) :=\n  restrict_congr_set Ico_ae_eq_Ioc",
      "suggestion": "\r\n  exact hE.ne' <| (separableSpace_iff_countable.mp h_sep.separableSpace\r\n    |> E.countable_coe_iff.mp).measure_zero \u03bc\r\n",
      "body": "```suggestion\r\n  exact hE.ne' <| (separableSpace_iff_countable.mp h_sep.separableSpace\r\n    |> E.countable_coe_iff.mp).measure_zero \u03bc\r\n```\r\nsame here",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/NoAtoms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "restrict",
          "theorem",
          "Ico_ae_eq_Ioc",
          "restrict_congr_set",
          "Ico",
          "Ioc",
          "restrict_Ico_eq_restrict_Ioc"
        ]
      }
    },
    {
      "id": 489,
      "before_code": "IsDiscrete S \u2194 \u2200 x \u2208 S, \ud835\udcdd[\u2260] x \u2293 \ud835\udcdf S = \u22a5 := by\n  rw [isDiscrete_iff_discreteTopology, discreteTopology_subtype_iff]",
      "suggestion": "\r\n  simpa [discreteTopology_subtype_iff, AccPt] using h\r\n",
      "body": "```suggestion\r\n  simpa [discreteTopology_subtype_iff, AccPt] using h\r\n```",
      "path": "Mathlib/Topology/DiscreteSubset.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "discreteTopology_subtype_iff",
          "isDiscrete_iff_discreteTopology",
          "IsDiscrete"
        ]
      }
    },
    {
      "id": 491,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term",
      "suggestion": "/-- Elaborator for the configuration in `apply (config := cfg)` syntax. -/\ndeclare_config_elab elabApplyConfig ApplyConfig\n",
      "body": "```suggestion\n/-- Elaborator for the configuration in `apply (config := cfg)` syntax. -/\ndeclare_config_elab elabApplyConfig ApplyConfig\n```",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Elab",
          "Mathlib",
          "public",
          "Lean",
          "Term",
          "Meta",
          "meta",
          "open",
          "Tactic",
          "section",
          "namespace"
        ]
      }
    },
    {
      "id": 492,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term\n\n/--\n`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying `apply` operation.",
      "suggestion": "\r\n  * `-synthAssignedInstances` will not synthesize instance implicit arguments if they have been\r\n",
      "body": "The `ApplyConfig` docstring for `synthAssignedInstances` is a bit confusing: it explains what `synthAssignedInstances := true` does, but this is in fact already the case by default. So `-synthAssignedInstances` does the opposite: it does not resynthesize and therefore there is nothing to check.\r\n\r\nBut we can get rid of the \"even\" in this sentence, because that would be confusing.\r\n\r\n```suggestion\r\n  * `-synthAssignedInstances` will not synthesize instance implicit arguments if they have been\r\n``",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "operation",
          "but",
          "open",
          "section",
          "apply",
          "Mathlib",
          "Lean",
          "pass",
          "configuration",
          "ApplyConfig",
          "like",
          "Elab",
          "public",
          "underlying",
          "allows",
          "Term",
          "provide",
          "you",
          "namespace",
          "config",
          "cfg",
          "Meta",
          "meta",
          "Tactic"
        ]
      }
    },
    {
      "id": 512,
      "before_code": "continuous_invFun := Units.continuous_iff.mpr\n    \u27e8continuous_pi fun _ \u21a6 Units.continuous_val.comp <| continuous_apply _,\n      continuous_pi fun _ \u21a6 Units.continuous_coe_inv.comp <| continuous_apply _\u27e9",
      "suggestion": "\r\n@[simps! apply]\r\n",
      "body": "instead of this\r\n```suggestion\r\n@[simps! apply]\r\n```\r\nI think you should do:\r\n```lean\r\ntheorem symm_mapContinuousMulEquiv_apply (f : M \u2243\u209c* N) (a : N\u02e3) :\r\n    (mapContinuousMulEquiv f).symm a = map f.symm a := rfl\r\n\r\n@[simp] theorem symm_mapContinuousMulEquiv (f : M \u2243\u209c* N) :\r\n    (mapContinuousMulEquiv f).symm = mapContinuousMulEquiv f.symm := rfl\r\n\r\n@[simp] theorem toMulEquiv_mapContinuousMulEquiv (f : M \u2243\u209c* N) :\r\n    (mapContinuousMulEquiv f : M\u02e3 \u2243* N\u02e3) = mapEquiv f := rfl\r\n```",
      "path": "Mathlib/Topology/Algebra/Group/Units.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply",
          "simp"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "Units",
          "mpr",
          "continuous_pi",
          "continuous_iff",
          "comp",
          "continuous_coe_inv",
          "continuous_apply",
          "continuous_val",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 521,
      "before_code": "Indep m\u2081 m\u2083 \u03ba \u03bc :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)",
      "suggestion": "  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n",
      "body": "I suggest this proof instead:\n```suggestion\n  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n```\nIt's exactly the same but I reworked the variables (and removed unnecessary parentheses). We often use `s`, `t` for sets. Here `s` and `t` are not of the same kind (`s` is a finset of the index type while `t` is a family of sets) so it's better to use `s` and `t` rather than `t1` and `t2` which suggests they are of the same kind. As `i` is an element of the index type `\u03b9`, `i` is the usual",
      "path": "Mathlib/Probability/Independence/Kernel/Indep.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "ht1",
          "ht2",
          "h_indep",
          "h32",
          "Indep"
        ]
      }
    },
    {
      "id": 523,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n",
      "body": "```suggestion\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "have",
          "refine"
        ],
        "removed_tactics": [
          "omega",
          "intro"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 524,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\n  have := abundancyIndex_le_ofDvd hd hn\r\n  have := ne_zero_of_dvd_ne_zero hn hd\r\n  grind [abundant_iff_two_lt_abundancyIndex]\r\n",
      "body": "```suggestion\r\n  have := abundancyIndex_le_ofDvd hd hn\r\n  have := ne_zero_of_dvd_ne_zero hn hd\r\n  grind [abundant_iff_two_lt_abundancyIndex]\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 525,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\n  have hmn : m * n \u2260 0 := mul_ne_zero hm hn\r\n  exact Abundant.ofDvd h (Nat.dvd_mul_left n m) hmn\r\n",
      "body": "```suggestion\r\n  have hmn : m * n \u2260 0 := mul_ne_zero hm hn\r\n  exact Abundant.ofDvd h (Nat.dvd_mul_left n m) hmn\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "exact",
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "obtain",
          "rw",
          "omega",
          "intro"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 529,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "theorem abundant_945 : Abundant 945 := by decide +kernel\n",
      "body": "```suggestion\ntheorem abundant_945 : Abundant 945 := by decide +kernel\n```\nIf you add `deriving Decidable` after the def of `Abundant`.\n\nBut why 945? And why can't this proof be inline?",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "decide"
        ],
        "body_tactics": [
          "decide"
        ],
        "new_tactics": [
          "decide"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 542,
      "before_code": "Submodule.span R (Set.range (ExteriorAlgebra.\u03b9Multi R n)) = \u22c0[R]^n M :=\n  ExteriorAlgebra.\u03b9Multi_span_fixedDegree R n",
      "suggestion": "open Set Submodule in\n/-- If a set `s` spans the module `M`, then the set of all elements of the form `x\u2081 \u2227 \u22ef \u2227 x\u2099`\nspans `\u22c0\u207f M`. -/\nlemma \u03b9Multi_span_fixedDegree_of_span_eq_top {s : Set M} (hs : span R s = \u22a4) :\n    span R (ExteriorAlgebra.\u03b9Multi R n '' {a | range a \u2286 s}) = \u22c0[R]^n M := by\n  apply le_antisymm\n  \u00b7 rw [span_le]\n    rintro - \u27e8y, \u27e8y_mem, rfl\u27e9\u27e9\n    apply ExteriorAlgebra.\u03b9Multi_range R n\n    simp\n  \u00b7 rw [ExteriorAlgebra.exteriorPower, LinearMap.range_eq_map, \u2190 hs, map_span, span_pow, span_le]\n    rintro x hx\n    obtain \u27e8f, rfl\u27e9 := Set.mem_pow.mp hx\n    refine mem_span_of_mem \u27e8ExteriorAlgebra.\u03b9Inv \u2218 Subtype.val \u2218 f, ?_, ?_\u27e9\n    \u00b7 rw [Set.mem_setOf_eq, Set.range_comp, Set.image_subset_iff]\n      apply Subset.trans ?_ (s.image_subset_preimage_of_inverse ExteriorAlgebra.\u03b9_leftInverse)\n      grind\n",
      "body": "This is mostly just vanity golfing. I think the main (minor) advantages are that the doc string and formal statement are slightly more human-friendly.\n```suggestion\nopen Set Submodule in\n/-- If a set `s` spans the module `M`, then the set of all elements of the form `x\u2081 \u2227 \u22ef \u2227 x\u2099`\nspans `\u22c0\u207f M`. -/\nlemma \u03b9Multi_span_fixedDegree_of_span_eq_top {s : Set M} (hs : span R s = \u22a4) :\n    span R (ExteriorAlgebra.\u03b9Multi R n '' {a | range a \u2286 s}) = \u22c0[R]^n M := by\n  apply le_antisymm\n  \u00b7 rw [span_le]\n    rint",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "grind",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "grind",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "rw",
          "refine",
          "simp",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "range",
          "Set",
          "span",
          "Submodule",
          "ExteriorAlgebra"
        ]
      }
    },
    {
      "id": 543,
      "before_code": "Submodule.range_subtype]\n  exact ExteriorAlgebra.\u03b9Multi_span_fixedDegree R n",
      "suggestion": "open Set Submodule in\n/-- A version of `\u03b9Multi_span_fixedDegree_of_span` that works in the exterior power. -/\nlemma \u03b9Multi_span_of_span {s : Set M} (hs : span R s = \u22a4) :\n    span R (\u03b9Multi R n '' {a | range a \u2286 s}) = \u22a4 := by\n  apply LinearMap.map_injective (ker_subtype (\u22c0[R]^n M))\n  simpa [LinearMap.map_span, Set.image_image] using \u03b9Multi_span_fixedDegree_of_span R n M hs\n",
      "body": "```suggestion\nopen Set Submodule in\n/-- A version of `\u03b9Multi_span_fixedDegree_of_span` that works in the exterior power. -/\nlemma \u03b9Multi_span_of_span {s : Set M} (hs : span R s = \u22a4) :\n    span R (\u03b9Multi R n '' {a | range a \u2286 s}) = \u22a4 := by\n  apply LinearMap.map_injective (ker_subtype (\u22c0[R]^n M))\n  simpa [LinearMap.map_span, Set.image_image] using \u03b9Multi_span_fixedDegree_of_span R n M hs\n```",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply"
        ],
        "body_tactics": [
          "simpa",
          "apply"
        ],
        "new_tactics": [
          "simpa",
          "apply"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "range_subtype",
          "Submodule",
          "ExteriorAlgebra"
        ]
      }
    },
    {
      "id": 546,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family_span_fixedDegree_aux\r\n    {I : Type*} [LinearOrder I] (v : I \u2192 M) (\u03b1 : Fin n \u2192 I) :\r\n    ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) \u2208 span R (range (ExteriorAlgebra.\u03b9Multi_family R n v)) := by\r\n  by_cases \u03b1_inj : Injective \u03b1; swap\r\n  \u00b7 suffices ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) = 0 by simp [this]\r\n    exact AlternatingMap.map_eq_zero_of_not_injective _ _ <| fun h \u21a6 \u03b1_inj (Injective.of_comp h)\r\n",
      "body": "Looking at this one last time, even though it is a private \"auxiliary\" lemma, I think we should fold in the case analysis on whether `\u03b1` is injective so that we don't have a redundant hypothesis:\r\n```suggestion\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 547,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "    rintro - \u27e8f, \u27e8f_range, rfl\u27e9\u27e9\n    rw [Set.mem_setOf] at f_range\n    obtain \u27e8\u03b1, rfl\u27e9 := Set.range_subset_range_iff_exists_comp.mp f_range\n    exact \u03b9Multi_family_span_fixedDegree_aux R v \u03b1\n",
      "body": "After the suggestion above, this can become:\n```suggestion\n    rintro - \u27e8f, \u27e8f_range, rfl\u27e9\u27e9\n    rw [Set.mem_setOf] at f_range\n    obtain \u27e8\u03b1, rfl\u27e9 := Set.range_subset_range_iff_exists_comp.mp f_range\n    exact \u03b9Multi_family_span_fixedDegree_aux R v \u03b1\n```",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 548,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "  simpa using \u03b9Multi_family_span_fixedDegree_of_span R hv\n",
      "body": "I slightly prefer the following, not because it is shorter but because it names fewer lemmas explicitly so it's slightly more maintainable (though what you had was also fine):\n```suggestion\n  simpa using \u03b9Multi_family_span_fixedDegree_of_span R hv\n```",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 550,
      "before_code": "theorem isOpen_implies_isOpen_iff : (\u2200 s, IsOpen[t\u2081] s \u2192 IsOpen[t\u2082] s) \u2194 t\u2082 \u2264 t\u2081 :=\n  Iff.rfl",
      "suggestion": "@[simp, push]\n",
      "body": "```suggestion\n@[simp, push]\n```",
      "path": "Mathlib/Topology/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Iff",
          "isOpen_implies_isOpen_iff",
          "IsOpen",
          "rfl"
        ]
      }
    },
    {
      "id": 551,
      "before_code": "theorem isOpen_implies_isOpen_iff : (\u2200 s, IsOpen[t\u2081] s \u2192 IsOpen[t\u2082] s) \u2194 t\u2082 \u2264 t\u2081 :=\n  Iff.rfl",
      "suggestion": "@[simp, push]\n",
      "body": "```suggestion\n@[simp, push]\n```",
      "path": "Mathlib/Topology/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Iff",
          "isOpen_implies_isOpen_iff",
          "IsOpen",
          "rfl"
        ]
      }
    },
    {
      "id": 554,
      "before_code": "/-- We say that a type has `MeasurableSup` if `(c \u2294 \u00b7)` and `(\u00b7 \u2294 c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (\u00b7 \u2294 \u00b7)` see `MeasurableSup\u2082`. -/\nclass MeasurableSup (M : Type*) [MeasurableSpace M] [Max M] : Prop where\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7)\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c)",
      "suggestion": "\r\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7) := by intro c; measurability\r\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c) := by intro c; measurability\r\n",
      "body": "Do we have a good understanding of when to use `fun_prop` vs `measurability`? I thought the latter was now based on the former and therefore as fast but also slightly stronger. Therefore I was expecting\r\n```suggestion\r\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7) := by intro c; measurability\r\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c) := by intro c; measurability\r\n```",
      "path": "Mathlib/MeasureTheory/Order/Lattice.lean",
      "tags": {
        "before_tactics": [
          "measurability"
        ],
        "suggestion_tactics": [
          "measurability",
          "intro"
        ],
        "body_tactics": [
          "fun_prop",
          "measurability",
          "have",
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "measurability",
          "order"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "Type",
          "typeclass",
          "class",
          "type",
          "has",
          "Max",
          "For",
          "MeasurableSup",
          "Prop",
          "are",
          "see",
          "say",
          "assuming",
          "measurable_sup_const",
          "that",
          "measurability",
          "MeasurableSpace",
          "measurable_const_sup",
          "uncurry",
          "functions",
          "measurable",
          "Measurable"
        ]
      }
    },
    {
      "id": 568,
      "before_code": "@[simp, norm_cast]\nlemma coe_I : I = Complex.I := rfl",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis lemma was in #32955, but got renamed to `im_pnat_div_pos` in the review process. Please remove the duplicate.",
      "path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "complex",
          "norm"
        ],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "coe_I",
          "lemma",
          "Complex",
          "simp",
          "rfl",
          "norm_cast"
        ]
      }
    },
    {
      "id": 569,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    by simpa using im_pnat_div_pos 1 z\u27e9)\r\n",
      "body": "```suggestion\r\n    by simpa using im_pnat_div_pos 1 z\u27e9)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 570,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n      (by simpa using norm_exp_two_pi_I_lt_one \u27e8-N / z, im_pnat_div_pos N z\u27e9)]\r\n",
      "body": "```suggestion\r\n      (by simpa using norm_exp_two_pi_I_lt_one \u27e8-N / z, im_pnat_div_pos N z\u27e9)]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 571,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n",
      "body": "```suggestion\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n```\r\n(re-labelling variables for consistency with previous lemma)",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "grind",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "grind",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "grind",
          "congr",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 572,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simp_rw [inv_neg, mul_neg, mul_sum]\r\n  rw [Summable.tsum_finsetSum (fun i hi \u21a6 by apply linear_left_summable (ne_zero z) i le_rfl)]\r\n",
      "body": "```suggestion\r\n  simp_rw [inv_neg, mul_neg, mul_sum]\r\n  rw [Summable.tsum_finsetSum (fun i hi \u21a6 by apply linear_left_summable (ne_zero z) i le_rfl)]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "rw"
        ],
        "body_tactics": [
          "apply",
          "rw"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 573,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simpa [e2Summand, eisSummand, \u2190 mul_sum] using aux_sum_Ico_S_identity z N\r\n",
      "body": "```suggestion\r\n  simpa [e2Summand, eisSummand, \u2190 mul_sum] using aux_sum_Ico_S_identity z N\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 575,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact fun i hi \u21a6 by simpa using linear_left_summable (ne_zero z) i le_rfl\r\n",
      "body": "```suggestion\r\n  exact fun i hi \u21a6 by simpa using linear_left_summable (ne_zero z) i le_rfl\r\n```\r\nI don't think we need `omega` to tell us that `2 \u2264 2`; and doing it this way avoids having to specify `k`.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "simpa",
          "exact",
          "omega"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_omega"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 576,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (m * z + n + 1)) =\r\n    1 / (m * z - b) - 1 / (m * z + b) := by\r\n  convert telescope_aux' b (fun n \u21a6 1 / ((m : \u2102) * z + n)) using 2 <;>\r\n  simp [add_assoc, sub_eq_add_neg]\r\n",
      "body": "I'd suggest splitting this up:\r\n```suggestion\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "aesop",
          "grind",
          "induction",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "grind",
          "induction",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "aesop",
          "induction",
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp",
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 577,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simpa using (tendsto_zero_inv_linear_sub z m).sub (tendsto_zero_inv_linear z m)\r\n",
      "body": "```suggestion\r\n  simpa using (tendsto_zero_inv_linear_sub z m).sub (tendsto_zero_inv_linear z m)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 578,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n      grind [Int.cast_natCast]\r\n",
      "body": "```suggestion\r\n      grind [Int.cast_natCast]\r\n```\r\nI'm not sure what lemmas `grind` knows; less than `simp`, but more than nothing. Similarly elsewhere in this proof.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "simp"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 579,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 simpa using summable_left_one_div_linear_sub_one_div_linear z (-d) d\r\n",
      "body": "```suggestion\r\n  \u00b7 simpa using summable_left_one_div_linear_sub_one_div_linear z (-d) d\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 581,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n",
      "body": "```suggestion\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n```\r\nAlso the capitalization is inconsistent: `Summable_cotTerm` is a proof of summability, not a statement of summability, so it should be lowercase \u2013 please change it wherever it's defined and here to match.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "aesop",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "aesop",
          "have"
        ],
        "new_tactics": [
          "aesop",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 582,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    simp only [\u2190 Nat.cast_add_one] at this\r\n",
      "body": "```suggestion\r\n    simp only [\u2190 Nat.cast_add_one] at this\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 583,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    apply this.subtype\r\n",
      "body": "Isn't `Nat.succ 0` a complicated way to write \"1\"? But better still,\r\n```suggestion\r\n    apply this.subtype\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 584,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  have := tendsto_zero_geometric_tsum_pnat (norm_exp_two_pi_I_lt_one \u27e8_, im_pnat_div_pos 1 z\u27e9)\r\n",
      "body": "```suggestion\r\n  have := tendsto_zero_geometric_tsum_pnat (norm_exp_two_pi_I_lt_one \u27e8_, im_pnat_div_pos 1 z\u27e9)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 585,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact this.congr <| by grind\r\n",
      "body": "```suggestion\r\n  exact this.congr <| by grind\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 586,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact tendsto_comp_val_Ioi_atTop.mpr tendsto_inv_atTop_nhds_zero_nat\r\n",
      "body": "```suggestion\r\n  exact tendsto_comp_val_Ioi_atTop.mpr tendsto_inv_atTop_nhds_zero_nat\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 587,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simp only [telescope_aux z, aux_tsum_identity_1 z] at this\r\n",
      "body": "```suggestion\r\n  simp only [telescope_aux z, aux_tsum_identity_1 z] at this\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 588,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 exact tendsto_comp_val_Ioi_atTop.mpr <| \r\n      by simpa using (tendsto_inv_atTop_nhds_zero_nat (\ud835\udd5c := \u2102)).const_mul (-2)\r\n",
      "body": "```suggestion\r\n  \u00b7 exact tendsto_comp_val_Ioi_atTop.mpr <| \r\n      by simpa using (tendsto_inv_atTop_nhds_zero_nat (\ud835\udd5c := \u2102)).const_mul (-2)\r\n```\r\nSome of the proofs here are a bit awkward (here and elsewhere in this file) because you are using `tendsto_comp_val_Ioi_atTop` with `\u2115+` arguments, relying on the defeq that `\u2115+ = \u2191(Set.Ioi 0)` (which `rw` and `simp` cannot see through). I wonder if it would be better to have a version of `tendsto_comp_val_Ioi_atTop` stated for the `\u2115+` case (maybe `PN",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 589,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 simpa only [aux_tsum_identity_2] using tendsto_comp_val_Ioi_atTop.mpr (aux_tendsto_tsum z)\r\n",
      "body": "```suggestion\r\n  \u00b7 simpa only [aux_tsum_identity_2] using tendsto_comp_val_Ioi_atTop.mpr (aux_tendsto_tsum z)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 590,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    apply (summable_left_one_div_linear_sub_one_div_linear z i (i + 1)).congr\r\n",
      "body": "`i` is already in `\u2124`, you don't need the type annotation \r\n```suggestion\r\n    apply (summable_left_one_div_linear_sub_one_div_linear z i (i + 1)).congr\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "congr"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 601,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n",
      "body": "```suggestion\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 602,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n",
      "body": "```suggestion\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 603,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n    have H : g = (swap a (g a) * (swap b c)) * (swap b c * (swap (g a) (g (g a)))) := by\r\n      simp [mul_assoc, \u2190 hg3.eq_swap_mul_swap_iff_mem_support.mpr ha]\r\n    rw [H]\r\n",
      "body": "```suggestion\r\n    have H : g = (swap a (g a) * (swap b c)) * (swap b c * (swap (g a) (g (g a)))) := by\r\n      simp [mul_assoc, \u2190 hg3.eq_swap_mul_swap_iff_mem_support.mpr ha]\r\n    rw [H]\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 604,
      "before_code": "simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *\n  grind",
      "suggestion": "theorem disjoint_swap_swap {x y z t : \u03b1} (h : [x, y, z, t].Nodup) :\n    Disjoint (swap x y) (swap z t) := by\n  intro; grind\n",
      "body": "We should drop the redundant finiteness assumption. Luckily, `grind` comes to the rescue:\n```suggestion\ntheorem disjoint_swap_swap {x y z t : \u03b1} (h : [x, y, z, t].Nodup) :\n    Disjoint (swap x y) (swap z t) := by\n  intro; grind\n```",
      "path": "Mathlib/GroupTheory/Perm/Support.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "intro"
        ],
        "body_tactics": [
          "grind",
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [
          "remove_redundant",
          "use_grind"
        ],
        "keywords": [
          "mul_apply",
          "swap_apply_def",
          "grind",
          "eq_iff",
          "mem_support",
          "simp",
          "injective",
          "only"
        ]
      }
    },
    {
      "id": 633,
      "before_code": "rw [zpow_natCast]\n  apply one_le_pow_of_one_le' H",
      "suggestion": "\r\ntheorem one_lt_zpow {x : G} (hx : 1 < x) {n : \u2124} (hn : 0 < n) : 1 < x ^ n := by\r\n  lift n to \u2115 using Int.le_of_lt hn\r\n  rw [zpow_natCast]\r\n  exact one_lt_pow' hx (Int.natCast_pos.mp hn).ne'\r\n",
      "body": "Sorry for breaking your code\r\n```suggestion\r\ntheorem one_lt_zpow {x : G} (hx : 1 < x) {n : \u2124} (hn : 0 < n) : 1 < x ^ n := by\r\n  lift n to \u2115 using Int.le_of_lt hn\r\n  rw [zpow_natCast]\r\n  exact one_lt_pow' hx (Int.natCast_pos.mp hn).ne'\r\n```",
      "path": "Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "apply",
          "zpow_natCast",
          "one_le_pow_of_one_le"
        ]
      }
    },
    {
      "id": 634,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero\n\nsection MultiplicativeNotation\n\n/-- Notation for `WithZero (Multiplicative \u2115)` -/\nscoped[Multiplicative] notation \"\u2115\u2098\u2080\" => WithZero (Multiplicative \u2115)\n\n/-- Notation for `WithZero (Multiplicative \u2124)` -/\nscoped[Multiplicative] notation \"\u2124\u2098\u2080\" => WithZero (Multiplicative \u2124)\n\nend MultiplicativeNotation",
      "suggestion": "\r\ntheorem Int.ofAdd_neg_natCast_lt_one {n : \u2115} : (Multiplicative.ofAdd (-n : \u2124) : \u2124\u2098\u2080) < 1 := by\r\n  rw [\u2190 coe_one, coe_lt_coe, \u2190 ofAdd_zero, ofAdd_lt]\r\n  omega\r\n",
      "body": "This lemma feels overly specific. Can you either:\r\n* drop it\r\n* generalise it, maybe something like\r\n```suggestion\r\ntheorem Int.ofAdd_neg_natCast_lt_one {n : \u2115} : (Multiplicative.ofAdd (-n : \u2124) : \u2124\u2098\u2080) < 1 := by\r\n  rw [\u2190 coe_one, coe_lt_coe, \u2190 ofAdd_zero, ofAdd_lt]\r\n  omega\r\n```\r\n(didn't fix the proof)",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "omega"
        ],
        "body_tactics": [
          "rw",
          "omega"
        ],
        "new_tactics": [
          "rw",
          "omega"
        ],
        "removed_tactics": [],
        "topics": [
          "int",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_omega"
        ],
        "keywords": [
          "end",
          "Notation",
          "scoped",
          "WithZero",
          "MultiplicativeNotation",
          "instLinearOrderedCommMonoidWithZero",
          "Multiplicative",
          "notation",
          "commGroupWithZero",
          "section",
          "for"
        ]
      }
    },
    {
      "id": 636,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero",
      "suggestion": "theorem one_lt_div' [LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1) {b : \u03b1} (hb : 0 < b) :\n    1 < a / b \u2194 b < a := by\n  rw [\u2190 mul_lt_mul_right (zero_lt_iff.mpr hb), one_mul, div_eq_mul_inv, inv_mul_cancel_right\u2080 hb]\n",
      "body": "Can you generalise that to `GroupWithZero` + `LinearOrder` + compatibility typeclasses by assuming \n```suggestion\ntheorem one_lt_div' [LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1) {b : \u03b1} (hb : 0 < b) :\n    1 < a / b \u2194 b < a := by\n  rw [\u2190 mul_lt_mul_right (zero_lt_iff.mpr hb), one_mul, div_eq_mul_inv, inv_mul_cancel_right\u2080 hb]\n```\nThis way it will also apply to eg linearly ordered fields. Same for the three lemmas below",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "apply",
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "WithZero",
          "end",
          "commGroupWithZero",
          "instLinearOrderedCommMonoidWithZero"
        ]
      }
    },
    {
      "id": 643,
      "before_code": "theorem inf_orthogonal_eq_bot : K \u2293 K\u15ee = \u22a5 := by\n  rw [eq_bot_iff]\n  intro x\n  simp only [toSubmodule_inf, orthogonal_toSubmodule_eq, Submodule.mem_inf, toSubmodule_bot,\n    Submodule.mem_bot, and_imp]\n  exact fun hx ho => inner_self_eq_zero.1 (ho x hx)",
      "suggestion": "\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n",
      "body": "```suggestion\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n```\r\nDoes this work?",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "theorem",
          "toSubmodule_inf",
          "exact",
          "eq_bot_iff",
          "mem_inf",
          "toSubmodule_bot",
          "mem_bot",
          "Submodule",
          "and_imp",
          "simp",
          "intro",
          "orthogonal_toSubmodule_eq",
          "inner_self_eq_zero",
          "inf_orthogonal_eq_bot"
        ]
      }
    },
    {
      "id": 654,
      "before_code": ".of_isCoveringMap_subtype (by simp) _ isCoveringMap_exp\n\nend Complex",
      "suggestion": "\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n",
      "body": "```suggestion\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n```",
      "path": "Mathlib/Analysis/Complex/CoveringMap.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "aesop",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "aesop",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "aesop",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "of_isCoveringMap_subtype",
          "end",
          "Complex",
          "simp",
          "isCoveringMap_exp"
        ]
      }
    },
    {
      "id": 660,
      "before_code": "rw [isLittleO_iff_forall_isBigOWith, isLittleO_iff_forall_isBigOWith]\n  simp [isBigOWith_mul_iff_isBigOWith_div hf]",
      "suggestion": "\r\n      _ \u2264 C\u2081 * \u2016g m\u2016 := by\r\n        gcongr\r\n        exact Finset.le_sup' (fun x => \u2016f x\u2016 / \u2016g x\u2016) (Finset.mem_def.mpr hm)\r\n",
      "body": "```suggestion\r\n      _ \u2264 C\u2081 * \u2016g m\u2016 := by\r\n        gcongr\r\n        exact Finset.le_sup' (fun x => \u2016f x\u2016 / \u2016g x\u2016) (Finset.mem_def.mpr hm)\r\n```",
      "path": "Mathlib/Analysis/Asymptotics/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "gcongr"
        ],
        "body_tactics": [
          "exact",
          "gcongr"
        ],
        "new_tactics": [
          "exact",
          "gcongr"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isBigOWith_mul_iff_isBigOWith_div",
          "simp",
          "isLittleO_iff_forall_isBigOWith"
        ]
      }
    },
    {
      "id": 662,
      "before_code": "map n (g \u2218\u2097 f) = map n g \u2218\u2097 map n f := by\n  aesop",
      "suggestion": "\r\n/-- If a linear map has a retraction, then the map it induces on exterior powers is injective. -/\r\nlemma map_injective {f : M \u2192\u2097[R] N} (g : N \u2192\u2097[R] M) (hg : g \u2218\u2097 f = .id) :\r\n    Injective (map n f) :=\r\n  RightInverse.injective (g := map n g)\r\n    (fun _ \u21a6 by rw [\u2190 LinearMap.comp_apply, \u2190 map_comp, hg, map_id, LinearMap.id_coe, id_eq])\r\n\r\n/-- If the base ring is a field, then any injective linear map induces an injective map on\r\nexterior powers. -/\r\nlemma map_injective_field {K : Type*} [Field K] [Module K M] [Module K N]\r\n    {f : M \u2192\u2097[K] N} (hf : Injective f) :\r\n    Injective (map n f) :=\r\n  map_injective _ (f.exists_leftInverse_of_injective (LinearMap.ker_eq_bot.mpr hf)).choose_spec\r\n",
      "body": "It is almost always more convenient to destruct an existential hypothesis and I think we should do so here. Given that and some other very minor style tweaks I suggest:\r\n```suggestion\r\n/-- If a linear map has a retraction, then the map it induces on exterior powers is injective. -/\r\nlemma map_injective {f : M \u2192\u2097[R] N} (g : N \u2192\u2097[R] M) (hg : g \u2218\u2097 f = .id) :\r\n    Injective (map n f) :=\r\n  RightInverse.injective (g := map n g)\r\n    (fun _ \u21a6 by rw [\u2190 LinearMap.comp_apply, \u2190 map_comp, hg, map_id, Line",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "ring",
          "rw"
        ],
        "body_tactics": [
          "ring",
          "rw"
        ],
        "new_tactics": [
          "ring",
          "rw"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "map",
          "aesop"
        ]
      }
    },
    {
      "id": 663,
      "before_code": "have B : \u2200\u1da0 x in atTop, x + 1 \u2264 exp x := eventually_atTop.2 \u27e80, fun x _ => add_one_le_exp x\u27e9\n  exact tendsto_atTop_mono' atTop B A",
      "suggestion": "  have h_le : y \u2264 exp (y - 1) := by simpa using add_one_le_exp (y - 1)\n  have h_mul_le : y * rexp (-y) \u2264 rexp (y - 1) * rexp (-y) := by gcongr\n  simpa [\u2190 exp_add, sub_add_eq_add_sub] using h_mul_le\n",
      "body": "```suggestion\n  have h_le : y \u2264 exp (y - 1) := by simpa using add_one_le_exp (y - 1)\n  have h_mul_le : y * rexp (-y) \u2264 rexp (y - 1) * rexp (-y) := by gcongr\n  simpa [\u2190 exp_add, sub_add_eq_add_sub] using h_mul_le\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Exp.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "simpa",
          "gcongr",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "gcongr",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "gcongr"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exp",
          "eventually_atTop",
          "exact",
          "have",
          "tendsto_atTop_mono",
          "add_one_le_exp",
          "atTop"
        ]
      }
    },
    {
      "id": 667,
      "before_code": "(hx : \u2200 r : R, r \u2022 x \u2208 Submodule.span R s \u2192 r = 0) : LinearIndepOn R id (insert x s) :=\n  hs.insert' <| by simpa",
      "suggestion": "/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?_\n  have aux (j : \u03b9) (hjs : j \u2208 s) (hji : j \u2260 i) : g j * (f i) (v j) = 0 := by simp [h1 hji.symm]\n  simpa [s.sum_eq_single i aux (by aesop), h2 i] using congr_arg (f i) hrel\n",
      "body": "Just a few minor style tweaks:\n```suggestion\n/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?",
      "path": "Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "have",
          "aesop",
          "simp",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "insert",
          "LinearIndepOn",
          "span",
          "simpa",
          "Submodule"
        ]
      }
    },
    {
      "id": 684,
      "before_code": "end InjectiveResolution",
      "suggestion": "  { exact := ShortComplex.exact_cokernel _ }\n",
      "body": "```suggestion\n  { exact := ShortComplex.exact_cokernel _ }\n```",
      "path": "Mathlib/CategoryTheory/Abelian/Injective/Resolution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "InjectiveResolution",
          "end"
        ]
      }
    },
    {
      "id": 691,
      "before_code": "end IsSetSemiring",
      "suggestion": "\r\n  rcases h.eq_or_lt with rfl | huv\r\n  \u00b7 grind [Set.Ioc_eq_empty_iff]\r\n  rw [Set.Ioc_eq_Ioc_iff huv] at hu'v'\r\n  grind\r\n",
      "body": "```suggestion\r\n  rcases h.eq_or_lt with rfl | huv\r\n  \u00b7 grind [Set.Ioc_eq_empty_iff]\r\n  rw [Set.Ioc_eq_Ioc_iff huv] at hu'v'\r\n  grind\r\n```\r\ncombined with my other suggestion, this golfs quite a bit, and in my eyes without any loss of readability",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "cases",
          "rw"
        ],
        "body_tactics": [
          "grind",
          "cases",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "cases",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 692,
      "before_code": "end IsSetSemiring",
      "suggestion": "\r\n  classical\r\n  rw [onIocAux, dite_eq_right_iff]\r\n  grind [Set.Ioc_eq_empty_iff]\r\n",
      "body": "```suggestion\r\n  classical\r\n  rw [onIocAux, dite_eq_right_iff]\r\n  grind [Set.Ioc_eq_empty_iff]\r\n```\r\na golf, if you like",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "rw"
        ],
        "body_tactics": [
          "grind",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 693,
      "before_code": "end IsSetSemiring",
      "suggestion": "      simp [this, onIocAux_empty f]\n",
      "body": "```suggestion\n      simp [this, onIocAux_empty f]\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 694,
      "before_code": "end IsSetSemiring",
      "suggestion": "      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n",
      "body": "```suggestion\n      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "rw",
          "simp",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 695,
      "before_code": "end IsSetSemiring",
      "suggestion": "      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n",
      "body": "```suggestion\n      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 696,
      "before_code": "end IsSetSemiring",
      "suggestion": "      have UI' : \u22c3\u2080 \u2191I' = Ioc u u' := by\n        have : (Ioc u' v \u222a \u22c3\u2080 \u2191I') \\ Ioc u' v = \u22c3\u2080 \u2191I' := by\n          refine Disjoint.sup_sdiff_cancel_left ?_\n          simp only [coe_erase, disjoint_sUnion_right, mem_diff, mem_singleton_iff, and_imp, I']\n          intro u hu hu'\n          exact (h'I hu tI hu').symm\n        simp only [I_eq_insert, coe_insert, sUnion_insert] at h'uv\n        grind\n",
      "body": "```suggestion\n      have UI' : \u22c3\u2080 \u2191I' = Ioc u u' := by\n        have : (Ioc u' v \u222a \u22c3\u2080 \u2191I') \\ Ioc u' v = \u22c3\u2080 \u2191I' := by\n          refine Disjoint.sup_sdiff_cancel_left ?_\n          simp only [coe_erase, disjoint_sUnion_right, mem_diff, mem_singleton_iff, and_imp, I']\n          intro u hu hu'\n          exact (h'I hu tI hu').symm\n        simp only [I_eq_insert, coe_insert, sUnion_insert] at h'uv\n        grind\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "refine",
          "simp",
          "intro",
          "exact",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 697,
      "before_code": "end IsSetSemiring",
      "suggestion": "      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n",
      "body": "```suggestion\n      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 698,
      "before_code": "ext\n  simp +contextual [imp_false]",
      "suggestion": "\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n",
      "body": "I know you're not a fan but `diagSet` seems to fit the hypothesis pretty well:\r\n```suggestion\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n```\r\nThe current proof (just without the underscore) will also work after your #32679 is merged",
      "path": "Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simpa",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "contextual",
          "imp_false",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 709,
      "before_code": "@[simp] lemma natCast_eq_zero {a n : \u2115} [NeZero n] : (a : Fin n) = 0 \u2194 n \u2223 a := by\n  simp [Fin.ext_iff, Nat.dvd_iff_mod_eq_zero]",
      "suggestion": "@[simp] lemma natCast_zero {n : \u2115} [NeZero n] : ((0 : \u2115) : Fin n) = 0 := by\n",
      "body": "```suggestion\n@[simp] lemma natCast_zero {n : \u2115} [NeZero n] : ((0 : \u2115) : Fin n) = 0 := by\n```\nWhen the right hand side of an eq or an iff is obvious, the Mathlib naming puts just the left hand side.",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "lemma",
          "ext_iff",
          "natCast_eq_zero",
          "Nat",
          "NeZero",
          "dvd_iff_mod_eq_zero",
          "simp",
          "Fin"
        ]
      }
    },
    {
      "id": 729,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 730,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 731,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 732,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 733,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 734,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 735,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 736,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 740,
      "before_code": "end map -- section",
      "suggestion": "\r\n  simp only [isProbabilityMeasure_iff, MeasurableSet.univ, Measure.bind_apply _ hf\u2080]\r\n  simp_rw [isProbabilityMeasure_iff] at hf\u2081\r\n  exact lintegral_eq_const hf\u2081\r\n",
      "body": "Alternative:\r\n```suggestion\r\n  simp only [isProbabilityMeasure_iff, MeasurableSet.univ, Measure.bind_apply _ hf\u2080]\r\n  simp_rw [isProbabilityMeasure_iff] at hf\u2081\r\n  exact lintegral_eq_const hf\u2081\r\n```\r\nYou can keep your version if you prefer.",
      "path": "Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "map",
          "end",
          "section"
        ]
      }
    },
    {
      "id": 745,
      "before_code": "(p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (\u2a05 i, p i) = \u2a05 i, comap f (p i) :=\n  (gc_map_comap f).u_iInf",
      "suggestion": "\r\n    (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (s.inf p) = s.inf fun i \u21a6 comap f (p i) := by\r\n  simp [Finset.inf_eq_iInf]\r\n",
      "body": "```suggestion\r\n    (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (s.inf p) = s.inf fun i \u21a6 comap f (p i) := by\r\n  simp [Finset.inf_eq_iInf]\r\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Map.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "gc_map_comap",
          "Submodule",
          "comap",
          "u_iInf"
        ]
      }
    },
    {
      "id": 746,
      "before_code": "theorem comap_iInf (K : \u03b9 \u2192 Ideal S) : (iInf K).comap f = \u2a05 i, (K i).comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_iInf",
      "suggestion": "\r\n    (s.inf K).comap f = s.inf fun i \u21a6 (K i).comap f := by\r\n  simp [Finset.inf_eq_iInf, comap_iInf]\r\n",
      "body": "```suggestion\r\n    (s.inf K).comap f = s.inf fun i \u21a6 (K i).comap f := by\r\n  simp [Finset.inf_eq_iInf, comap_iInf]\r\n```",
      "path": "Mathlib/RingTheory/Ideal/Maps.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Ideal",
          "GaloisConnection",
          "theorem",
          "comap_iInf",
          "gc_map_comap",
          "iInf",
          "map",
          "u_iInf",
          "comap"
        ]
      }
    },
    {
      "id": 756,
      "before_code": "simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b\u2081, h, \u2190 mul_assoc, mul_comm _ (f a)]",
      "suggestion": "    exact (hki.2 (hs hi hj hij k (by grind))).elim\n",
      "body": "```suggestion\n    exact (hki.2 (hs hi hj hij k (by grind))).elim\n```",
      "path": "Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mul_assoc",
          "not_true_eq_false",
          "false_and",
          "mem_erase",
          "ne_eq",
          "not_false_eq_true",
          "simp",
          "mul_comm",
          "only",
          "prod_insert"
        ]
      }
    },
    {
      "id": 768,
      "before_code": "rcases IH with \u27e8d, had, hdb\u27e9\n  exact \u27e8_, had, hdb.tail hbc\u27e9",
      "suggestion": "\r\ntheorem symmetric (hr : Symmetric r) : Symmetric (TransGen r) := by\r\n  intro x y h\r\n  induction h with\r\n  | single i => exact .single (hr i)\r\n  | tail _ h\u2081 h\u2082 => exact .head (hr h\u2081) h\u2082\r\n",
      "body": "```suggestion\r\ntheorem symmetric (hr : Symmetric r) : Symmetric (TransGen r) := by\r\n  intro x y h\r\n  induction h with\r\n  | single i => exact .single (hr i)\r\n  | tail _ h\u2081 h\u2082 => exact .head (hr h\u2081) h\u2082\r\n```",
      "path": "Mathlib/Logic/Relation.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases"
        ],
        "suggestion_tactics": [
          "exact",
          "induction",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "induction",
          "intro"
        ],
        "new_tactics": [
          "induction",
          "intro"
        ],
        "removed_tactics": [
          "cases"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "had",
          "rcases",
          "hdb",
          "tail",
          "hbc"
        ]
      }
    },
    {
      "id": 770,
      "before_code": "theorem preCantorSet_antitone : Antitone preCantorSet := by\n  apply antitone_nat_of_succ_le\n  intro m",
      "suggestion": "\r\n  refine antitone_nat_of_succ_le fun m \u21a6 ?_\r\n",
      "body": "Since we're already golfing:\r\n```suggestion\r\n  refine antitone_nat_of_succ_le fun m \u21a6 ?_\r\n```",
      "path": "Mathlib/Topology/Instances/CantorSet.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "intro"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "apply",
          "intro"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "antitone_nat_of_succ_le",
          "theorem",
          "preCantorSet",
          "preCantorSet_antitone",
          "Antitone",
          "intro"
        ]
      }
    },
    {
      "id": 774,
      "before_code": "theorem symm_comp : e.symm.toLinearMap \u2218\u209b\u2097 e.toLinearMap = LinearMap.id :=\n  LinearMap.ext e.symm_apply_apply",
      "suggestion": "\r\n    e\u2081\u2082.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n\r\n@[simp]\r\nlemma symm_comp_assoc (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) [RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082] :\r\n    e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n",
      "body": "```suggestion\r\n    e\u2081\u2082.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n\r\n@[simp]\r\nlemma symm_comp_assoc (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) [RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082] :\r\n    e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n```",
      "path": "Mathlib/Algebra/Module/Equiv/Defs.lean",
      "tags": {
        "before_tactics": [
          "ext"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "LinearMap",
          "theorem",
          "symm_apply_apply",
          "symm_comp",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 777,
      "before_code": "\u00b7 rwa [inf_of_le_right (show (LinearMap.ker f) \u2264\n      (LinearMap.ker g).comap f from comap_mono bot_le)]",
      "suggestion": "\r\n/-- If $M \u2192 N \u2192 P \u2192 0$ is exact and $M$ and $P$ are finitely generated then so is $N$.\r\n",
      "body": "```suggestion\r\n/-- If $M \u2192 N \u2192 P \u2192 0$ is exact and $M$ and $P$ are finitely generated then so is $N$.\r\n```",
      "path": "Mathlib/RingTheory/Finiteness/Finsupp.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rwa",
          "LinearMap",
          "inf_of_le_right",
          "show",
          "comap",
          "from",
          "comap_mono",
          "bot_le",
          "ker"
        ]
      }
    },
    {
      "id": 780,
      "before_code": "\u00b7 rwa [inf_of_le_right (show (LinearMap.ker f) \u2264\n      (LinearMap.ker g).comap f from comap_mono bot_le)]",
      "suggestion": "\r\n/-- If `M \u2192 N \u2192 P \u2192 0` is exact and `M` and `P` are finitely generated then so is `N`.\r\n",
      "body": "```suggestion\r\n/-- If `M \u2192 N \u2192 P \u2192 0` is exact and `M` and `P` are finitely generated then so is `N`.\r\n```\r\nI am guessing we should either backticks + unicode or dollar signs + TeX.",
      "path": "Mathlib/RingTheory/Finiteness/Finsupp.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rwa",
          "LinearMap",
          "inf_of_le_right",
          "show",
          "comap",
          "from",
          "comap_mono",
          "bot_le",
          "ker"
        ]
      }
    },
    {
      "id": 809,
      "before_code": "end IsNontrivial",
      "suggestion": "\r\nvariable {B : Type*} {A : Type*} [CommSemiring A] [Ring B] [Algebra A B] (v : Valuation B \u0393\u2080)\r\n",
      "body": "```suggestion\r\nvariable {B : Type*} {A : Type*} [CommSemiring A] [Ring B] [Algebra A B] (v : Valuation B \u0393\u2080)\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "IsNontrivial",
          "end"
        ]
      }
    },
    {
      "id": 816,
      "before_code": "theorem irreducible_of_factor {a : \u03b1} : \u2200 x : \u03b1, x \u2208 factors a \u2192 Irreducible x := fun x h =>\n  (prime_of_factor x h).irreducible",
      "suggestion": "  have hf : factors a \u2260 0 := by\n    intro hf\n    simpa [hf, Associated.comm, ha.not_isUnit] using factors_prod ha.ne_zero\n",
      "body": "I think this is clearer as:\n```suggestion\n  have hf : factors a \u2260 0 := by\n    intro hf\n    simpa [hf, Associated.comm, ha.not_isUnit] using factors_prod ha.ne_zero\n```\nand then deindent the rest of the proof",
      "path": "Mathlib/RingTheory/UniqueFactorizationDomain/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "irreducible",
          "theorem",
          "Irreducible",
          "factors",
          "irreducible_of_factor",
          "prime_of_factor"
        ]
      }
    },
    {
      "id": 818,
      "before_code": "simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]",
      "suggestion": "  grind [Finset.card_eq_zero, primeFactors_eq_empty]\n",
      "body": "Looks like this can be:\n```suggestion\n  grind [Finset.card_eq_zero, primeFactors_eq_empty]\n```",
      "path": "Mathlib/Data/Nat/Factorization/PrimePow.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Finsupp",
          "support_factorization",
          "Nat",
          "pos_iff_ne_zero",
          "card_support_eq_one",
          "simp_rw",
          "isPrimePow_iff_factorization_eq_single"
        ]
      }
    },
    {
      "id": 823,
      "before_code": "rw [PrimeSpectrum.isClosed_singleton_iff_isMaximal, closedPoint]\n  infer_instance",
      "suggestion": "\r\ntheorem primeSpectrum_eq_of_krullDimLE_one [IsDomain R] [hd : Ring.KrullDimLE 1 R]\r\n",
      "body": "```suggestion\r\ntheorem primeSpectrum_eq_of_krullDimLE_one [IsDomain R] [hd : Ring.KrullDimLE 1 R]\r\n```\r\nOr maybe `Ring.KrullDimLE.eq_bot_or_eq_top`.",
      "path": "Mathlib/RingTheory/Spectrum/Prime/Topology.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "PrimeSpectrum",
          "isClosed_singleton_iff_isMaximal",
          "closedPoint",
          "infer_instance"
        ]
      }
    },
    {
      "id": 826,
      "before_code": "rw [PrimeSpectrum.isClosed_singleton_iff_isMaximal, closedPoint]\n  infer_instance",
      "suggestion": "\r\ntheorem Ring.KrullDimLE.eq_bot_or_eq_top [IsDomain R] [Ring.KrullDimLE 1 R]\r\n",
      "body": "```suggestion\r\ntheorem Ring.KrullDimLE.eq_bot_or_eq_top [IsDomain R] [Ring.KrullDimLE 1 R]\r\n```",
      "path": "Mathlib/RingTheory/Spectrum/Prime/Topology.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "PrimeSpectrum",
          "isClosed_singleton_iff_isMaximal",
          "closedPoint",
          "infer_instance"
        ]
      }
    },
    {
      "id": 827,
      "before_code": "rw [PrimeSpectrum.isClosed_singleton_iff_isMaximal, closedPoint]\n  infer_instance",
      "suggestion": "\ninstance [IsDomain R] [Ring.KrullDimLE 1 R] [Nontrivial (PrimeSpectrum R)] :\n    IsSimpleOrder (PrimeSpectrum R) where\n  eq_bot_or_eq_top := Ring.KrullDimLE.eq_bot_or_eq_top\n\n",
      "body": "Is it worth adding the following for the 1-dimensional case:\n```suggestion\n\ninstance [IsDomain R] [Ring.KrullDimLE 1 R] [Nontrivial (PrimeSpectrum R)] :\n    IsSimpleOrder (PrimeSpectrum R) where\n  eq_bot_or_eq_top := Ring.KrullDimLE.eq_bot_or_eq_top\n\n```",
      "path": "Mathlib/RingTheory/Spectrum/Prime/Topology.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "PrimeSpectrum",
          "isClosed_singleton_iff_isMaximal",
          "closedPoint",
          "infer_instance"
        ]
      }
    },
    {
      "id": 830,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
      "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 831,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
      "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 832,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
      "body": "```suggestion\n  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 833,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
      "body": "```suggestion\n  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 837,
      "before_code": "instance [Nontrivial M] : Nontrivial P.invtRootSubmodule where\n  exists_pair_ne := \u27e8\u22a5, \u22a4, by rw [ne_eq, Subtype.ext_iff]; exact bot_ne_top\u27e9",
      "suggestion": "    q = \u22a4 \u2194 range P.root \u2286 q :=\n  \u27e8fun h \u21a6 by simp [h], fun h \u21a6 by simpa using Submodule.span_mono h (R := K)\u27e9\n",
      "body": "How about:\n```suggestion\n    q = \u22a4 \u2194 range P.root \u2286 q :=\n  \u27e8fun h \u21a6 by simp [h], fun h \u21a6 by simpa using Submodule.span_mono h (R := K)\u27e9\n```\n(I confess I'm slightly amazed I could golf this so much: it suggests our `simp` sets are in pretty good shape)",
      "path": "Mathlib/LinearAlgebra/RootSystem/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Subtype",
          "ext_iff",
          "Nontrivial",
          "exact",
          "invtRootSubmodule",
          "ne_eq",
          "exists_pair_ne",
          "instance",
          "bot_ne_top"
        ]
      }
    },
    {
      "id": 846,
      "before_code": "map_id _ := rfl\n  map_comp := by rintro _ _ _ \u27e8p\u27e9 \u27e8q\u27e9; exact congr_arg Quotient.mk'' (p.map_trans q f.continuous)",
      "suggestion": "@[simp]\nprotected theorem map_id : map (.id X) = \ud835\udfed _ := by\n",
      "body": "```suggestion\n@[simp]\nprotected theorem map_id : map (.id X) = \ud835\udfed _ := by\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "congr_arg",
          "Quotient",
          "exact",
          "map_trans",
          "map_comp",
          "rintro",
          "continuous",
          "rfl",
          "map_id"
        ]
      }
    },
    {
      "id": 847,
      "before_code": "map_id _ := rfl\n  map_comp := by rintro _ _ _ \u27e8p\u27e9 \u27e8q\u27e9; exact congr_arg Quotient.mk'' (p.map_trans q f.continuous)",
      "suggestion": "@[simp]\nprotected theorem map_comp {Z : Type*} [TopologicalSpace Z] (g : C(Y, Z)) (f : C(X, Y)) :\n",
      "body": "```suggestion\n@[simp]\nprotected theorem map_comp {Z : Type*} [TopologicalSpace Z] (g : C(Y, Z)) (f : C(X, Y)) :\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "congr_arg",
          "Quotient",
          "exact",
          "map_trans",
          "map_comp",
          "rintro",
          "continuous",
          "rfl",
          "map_id"
        ]
      }
    },
    {
      "id": 848,
      "before_code": "## Main definitions\n\n  - `FundamentalGroupoidFunctor.homotopicMapsNatIso H` The natural isomorphism\n    between the induced functors `f : \u03c0(X) \u2964 \u03c0(Y)` and `g : \u03c0(X) \u2964 \u03c0(Y)`, given a homotopy\n    `H : f \u223c g`\n\n  - `FundamentalGroupoidFunctor.equivOfHomotopyEquiv hequiv` The equivalence of the categories\n    `\u03c0(X)` and `\u03c0(Y)` given a homotopy equivalence `hequiv : X \u2243\u2095 Y` between them.\n\n## Implementation notes\n  - In order to be more universe polymorphic, we define `ContinuousMap.Homotopy.uliftMap`\n  which lifts a homotopy from `I \u00d7 X \u2192 Y` to `(TopCat.of ((ULift I) \u00d7 X)) \u2192 Y`. This is because\n  this construction uses `FundamentalGroupoidFunctor.prodToProdTop` to convert between\n  pairs of paths in I and X and the corresponding path after passing through a homotopy `H`.\n  But `FundamentalGroupoidFunctor.prodToProdTop` requires two spaces in the same universe.\n-/\n\n@[expose] public section\n\n\nnoncomputable section\n\nuniverse u\n\nopen FundamentalGroupoid\n\nopen CategoryTheory",
      "suggestion": "  apply CategoryTheory.Equivalence.mk (map hequiv) (map hequiv.symm)\n",
      "body": "```suggestion\n  apply CategoryTheory.Equivalence.mk (map hequiv) (map hequiv.symm)\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "equiv",
          "list",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "FundamentalGroupoid",
          "natural",
          "homotopicMapsNatIso",
          "convert",
          "expose",
          "after",
          "which",
          "But",
          "isomorphism",
          "CategoryTheory",
          "Main",
          "open",
          "section",
          "paths",
          "equivOfHomotopyEquiv",
          "This",
          "noncomputable",
          "universe",
          "corresponding",
          "notes",
          "equivalence",
          "requires",
          "spaces",
          "more",
          "passing",
          "TopCat",
          "pairs",
          "two",
          "homotopy",
          "public",
          "path",
          "definitions",
          "ULift",
          "uses",
          "induced",
          "prodToProdTop",
          "FundamentalGroupoidFunctor",
          "between",
          "Homotopy",
          "given",
          "construction",
          "uliftMap",
          "categories",
          "functors",
          "them",
          "through",
          "Implementation",
          "same",
          "hequiv",
          "this"
        ]
      }
    },
    {
      "id": 853,
      "before_code": "rw [totient_mul _, totient_prime hp]\n  simpa [h] using coprime_or_dvd_of_prime hp n",
      "suggestion": "\r\n  simpa using totient_mul_of_prime_of_not_dvd prime_two hn.not_two_dvd_nat\r\n",
      "body": "Does\r\n```suggestion\r\n  simpa using totient_mul_of_prime_of_not_dvd prime_two hn.not_two_dvd_nat\r\n```\r\nwork here?",
      "path": "Mathlib/Data/Nat/Totient.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "simpa",
          "totient_mul",
          "totient_prime",
          "coprime_or_dvd_of_prime",
          "using"
        ]
      }
    },
    {
      "id": 860,
      "before_code": "(entourageProd u v).IsSymm where\n  symm _ _ := .imp u.symm v.symm",
      "suggestion": "@[simp]\ntheorem image_entourageProd_prod (u : SetRel \u03b1 \u03b1) (v : SetRel \u03b2 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n",
      "body": "```suggestion\n@[simp]\ntheorem image_entourageProd_prod (u : SetRel \u03b1 \u03b1) (v : SetRel \u03b2 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n```",
      "path": "Mathlib/Topology/UniformSpace/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsSymm",
          "entourageProd",
          "symm",
          "imp"
        ]
      }
    },
    {
      "id": 861,
      "before_code": "(entourageProd u v).IsSymm where\n  symm _ _ := .imp u.symm v.symm",
      "suggestion": "@[simp]\ntheorem preimage_entourageProd_prod (u : SetRel \u03b1 \u03b1) (v : SetRel \u03b2 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n",
      "body": "```suggestion\n@[simp]\ntheorem preimage_entourageProd_prod (u : SetRel \u03b1 \u03b1) (v : SetRel \u03b2 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n```",
      "path": "Mathlib/Topology/UniformSpace/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsSymm",
          "entourageProd",
          "symm",
          "imp"
        ]
      }
    },
    {
      "id": 862,
      "before_code": "end LinearMap.transvection\n\nend baseChange",
      "suggestion": "@[simp] theorem det [Module.Free R V] [Module.Finite R V]\n",
      "body": "```suggestion\n@[simp] theorem det [Module.Free R V] [Module.Finite R V]\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "LinearMap",
          "end",
          "baseChange"
        ]
      }
    },
    {
      "id": 863,
      "before_code": "end LinearMap.transvection\n\nend baseChange",
      "suggestion": "@[simp] theorem _root_.LinearEquiv.det_eq_one\n",
      "body": "```suggestion\n@[simp] theorem _root_.LinearEquiv.det_eq_one\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "LinearMap",
          "end",
          "baseChange"
        ]
      }
    },
    {
      "id": 865,
      "before_code": "ext\n  simp",
      "suggestion": "@[simp]\ntheorem order_exp (A : Type*) [Ring A] [Algebra \u211a A] [Nontrivial A] : (exp A).order = 0 :=\n",
      "body": "```suggestion\n@[simp]\ntheorem order_exp (A : Type*) [Ring A] [Algebra \u211a A] [Nontrivial A] : (exp A).order = 0 :=\n```",
      "path": "Mathlib/RingTheory/PowerSeries/Exp.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "ring",
          "simp"
        ],
        "body_tactics": [
          "ring",
          "simp"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 871,
      "before_code": "have h\u2082 := cos_pi_div_three;\n    have h\u2082 := cos_zero] <;>\n  simp [injOn_cos h_bnd \u27e8by positivity, by linarith [pi_nonneg]\u27e9 (h\u2082 \u25b8 h)]",
      "suggestion": "  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n",
      "body": "```suggestion\n  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n```",
      "path": "Mathlib/NumberTheory/Niven.lean",
      "tags": {
        "before_tactics": [
          "positivity",
          "have",
          "simp",
          "linarith"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "grind",
          "have",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "grind",
          "have",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "grind",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "removed_tactics": [
          "positivity",
          "simp",
          "linarith"
        ],
        "topics": [],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "injOn_cos",
          "cos_pi_div_three",
          "positivity",
          "pi_nonneg",
          "have",
          "h_bnd",
          "simp",
          "linarith",
          "cos_zero"
        ]
      }
    },
    {
      "id": 892,
      "before_code": "obtain \u27e8b', hb', d_ab\u27e9 := exists_lt_mul_right_of_nonneg ha'.1 hd d_ab\n  exact d_ab.le.trans (h a' ha'.1 ha'.2 b' hb'.1 hb'.2)\n\ntheorem mul_self_inj_of_nonneg (a0 : 0 \u2264 a) (b0 : 0 \u2264 b) : a * a = b * b \u2194 a = b :=\n  mul_self_eq_mul_self_iff.trans <|\n    or_iff_left_of_imp fun h => by grind",
      "suggestion": "\r\n  have := fun h \u21a6 le_antisymm (neg_nonneg.mp h) b0\r\n  grind [sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg]\r\n",
      "body": "this is the same proof, but just using grind:\r\n```suggestion\r\n  have := fun h \u21a6 le_antisymm (neg_nonneg.mp h) b0\r\n  grind [sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg]\r\n```\r\nnot sure what file this could go to though\r\n\r\nalso, we have this [sq_eq_sq\u2080](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#sq_eq_sq%E2%82%80) which is essentially the same (but uses `LinearOrder`)",
      "path": "Mathlib/Algebra/Order/Field/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "grind",
          "obtain"
        ],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mul_self_eq_mul_self_iff",
          "theorem",
          "exact",
          "mul_self_inj_of_nonneg",
          "grind",
          "d_ab",
          "obtain",
          "trans",
          "exists_lt_mul_right_of_nonneg",
          "or_iff_left_of_imp"
        ]
      }
    },
    {
      "id": 907,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  simp [Lagrange.basis, basisDivisor, div_eq_mul_inv, prod_mul_distrib, \u2190 map_prod,\n    \u2190 prod_inv_distrib, mul_assoc]\n",
      "body": "```suggestion\n  simp [Lagrange.basis, basisDivisor, div_eq_mul_inv, prod_mul_distrib, \u2190 map_prod,\n    \u2190 prod_inv_distrib, mul_assoc]\n```\nThis can be done in one `simp`.",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 910,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_injOn hvs').mono (by grind)\n        case i_surj => grind [card_image_of_injOn, hvs'.mono]\n        case h =>\n          rw [eq_comm]\n          exact prod_image <| by grind [hvs'.mono]\n",
      "body": "```suggestion\n          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_in",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "rw",
          "intro",
          "omega"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_omega",
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 911,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  rw [iterate_derivative_interpolate _ hvs hk]\n  simp [eval_finset_sum, eval_prod]\n",
      "body": "```suggestion\n  rw [iterate_derivative_interpolate _ hvs hk]\n  simp [eval_finset_sum, eval_prod]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 912,
      "before_code": "namespace Matrix",
      "suggestion": "\r\n@[simp] lemma permMatrix_refl [Zero R] [One R] : Equiv.Perm.permMatrix R (.refl n) = 1 := by\r\n  simp [\u2190 Matrix.ext_iff, Matrix.one_apply]\r\n\r\n@[simp]\r\nlemma permMatrix_one [Zero R] [One R] : (1 : Equiv.Perm n).permMatrix R = 1 :=\r\n  permMatrix_refl\r\n",
      "body": "how about also adding the `Equiv.refl` part?\r\n\r\n```suggestion\r\n@[simp] lemma permMatrix_refl [Zero R] [One R] : Equiv.Perm.permMatrix R (.refl n) = 1 := by\r\n  simp [\u2190 Matrix.ext_iff, Matrix.one_apply]\r\n\r\n@[simp]\r\nlemma permMatrix_one [Zero R] [One R] : (1 : Equiv.Perm n).permMatrix R = 1 :=\r\n  permMatrix_refl\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/Permutation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Matrix",
          "namespace"
        ]
      }
    },
    {
      "id": 914,
      "before_code": "minTensorProduct C\u2081 C\u2082 \u2264 maxTensorProduct C\u2081 C\u2082 := by\n  exact Submodule.span_le.mpr (tmul_subset_maxTensorProduct C\u2081 C\u2082)",
      "suggestion": "  refine \u27e8?_, fun hz \u21a6\n    \u27e8(TensorProduct.comm R H G) z, ?_, (TensorProduct.comm R H G).symm_apply_apply z\u27e9\u27e9\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9 \u03c8 h\u03c8 \u03c6 h\u03c6\n    simpa [dualDistrib_apply_comm] using hw \u03c6 h\u03c6 \u03c8 h\u03c8\n  \u00b7 intro \u03c6 h\u03c6 \u03c8 h\u03c8\n    simpa [dualDistrib_apply_comm] using hz \u03c8 h\u03c8 \u03c6 h\u03c6\n",
      "body": "```suggestion\n  refine \u27e8?_, fun hz \u21a6\n    \u27e8(TensorProduct.comm R H G) z, ?_, (TensorProduct.comm R H G).symm_apply_apply z\u27e9\u27e9\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9 \u03c8 h\u03c8 \u03c6 h\u03c6\n    simpa [dualDistrib_apply_comm] using hw \u03c6 h\u03c6 \u03c8 h\u03c8\n  \u00b7 intro \u03c6 h\u03c6 \u03c8 h\u03c8\n    simpa [dualDistrib_apply_comm] using hz \u03c8 h\u03c8 \u03c6 h\u03c6\n```\ngolf; unsqueeze terminal simps",
      "path": "Mathlib/Geometry/Convex/Cone/TensorProduct.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "tmul_subset_maxTensorProduct",
          "mpr",
          "exact",
          "maxTensorProduct",
          "Submodule",
          "minTensorProduct",
          "span_le"
        ]
      }
    },
    {
      "id": 915,
      "before_code": "minTensorProduct C\u2081 C\u2082 \u2264 maxTensorProduct C\u2081 C\u2082 := by\n  exact Submodule.span_le.mpr (tmul_subset_maxTensorProduct C\u2081 C\u2082)",
      "suggestion": "  simp [minTensorProduct, map, span, Submodule.map_span, Set.image_image2,\n    Set.image2_swap (\u00b7 \u2297\u209c[R] \u00b7 : H \u2192 G \u2192 _)]\n",
      "body": "```suggestion\n  simp [minTensorProduct, map, span, Submodule.map_span, Set.image_image2,\n    Set.image2_swap (\u00b7 \u2297\u209c[R] \u00b7 : H \u2192 G \u2192 _)]\n```\nunsqueeze terminal simp",
      "path": "Mathlib/Geometry/Convex/Cone/TensorProduct.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "tmul_subset_maxTensorProduct",
          "mpr",
          "exact",
          "maxTensorProduct",
          "Submodule",
          "minTensorProduct",
          "span_le"
        ]
      }
    },
    {
      "id": 928,
      "before_code": "lemma not_monotone_not_antitone_iff_exists_le_le :\n    \u00ac Monotone f \u2227 \u00ac Antitone f \u2194\n      \u2203 a b c, a \u2264 b \u2227 b \u2264 c \u2227 ((f a < f b \u2227 f c < f b) \u2228 (f b < f a \u2227 f b < f c)) := by\n  simp_rw [Monotone, Antitone, not_forall, not_le]\n  refine Iff.symm \u27e8?_, ?_\u27e9\n  \u00b7 rintro \u27e8a, b, c, hab, hbc, \u27e8hfab, hfcb\u27e9 | \u27e8hfba, hfbc\u27e9\u27e9\n    exacts [\u27e8\u27e8_, _, hbc, hfcb\u27e9, _, _, hab, hfab\u27e9, \u27e8\u27e8_, _, hab, hfba\u27e9, _, _, hbc, hfbc\u27e9]\n  rintro \u27e8\u27e8a, b, hab, hfba\u27e9, c, d, hcd, hfcd\u27e9\n  obtain hda | had := le_total d a\n  \u00b7 obtain hfad | hfda := le_total (f a) (f d)\n    \u00b7 exact \u27e8c, d, b, hcd, hda.trans hab, Or.inl \u27e8hfcd, hfba.trans_le hfad\u27e9\u27e9\n    \u00b7 exact \u27e8c, a, b, hcd.trans hda, hab, Or.inl \u27e8hfcd.trans_le hfda, hfba\u27e9\u27e9\n  obtain hac | hca := le_total a c\n  \u00b7 obtain hfdb | hfbd := le_or_gt (f d) (f b)\n    \u00b7 exact \u27e8a, c, d, hac, hcd, Or.inr \u27e8hfcd.trans <| hfdb.trans_lt hfba, hfcd\u27e9\u27e9\n    obtain hfca | hfac := lt_or_ge (f c) (f a)\n    \u00b7 exact \u27e8a, c, d, hac, hcd, Or.inr \u27e8hfca, hfcd\u27e9\u27e9\n    obtain hbd | hdb := le_total b d\n    \u00b7 exact \u27e8a, b, d, hab, hbd, Or.inr \u27e8hfba, hfbd\u27e9\u27e9\n    \u00b7 exact \u27e8a, d, b, had, hdb, Or.inl \u27e8hfac.trans_lt hfcd, hfbd\u27e9\u27e9\n  \u00b7 obtain hfdb | hfbd := le_or_gt (f d) (f b)\n    \u00b7 exact \u27e8c, a, b, hca, hab, Or.inl \u27e8hfcd.trans <| hfdb.trans_lt hfba, hfba\u27e9\u27e9\n    obtain hfca | hfac := lt_or_ge (f c) (f a)\n    \u00b7 exact \u27e8c, a, b, hca, hab, Or.inl \u27e8hfca, hfba\u27e9\u27e9\n    obtain hbd | hdb := le_total b d\n    \u00b7 exact \u27e8a, b, d, hab, hbd, Or.inr \u27e8hfba, hfbd\u27e9\u27e9\n    \u00b7 exact \u27e8a, d, b, had, hdb, Or.inl \u27e8hfac.trans_lt hfcd, hfbd\u27e9\u27e9",
      "suggestion": "  simp only [Monotone, Antitone]\n  grind [not_le]\n",
      "body": "Let's make it clear that `grind` only needs to know about `not_le`, especially as the pattern `grind [foo, bar, baz]` can be a bit brittle to changes in `grind`\n```suggestion\n  simp only [Monotone, Antitone]\n  grind [not_le]\n```",
      "path": "Mathlib/Order/Monotone/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "suggestion_tactics": [
          "grind",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "lemma",
          "hca",
          "rintro",
          "Iff",
          "hfcb",
          "obtain",
          "hfac",
          "lt_or_ge",
          "inl",
          "hfba",
          "exacts",
          "symm",
          "refine",
          "not_le",
          "hfca",
          "hfbd",
          "Antitone",
          "simp_rw",
          "trans_le",
          "hfab",
          "hda",
          "hab",
          "hcd",
          "had",
          "not_monotone_not_antitone_iff_exists_le_le",
          "hbc",
          "hfbc",
          "hfdb",
          "hac",
          "le_total",
          "hfad",
          "exact",
          "Monotone",
          "hfcd",
          "le_or_gt",
          "not_forall",
          "trans",
          "hbd",
          "hdb",
          "trans_lt",
          "hfda",
          "inr"
        ]
      }
    },
    {
      "id": 930,
      "before_code": "simp_rw [measurable_iff_comap_le, MeasurableSpace.pi, MeasurableSpace.comap_iSup,\n    MeasurableSpace.comap_comp, Function.comp_def, iSup_le_iff]",
      "suggestion": "theorem MeasurableSpace.comap_le_comap_pi {g : (a : \u03b4) \u2192 \u03b2 \u2192 X a} (a : \u03b4) :\n    .comap (g a) inferInstance \u2264 pi.comap (fun b c \u21a6 g c b) := by\n  simpa only [pi, comap_iSup] using le_iSup_of_le a <| by measurability\n",
      "body": "```suggestion\ntheorem MeasurableSpace.comap_le_comap_pi {g : (a : \u03b4) \u2192 \u03b2 \u2192 X a} (a : \u03b4) :\n    .comap (g a) inferInstance \u2264 pi.comap (fun b c \u21a6 g c b) := by\n  simpa only [pi, comap_iSup] using le_iSup_of_le a <| by measurability\n```",
      "path": "Mathlib/MeasureTheory/MeasurableSpace/Constructions.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "measurability"
        ],
        "body_tactics": [
          "simpa",
          "measurability"
        ],
        "new_tactics": [
          "simpa",
          "measurability"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "order",
          "function"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "comp_def",
          "iSup_le_iff",
          "comap_iSup",
          "comap_comp",
          "simp_rw",
          "MeasurableSpace",
          "Function",
          "measurable_iff_comap_le"
        ]
      }
    },
    {
      "id": 965,
      "before_code": "end QuasiFinite",
      "suggestion": "  have : IsLocalizedModule (.powers r) (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8fun x \u21a6 IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n      \u27e8x, hrp' x.2\u27e9, fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simp [Submonoid.mem_powers_iff]\u27e9\n",
      "body": "```suggestion\n  have : IsLocalizedModule (.powers r) (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8fun x \u21a6 IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n      \u27e8x, hrp' x.2\u27e9, fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simp [Submonoid.mem_powers_iff]\u27e9\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 967,
      "before_code": "end QuasiFinite",
      "suggestion": "  have : IsLocalizedModule p.primeCompl (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p)),\n      fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simpa using \u27e81, p.primeCompl.one_mem\u27e9\u27e9\n",
      "body": "```suggestion\n  have : IsLocalizedModule p.primeCompl (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p)),\n      fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simpa using \u27e81, p.primeCompl.one_mem\u27e9\u27e9\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 968,
      "before_code": "end QuasiFinite",
      "suggestion": "  obtain \u27e8r, hrp, H\u27e9 := exists_bijective_map_powers p.primeCompl\n      (Algebra.linearMap S (Localization.AtPrime p)) (.id (R := S) (M := Localization.AtPrime p))\n      (Algebra.linearMap S (Localization.AtPrime p)) <| by\n    convert show Function.Bijective LinearMap.id from Function.bijective_id\n    apply IsLocalizedModule.ext p.primeCompl (Algebra.linearMap S (Localization.AtPrime p))\n    \u00b7 exact IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n    \u00b7 simp [IsLocalizedModule.map_comp]\n",
      "body": "```suggestion\n  obtain \u27e8r, hrp, H\u27e9 := exists_bijective_map_powers p.primeCompl\n      (Algebra.linearMap S (Localization.AtPrime p)) (.id (R := S) (M := Localization.AtPrime p))\n      (Algebra.linearMap S (Localization.AtPrime p)) <| by\n    convert show Function.Bijective LinearMap.id from Function.bijective_id\n    apply IsLocalizedModule.ext p.primeCompl (Algebra.linearMap S (Localization.AtPrime p))\n    \u00b7 exact IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n    \u00b7 sim",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "ext",
          "exact",
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "ext",
          "exact",
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "simp",
          "ext",
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 970,
      "before_code": "end QuasiFinite",
      "suggestion": "  -- As S\u209a is an artinian local ring, its prime spectrum is a singleton.\n  obtain rfl : q = IsLocalRing.closedPoint _ := Subsingleton.elim _ _\n",
      "body": "```suggestion\n  -- As S\u209a is an artinian local ring, its prime spectrum is a singleton.\n  obtain rfl : q = IsLocalRing.closedPoint _ := Subsingleton.elim _ _\n```\nI was quite confused for a bit what was going on here.",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "ring"
        ],
        "body_tactics": [
          "obtain",
          "ring"
        ],
        "new_tactics": [
          "obtain",
          "ring"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 971,
      "before_code": "end QuasiFinite",
      "suggestion": "    congr($(e.symm_apply_apply \u27e8\u27e8q, \u2039_\u203a\u27e9, PrimeSpectrum.ext (q.over_def p).symm\u27e9).1.1).symm\n",
      "body": "```suggestion\n    congr($(e.symm_apply_apply \u27e8\u27e8q, \u2039_\u203a\u27e9, PrimeSpectrum.ext (q.over_def p).symm\u27e9).1.1).symm\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr",
          "ext"
        ],
        "body_tactics": [
          "congr",
          "ext"
        ],
        "new_tactics": [
          "congr",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 978,
      "before_code": "map_smul' := g.hom.map_smul }\n  map_add' _ _ := rfl",
      "suggestion": "\r\n/-- Restrictions of scalars along equal ring homomorphisms are naturally isomorphic. -/\r\n",
      "body": "```suggestion\r\n/-- Restrictions of scalars along equal ring homomorphisms are naturally isomorphic. -/\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/ChangeOfRings.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "rfl",
          "hom",
          "map_smul",
          "map_add"
        ]
      }
    },
    {
      "id": 979,
      "before_code": "map_smul' := g.hom.map_smul }\n  map_add' _ _ := rfl",
      "suggestion": "\r\n\r\n@[simp]\r\nlemma restrictScalarsCongr_inv_app\r\n    {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] {f g : R \u2192+* S} (e : f = g)\r\n    (M : ModuleCat S) (x : M) :\r\n  (restrictScalarsCongr e).inv.app M x = x := rfl\r\n\r\n",
      "body": "```suggestion\r\n\r\n@[simp]\r\nlemma restrictScalarsCongr_inv_app\r\n    {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] {f g : R \u2192+* S} (e : f = g)\r\n    (M : ModuleCat S) (x : M) :\r\n  (restrictScalarsCongr e).inv.app M x = x := rfl\r\n\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/ChangeOfRings.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ring",
          "simp"
        ],
        "body_tactics": [
          "ring",
          "simp"
        ],
        "new_tactics": [
          "ring",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "rfl",
          "hom",
          "map_smul",
          "map_add"
        ]
      }
    },
    {
      "id": 981,
      "before_code": "pushforward.{v} (S := R) (F := \ud835\udfed _) (\ud835\udfd9 R) \u2245 \ud835\udfed _ :=\n  Iso.refl _",
      "suggestion": "\r\n\r\n@[simp] lemma pushforwardCongr_inv_app_val_app\r\n    {\u03c6 \u03c8 : S \u27f6 (F.sheafPushforwardContinuous RingCat.{u} J K).obj R} (e : \u03c6 = \u03c8) (M U x) :\r\n  ((pushforwardCongr e).inv.app M).val.app U x = x := rfl\r\n\r\n",
      "body": "```suggestion\r\n\r\n@[simp] lemma pushforwardCongr_inv_app_val_app\r\n    {\u03c6 \u03c8 : S \u27f6 (F.sheafPushforwardContinuous RingCat.{u} J K).obj R} (e : \u03c6 = \u03c8) (M U x) :\r\n  ((pushforwardCongr e).inv.app M).val.app U x = x := rfl\r\n\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/PushforwardContinuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Iso",
          "refl",
          "pushforward"
        ]
      }
    },
    {
      "id": 985,
      "before_code": "instance : Abelian X.Modules :=\n  inferInstanceAs (Abelian (SheafOfModules.{u} X.ringCatSheaf))",
      "suggestion": "\r\n\r\n@[simp] lemma Hom.comp_app {K : X.Modules} (\u03c6 : M \u27f6 N) (\u03c8 : N \u27f6 K) :\r\n    (\u03c6 \u226b \u03c8).app U = \u03c6.app U \u226b \u03c8.app U := rfl\r\n\r\n@[simp] lemma Hom.id_app (M : X.Modules) : (\ud835\udfd9 M : _ \u27f6 _).app U = \ud835\udfd9 _ := rfl\r\n\r\n",
      "body": "```suggestion\r\n\r\n@[simp] lemma Hom.comp_app {K : X.Modules} (\u03c6 : M \u27f6 N) (\u03c8 : N \u27f6 K) :\r\n    (\u03c6 \u226b \u03c8).app U = \u03c6.app U \u226b \u03c8.app U := rfl\r\n\r\n@[simp] lemma Hom.id_app (M : X.Modules) : (\ud835\udfd9 M : _ \u27f6 _).app U = \ud835\udfd9 _ := rfl\r\n\r\n```",
      "path": "Mathlib/AlgebraicGeometry/Modules/Sheaf.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Abelian",
          "Modules",
          "inferInstanceAs",
          "SheafOfModules",
          "ringCatSheaf",
          "instance"
        ]
      }
    },
    {
      "id": 996,
      "before_code": "(g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g :=\n  rfl",
      "suggestion": "@[simp]\nlemma coe_prod {\u03b9 : Type} {s : Finset \u03b9} (hs : s.Nonempty) {k : \u03b9 \u2192 \u2124}\n",
      "body": "```suggestion\n@[simp]\nlemma coe_prod {\u03b9 : Type} {s : Finset \u03b9} (hs : s.Nonempty) {k : \u03b9 \u2192 \u2124}\n```\nFollowing what `coe_mul` does.",
      "path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "SlashInvariantForm",
          "mul"
        ]
      }
    },
    {
      "id": 997,
      "before_code": "(g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g :=\n  rfl",
      "suggestion": "@[simp]\nlemma coe_prodType {\u03b9 : Type} [Fintype \u03b9] [Nonempty \u03b9] {k : \u03b9 \u2192 \u2124} (m : \u2124)\n",
      "body": "```suggestion\n@[simp]\nlemma coe_prodType {\u03b9 : Type} [Fintype \u03b9] [Nonempty \u03b9] {k : \u03b9 \u2192 \u2124} (m : \u2124)\n```",
      "path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "SlashInvariantForm",
          "mul"
        ]
      }
    },
    {
      "id": 1037,
      "before_code": "DFunLike.coe_injective.addCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl",
      "suggestion": "\r\nopen Classical in\r\n@[simp]\r\ntheorem sum_apply {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 \ud835\udce2(E, F)) (x : E) :\r\n    (\u2211 i \u2208 s, f i) x = \u2211 i \u2208 s, f i x := by\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert i s his h =>\r\n    simp [his, h]\r\n",
      "body": "```suggestion\r\nopen Classical in\r\n@[simp]\r\ntheorem sum_apply {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 \ud835\udce2(E, F)) (x : E) :\r\n    (\u2211 i \u2208 s, f i) x = \u2211 i \u2208 s, f i x := by\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert i s his h =>\r\n    simp [his, h]\r\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "induction",
          "simp"
        ],
        "body_tactics": [
          "induction",
          "simp"
        ],
        "new_tactics": [
          "induction",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "rfl",
          "coe_injective",
          "DFunLike",
          "addCommGroup"
        ]
      }
    },
    {
      "id": 1038,
      "before_code": "DFunLike.coe_injective.addCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl",
      "suggestion": "\r\n  | insert i s his h => simp [his, h]\r\n",
      "body": "```suggestion\r\n  | insert i s his h => simp [his, h]\r\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "rfl",
          "coe_injective",
          "DFunLike",
          "addCommGroup"
        ]
      }
    },
    {
      "id": 1050,
      "before_code": "convert (sum_map _ (addRightEmbedding k) (\u00b7.choose k)).symm using 2\n  rw [map_add_right_Ico, zero_add, add_right_comm, Ico_add_one_right_eq_Icc]",
      "suggestion": "\r\nlemma sum_range_multichoose (n k : \u2115) :\r\n    \u2211 i \u2208 Finset.range (n + 1), k.multichoose i = (n + k).choose k := by\r\n  cases k with\r\n  | zero => simp [Finset.sum_range_succ']\r\n  | succ k => grind [multichoose_eq, choose_symm_of_eq_add, sum_range_add_choose]\r\n",
      "body": "```suggestion\r\nlemma sum_range_multichoose (n k : \u2115) :\r\n    \u2211 i \u2208 Finset.range (n + 1), k.multichoose i = (n + k).choose k := by\r\n  cases k with\r\n  | zero => simp [Finset.sum_range_succ']\r\n  | succ k => grind [multichoose_eq, choose_symm_of_eq_add, sum_range_add_choose]\r\n```\r\nThis theorem can be proved in a shorter way, and with fewer assumptions. \r\n(Also, I think patterns like `simp only [\u2190 h1 \u25b8 h2 \u25b8 (sum_Icc_choose (n + (k - 1)) (k - 1))` should be avoided from mathlib, since they're pretty to",
      "path": "Mathlib/Data/Nat/Choose/Sum.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "grind",
          "cases",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "cases",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "Ico_add_one_right_eq_Icc",
          "addRightEmbedding",
          "symm",
          "convert",
          "zero_add",
          "add_right_comm",
          "choose",
          "sum_map",
          "map_add_right_Ico",
          "using"
        ]
      }
    },
    {
      "id": 1055,
      "before_code": "/-! ### Properties about `aleph0` -/\n\ntheorem nat_lt_aleph0 (n : \u2115) : (n : Cardinal.{u}) < \u2135\u2080 :=\n  succ_le_iff.1\n    (by\n      rw [\u2190 nat_succ, \u2190 lift_mk_fin, aleph0, lift_mk_le.{u}]\n      exact \u27e8\u27e8(\u2191), fun a b => Fin.ext\u27e9\u27e9)",
      "suggestion": "\r\n@[simp] lemma natCast_lt_aleph0 {n : \u2115} : (n : Cardinal.{u}) < \u2135\u2080 := by\r\n",
      "body": "Shouldn't this be called?\r\n```suggestion\r\n@[simp] lemma natCast_lt_aleph0 {n : \u2115} : (n : Cardinal.{u}) < \u2135\u2080 := by\r\n```",
      "path": "Mathlib/SetTheory/Cardinal/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "ext"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "about",
          "aleph0",
          "ext",
          "theorem",
          "exact",
          "Properties",
          "nat_succ",
          "Fin",
          "lift_mk_le",
          "lift_mk_fin",
          "succ_le_iff",
          "nat_lt_aleph0",
          "Cardinal"
        ]
      }
    },
    {
      "id": 1056,
      "before_code": "e.conj f = ((\u2191e : M\u2081' \u2192\u209b\u2097[\u03c3\u2081'\u2082'] M\u2082').comp f).comp (e.symm : M\u2082' \u2192\u209b\u2097[\u03c3\u2082'\u2081'] M\u2081') :=\n  rfl",
      "suggestion": "\r\n/--\r\nNote this has lower `simp` priority for performance reasons, so that we rewrite as\r\n`e.conj LinearMap.id x => LinearMap.id x` => `x` rather than\r\n`e.conj LinearMap.id x => e (LinearMap.id (e.symm x)) => e (e.symm x) => x`.\r\n-/\r\n",
      "body": "```suggestion\r\n/--\r\nNote this has lower `simp` priority for performance reasons, so that we rewrite as\r\n`e.conj LinearMap.id x => LinearMap.id x` => `x` rather than\r\n`e.conj LinearMap.id x => e (LinearMap.id (e.symm x)) => e (e.symm x) => x`.\r\n-/\r\n```",
      "path": "Mathlib/Algebra/Module/Equiv/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "symm",
          "conj"
        ]
      }
    },
    {
      "id": 1064,
      "before_code": "characteristic f \u22a4 - characteristic (f \u00b7 - a\u2080) \u22a4 = proximity f \u22a4 - proximity (f \u00b7 - a\u2080) \u22a4 := by\n  simp [\u2190 Pi.sub_def, characteristic, logCounting_sub_const h]",
      "suggestion": "\r\n    0 \u2264 characteristic f a r := \r\n  add_nonneg (proximity_nonneg r) (logCounting_nonneg hr)\r\n",
      "body": "In this case, the `simp` is only applying defeqs, so you can just do this:\r\n```suggestion\r\n    0 \u2264 characteristic f a r := \r\n  add_nonneg (proximity_nonneg r) (logCounting_nonneg hr)\r\n```\r\nIn case it weren't, you could do this (do you know about `simpa`)?\r\n```suggestion\r\n    0 \u2264 characteristic f a r := by\r\n  simpa only [characteristic, Pi.add_apply] using\r\n  \tadd_nonneg (proximity_nonneg r) (logCounting_nonneg hr)\r\n```\r\n`simpa` is helpful when you want to construct a term, but both that term and",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CharacteristicFunction.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "logCounting_sub_const",
          "proximity",
          "sub_def",
          "characteristic",
          "simp"
        ]
      }
    },
    {
      "id": 1065,
      "before_code": "@[simp] theorem logCounting_const_zero {e : WithTop E} :\n    logCounting (0 : \ud835\udd5c \u2192 E) e = 0 := logCounting_const",
      "suggestion": "\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n",
      "body": "```suggestion\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n```",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CountingFunction.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "positivity"
        ],
        "body_tactics": [
          "simpa",
          "positivity"
        ],
        "new_tactics": [
          "simpa",
          "positivity"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "logCounting",
          "WithTop",
          "theorem",
          "logCounting_const_zero",
          "logCounting_const",
          "simp"
        ]
      }
    },
    {
      "id": 1076,
      "before_code": "isLocalizedModule_iff_isLocalization.mp inferInstance\n  inferInstance",
      "suggestion": "\r\n  \u00b7 simp [tensorKaehlerEquiv']\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [tensorKaehlerEquiv']\r\n```",
      "path": "Mathlib/RingTheory/Kaehler/TensorProduct.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "isLocalizedModule_iff_isLocalization",
          "inferInstance"
        ]
      }
    },
    {
      "id": 1077,
      "before_code": "isLocalizedModule_iff_isLocalization.mp inferInstance\n  inferInstance",
      "suggestion": "\r\n  rw [show s \u2297\u209c[R] 1 = algebraMap S (S \u2297[R] A) s by rfl,\r\n    show (algebraMap A (S \u2297[R] A)) a = 1 \u2297\u209c[R] a by rfl,\r\n    algebraMap_smul, \u2190 Derivation.map_smul, smul_tmul', smul_eq_mul, mul_one]\r\n",
      "body": "```suggestion\r\n  rw [show s \u2297\u209c[R] 1 = algebraMap S (S \u2297[R] A) s by rfl,\r\n    show (algebraMap A (S \u2297[R] A)) a = 1 \u2297\u209c[R] a by rfl,\r\n    algebraMap_smul, \u2190 Derivation.map_smul, smul_tmul', smul_eq_mul, mul_one]\r\n```\r\nI think this is slightly better: this way it\u2019s clear what defeq are being used.",
      "path": "Mathlib/RingTheory/Kaehler/TensorProduct.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "isLocalizedModule_iff_isLocalization",
          "inferInstance"
        ]
      }
    },
    {
      "id": 1084,
      "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
      "suggestion": "\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n",
      "body": "Untested, but something like this should work?\r\n```suggestion\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "new_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "_ha",
          "mem_top",
          "le_top",
          "theorem"
        ]
      }
    },
    {
      "id": 1085,
      "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
      "suggestion": "\r\n  refine fun h \u21a6 \u27e8\u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9, ?_\u27e9\r\n",
      "body": "You could merge these two lines as well (though you might argue the original is cleaner)\r\n```suggestion\r\n  refine fun h \u21a6 \u27e8\u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9, ?_\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "_ha",
          "mem_top",
          "le_top",
          "theorem"
        ]
      }
    },
    {
      "id": 1102,
      "before_code": "(s.reindex e).touchpoint signs i = s.touchpoint (signs.map e.symm) (e.symm i) :=\n  orthogonalProjectionSpan_congr (s.range_faceOpposite_reindex _ _) (s.excenter_reindex _ _)",
      "suggestion": "\r\n  haveI := Nonempty.map (AffineSubspace.inclusion hS) inferInstance\r\n  exact (h.touchpoint_map S.subtype\u2090\u1d62 i).symm\r\n",
      "body": "```suggestion\r\n  haveI := Nonempty.map (AffineSubspace.inclusion hS) inferInstance\r\n  exact (h.touchpoint_map S.subtype\u2090\u1d62 i).symm\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Incenter.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "orthogonalProjectionSpan_congr",
          "reindex",
          "map",
          "signs",
          "touchpoint",
          "range_faceOpposite_reindex",
          "excenter_reindex"
        ]
      }
    },
    {
      "id": 1103,
      "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
      "suggestion": "\r\n  simp only [Submodule.ext_iff, mem_map, mem_orthogonal, forall_exists_index, and_imp,\r\n    forall_apply_eq_imp_iff\u2082, LinearIsometryEquiv.inner_map_eq_flip]\r\n  exact fun x \u21a6 \u27e8fun \u27e8y, hy\u27e9 z hz \u21a6 by simp [\u2190 hy.2, hy.1 _ hz], fun h \u21a6 \u27e8_, h, by simp\u27e9\u27e9\r\n",
      "body": "```suggestion\r\n  simp only [Submodule.ext_iff, mem_map, mem_orthogonal, forall_exists_index, and_imp,\r\n    forall_apply_eq_imp_iff\u2082, LinearIsometryEquiv.inner_map_eq_flip]\r\n  exact fun x \u21a6 \u27e8fun \u27e8y, hy\u27e9 z hz \u21a6 by simp [\u2190 hy.2, hy.1 _ hz], fun h \u21a6 \u27e8_, h, by simp\u27e9\u27e9\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "CompleteSpace",
          "instOrthogonalCompleteSpace",
          "isClosed_orthogonal",
          "instance",
          "completeSpace_coe"
        ]
      }
    },
    {
      "id": 1104,
      "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
      "suggestion": "\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n",
      "body": "(I don't know if this is recommended, but you _can_ technically do this in one line:\r\n```suggestion\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n```\r\n)\r\nProbably over-golfed though... so less of a suggestion, and more of an observation I guess",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "cleanup_simp",
          "use_aesop"
        ],
        "keywords": [
          "CompleteSpace",
          "instOrthogonalCompleteSpace",
          "isClosed_orthogonal",
          "instance",
          "completeSpace_coe"
        ]
      }
    },
    {
      "id": 1113,
      "before_code": "convert ((open_iff i subset_rfl).mp open_V).inter open_W using 1\n    refine Set.ext fun e \u21a6 and_right_comm.trans (and_congr_right fun \u27e8hV, hU\u27e9 \u21a6 ?_)\n    rw [Set.mem_preimage, dif_pos hV, inj i (inv_U i _) hU (f_inv i _)]",
      "suggestion": "\r\n  /- for each preimage e of x, choose a homeomorphism \u03c6\u2091\r\n    from a neighborhood of e to its image -/\r\n  choose \u03c6 h\u03c6 using fun e : f \u207b\u00b9' {x} \u21a6 h e e.2\r\n  -- separately, choose pairwise disjoint neighborhoods V\u2091 by Hausdorff-ness\r\n  have \u27e8V, hV, disj\u27e9 := fin.t2_separation\r\n  -- let V\u2091' be the intersection V\u2091 \u2229 dom(\u03c6\u2091)\r\n  let V' (e : f \u207b\u00b9' {x}) := V e \u2229 (\u03c6 e).source\r\n  have hV' e : IsOpen (V' e) := (hV e).2.inter (\u03c6 e).open_source\r\n  have : \u22c3 e, V' e \u2208 nhdsSet (f \u207b\u00b9' {x}) :=\r\n    (isOpen_iUnion hV').mem_nhdsSet.2 fun e he \u21a6 mem_iUnion_of_mem \u27e8e, he\u27e9 \u27e8(hV e).1, (h\u03c6 _).1\u27e9\r\n  -- since f is a closed map, the union of the V\u2091' contains the preimage of a neighborhood U \u220b x\r\n  have \u27e8W, hWx, hWV\u27e9 := isClosedMap_iff_comap_nhds_le.mp hf this\r\n  cases isEmpty_or_nonempty (f \u207b\u00b9' {x})\r\n  \u00b7 exact .of_preimage_eq_empty _ hWx (by simpa using hWV)\r\n  have \u27e8U, hUW, hU, hxU\u27e9 := mem_nhds_iff.mp hWx\r\n  -- show that the intersection of U with the images of V\u2091' is evenly covered\r\n  let U' := U \u2229 \u22c2 e : f \u207b\u00b9' ",
      "body": "```suggestion\r\n  /- for each preimage e of x, choose a homeomorphism \u03c6\u2091\r\n    from a neighborhood of e to its image -/\r\n  choose \u03c6 h\u03c6 using fun e : f \u207b\u00b9' {x} \u21a6 h e e.2\r\n  -- separately, choose pairwise disjoint neighborhoods V\u2091 by Hausdorff-ness\r\n  have \u27e8V, hV, disj\u27e9 := fin.t2_separation\r\n  -- let V\u2091' be the intersection V\u2091 \u2229 dom(\u03c6\u2091)\r\n  let V' (e : f \u207b\u00b9' {x}) := V e \u2229 (\u03c6 e).source\r\n  have hV' e : IsOpen (V' e) := (hV e).2.inter (\u03c6 e).open_source\r\n  have : \u22c3 e, V' e \u2208 nhdsSet (f \u207b\u00b9' {x}) :=\r\n    (",
      "path": "Mathlib/Topology/Covering/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "removed_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "and_right_comm",
          "refine",
          "ext",
          "convert",
          "f_inv",
          "open_iff",
          "dif_pos",
          "inter",
          "and_congr_right",
          "subset_rfl",
          "open_W",
          "inv_U",
          "Set",
          "trans",
          "mem_preimage",
          "using",
          "open_V",
          "inj"
        ]
      }
    },
    {
      "id": 1119,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    exact (one_ne_zero heq).elim\r\n",
      "body": "Here's a slight golf.\r\n```suggestion\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at he",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 1121,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n",
      "body": "```suggestion\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n```\r\nThis is slightly shorter.",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "simp_all",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 1122,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n",
      "body": "```suggestion\n  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "grind",
          "simp_all",
          "have",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp_all",
          "have",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "have",
          "simp",
          "simp_all"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 1142,
      "before_code": "@[simp]\ntheorem filter_ne_eq_erase' (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : f.filter (i \u2260 \u00b7) = f.erase i := by\n  rw [\u2190 filter_ne_eq_erase f i]\n  congr with j\n  exact ne_comm",
      "suggestion": "\r\n  ext; grind\r\n",
      "body": "```suggestion\r\n  ext; grind\r\n```\r\n\r\nIn the meantime, it is preferable to the one-liner `ext; grind`. (also `filter_ne_eq_erase` while you're at it)",
      "path": "Mathlib/Data/DFinsupp/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "congr",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "ext"
        ],
        "body_tactics": [
          "grind",
          "ext"
        ],
        "new_tactics": [
          "grind",
          "ext"
        ],
        "removed_tactics": [
          "exact",
          "congr",
          "rw",
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "filter_ne_eq_erase",
          "erase",
          "theorem",
          "exact",
          "filter",
          "ne_comm",
          "simp",
          "congr"
        ]
      }
    },
    {
      "id": 1148,
      "before_code": "set_option linter.unusedTactic false in\nadd_aesop_rules safe tactic (rule_sets := [finiteness]) (by positivity)\n\n/-- Tactic to solve goals of the form `*** < \u221e` and (equivalently) `*** \u2260 \u221e` in the extended\nnonnegative reals (`\u211d\u22650\u221e`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (config := { introsTransparency? := some .reducible, terminal := true, enableSimp := false })\n    (rule_sets := [$(Lean.mkIdent `finiteness):ident, -default, -builtin]))",
      "suggestion": "\r\n| `(tactic| finiteness $c:Aesop.tactic_clause* [$h,+]) =>\r\n",
      "body": "```suggestion\r\n| `(tactic| finiteness $c:Aesop.tactic_clause* [$h,+]) =>\r\n```\r\nI believe you can use this to ensure that there is at least one argument (the next line doesn't change) (also below).",
      "path": "Mathlib/Tactic/Finiteness.lean",
      "tags": {
        "before_tactics": [
          "positivity",
          "aesop"
        ],
        "suggestion_tactics": [
          "aesop"
        ],
        "body_tactics": [
          "aesop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "positivity"
        ],
        "topics": [
          "real",
          "set_theory",
          "equiv"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "tactic_clause",
          "reducible",
          "reals",
          "true",
          "safe",
          "terminal",
          "nonnegative",
          "Tactic",
          "equivalently",
          "mkIdent",
          "form",
          "finiteness",
          "positivity",
          "Lean",
          "builtin",
          "linter",
          "introsTransparency",
          "name",
          "false",
          "solve",
          "goals",
          "unusedTactic",
          "aesop",
          "add_aesop_rules",
          "macro",
          "ident",
          "default",
          "tactic",
          "config",
          "extended",
          "Aesop",
          "rule_sets",
          "enableSimp",
          "set_option",
          "some"
        ]
      }
    },
    {
      "id": 1165,
      "before_code": "ContinuousLinearMap.fst \ud835\udd5c E E + ContinuousLinearMap.snd \ud835\udd5c E E |>.isBigOTVS_comp\n    |>.trans <| h\u2081.prodMk h\u2082",
      "suggestion": "\r\n@[to_fun]\r\nprotected theorem IsLittleOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n",
      "body": "```suggestion\r\n@[to_fun]\r\nprotected theorem IsLittleOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n```\r\nUnfortunately this does not work earlier because we can't provide our own name...",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigOTVS_comp",
          "ContinuousLinearMap",
          "fst",
          "trans",
          "prodMk",
          "snd"
        ]
      }
    },
    {
      "id": 1166,
      "before_code": "ContinuousLinearMap.fst \ud835\udd5c E E + ContinuousLinearMap.snd \ud835\udd5c E E |>.isBigOTVS_comp\n    |>.trans <| h\u2081.prodMk h\u2082",
      "suggestion": "\r\n\r\ntheorem isLittleOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isLittleOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =o[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =o[\ud835\udd5c; l] g :=\r\n  isLittleOTVS_comm\r\n\r\n@[to_fun]\r\nprotected theorem IsBigOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n\r\ntheorem isBigOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isBigOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =O[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =O[\ud835\udd5c; l] g :=\r\n  isBigOTVS_comm\r\n\r\n",
      "body": "Why no also add the following?\r\n```suggestion\r\n\r\ntheorem isLittleOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isLittleOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =o[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =o[\ud835\udd5c; l] g :=\r\n  isLittleOTVS_comm\r\n\r\n@[to_fun]\r\nprotected theorem IsBigOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n\r\ntheorem isBigOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 ",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigOTVS_comp",
          "ContinuousLinearMap",
          "fst",
          "trans",
          "prodMk",
          "snd"
        ]
      }
    },
    {
      "id": 1167,
      "before_code": "ContinuousLinearMap.fst \ud835\udd5c E E + ContinuousLinearMap.snd \ud835\udd5c E E |>.isBigOTVS_comp\n    |>.trans <| h\u2081.prodMk h\u2082",
      "suggestion": "\r\n\r\ntheorem IsBigOTVS.triangle [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E]\r\n    {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : Filter \u03b1}\r\n    (h\u2081 : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) (h\u2082 : (f\u2082 - f\u2083) =O[\ud835\udd5c; l] g) : (f\u2081 - f\u2083) =O[\ud835\udd5c; l] g := by\r\n  simpa using h\u2081.add h\u2082\r\n\r\n",
      "body": "While you're at it:\r\n```suggestion\r\n\r\ntheorem IsBigOTVS.triangle [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E]\r\n    {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : Filter \u03b1}\r\n    (h\u2081 : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) (h\u2082 : (f\u2082 - f\u2083) =O[\ud835\udd5c; l] g) : (f\u2081 - f\u2083) =O[\ud835\udd5c; l] g := by\r\n  simpa using h\u2081.add h\u2082\r\n\r\n```",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigOTVS_comp",
          "ContinuousLinearMap",
          "fst",
          "trans",
          "prodMk",
          "snd"
        ]
      }
    },
    {
      "id": 1180,
      "before_code": "le_prod_of_submultiplicative_on_pred_of_nonneg f (fun _ \u21a6 True) h0 h_one\n    (fun x y _ _ \u21a6 h_mul x y) (by simp) s (by simp)",
      "suggestion": "      \u00b7 exact le_trans (zero_le_one' \u03b2) (h1 a)\n",
      "body": "The use of `MulOpposite.one_le_op.mp (h1 a)` appears incorrect. The lemma `MulOpposite.one_le_op` states `1 \u2264 op a \u2194 1 \u2264 a`, so `.mp` requires a hypothesis of the form `1 \u2264 op (f a)`, but `h1 a` provides `1 \u2264 f a`, not `1 \u2264 op (f a)`. The expression `le_trans (zero_le_one' \u03b2) (h1 a)` should be sufficient to prove `0 \u2264 f a`.\n```suggestion\n      \u00b7 exact le_trans (zero_le_one' \u03b2) (h1 a)\n```",
      "path": "Mathlib/Algebra/Order/BigOperators/Ring/Multiset.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "True",
          "le_prod_of_submultiplicative_on_pred_of_nonneg",
          "simp",
          "h_one",
          "h_mul"
        ]
      }
    },
    {
      "id": 1183,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  have h_ineq := h \u25b8 (leading_coeff_le_mahlerMeasure <| p.map (castRingHom \u2102))\n  rw [leadingCoeff_map_of_injective (castRingHom \u2102).injective_int, eq_intCast]\n",
      "body": "```suggestion\n  have h_ineq := h \u25b8 (leading_coeff_le_mahlerMeasure <| p.map (castRingHom \u2102))\n  rw [leadingCoeff_map_of_injective (castRingHom \u2102).injective_int, eq_intCast]\n```\n(minor golfing; possibly the `rw` line can be combined with the next after this)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "rw",
          "have"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1184,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  rw [leadingCoeff_map_of_injective (castRingHom \u2102).injective_int, eq_intCast] at this\n",
      "body": "```suggestion\n  rw [leadingCoeff_map_of_injective (castRingHom \u2102).injective_int, eq_intCast] at this\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1185,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "\r\n  have : p.leadingCoeff = 1 \u2228 p.leadingCoeff = -1 := abs_eq_abs.mp <|\r\n    abs_leadingCoeff_eq_one_of_mahlerMeasure_eq_one h\r\n",
      "body": "```suggestion\r\n  have : p.leadingCoeff = 1 \u2228 p.leadingCoeff = -1 := abs_eq_abs.mp <|\r\n    abs_leadingCoeff_eq_one_of_mahlerMeasure_eq_one h\r\n```\r\n(`<|` should be at the end of the line, not at the beginning)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1186,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "        mem_le_prod_of_one_le _ (fun a \u21a6 le_max_left 1 \u2016a\u2016) _ z hz\n",
      "body": "```suggestion\n        mem_le_prod_of_one_le _ (fun a \u21a6 le_max_left 1 \u2016a\u2016) _ z hz\n```\n(this is where you'll have some simplification from making the arguments implicit)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1188,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  suffices \u2203 (n : \u2115) (_ : 0 < n), y ^ n = 1 by\n    obtain \u27e8n, hn\u2080, hn\u2081\u27e9 := this\n    exact \u27e8n, hn\u2080, congrArg (algebraMap K \u2102) hn\u2081\u27e9\n  refine NumberField.Embeddings.pow_eq_one_of_norm_le_one (x := y) K \u2102 (Subtype.coe_ne_coe.mp hz\u2080)\n    (coe_isIntegral_iff.mp <| isIntegral_of_mahlerMeasure_eq_one h hz)\n    fun \u03c6 \u21a6 norm_root_le_one_of_mahlerMeasure_eq_one h ?_\n  -- the conjugates of `y` are inside the closed unit disk\n",
      "body": "```suggestion\n  suffices \u2203 (n : \u2115) (_ : 0 < n), y ^ n = 1 by\n    obtain \u27e8n, hn\u2080, hn\u2081\u27e9 := this\n    exact \u27e8n, hn\u2080, congrArg (algebraMap K \u2102) hn\u2081\u27e9\n  refine NumberField.Embeddings.pow_eq_one_of_norm_le_one (x := y) K \u2102 (Subtype.coe_ne_coe.mp hz\u2080)\n    (coe_isIntegral_iff.mp <| isIntegral_of_mahlerMeasure_eq_one h hz)\n    fun \u03c6 \u21a6 norm_root_le_one_of_mahlerMeasure_eq_one h ?_\n  -- the conjugates of `y` are inside the closed unit disk\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "new_tactics": [
          "obtain",
          "refine"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1189,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  rw [mem_aroots] at hz \u22a2\n  refine \u27e8hz.1, ?_\u27e9\n  have H (\u03c8 : K \u2192+* \u2102) : \u03c8 ((aeval y) p) = (aeval (\u03c8 y)) p := by\n    conv_rhs => rw [\u2190 map_id (p := p)]\n    exact p.map_aeval_eq_aeval_map (by ext; simp) y\n  rw [\u2190 H, map_eq_zero_iff _ \u03c6.injective,\n    \u2190 map_eq_zero_iff _ (FaithfulSMul.algebraMap_injective \u21a5K \u2102), H]\n  exact hz.2\n",
      "body": "```suggestion\n  rw [mem_aroots] at hz \u22a2\n  refine \u27e8hz.1, ?_\u27e9\n  have H (\u03c8 : K \u2192+* \u2102) : \u03c8 ((aeval y) p) = (aeval (\u03c8 y)) p := by\n    conv_rhs => rw [\u2190 map_id (p := p)]\n    exact p.map_aeval_eq_aeval_map (by ext; simp) y\n  rw [\u2190 H, map_eq_zero_iff _ \u03c6.injective,\n    \u2190 map_eq_zero_iff _ (FaithfulSMul.algebraMap_injective \u21a5K \u2102), H]\n  exact hz.2\n```\n* The `convert`s resulting in an `Iff` are a bit ugly.\n* The way I have arranged it is closer to the usual Mathlib style (arguing \"backwards\").\n* Also, one ",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "ext",
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1194,
      "before_code": "rintro rfl\n      exact \u27e81, rfl\u27e9 }",
      "suggestion": "\r\n  have : Away (algebraMap R S z) T := by rwa [iff_of_associated h]\r\n",
      "body": "```suggestion\r\n  have : Away (algebraMap R S z) T := by rwa [iff_of_associated h]\r\n```",
      "path": "Mathlib/RingTheory/Localization/Away/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "exact",
          "rintro"
        ]
      }
    },
    {
      "id": 1195,
      "before_code": "rintro rfl\n      exact \u27e81, rfl\u27e9 }",
      "suggestion": "\r\n  have : Away (algebraMap R S y) S := away_of_isUnit_of_bijective _ h Function.bijective_id\r\n",
      "body": "```suggestion\r\n  have : Away (algebraMap R S y) S := away_of_isUnit_of_bijective _ h Function.bijective_id\r\n```",
      "path": "Mathlib/RingTheory/Localization/Away/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "exact",
          "rintro"
        ]
      }
    },
    {
      "id": 1196,
      "before_code": "rintro rfl\n      exact \u27e81, rfl\u27e9 }",
      "suggestion": "\r\n  have : Away (algebraMap R S x) S := away_of_isUnit_of_bijective _ h Function.bijective_id\r\n",
      "body": "```suggestion\r\n  have : Away (algebraMap R S x) S := away_of_isUnit_of_bijective _ h Function.bijective_id\r\n```",
      "path": "Mathlib/RingTheory/Localization/Away/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "exact",
          "rintro"
        ]
      }
    },
    {
      "id": 1198,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  have : e\u209a = b.repr.symm := by\r\n    ext i\r\n    trans IsLocalizedModule.map p.primeCompl l\u2081 l\u2082 e (l\u2081 (Finsupp.single i 1))\r\n    \u00b7 simp [e\u209a, -IsLocalizedModule.map_apply, l\u2081]\r\n    \u00b7 simp [l\u2082, e, hb, v]\r\n",
      "body": "I think this is more readable than squeezed simps.\r\n```suggestion\r\n  have : e\u209a = b.repr.symm := by\r\n    ext i\r\n    trans IsLocalizedModule.map p.primeCompl l\u2081 l\u2082 e (l\u2081 (Finsupp.single i 1))\r\n    \u00b7 simp [e\u209a, -IsLocalizedModule.map_apply, l\u2081]\r\n    \u00b7 simp [l\u2082, e, hb, v]\r\n```\r\n(if you change the definition of `e`)",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "have",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "have",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "have",
          "ext"
        ],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1199,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  have he\u209a : Function.Bijective e\u209a := this \u25b8 b.repr.symm.bijective\r\n",
      "body": "```suggestion\r\n  have he\u209a : Function.Bijective e\u209a := this \u25b8 b.repr.symm.bijective\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1200,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  let e : (\u03ba \u2192\u2080 S) \u2192\u2097[S] \u03a9[S\u2044R] :=\r\n",
      "body": "```suggestion\r\n  let e : (\u03ba \u2192\u2080 S) \u2192\u2097[S] \u03a9[S\u2044R] :=\r\n```\r\nWhy do you have parentheses around Omega? (in other places as well).",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "omega",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_omega"
        ],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1201,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  \u00b7 simp [\u2190 PrimeSpectrum.iSup_basicOpen_eq_top_iff, TopologicalSpace.Opens.ext_iff, Set.ext_iff]\r\n    grind\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [\u2190 PrimeSpectrum.iSup_basicOpen_eq_top_iff, TopologicalSpace.Opens.ext_iff, Set.ext_iff]\r\n    grind\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1203,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  -- `\u03a9[S\u209a\u2044R]` is projective, so free over the local ring `S\u209a` and\r\n",
      "body": "```suggestion\r\n  -- `\u03a9[S\u209a\u2044R]` is projective, so free over the local ring `S\u209a` and\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1204,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  obtain \u27e8\u03ba, a, b, hb\u27e9 := Module.exists_basis_of_span_of_flat _\r\n    (span_range_map_derivation_of_isLocalization R _ (Localization.AtPrime p) p.primeCompl)\r\n",
      "body": "```suggestion\r\n  obtain \u27e8\u03ba, a, b, hb\u27e9 := Module.exists_basis_of_span_of_flat _\r\n    (span_range_map_derivation_of_isLocalization R _ (Localization.AtPrime p) p.primeCompl)\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1205,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  exact \u27e8algebraMap S _ (a i), by simp +zetaDelta [IsLocalizedModule.map_linearCombination]\u27e9\r\n",
      "body": "```suggestion\r\n  exact \u27e8algebraMap S _ (a i), by simp +zetaDelta [IsLocalizedModule.map_linearCombination]\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1213,
      "before_code": "rwa [hf i hi, map_add, hn, hm, \u2190 Int.cast_add, \u2190 Int.cast_one, Int.cast_inj] at contra\n  lia",
      "suggestion": "/-- An alternate constructor for `RootPairing.Base` which demands the axioms for roots but not for\ncoroots. (This requires the ambient root system to be crystallographic and reduced.) -/\n",
      "body": "```suggestion\n/-- An alternate constructor for `RootPairing.Base` which demands the axioms for roots but not for\ncoroots. (This requires the ambient root system to be crystallographic and reduced.) -/\n```",
      "path": "Mathlib/LinearAlgebra/RootSystem/BaseExists.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "constructor"
        ],
        "body_tactics": [
          "constructor"
        ],
        "new_tactics": [
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "cast_one",
          "rwa",
          "Int",
          "cast_inj",
          "map_add",
          "lia",
          "contra",
          "cast_add"
        ]
      }
    },
    {
      "id": 1217,
      "before_code": "theorem toCompacts_injective : Function.Injective (toCompacts (\u03b1 := \u03b1)) :=\n  .of_comp (f := SetLike.coe) SetLike.coe_injective",
      "suggestion": "\r\n@[simp]\r\ntheorem range_toCompacts : range (toCompacts (\u03b1 := \u03b1)) = {\u22a5}\u1d9c := by\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem range_toCompacts : range (toCompacts (\u03b1 := \u03b1)) = {\u22a5}\u1d9c := by\r\n```",
      "path": "Mathlib/Topology/Sets/Compacts.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "Injective",
          "toCompacts",
          "theorem",
          "SetLike",
          "toCompacts_injective",
          "of_comp",
          "Function",
          "coe",
          "coe_injective"
        ]
      }
    },
    {
      "id": 1218,
      "before_code": "theorem coe_bot : (\u2191(\u22a5 : Compacts \u03b1) : Set \u03b1) = \u2205 :=\n  rfl",
      "suggestion": "\r\n@[simp]\r\ntheorem coe_nonempty {s : Compacts \u03b1} : (s : Set \u03b1).Nonempty \u2194 s \u2260 \u22a5 :=\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem coe_nonempty {s : Compacts \u03b1} : (s : Set \u03b1).Nonempty \u2194 s \u2260 \u22a5 :=\r\n```",
      "path": "Mathlib/Topology/Sets/Compacts.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "coe_bot",
          "theorem",
          "Set",
          "rfl",
          "Compacts"
        ]
      }
    },
    {
      "id": 1219,
      "before_code": "obtain \u27e8u, hut, hu, hu'\u27e9 := decomposition_erase_inf ht\n  exact \u27e8u, hu, fun _ hi \u21a6 ht' (hut hi), ht''.mono hut, hu'\u27e9\n\nlemma IsLasker.minimal [DecidableEq (Ideal R)] (h : IsLasker R) (I : Ideal R) :\n    \u2203 t : Finset (Ideal R), t.inf id = I \u2227 (\u2200 \u2983J\u2984, J \u2208 t \u2192 J.IsPrimary) \u2227\n      ((t : Set (Ideal R)).Pairwise ((\u00b7 \u2260 \u00b7) on radical)) \u2227\n      (\u2200 \u2983J\u2984, J \u2208 t \u2192 \u00ac (t.erase J).inf id \u2264 J) := by\n  obtain \u27e8s, hs, hs'\u27e9 := h I\n  exact exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs hs'",
      "suggestion": "\r\nare primary, have pairwise distinct radicals, and removing any ideal changes the intersection. -/\r\n",
      "body": "```suggestion\r\nare primary, have pairwise distinct radicals, and removing any ideal changes the intersection. -/\r\n```",
      "path": "Mathlib/RingTheory/Lasker.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "IsLasker",
          "erase",
          "lemma",
          "Ideal",
          "mono",
          "radical",
          "exact",
          "inf",
          "Finset",
          "hut",
          "Set",
          "IsPrimary",
          "obtain",
          "Pairwise",
          "minimal",
          "DecidableEq",
          "exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition",
          "decomposition_erase_inf"
        ]
      }
    },
    {
      "id": 1224,
      "before_code": "finsum (fun d \u21a6 coeff d f \u2022 (constantCoeff (d.prod fun s e => (a s) ^ e))) := by\n  simp only [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_subst ha f 0]",
      "suggestion": "\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n",
      "body": "```suggestion\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Substitution.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "coeff",
          "prod",
          "coeff_zero_eq_constantCoeff_apply",
          "coeff_subst",
          "simp",
          "finsum",
          "constantCoeff",
          "only"
        ]
      }
    },
    {
      "id": 1241,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n",
      "body": "```suggestion\n    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n```\nMost of the time, `by exact` is useless.",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 1250,
      "before_code": "integer `z` (in the supertype) to `\u2115` (the subtype), given a proof that `z \u2265 0`;\npropositions concerning `z` will still be over `\u2124`. `zify` changes propositions about `\u2115` (the\nsubtype) to propositions about `\u2124` (the supertype), without changing the type of any variable.",
      "suggestion": "The `norm_cast` tactic can be used after `lift` to normalize introduced casts.\n",
      "body": "```suggestion\nThe `norm_cast` tactic can be used after `lift` to normalize introduced casts.\n```",
      "path": "Mathlib/Tactic/Lift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "norm_cast"
        ],
        "body_tactics": [
          "norm_cast"
        ],
        "new_tactics": [
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "order",
          "nat",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "supertype",
          "type",
          "concerning",
          "changing",
          "subtype",
          "changes",
          "variable",
          "over",
          "integer",
          "that",
          "given",
          "will",
          "about",
          "propositions",
          "zify",
          "without",
          "any",
          "still",
          "proof"
        ]
      }
    },
    {
      "id": 1263,
      "before_code": "F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]",
      "suggestion": "\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n",
      "body": "```suggestion\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n```\r\nvery minor, but this way you don\u2019t have to guess what the `rwa` is proving from the source.",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isoAdd",
          "inv",
          "shiftFunctorAdd",
          "app",
          "_eq_shiftFunctorAdd",
          "map",
          "simp",
          "_inv_app",
          "only"
        ]
      }
    },
    {
      "id": 1265,
      "before_code": "end Functor",
      "suggestion": "\r\n@[simp, reassoc]\r\n",
      "body": "```suggestion\r\n@[simp, reassoc]\r\n```",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Functor"
        ]
      }
    },
    {
      "id": 1266,
      "before_code": "end Functor",
      "suggestion": "\r\n@[simp, reassoc]\r\n",
      "body": "```suggestion\r\n@[simp, reassoc]\r\n```",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Functor"
        ]
      }
    },
    {
      "id": 1273,
      "before_code": "abbrev fromPath {x\u2080 x\u2081 : X} (p : Path.Homotopic.Quotient x\u2080 x\u2081) :\n    FundamentalGroupoid.mk x\u2080 \u27f6 FundamentalGroupoid.mk x\u2081 := p",
      "suggestion": "\r\n    fromPath (Path.Homotopic.Quotient.mk f) = fromPath (Path.Homotopic.Quotient.mk g) \u2194\r\n      f.Homotopic g :=\r\n",
      "body": "```suggestion\r\n    fromPath (Path.Homotopic.Quotient.mk f) = fromPath (Path.Homotopic.Quotient.mk g) \u2194\r\n      f.Homotopic g :=\r\n```\r\n\r\nThere have been some changes (#31574) and now the simp normal form is `Path.Homotopic.Quotient.mk f` instead of `\u27e6f\u27e7` (the two are definitionally equal, but not at reducible transparency). In practice, this means that use of automation will more likely drive you into this form rather than the one you are currently using, and it will make it slightly easier to app",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "apply",
          "have",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simp"
        ],
        "keywords": [
          "FundamentalGroupoid",
          "abbrev",
          "Quotient",
          "fromPath",
          "Path",
          "Homotopic"
        ]
      }
    },
    {
      "id": 1312,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm",
      "suggestion": "  lift P.degree to \u2115 with n hn\n  \u00b7 contrapose hP\n    simp [hP]\n  simp [hP, \u2190 WithBot.coe_one, \u2190 WithBot.coe_add]\n",
      "body": "This also works:\n```suggestion\n  lift P.degree to \u2115 with n hn\n  \u00b7 contrapose hP\n    simp [hP]\n  simp [hP, \u2190 WithBot.coe_one, \u2190 WithBot.coe_add]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "eval",
          "Polynomial",
          "open",
          "symm",
          "scoped",
          "eq_interpolate",
          "interpolate",
          "insert_subset_iff",
          "InjOn",
          "sdiff_singleton_eq_erase",
          "hvs",
          "card",
          "Classical",
          "interpolate_poly_eq_self",
          "theorem",
          "exact",
          "Set",
          "degree",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 1315,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm",
      "suggestion": "\r\n  rw (occs := [1]) [eq_interpolate hvs hP]\r\n  rw [interpolate_apply, finset_sum_coeff]\r\n  congr! with i hi\r\n  rw [coeff_C_mul, \u2190 natDegree_basis hvs hi, \u2190 leadingCoeff, leadingCoeff_basis hvs hi]\r\n  field_simp\r\n",
      "body": "The second arm of the rw is unnecessary--it's proving a hypothesis.\r\n```suggestion\r\n  rw (occs := [1]) [eq_interpolate hvs hP]\r\n  rw [interpolate_apply, finset_sum_coeff]\r\n  congr! with i hi\r\n  rw [coeff_C_mul, \u2190 natDegree_basis hvs hi, \u2190 leadingCoeff, leadingCoeff_basis hvs hi]\r\n  field_simp\r\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "congr",
          "field_simp",
          "rw"
        ],
        "body_tactics": [
          "congr",
          "field_simp",
          "rw"
        ],
        "new_tactics": [
          "congr",
          "rw",
          "field_simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "mpr",
          "eval",
          "Polynomial",
          "open",
          "symm",
          "scoped",
          "eq_interpolate",
          "interpolate",
          "insert_subset_iff",
          "InjOn",
          "sdiff_singleton_eq_erase",
          "hvs",
          "card",
          "Classical",
          "interpolate_poly_eq_self",
          "theorem",
          "exact",
          "Set",
          "degree",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 1324,
      "before_code": "rw [I_sq]\n    ring",
      "suggestion": "\r\n@[simp] theorem _root_.RCLike.to_complex_nonneg_iff {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {a : \ud835\udd5c} :\r\n",
      "body": "```suggestion\r\n@[simp] theorem _root_.RCLike.to_complex_nonneg_iff {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {a : \ud835\udd5c} :\r\n```",
      "path": "Mathlib/Analysis/Complex/Basic.lean",
      "tags": {
        "before_tactics": [
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "ring",
          "I_sq"
        ]
      }
    },
    {
      "id": 1328,
      "before_code": "namespace RCLike",
      "suggestion": "\r\n@[simp] theorem map_apply_real (x : \u211d) : map \u211d K x = x := by simp [im, re]\r\n",
      "body": "```suggestion\r\n@[simp] theorem map_apply_real (x : \u211d) : map \u211d K x = x := by simp [im, re]\r\n```",
      "path": "Mathlib/Analysis/RCLike/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "RCLike",
          "namespace"
        ]
      }
    },
    {
      "id": 1351,
      "before_code": "fun _ h\u2081 _ h\u2082 \u21a6 h\u2082 _ fun _ h\u2083 \u21a6 h\u2081 _ fun _ h\u2084 \u21a6 h_comm _ h\u2084 _ h\u2083\n\n@[to_additive addCentralizer_empty]",
      "suggestion": "\r\n@[to_additive (attr := simp) addCentralizer_empty]\r\n",
      "body": "```suggestion\r\n@[to_additive (attr := simp) addCentralizer_empty]\r\n```",
      "path": "Mathlib/Algebra/Group/Center.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "to_additive",
          "addCentralizer_empty",
          "h_comm"
        ]
      }
    },
    {
      "id": 1366,
      "before_code": "lemma Odd.ne_two_of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : m \u2260 2 := by\n  rintro rfl\n  exact absurd (hn.of_dvd_nat hm) (by decide)",
      "suggestion": "lemma Int.le_abs_of_dvd {a b : \u2124} (h\u2081 : b \u2260 0) (h\u2082 : a \u2223 b) : a \u2264 |b| :=\n  le_of_dvd (by simpa) (by simpa)\n",
      "body": "```suggestion\nlemma Int.le_abs_of_dvd {a b : \u2124} (h\u2081 : b \u2260 0) (h\u2082 : a \u2223 b) : a \u2264 |b| :=\n  le_of_dvd (by simpa) (by simpa)\n```",
      "path": "Mathlib/Algebra/Order/Ring/Abs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "decide"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "decide"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "lemma",
          "Odd",
          "exact",
          "rintro",
          "decide",
          "absurd",
          "rfl",
          "of_dvd_nat",
          "ne_two_of_dvd_nat"
        ]
      }
    },
    {
      "id": 1369,
      "before_code": "## Behaviour under Arithmetic Operations\n-/",
      "suggestion": "\r\n    gcongr\r\n",
      "body": "This isn't just to golf. I want to make sure you know about the existence of this tactic.\r\n```suggestion\r\n    gcongr\r\n```",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CharacteristicFunction.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "gcongr"
        ],
        "body_tactics": [
          "gcongr"
        ],
        "new_tactics": [
          "gcongr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Behaviour",
          "Operations",
          "Arithmetic",
          "under"
        ]
      }
    },
    {
      "id": 1371,
      "before_code": "ext1 f\n  simp [hg\u2081, hg\u2082]",
      "suggestion": "\r\n    Lp.toTemperedDistribution (hg\u2082.toLp _ \u2022 f) = smulLeftCLM F g (Lp.toTemperedDistribution f) := by\r\n  ext u\r\n  simp only [Lp.toTemperedDistribution_apply, smulLeftCLM_apply_apply]\r\n  apply integral_congr_ae\r\n  filter_upwards [Lp.coeFn_lpSMul (r := r) (hg\u2082.toLp _) f, hg\u2082.coeFn_toLp] with x hg hg'\r\n  simp [hg, hg', hg\u2081, smul_smul, mul_comm]\r\n",
      "body": "We have an `HSMul` instance :smiley:\r\n```suggestion\r\n    Lp.toTemperedDistribution (hg\u2082.toLp _ \u2022 f) = smulLeftCLM F g (Lp.toTemperedDistribution f) := by\r\n  ext u\r\n  simp only [Lp.toTemperedDistribution_apply, smulLeftCLM_apply_apply]\r\n  apply integral_congr_ae\r\n  filter_upwards [Lp.coeFn_lpSMul (r := r) (hg\u2082.toLp _) f, hg\u2082.coeFn_toLp] with x hg hg'\r\n  simp [hg, hg', hg\u2081, smul_smul, mul_comm]\r\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "apply",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "ext1",
          "simp"
        ]
      }
    },
    {
      "id": 1377,
      "before_code": "end PosSemidef",
      "suggestion": "\r\ntheorem IsHermitian.det_abs [DecidableEq n] {A : Matrix n n \ud835\udd5c} (hA : A.IsHermitian) :\r\n",
      "body": "Or maybe\r\n```suggestion\r\ntheorem IsHermitian.det_abs [DecidableEq n] {A : Matrix n n \ud835\udd5c} (hA : A.IsHermitian) :\r\n```\r\nsince we have [Matrix.PosSemidef.inv_sqrt](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Matrix/Order.html#Matrix.PosSemidef.inv_sqrt)?\r\n\r\nUnless that one should be renamed to also include the word cfc?",
      "path": "Mathlib/Analysis/Matrix/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "PosSemidef",
          "end"
        ]
      }
    },
    {
      "id": 1378,
      "before_code": "_ \u2264 1 + x + (x / 2) ^ 2 := le_add_of_nonneg_right <| sq_nonneg _\n    _ = _ := by ring",
      "suggestion": "\r\n  convert congr_arg NNReal.toReal <| map_prod NNReal.sqrtHom (Real.toNNReal \u2218 x) s <;>\r\n    simp +contextual [-map_prod, NNReal.sqrtHom, hx]\r\n",
      "body": "```suggestion\r\n  convert congr_arg NNReal.toReal <| map_prod NNReal.sqrtHom (Real.toNNReal \u2218 x) s <;>\r\n    simp +contextual [-map_prod, NNReal.sqrtHom, hx]\r\n```",
      "path": "Mathlib/Data/Real/Sqrt.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "ring",
          "le_add_of_nonneg_right",
          "sq_nonneg"
        ]
      }
    },
    {
      "id": 1380,
      "before_code": "Matrix.toLinearMap\u2082' \ud835\udd5c A (star x) x = 0 \u2194 A *\u1d65 x = 0 := by\n  simpa only [toLinearMap\u2082'_apply'] using hA.dotProduct_mulVec_zero_iff x",
      "suggestion": "\r\n    (CFC.sqrt A).det ^ 2 = A.det := by\r\n",
      "body": "I guess the other option is to have\r\n```suggestion\r\n    (CFC.sqrt A).det ^ 2 = A.det := by\r\n```\r\nThe naming would be weird though: `det_sqrt_sq`? which sounds like `((CFC.sqrt A) ^ 2).det`",
      "path": "Mathlib/Analysis/Matrix/Order.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "Matrix",
          "simpa",
          "_apply",
          "star",
          "dotProduct_mulVec_zero_iff",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 1385,
      "before_code": "instance [Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] : IsSemireal R where\n  one_add_ne_zero hs amo := zero_ne_one' R (le_antisymm zero_le_one\n                              (le_of_le_of_eq (le_add_of_nonneg_right hs.nonneg) amo))",
      "suggestion": "\r\n      rw [add_comm] at hn\r\n      push_cast at hn\r\n      simpa using IsSemireal.one_add_ne_zero (by simp) hn\r\n",
      "body": "```suggestion\r\n      rw [add_comm] at hn\r\n      push_cast at hn\r\n      simpa using IsSemireal.one_add_ne_zero (by simp) hn\r\n```",
      "path": "Mathlib/Algebra/Ring/Semireal/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "body_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "ExistsAddOfLE",
          "le_antisymm",
          "zero_ne_one",
          "Semiring",
          "amo",
          "le_of_le_of_eq",
          "one_add_ne_zero",
          "LinearOrder",
          "IsSemireal",
          "instance",
          "le_add_of_nonneg_right",
          "IsStrictOrderedRing",
          "zero_le_one",
          "nonneg"
        ]
      }
    },
    {
      "id": 1387,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\ntheorem support_bot : (\u22a5 : SimpleGraph V).support = \u2205 := by\r\n  grind only [mem_support, Set.mem_empty_iff_false, bot_adj]\r\n",
      "body": "```suggestion\r\ntheorem support_bot : (\u22a5 : SimpleGraph V).support = \u2205 := by\r\n  grind only [mem_support, Set.mem_empty_iff_false, bot_adj]\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1388,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\n/-- The support of a graph is empty if there at most one vertex. -/\r\n@[simp]\r\ntheorem support_of_subsingleton [Subsingleton V] (G : SimpleGraph V) : G.support = \u2205 :=\r\n  Set.eq_empty_of_forall_notMem fun v \u27e8w, h\u27e9 => G.irrefl <| Subsingleton.elim v w \u25b8 h\r\n",
      "body": "```suggestion\r\n/-- The support of a graph is empty if there at most one vertex. -/\r\n@[simp]\r\ntheorem support_of_subsingleton [Subsingleton V] (G : SimpleGraph V) : G.support = \u2205 :=\r\n  Set.eq_empty_of_forall_notMem fun v \u27e8w, h\u27e9 => G.irrefl <| Subsingleton.elim v w \u25b8 h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1402,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "/--\nDetermines if the pretty-printed version of the given name would parse as an `ident` with an underlying name (via `getId`) equal to the original name. The pretty-printer usually escapes unparseable components of a name with `\u00ab\u00bb`, but makes exceptions for various names with special meaning, meaning that the result does not round trip. We therefore re-check those conditions here.\n\nThis function is intended to be \"safe\" in that it if it returns `true`, the name will definitely round trip. Any deviation from this behavior is a bug which should be fixed.\n-/\n-- See also [Zulip](https://leanprover.zulipchat.com/#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Check.20if.20a.20.60Lean.2EName.60.20is.20roundtrippable/with/565735560)\ndef Lean.Name.willRoundTrip (n : Name) : Bool :=\n  !n.isAnonymous -- anonymous names do not roundtrip\n    && !n.hasMacroScopes -- names with macroscopes do not roundtrip\n    && !maybePseudoSyntax -- names which might be \"pseudo-syntax\" do not roundtrip\n ",
      "body": "Oh, hey, this seems so familiar... :)\n\nIf we keep this, we should document the living daylights out of this function. Without doing so, it would be totally mysterious to a future maintainer of this file who is trying to figure out e.g. what core change made roundtripping break.\n\nHere's a first pass at documentation. (Sorry, adding newlines is necessary.)\n\n```suggestion\n/--\nDetermines if the pretty-printed version of the given name would parse as an `ident` with an underlying name (via `getId`) e",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 1420,
      "before_code": "ext1 f\n  exact smulLeftCLM_smulLeftCLM_apply hg\u2081 hg\u2082 f",
      "suggestion": "  apply Finset.sum_congr rfl\n",
      "body": "```suggestion\n  apply Finset.sum_congr rfl\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "ext1",
          "smulLeftCLM_smulLeftCLM_apply"
        ]
      }
    },
    {
      "id": 1426,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  have := hs (i := 1) (j := 2) (by decide)\r\n",
      "body": "```suggestion\r\n  have := hs (i := 1) (j := 2) (by decide)\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "decide",
          "have"
        ],
        "body_tactics": [
          "decide",
          "have"
        ],
        "new_tactics": [
          "decide",
          "have"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1427,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  have := hs (i := 0) (j := 1) (by decide)\r\n",
      "body": "```suggestion\r\n  have := hs (i := 0) (j := 1) (by decide)\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "decide",
          "have"
        ],
        "body_tactics": [
          "decide",
          "have"
        ],
        "new_tactics": [
          "decide",
          "have"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1428,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  rcases this with h | h <;> simp_all [G\u2082]\r\n\r\n",
      "body": "```suggestion\r\n  rcases this with h | h <;> simp_all [G\u2082]\r\n\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "cases",
          "simp_all"
        ],
        "body_tactics": [
          "cases",
          "simp_all"
        ],
        "new_tactics": [
          "cases",
          "simp_all"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1440,
      "before_code": "simpa using hl)\n      exact .sub (.div (by fun_prop) (by fun_prop) (by simpa)) (by fun_prop)",
      "suggestion": "\r\n@[simp] lemma deriv_weierstrassPExcept (l : \u2102) : deriv \u2118[L - l] l = \u2118'[L - l] l :=\r\n",
      "body": "```suggestion\r\n@[simp] lemma deriv_weierstrassPExcept (l : \u2102) : deriv \u2118[L - l] l = \u2118'[L - l] l :=\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "fun_prop",
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "simpa",
          "fun_prop",
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "sub",
          "simpa",
          "div",
          "fun_prop",
          "using"
        ]
      }
    },
    {
      "id": 1441,
      "before_code": "\u00b7 rw [analyticOrderAt_of_not_analyticAt hf,\n      analyticOrderAt_of_not_analyticAt fun hg \u21a6 hf <| hg.congr hfg.symm]",
      "suggestion": "\r\n@[simp] lemma analyticOrderAt_id : analyticOrderAt (\ud835\udd5c := \ud835\udd5c) id 0 = 1 :=\r\n",
      "body": "```suggestion\r\n@[simp] lemma analyticOrderAt_id : analyticOrderAt (\ud835\udd5c := \ud835\udd5c) id 0 = 1 :=\r\n```",
      "path": "Mathlib/Analysis/Analytic/Order.lean",
      "tags": {
        "before_tactics": [
          "congr",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "congr",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "congr",
          "analyticOrderAt_of_not_analyticAt",
          "symm",
          "hfg"
        ]
      }
    },
    {
      "id": 1444,
      "before_code": "end NormedLinearOrderedField_comap",
      "suggestion": "\r\n  simp [parallelepiped_basis_eq, x', Int.floor_le, Int.lt_floor_add_one, le_of_lt, add_comm (1 : \u211d)]\r\n",
      "body": "```suggestion\r\n  simp [parallelepiped_basis_eq, x', Int.floor_le, Int.lt_floor_add_one, le_of_lt, add_comm (1 : \u211d)]\r\n```\r\n(and then you don't need to add `Int.le_floor_add_one` any more)",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "NormedLinearOrderedField_comap",
          "end"
        ]
      }
    },
    {
      "id": 1446,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n  obtain (_ | _ | n) := n <;>\r\n  simp [iteratedDeriv_succ', iteratedDeriv_const]\r\n",
      "body": "```suggestion\r\n  obtain (_ | _ | n) := n <;>\r\n  simp [iteratedDeriv_succ', iteratedDeriv_const]\r\n```\r\n(fortunately `simp` is clever enough not to complain about unused simp lemmas when inside a `<;>` block)",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "cleanup_simp",
          "use_simp"
        ],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1448,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n    obtain \u27e8U, hU, H\u27e9 := ((hf.eventually (by simp)).and (hg.eventually (by simp))).exists_mem\r\n",
      "body": ":golf:\r\n```suggestion\r\n    obtain \u27e8U, hU, H\u27e9 := ((hf.eventually (by simp)).and (hg.eventually (by simp))).exists_mem\r\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1449,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n      all_goals clear IH H U hU; fun_prop (disch := simp_all)\r\n",
      "body": "This is quite slow because the context here includes a lot of complicated stuff, and `simp_all` simplifies everything it sees (it has no way to determine which parts of the context are relevant and which aren't). The following speeds it up substantially:\r\n```suggestion\r\n      all_goals clear IH H U hU; fun_prop (disch := simp_all)\r\n```\r\nIt's still slower than the hand-rolled proof but I think it's tolerable.",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "simp_all"
        ],
        "body_tactics": [
          "fun_prop",
          "simp_all"
        ],
        "new_tactics": [
          "fun_prop",
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1450,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n  simp [\u2190 smul_eq_mul, iteratedDerivWithin_smul hf hg hs hx]\r\n",
      "body": "```suggestion\r\n  simp [\u2190 smul_eq_mul, iteratedDerivWithin_smul hf hg hs hx]\r\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1451,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n  simpa [iteratedDerivWithin_univ] using\r\n    iteratedDerivWithin_mul hf.contDiffWithinAt hg.contDiffWithinAt uniqueDiffOn_univ trivial\r\n",
      "body": ":golf:\r\n```suggestion\r\n  simpa [iteratedDerivWithin_univ] using\r\n    iteratedDerivWithin_mul hf.contDiffWithinAt hg.contDiffWithinAt uniqueDiffOn_univ trivial\r\n```\r\nMaybe `iteratedDerivWithin_univ` should be `@[simp]`, matching `derivWithin_univ`, and then you get even more golf points.",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1452,
      "before_code": "rw [weierstrassPExceptSeries, FormalMultilinearSeries.ofScalars_apply_eq,\n      FormalMultilinearSeries.coeff_ofScalars, smul_eq_mul]\n\nlemma analyticOnNhd_weierstrassPExcept (l\u2080 : \u2102) : AnalyticOnNhd \u2102 \u2118[L - l\u2080] (L.lattice \\ {l\u2080})\u1d9c :=\n  (L.differentiableOn_weierstrassPExcept l\u2080).analyticOnNhd L.isOpen_compl_lattice_diff",
      "suggestion": "\r\n    \u00b7 simp [Nat.factorial_succ (n + 1)]\r\n      field [(n + 1).factorial_pos.ne']\r\n",
      "body": "```suggestion\r\n    \u00b7 simp [Nat.factorial_succ (n + 1)]\r\n      field [(n + 1).factorial_pos.ne']\r\n```\r\nIt's a pity that `field_simp` isn't able to spot automatically that factorials are non-zero, given how often one needs to divide by `n!`. Perhaps one could do the following:\r\n- add an instance `NeZero n.factorial` for all `n : Nat` (a bundled version of `Nat.factorial_ne_zero`)\r\n- add `NeZero.ne` to the list of lemmas used by `field_simp` in line 85-6 of `Mathlib.Tactic.FieldSimp.Discharger`.\r\nB",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "field_simp",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "complex",
          "differentiability",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "analyticOnNhd_weierstrassPExcept",
          "FormalMultilinearSeries",
          "weierstrassPExceptSeries",
          "AnalyticOnNhd",
          "coeff_ofScalars",
          "isOpen_compl_lattice_diff",
          "ofScalars_apply_eq",
          "differentiableOn_weierstrassPExcept",
          "smul_eq_mul",
          "analyticOnNhd",
          "lattice"
        ]
      }
    },
    {
      "id": 1455,
      "before_code": "exact (LinearMap.quotientInfEquivSupQuotient Y X).symm\n\nend JordanHolderModule",
      "suggestion": "\r\n/-- The Jacobson density theorem for a module finite over its endomorphism ring. -/\r\nprotected theorem Module.Finite.toModuleEnd_moduleEnd_surjective [Module.Finite (End R M) M] :\r\n",
      "body": "Something like\r\n```suggestion\r\n/-- The Jacobson density theorem for a module finite over its endomorphism ring. -/\r\nprotected theorem Module.Finite.toModuleEnd_moduleEnd_surjective [Module.Finite (End R M) M] :\r\n```\r\n? (I added another `moduleEnd` to emphasize the nested `End`).",
      "path": "Mathlib/RingTheory/SimpleModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "symm",
          "end",
          "LinearMap",
          "JordanHolderModule",
          "exact",
          "quotientInfEquivSupQuotient"
        ]
      }
    },
    {
      "id": 1460,
      "before_code": "\u00b7 intro Y hY\n    exact H _ hY",
      "suggestion": "",
      "body": "This line is unnecessary:\n```suggestion\n```",
      "path": "Mathlib/CategoryTheory/MorphismProperty/Ind.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "exact",
          "intro"
        ]
      }
    },
    {
      "id": 1474,
      "before_code": "smul_comm r x y := by\n    rw [\u2190 single_zero_smul_eq_smul \u0393, \u2190 mul_smul', mul_comm, mul_smul', single_zero_smul_eq_smul \u0393]",
      "suggestion": "instance {\u0393 V : Type*} [Ring R] [IsDomain R] [AddCommGroup V] [AddCommMonoid \u0393]\n",
      "body": "Is the auto-generated name bad?\n```suggestion\ninstance {\u0393 V : Type*} [Ring R] [IsDomain R] [AddCommGroup V] [AddCommMonoid \u0393]\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "mul_smul",
          "smul_comm",
          "mul_comm",
          "single_zero_smul_eq_smul"
        ]
      }
    },
    {
      "id": 1483,
      "before_code": "instance ULift.instT5Space [T5Space X] : T5Space (ULift X) :=\n  IsEmbedding.uliftDown.t5Space",
      "suggestion": "    T5Space X \u2194 \u2200 s : Set X, IsOpen s \u2192 T4Space s where\n  mp := fun _ _ _ => inferInstance\n  mpr h := \n  \t{ toCompletelyNormalSpace :=\n        completelyNormalSpace_iff_forall_isOpen_normalSpace.2 fun s hs => (h s hs).toNormalSpace\n      toT1Space :=\n        have := h univ isOpen_univ\n        t1Space_of_injective_of_continuous\n          (fun _ _ => congrArg Subtype.val) (continuous_id.subtype_mk mem_univ) }\n",
      "body": "I prefer to use `where` or `:= by` when the proof of an `\u2194` where one of the proofs is more than a line or two.\n```suggestion\n    T5Space X \u2194 \u2200 s : Set X, IsOpen s \u2192 T4Space s where\n  mp := fun _ _ _ => inferInstance\n  mpr h := \n  \t{ toCompletelyNormalSpace :=\n        completelyNormalSpace_iff_forall_isOpen_normalSpace.2 fun s hs => (h s hs).toNormalSpace\n      toT1Space :=\n        have := h univ isOpen_univ\n        t1Space_of_injective_of_continuous\n          (fun _ _ => congrArg Subtype.val) (",
      "path": "Mathlib/Topology/Separation/Regular.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsEmbedding",
          "T5Space",
          "ULift",
          "uliftDown",
          "t5Space",
          "instT5Space",
          "instance"
        ]
      }
    },
    {
      "id": 1504,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\n@[simp]\r\nlemma ringKrullDim_of_isNoetherianRing : ringKrullDim R[X] = ringKrullDim R + 1 := by\r\n",
      "body": "```suggestion\r\n@[simp]\r\nlemma ringKrullDim_of_isNoetherianRing : ringKrullDim R[X] = ringKrullDim R + 1 := by\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 1505,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\n@[simp]\r\nlemma MvPolynomial.ringKrullDim_of_isNoetherianRing {\u03b9 : Type*} [Finite \u03b9] :\r\n",
      "body": "```suggestion\r\n@[simp]\r\nlemma MvPolynomial.ringKrullDim_of_isNoetherianRing {\u03b9 : Type*} [Finite \u03b9] :\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 1506,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\n  have : p.IsPrime := by rw [P.over_def p]; infer_instance\r\n",
      "body": "```suggestion\r\n  have : p.IsPrime := by rw [P.over_def p]; infer_instance\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw",
          "have"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 1509,
      "before_code": "end single",
      "suggestion": "\r\ntheorem trace_surjective [AddCommMonoid R] [Nonempty n] :\r\n    Function.Surjective (trace : Matrix n n R \u2192 R) := fun r \u21a6 by\r\n  classical\r\n  let i := Classical.arbitrary n\r\n  exact \u27e8single i i r, trace_single_eq_same i r\u27e9\r\n",
      "body": "No need to section things off. And better to just use the variables above. And also instead of repeating `Classical.arbitrary` just define it once:\r\n\r\n```suggestion\r\ntheorem trace_surjective [AddCommMonoid R] [Nonempty n] :\r\n    Function.Surjective (trace : Matrix n n R \u2192 R) := fun r \u21a6 by\r\n  classical\r\n  let i := Classical.arbitrary n\r\n  exact \u27e8single i i r, trace_single_eq_same i r\u27e9\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/Trace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "single",
          "end"
        ]
      }
    },
    {
      "id": 1510,
      "before_code": "end single",
      "suggestion": "\r\n  inhabit n\r\n  exact \u27e8single default default r, trace_single_eq_same default r\u27e9\r\n",
      "body": "I would probably do this:\r\n```suggestion\r\n  inhabit n\r\n  exact \u27e8single default default r, trace_single_eq_same default r\u27e9\r\n```\r\n\r\nIt feels more idiomatic to me, and signals \"the exact value does not matter\" similarly well.",
      "path": "Mathlib/LinearAlgebra/Matrix/Trace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "single",
          "end"
        ]
      }
    },
    {
      "id": 1513,
      "before_code": "(rootSpaceProduct R L H \u03b1 (-\u03b1) 0 (add_neg_cancel \u03b1) (\u27e8y, hy\u27e9 \u2297\u209c[R] \u27e8z, hz\u27e9)).property using 0\n  simp [hyz]",
      "suggestion": "lemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n",
      "body": "```suggestion\nlemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n```",
      "path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "exact",
          "simpa",
          "rw",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "rootSpaceProduct",
          "property",
          "simp",
          "add_neg_cancel",
          "using",
          "hyz"
        ]
      }
    },
    {
      "id": 1514,
      "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
      "suggestion": "    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n",
      "body": "There are two _independent_ changes here:\n\n1. Fix the `by exact` issue by adding `.toLinearMap` to help elaboration\n2. Add `.toSubmodule` rather than a coercion to avoid an indirect coercion (`LieIdeal` to `LieSubalgebra` to `Submodule`)\n```suggestion\n    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n```",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "add_lie",
          "mem_coe",
          "SetLike",
          "exact",
          "Submodule",
          "add_mem",
          "simp",
          "carrier_eq_coe",
          "only"
        ]
      }
    },
    {
      "id": 1515,
      "before_code": "(rootSpaceProduct R L H \u03b1 (-\u03b1) 0 (add_neg_cancel \u03b1) (\u27e8y, hy\u27e9 \u2297\u209c[R] \u27e8z, hz\u27e9)).property using 0\n  simp [hyz]",
      "suggestion": "lemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup\u2082_of_le \u03b1 h\u03b1 (le_refl _)\n",
      "body": "This lemma becomes more difficult to use if we include the bundled finiteness expressed as `H.root`. Instead I suggest:\n```suggestion\nlemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup\u2082_of_le \u03b1 h\u03b1 (le_refl _)\n```",
      "path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "exact",
          "rw",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rootSpaceProduct",
          "property",
          "simp",
          "add_neg_cancel",
          "using",
          "hyz"
        ]
      }
    },
    {
      "id": 1516,
      "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
      "suggestion": "\r\n-- This should probably be somewhere in the file `Algebra.Lie.Weights.RootSystem`\r\nopen LieSubmodule in\r\n@[simp]\r\nlemma biSup_corootSpace_eq_top :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 := by\r\n  simp only [\u2190 toSubmodule_inj, top_toSubmodule, iSup_toSubmodule,\r\n    \u2190 RootPairing.IsRootSystem.span_coroot_eq_top (P := rootSystem H),\r\n    coe_corootSpace_eq_span_singleton, Submodule.iSup_span]\r\n  congr\r\n  ext \u03b1\r\n  simp [eq_comm]\r\n\r\n-- This should probably be below `bisup_corootSpace_eq_top`\r\n@[simp]\r\nlemma biSup_corootSubmodule_eq_cartan :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSubmodule \u03b1 = H.toLieSubmodule := by\r\n  suffices \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 from\r\n    le_antisymm (by simp) (by simp [\u2190 LieSubmodule.map_iSup, this])\r\n  simp\r\n\r\nopen LieSubmodule in\r\n@[simp] lemma invtSubmoduleToLieIdeal_top :\r\n    invtSubmoduleToLieIdeal (\u22a4 : Submodule K (Module.Dual K H)) (by simp) = \u22a4 := by\r\n  simp_rw [\u2190 toSubmodule_inj, coe_",
      "body": "I think the right way to break this result down is as follows:\r\n```suggestion\r\n-- This should probably be somewhere in the file `Algebra.Lie.Weights.RootSystem`\r\nopen LieSubmodule in\r\n@[simp]\r\nlemma biSup_corootSpace_eq_top :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 := by\r\n  simp only [\u2190 toSubmodule_inj, top_toSubmodule, iSup_toSubmodule,\r\n    \u2190 RootPairing.IsRootSystem.span_coroot_eq_top (P := rootSystem H),\r\n    coe_corootSpace_eq_span_singleton, Submodule.iSup_span]\r\n  ",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "congr",
          "refine",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "congr",
          "refine",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "congr",
          "refine",
          "ext"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "line_break"
        ],
        "keywords": [
          "add_lie",
          "mem_coe",
          "SetLike",
          "exact",
          "Submodule",
          "add_mem",
          "simp",
          "carrier_eq_coe",
          "only"
        ]
      }
    },
    {
      "id": 1539,
      "before_code": "contrapose! hs\n  simpa [hs] using IsMeagre.empty",
      "suggestion": "  suffices IsMeagre (\u22c3 i : I, A i) by simpa\n",
      "body": "```suggestion\n  suffices IsMeagre (\u22c3 i : I, A i) by simpa\n```",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "contrapose",
          "empty",
          "IsMeagre",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 1540,
      "before_code": "applyReplacementFun t e #[]\n\n/-- Unfold auxlemmas in the type and value. -/",
      "suggestion": "\r\n/-- Unfold auxlemmas (generated by `simp`) in the type and value. -/\r\n",
      "body": "```suggestion\r\n/-- Unfold auxlemmas (generated by `simp`) in the type and value. -/\r\n```",
      "path": "Mathlib/Tactic/Translate/Core.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "auxlemmas",
          "Unfold",
          "value",
          "type",
          "applyReplacementFun"
        ]
      }
    },
    {
      "id": 1541,
      "before_code": "convexCombination (.duple x y hs ht h)\n\n/-- A binary convex combination with weight 0 on the first point returns the second point. -/\nproof_wanted convexComboPair_zero {x y : M} :\n  convexComboPair (0 : R) 1 (by simp) (by simp) (by simp) x y = y\n\n/-- A binary convex combination with weight 1 on the first point returns the first point. -/\nproof_wanted convexComboPair_one {x y : M} :\n  convexComboPair (1 : R) 0 (by simp) (by simp) (by simp) x y = x\n\n/-- A convex combination of a point with itself is that point. -/\nproof_wanted convexComboPair_same {s t : R} (hs : 0 \u2264 s) (ht : 0 \u2264 t) (h : s + t = 1) {x : M} :\n  convexComboPair s t hs ht h x x = x",
      "suggestion": "\r\n  simp only [StdSimplex.duple, StdSimplex.single, \u2190 Finsupp.single_add, h]\r\n",
      "body": "does this work?\r\n```suggestion\r\n  simp only [StdSimplex.duple, StdSimplex.single, \u2190 Finsupp.single_add, h]\r\n```",
      "path": "Mathlib/LinearAlgebra/ConvexSpace.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "binary",
          "returns",
          "convexComboPair",
          "combination",
          "second",
          "convexCombination",
          "duple",
          "convexComboPair_same",
          "that",
          "point",
          "convexComboPair_zero",
          "simp",
          "proof_wanted",
          "convexComboPair_one",
          "first",
          "itself",
          "weight",
          "convex"
        ]
      }
    },
    {
      "id": 1548,
      "before_code": "IsOpenMap f \u2194 LowerHemicontinuous (f \u207b\u00b9' {\u00b7}) := by\n  rw [isOpenMap_iff_kernImage, lowerHemicontinuous_iff_isClosed_preimage_Iic]\n  aesop",
      "suggestion": "@[simp]\nlemma upperHemicontinuousWithinAt_singleton_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} :\n",
      "body": "```suggestion\n@[simp]\nlemma upperHemicontinuousWithinAt_singleton_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} :\n```",
      "path": "Mathlib/Topology/Semicontinuity/Hemicontinuity.lean",
      "tags": {
        "before_tactics": [
          "aesop",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop",
          "rw"
        ],
        "topics": [
          "continuity",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "IsOpenMap",
          "aesop",
          "LowerHemicontinuous",
          "isOpenMap_iff_kernImage",
          "lowerHemicontinuous_iff_isClosed_preimage_Iic"
        ]
      }
    },
    {
      "id": 1551,
      "before_code": "Tendsto (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm (f \u00d7\u02e2 (g \u00d7\u02e2 h)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) :=\n  (prod_assoc_symm f g h).le",
      "suggestion": "  simp [\u2190 prod_assoc]\n",
      "body": "A proof ending in `rfl` suggests missing lemmas:\n```suggestion\n  simp [\u2190 prod_assoc]\n```",
      "path": "Mathlib/Order/Filter/Prod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "prod_assoc_symm",
          "prodAssoc",
          "Tendsto",
          "Equiv"
        ]
      }
    },
    {
      "id": 1554,
      "before_code": "simp only [ContinuousLinearMap.ext_iff, ContinuousLinearMap.comp_apply] at hg'inv hg'invf \u22a2\n  simp [ContinuousLinearEquiv.eq_symm_apply, *]",
      "suggestion": "  simp_rw [nhds_prod_eq]\n  apply \u03c6.implicitFunction_apply_image.prod_mk \u03c6.prod_map_implicitFunction |>.mono\n  aesop\n",
      "body": "I'm proposing we drop this lemma but I'll note in passing that the proof can be just:\n```suggestion\n  simp_rw [nhds_prod_eq]\n  apply \u03c6.implicitFunction_apply_image.prod_mk \u03c6.prod_map_implicitFunction |>.mono\n  aesop\n```",
      "path": "Mathlib/Analysis/Calculus/Implicit.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop"
        ],
        "body_tactics": [
          "apply",
          "aesop"
        ],
        "new_tactics": [
          "apply",
          "aesop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "ContinuousLinearEquiv",
          "eq_symm_apply",
          "ext_iff",
          "ContinuousLinearMap",
          "inv",
          "comp_apply",
          "invf",
          "simp",
          "only"
        ]
      }
    },
    {
      "id": 1556,
      "before_code": "\u00b7 rw [h1]\n  \u00b7 rfl",
      "suggestion": "theorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitFunction xy.1 = xy.2 := by\n  refine h.implicitFunctionData.hasStrictFDerivAt.eventually_left_inverse.mono fun xy h\u2081 h\u2082 \u21a6 ?_\n  change (h.implicitFunctionData.implicitFunction xy.1 (f a)).2 = xy.2\n  change h.implicitFunctionData.implicitFunction xy.1 (f xy) = xy at h\u2081\n  aesop\n",
      "body": "I strongly encourage you to embrace the existing API for `ImplicitFunctionData`. You're currently fighting it quite a bit in this proof. I prefer the following golf not so much because it is shorter but because it makes it clear that this is really just a wrapper around `ImplicitFunctionData.hasStrictFDerivAt` and `HasStrictFDerivAt.eventually_left_inverse`:\n```suggestion\ntheorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitF",
      "path": "Mathlib/Analysis/Calculus/ImplicitContDiff.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "rfl"
        ]
      }
    },
    {
      "id": 1581,
      "before_code": "rw [and_congr_right IsClosed.isNowhereDense_iff,\n    isOpen_compl_iff, interior_eq_empty_iff_dense_compl]",
      "suggestion": "\r\n/-- To check that `s` is nowhere dense, it suffices to check that no point of `s`\r\nis in the interior of `closure s`. -/\r\nlemma isNowhereDense_iff_disjoint {s : Set X} :\r\n    IsNowhereDense s \u2194 Disjoint s (interior (closure s)) :=\r\n  \u27e8fun H \u21a6 H \u25b8 disjoint_empty _, fun H \u21a6\r\n    H.closure_left isOpen_interior |>.mono_left interior_subset |>.eq_bot_of_self\u27e9\r\n\r\n/-- To check that `s` is nowhere dense, it suffices to check that `closure s` is not a\r\nneighborhood of any point of `s`. -/\r\nlemma isNowhereDense_iff_forall_notMem_nhds {s : Set X} :\r\n    IsNowhereDense s \u2194 \u2200 x \u2208 s, closure s \u2209 \ud835\udcdd x := by\r\n  simp [isNowhereDense_iff_disjoint, disjoint_iff_inter_eq_empty, eq_empty_iff_forall_notMem,\r\n    mem_interior_iff_mem_nhds]\r\n\r\n/-- The image of a nowhere dense set through an inducing map is nowhere dense. -/\r\nlemma Topology.IsInducing.isNowhereDense_image {f : X \u2192 Y} [TopologicalSpace Y]\r\n    (hf : Topology.IsInducing f) {s : Set X} (h : IsNowhereDense s) : IsNowhereDense (f '' s) := by\r\n  rw",
      "body": "I was intrigued by this proof: it is slightly mathematically annoying, because you have to change the original `y` if it's not in `f '' s`. This led me to the following, which you should feel free to accept or not (i.e I have no preference):\r\n```suggestion\r\n/-- To check that `s` is nowhere dense, it suffices to check that no point of `s`\r\nis in the interior of `closure s`. -/\r\nlemma isNowhereDense_iff_disjoint {s : Set X} :\r\n    IsNowhereDense s \u2194 Disjoint s (interior (closure s)) :=\r\n  \u27e8fun H \u21a6",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "interior_eq_empty_iff_dense_compl",
          "and_congr_right",
          "isOpen_compl_iff",
          "IsClosed",
          "isNowhereDense_iff"
        ]
      }
    },
    {
      "id": 1582,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  obtain \u27e8x, rfl\u27e9 := h\u2081\r\n  choose c hc using @h\u2082\r\n  simp only [funext_iff] at hc\r\n  use x.substFunc c\r\n  funext v\r\n  induction x with\r\n  | var => simp\r\n  | func f ts ih => simp [\u2190 ih, \u2190 hc]\r\n",
      "body": "We have `choose` tactic, which is easier to read than raw `Classical.choose`.\r\n\r\n```suggestion\r\n  obtain \u27e8x, rfl\u27e9 := h\u2081\r\n  choose c hc using @[user]\r\n  simp only [funext_iff] at hc\r\n  use x.substFunc c\r\n  funext v\r\n  induction x with\r\n  | var => simp\r\n  | func f ts ih => simp [\u2190 ih, \u2190 hc]\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "funext",
          "induction",
          "simp"
        ],
        "body_tactics": [
          "funext",
          "have",
          "obtain",
          "induction",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "funext",
          "induction",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1583,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  obtain \u27e8\u03c6, rfl\u27e9 := h\r\n",
      "body": "```suggestion\r\n  obtain \u27e8\u03c6, rfl\u27e9 := h\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1584,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081_iff_termDefinable (f : M \u2192 M) : A.TermDefinable\u2081 L f \u2194\r\n    A.TermDefinable L (fun v \u21a6 f (v ())) := by\r\n  refine exists_congr fun \u03c6 \u21a6 ?_\r\n  rw [funext_iff, funext_iff, (Equiv.funUnique Unit M).forall_congr']\r\n  simp only [Equiv.funUnique_symm_apply, uniqueElim_const, Function.comp_apply]\r\n  congr!\r\n",
      "body": "This would be shorter (just an suggestion, feel free to ignore it)\r\n\r\n```suggestion\r\ntheorem TermDefinable\u2081_iff_termDefinable (f : M \u2192 M) : A.TermDefinable\u2081 L f \u2194\r\n    A.TermDefinable L (fun v \u21a6 f (v ())) := by\r\n  refine exists_congr fun \u03c6 \u21a6 ?_\r\n  rw [funext_iff, funext_iff, (Equiv.funUnique Unit M).forall_congr']\r\n  simp only [Equiv.funUnique_symm_apply, uniqueElim_const, Function.comp_apply]\r\n  congr!\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1586,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  obtain \u27e8t, h\u27e9 := TermDefinable.Definable A L h\r\n",
      "body": "```suggestion\r\n  obtain \u27e8t, h\u27e9 := TermDefinable.Definable A L h\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1588,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.const M C) :=\r\n  (TermDefinable.const C).termDefinable\u2081\r\n",
      "body": "Generalize\r\n\r\n```suggestion\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.c",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_fun_prop"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1589,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp {f g : M \u2192 M} (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable\u2081 L g) :\r\n    A.TermDefinable\u2081 L (f \u2218 g) :=\r\n  (hf.termDefinable.comp fun _ \u21a6 hg.termDefinable).termDefinable\u2081\r\n\r\n/-- A `TermDefinable` function postcomposed with `TermDefinable\u2081` is `TermDefinable`. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp_termDefinable {f : M \u2192 M} {g : (\u03b1 \u2192 M) \u2192 M}\r\n    (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable L g) : A.TermDefinable L (f \u2218 g) :=\r\n  hf.termDefinable.comp fun _ \u21a6 hg\r\n",
      "body": "```suggestion\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "new_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_fun_prop"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1591,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081.graph_definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n    A.Definable\u2082 L f.graph := by\r\n  obtain \u27e8t, h\u27e9 := h.termDefinable.tupleGraph_definable A L\r\n  use t.relabel (Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  ext v\r\n  convert Set.ext_iff.1 h (Sum.elim (fun _ \u21a6 v 0) (fun _ \u21a6 v 1))\r\n  rw [mem_setOf, mem_setOf, Formula.realize_relabel, Sum.comp_elim]\r\n  rfl\r\n",
      "body": "```suggestion\r\ntheorem TermDefinable\u2081.graph_definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n    A.Definable\u2082 L f.graph := by\r\n  obtain \u27e8t, h\u27e9 := h.termDefinable.tupleGraph_definable A L\r\n  use t.relabel (Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  ext v\r\n  convert Set.ext_iff.1 h (Sum.elim (fun _ \u21a6 v 0) (fun _ \u21a6 v 1))\r\n  rw [mem_setOf, mem_setOf, Formula.realize_relabel, Sum.comp_elim]\r\n  rfl\r\n```\r\n\r\n`rw [setOf]` is a defeq abuse (see docstring of `Set.setOf_app_iff`)",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1593,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  convert Set.ext_iff.1 h (v \u2218 Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  simp\r\n",
      "body": "golf\r\n```suggestion\r\n  convert Set.ext_iff.1 h (v \u2218 Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  simp\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1616,
      "before_code": "(eq_bot_or_eq_top (Subgroup.zpowers g)).resolve_left (Subgroup.zpowers_ne_bot.2 hg)\n  exact \u27e8\u27e8g, (Subgroup.eq_top_iff' _).1 this\u27e9\u27e9\n\n@[to_additive]\ntheorem prime_card [Finite \u03b1] : (Nat.card \u03b1).Prime := by",
      "suggestion": "\r\ntheorem prime_card : (Nat.card \u03b1).Prime := by\r\n  have : Finite \u03b1 := CommSimple_is_Finite\r\n",
      "body": "I think you should just modify this proof instead of making another one\r\n```suggestion\r\ntheorem prime_card : (Nat.card \u03b1).Prime := by\r\n  have : Finite \u03b1 := CommSimple_is_Finite\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "to_additive",
          "Finite",
          "theorem",
          "exact",
          "Nat",
          "eq_bot_or_eq_top",
          "zpowers",
          "this",
          "eq_top_iff",
          "prime_card",
          "resolve_left",
          "zpowers_ne_bot",
          "Prime",
          "card"
        ]
      }
    },
    {
      "id": 1621,
      "before_code": "|>.symm.trans <| QuotientAddGroup.quotientAddEquivOfEq kereq\n    |>.symm.trans <| QuotientAddGroup.quotientKerEquivOfSurjective (zmultiplesHom G g) surj",
      "suggestion": "  have orderG : Nat.card G = p := (orderOf_eq_card_of_zpowers_eq_top hg).symm\n",
      "body": "```suggestion\n  have orderG : Nat.card G = p := (orderOf_eq_card_of_zpowers_eq_top hg).symm\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "QuotientAddGroup",
          "quotientAddEquivOfEq",
          "quotientKerEquivOfSurjective",
          "kereq",
          "zmultiplesHom",
          "surj",
          "trans"
        ]
      }
    },
    {
      "id": 1622,
      "before_code": "|>.symm.trans <| QuotientAddGroup.quotientAddEquivOfEq kereq\n    |>.symm.trans <| QuotientAddGroup.quotientKerEquivOfSurjective (zmultiplesHom G g) surj",
      "suggestion": "  \u00b7 exact \u27e8(zmodAddCyclicAddEquiv (G := Additive G) inferInstance).symm\u27e9\n",
      "body": "```suggestion\n  \u00b7 exact \u27e8(zmodAddCyclicAddEquiv (G := Additive G) inferInstance).symm\u27e9\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "QuotientAddGroup",
          "quotientAddEquivOfEq",
          "quotientKerEquivOfSurjective",
          "kereq",
          "zmultiplesHom",
          "surj",
          "trans"
        ]
      }
    },
    {
      "id": 1633,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n",
      "body": "```suggestion\n  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n```\n\n`by exact` is (almost always) a no-op.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 1634,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "      (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset]))\n",
      "body": "```suggestion\n      (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset]))\n```",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 1636,
      "before_code": "(fun n => closure_mono <| hK_anti n) (fun n => (K n).nonempty.closure)\n      (K 0).isCompact.closure fun n => isClosed_closure\n  exact hK_nonempty.mono hK_subset",
      "suggestion": "  have : BaireSpace ((\u2191) \u207b\u00b9' s : Set (closure s)) :=\n    (isG\u03b4_induced continuous_subtype_val hG).baireSpace_of_dense\n",
      "body": "```suggestion\n  have : BaireSpace ((\u2191) \u207b\u00b9' s : Set (closure s)) :=\n    (isG\u03b4_induced continuous_subtype_val hG).baireSpace_of_dense\n```",
      "path": "Mathlib/Topology/Baire/LocallyCompactRegular.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "mono",
          "exact",
          "closure",
          "hK_nonempty",
          "closure_mono",
          "hK_subset",
          "nonempty",
          "isCompact",
          "isClosed_closure",
          "hK_anti"
        ]
      }
    },
    {
      "id": 1637,
      "before_code": "theorem IsG\u03b4.iUnion [Finite \u03b9'] {f : \u03b9' \u2192 Set X} (h : \u2200 i, IsG\u03b4 (f i)) : IsG\u03b4 (\u22c3 i, f i) :=\n  .sUnion (finite_range _) <| forall_mem_range.2 h",
      "suggestion": "  obtain \u27e8U, hU1, hU2\u27e9 := hs.eq_iInter_nat\n",
      "body": "```suggestion\n  obtain \u27e8U, hU1, hU2\u27e9 := hs.eq_iInter_nat\n```",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "Finite",
          "theorem",
          "forall_mem_range",
          "iUnion",
          "Set",
          "sUnion",
          "finite_range"
        ]
      }
    },
    {
      "id": 1638,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "    (fun n => (hg1 n).inter (hV.1 n))\n    (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset])) (hg1 n))\n",
      "body": "```suggestion\n    (fun n => (hg1 n).inter (hV.1 n))\n    (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset])) (hg1 n))\n```\nI think this slightly improves readability.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 1642,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n",
      "body": "I would like to reformat this to make it easier to distinguish the different arguments. I originally thought this was one argument to `mkCLM`.\n```suggestion\n  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n```\nThen indent the remainder of the proof, and remove the final `)`.",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "simpa",
          "simp",
          "intro",
          "fun_prop"
        ],
        "body_tactics": [
          "ext",
          "simpa",
          "simp",
          "intro",
          "fun_prop"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "ext",
          "intro",
          "fun_prop"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa",
          "use_fun_prop"
        ],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 1643,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "        cases n with\n        | zero => \n          simp only [Finset.range_zero, Nat.choose_zero_succ, CharP.cast_eq_zero, zero_mul,\n            Finset.sum_const_zero]\n          positivity\n        | succ n =>\n          have : \u2211 k \u2208 Finset.range n,\n              (((n + 1).choose (k + 1 + 1)) : \u211d) * \u2016iteratedFDeriv \u211d (k + 1 + 1) L x\u2016 *\n              \u2016iteratedFDeriv \u211d (n + 1 - (k + 1 + 1)) f x\u2016 = 0 := by\n            apply Finset.sum_eq_zero\n            simp [iteratedFDeriv_succ_eq_comp_right, iteratedFDeriv_succ_const]\n          rw [Finset.sum_range_succ', this]\n",
      "body": "It's nicer to use `cases` here since `n : \u2115`. Then you don't have to futz with `n' + 1 = n` and all so forth.\n```suggestion\n        cases n with\n        | zero => \n          simp only [Finset.range_zero, Nat.choose_zero_succ, CharP.cast_eq_zero, zero_mul,\n            Finset.sum_const_zero]\n          positivity\n        | succ n =>\n          have : \u2211 k \u2208 Finset.range n,\n              (((n + 1).choose (k + 1 + 1)) : \u211d) * \u2016iteratedFDeriv \u211d (k + 1 + 1) L x\u2016 *\n              \u2016iteratedFDeriv \u211d (n + 1 - ",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "positivity",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "positivity",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "positivity",
          "rw",
          "simp",
          "cases",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 1644,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "        grw [le_opNorm, \u2190 le_seminorm \ud835\udd5c (k + 1) n f x, \u2190 le_seminorm \ud835\udd5c k (n - 1) f x]\n        apply le_of_eq\n        ring\n",
      "body": "no need for the `add_le_add` as that's sort of the point of `grw`. And I think `apply le_of_eq` is better so that we get a terminal `ring` call.\n```suggestion\n        grw [le_opNorm, \u2190 le_seminorm \ud835\udd5c (k + 1) n f x, \u2190 le_seminorm \ud835\udd5c k (n - 1) f x]\n        apply le_of_eq\n        ring\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "ring"
        ],
        "body_tactics": [
          "apply",
          "ring"
        ],
        "new_tactics": [
          "apply",
          "ring"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 1645,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "        gcongr <;> simp\n",
      "body": "```suggestion\n        gcongr <;> simp\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "gcongr",
          "simp"
        ],
        "body_tactics": [
          "gcongr",
          "simp"
        ],
        "new_tactics": [
          "gcongr",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 1646,
      "before_code": "continuousOn_sqrt := by fun_prop\n  sqrt_nonneg _ _ := by simp\n  sqrt_mul_sqrt x hx := by\n    simp only [Function.comp_apply,]",
      "suggestion": "    simp only [Function.comp_apply]\n",
      "body": "```suggestion\n    simp only [Function.comp_apply]\n```",
      "path": "Mathlib/Topology/ContinuousMap/ContinuousSqrt.lean",
      "tags": {
        "before_tactics": [
          "fun_prop",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "function"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "sqrt_mul_sqrt",
          "continuousOn_sqrt",
          "comp_apply",
          "simp",
          "sqrt_nonneg",
          "Function",
          "fun_prop",
          "only"
        ]
      }
    },
    {
      "id": 1648,
      "before_code": "convert hf.add hg.neg using 1\n  grind",
      "suggestion": "\r\n  classical\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert a s has ih => \r\n    obtain \u27e8hf, h\u27e9 := by simpa using hf\r\n    simpa [has] using hf.add (ih h)\r\n",
      "body": "When I saw this, I thought \"do we really not have `HasTemperateGrowth.add`?\" and then I realized we do. This is much easier than you're making it. You need to use an induction principle. In this case:\r\n```suggestion\r\n  classical\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert a s has ih => \r\n    obtain \u27e8hf, h\u27e9 := by simpa using hf\r\n    simpa [has] using hf.add (ih h)\r\n```",
      "path": "Mathlib/Analysis/Distribution/TemperateGrowth.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "removed_tactics": [
          "grind"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "add",
          "neg",
          "convert",
          "grind",
          "using"
        ]
      }
    },
    {
      "id": 1649,
      "before_code": "filter_upwards [Tendsto.eventually_const_lt (zero_lt_one) h\u03c6, hu\u03c6v] with x h\u03c6_pos huv'\n  simp [\u2190 Real.mul_rpow (le_of_lt h\u03c6_pos) (hv x), huv']",
      "suggestion": "\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <| Real.tendsto_log_atTop.comp g_tendsto\r\n",
      "body": "slightly cleaner\r\n```suggestion\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <",
      "path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "body_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "new_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "eventually_const_lt",
          "zero_lt_one",
          "Real",
          "Tendsto",
          "filter_upwards",
          "mul_rpow",
          "simp",
          "huv"
        ]
      }
    },
    {
      "id": 1658,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "\r\ntheorem iterate_derivative_derivative_mul_X_pow {n m l : \u2115} (p : R[X]) (hl : m \u2264 l) :\r\n    derivative^[n] (derivative^[l] p * X ^ m) =\r\n      \u2211 k \u2208 range (min m n).succ,\r\n        ((n.choose k * m.descFactorial k) \u2022 (derivative^[n + (l - k)] p * X ^ (m - k))) := by\r\n  have {k : \u2115} (hk : k \u2208 range (min m n).succ) : n - k + l = n + (l - k) := by\r\n    replace hk : k \u2264 m \u2227 k \u2264 n := by simpa using hk\r\n    grind\r\n  simp_rw [iterate_derivative_mul_X_pow, \u2190 Function.iterate_add_apply]\r\n  exact Finset.sum_congr rfl fun k hk \u21a6 by simp [this hk]\r\n",
      "body": "I'm also dubious about this lemma since it's really just an extension of `iterate_derivative_mul_X_pow` which inlines a proof that `n + (m - k) = n - k + m` for `k` in the right range.\r\n\r\nOf course convenience lemmas can be justified if they come up enough. If you do have compelling evidence in favour then I think we should generalise since the repeated `m` is not relevant, and also avoid using low-level lemmas like `Nat.add_sub_assoc` as follows:\r\n```suggestion\r\ntheorem iterate_derivative_deriv",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1661,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n    simp_rw [iterate_derivative_mul, iterate_derivative_X_pow_eq_smul, mul_smul]\n    congr! 2 with k hk\n    norm_cast\n    ring\n  rw [hsum]\n  refine sum_congr_of_eq_on_inter (fun k hk hk' \u21a6 ?_) (by aesop) (by simp)\n  rcases le_or_gt k m with hkm | hkm\n  \u00b7 replace hk' : n < k := by simpa [hkm] using hk'\n    simp [Nat.choose_eq_zero_of_lt hk']\n  \u00b7 simp [Nat.descFactorial_eq_zero_iff_lt.mpr hkm]\n",
      "body": "Here's a slight golf. It's happens to be shorter but my main aim was to make the formal proof match how I think about this argument a bit more closely:\n```suggestion\ntheorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivati",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "ring",
          "norm_cast"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "ring",
          "norm_cast"
        ],
        "new_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_ring",
          "use_aesop"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1662,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_derivative_mul_X {n : \u2115} (p : R[X]) :\n    derivative^[n] (derivative p * X) = (derivative^[n + 1] p) * X + n \u2022 derivative^[n] p := by\n  convert (derivative p).iterate_derivative_mul_X_pow n 1; \u00b7 simp\n  rcases n with rfl | n <;> simp [sum_range_succ]\n",
      "body": "Another small golf, with similar goals to the one above. Also a rename (using primed names is allowed but only really as a last resort):\n```suggestion\ntheorem iterate_derivative_derivative_mul_X {n : \u2115} (p : R[X]) :\n    derivative^[n] (derivative p * X) = (derivative^[n + 1] p) * X + n \u2022 derivative^[n] p := by\n  convert (derivative p).iterate_derivative_mul_X_pow n 1; \u00b7 simp\n  rcases n with rfl | n <;> simp [sum_range_succ]\n```",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1663,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_derivative_mul_X_sq {n : \u2115} (p : R[X]) :\n    derivative^[n] (derivative^[2] p * X ^ 2) =\n      (derivative^[n + 2] p) * X ^ 2 + (2 * n) \u2022 (derivative^[n + 1] p) * X +\n        (n * (n - 1)) \u2022 derivative^[n] p := by\n  convert (derivative^[2] p).iterate_derivative_mul_X_pow n 2\n  rcases n with rfl | n; \u00b7 simp\n  rcases n with rfl | n; \u00b7 simp [sum_range_succ, \u2190 mul_assoc]\n  suffices ((n + 1 + 1) * (n + 1) / 2) * 2 = (n + 1 + 1) * (n + 1) by\n    simp [this, -nsmul_eq_mul, sum_range_succ, Nat.choose_two_right]\n    ring\n  rw [mul_comm (n + 1 + 1)]\n  exact Nat.div_mul_cancel (Nat.two_dvd_mul_add_one _)\n",
      "body": "One more golf, again with similar aims. The `simp` in this is disappointingly slow but within our tolerances:\n```suggestion\ntheorem iterate_derivative_derivative_mul_X_sq {n : \u2115} (p : R[X]) :\n    derivative^[n] (derivative^[2] p * X ^ 2) =\n      (derivative^[n + 2] p) * X ^ 2 + (2 * n) \u2022 (derivative^[n + 1] p) * X +\n        (n * (n - 1)) \u2022 derivative^[n] p := by\n  convert (derivative^[2] p).iterate_derivative_mul_X_pow n 2\n  rcases n with rfl | n; \u00b7 simp\n  rcases n with rfl | n; \u00b7 simp [sum_rang",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "cases",
          "rw",
          "simp",
          "ring"
        ],
        "body_tactics": [
          "exact",
          "cases",
          "rw",
          "simp",
          "ring"
        ],
        "new_tactics": [
          "exact",
          "cases",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1664,
      "before_code": "lemma two_dvd_mul_add_one (k : \u2115) : 2 \u2223 k * (k + 1) :=\n  even_iff_two_dvd.mp (even_mul_succ_self k)",
      "suggestion": "lemma two_dvd_mul_sub_one (k : \u2115) : 2 \u2223 k * (k - 1) := by\n  rcases k with rfl | k; \u00b7 simp\n  simpa [mul_comm (k + 1)] using k.two_dvd_mul_add_one\n",
      "body": "After the golfs suggested above, this lemma is no longer needed but I think is still worth adding (despite containing an evil nat subtraction). However let's try for a more idiomatic proof:\n```suggestion\nlemma two_dvd_mul_sub_one (k : \u2115) : 2 \u2223 k * (k - 1) := by\n  rcases k with rfl | k; \u00b7 simp\n  simpa [mul_comm (k + 1)] using k.two_dvd_mul_add_one\n```",
      "path": "Mathlib/Algebra/Ring/Parity.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "cases",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "cases",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "cases",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "two_dvd_mul_add_one",
          "even_mul_succ_self",
          "lemma",
          "even_iff_two_dvd"
        ]
      }
    },
    {
      "id": 1667,
      "before_code": "public import Mathlib.Algebra.Category.ModuleCat.Basic\npublic import Mathlib.LinearAlgebra.Matrix.Module\n\n/-!\n# Morita Equivalece between `R` and `M\u2099(R)`\n\n## Main definitions\n- `ModuleCat.toMatrixModCat`: The functor from `Mod-R` to `Mod-M\u2099(R)` induced by\n  `LinearMap.mapMatrixModule` and `Matrix.Module.matrixModule`.\n\n## TODO (Edison)\n- Prove `R` and `M\u2099(R)` are morita-equivalent.\n-/\n\n@[expose] public section\n\nuniverse u\n\nvariable (R \u03b9 : Type*) [Ring R] [Fintype \u03b9] [DecidableEq \u03b9]\n\nopen CategoryTheory Matrix.Module\n\n/-- The functor from `Mod-R` to `Mod-M\u2099(R)` induced by `LinearMap.mapModule` and\n  `Matrix.matrixModule`. -/\n@[simps]\ndef ModuleCat.toMatrixModCat : ModuleCat R \u2964 ModuleCat (Matrix \u03b9 \u03b9 R) where\n  obj M := ModuleCat.of (Matrix \u03b9 \u03b9 R) (\u03b9 \u2192 M)\n  map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\n  haveI (M : ModuleCat (Matrix \u03b9 \u03b9 R)) : IsScalarTower R (Matrix \u03b9 \u03b9 R) M :=\r\n    { smul_assoc r m x := show _ = (Matrix.scalar \u03b9 r) \u2022 (m \u2022 x) by\r\n        rw [\u2190 mul_smul, Matrix.scalar_apply, Matrix.smul_eq_diagonal_mul] }\r\n",
      "body": "```suggestion\r\n  haveI (M : ModuleCat (Matrix \u03b9 \u03b9 R)) : IsScalarTower R (Matrix \u03b9 \u03b9 R) M :=\r\n    { smul_assoc r m x := show _ = (Matrix.scalar \u03b9 r) \u2022 (m \u2022 x) by\r\n        rw [\u2190 mul_smul, Matrix.scalar_apply, Matrix.smul_eq_diagonal_mul] }\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "hom",
          "import",
          "expose",
          "Ring",
          "Type",
          "CategoryTheory",
          "mapModule",
          "Main",
          "open",
          "section",
          "TODO",
          "ModuleCat",
          "Basic",
          "Mathlib",
          "LinearMap",
          "functor",
          "universe",
          "map_comp",
          "mapMatrixModule",
          "map",
          "equivalent",
          "are",
          "morita",
          "DecidableEq",
          "mapMatrixModule_comp",
          "Prove",
          "LinearAlgebra",
          "variable",
          "public",
          "def",
          "definitions",
          "induced",
          "simps",
          "between",
          "Morita",
          "toMatrixModCat",
          "Mod",
          "ofHom",
          "obj",
          "map_id",
          "hom_ext",
          "matrixModule",
          "Equivalece",
          "Edison",
          "Category",
          "mapMatrixModule_id",
          "Fintype",
          "from",
          "Matrix"
        ]
      }
    },
    {
      "id": 1669,
      "before_code": "map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\ndef toModuleCatObj : Submodule R M :=\r\n  LinearMap.range (\u03c4\u2081\u2082 := .id _) <|\r\n    { __ := DistribMulAction.toAddMonoidHom M (single default default 1 : Matrix \u03b9 \u03b9 R)\r\n      map_smul' r x := by\r\n        dsimp\r\n        rw [\u2190 smul_assoc r, Matrix.smul_eq_diagonal_mul, show (diagonal fun x : \u03b9 \u21a6 r) *\r\n          single _ _ 1 = single default default 1 * diagonal (fun _ \u21a6 r) by ext; simp [Matrix.single],\r\n          SemigroupAction.mul_smul, \u2190 Matrix.smul_one_eq_diagonal]\r\n        nth_rw 1 [\u2190 one_smul (Matrix \u03b9 \u03b9 R) x]\r\n        rw [smul_assoc] }\r\n",
      "body": "Perhaps nicer to build the map first:\r\n```suggestion\r\ndef toModuleCatObj : Submodule R M :=\r\n  LinearMap.range (\u03c4\u2081\u2082 := .id _) <|\r\n    { __ := DistribMulAction.toAddMonoidHom M (single default default 1 : Matrix \u03b9 \u03b9 R)\r\n      map_smul' r x := by\r\n        dsimp\r\n        rw [\u2190 smul_assoc r, Matrix.smul_eq_diagonal_mul, show (diagonal fun x : \u03b9 \u21a6 r) *\r\n          single _ _ 1 = single default default 1 * diagonal (fun _ \u21a6 r) by ext; simp [Matrix.single],\r\n          SemigroupAction.mul_smul, \u2190 Matrix.",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "LinearMap",
          "map_comp",
          "mapMatrixModule",
          "mapMatrixModule_id",
          "map",
          "ModuleCat",
          "hom_ext",
          "ofHom",
          "mapMatrixModule_comp",
          "map_id"
        ]
      }
    },
    {
      "id": 1674,
      "before_code": "rw [\u2190 IsOpenImmersion.lift_fac U.\u03b9 g (by simp [U])]\n  infer_instance",
      "suggestion": "  \u00b7 dsimp [MorphismProperty.isomorphisms] at H \u22a2\n    exact IsZariskiLocalAtTarget.of_isPullback (.flip <| .of_hasPullback _ _) H\n",
      "body": "Untested:\n```suggestion\n  \u00b7 dsimp [MorphismProperty.isomorphisms] at H \u22a2\n    exact IsZariskiLocalAtTarget.of_isPullback (.flip <| .of_hasPullback _ _) H\n```",
      "path": "Mathlib/AlgebraicGeometry/Morphisms/FlatDescent.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "lift_fac",
          "simp",
          "IsOpenImmersion",
          "infer_instance"
        ]
      }
    },
    {
      "id": 1679,
      "before_code": "theorem uniqueProd_apply [Preorder \u03b1] [Unique \u03b1] [LE \u03b2] (x : \u03b1 \u00d7\u2097 \u03b2) :\n    uniqueProd \u03b1 \u03b2 x = (ofLex x).2 := rfl",
      "suggestion": "\r\n    simp only [Prod.Lex.le_iff, Prod.Lex.lt_iff, Equiv.trans_apply, Equiv.prodCongr_apply,\r\n      Equiv.prodAssoc_apply]\r\n    grind [EmbeddingLike.apply_eq_iff_eq, ofLex_toLex]\r\n",
      "body": "```suggestion\r\n    simp only [Prod.Lex.le_iff, Prod.Lex.lt_iff, Equiv.trans_apply, Equiv.prodCongr_apply,\r\n      Equiv.prodAssoc_apply]\r\n    grind [EmbeddingLike.apply_eq_iff_eq, ofLex_toLex]\r\n```",
      "path": "Mathlib/Order/Hom/Lex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "ofLex",
          "theorem",
          "uniqueProd",
          "Preorder",
          "rfl",
          "Unique",
          "uniqueProd_apply"
        ]
      }
    },
    {
      "id": 1685,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n",
      "body": "For this sort of argument (where `fun_prop` can't quite close the goal alone), I find it works well to put auxiliary facts into the context and then run `fun_prop` with a custom discharger:\r\n ```suggestion\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "use_fun_prop"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 1686,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n",
      "body": "We can use more automation here too:\r\n```suggestion\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "funext",
          "exact",
          "have",
          "simp",
          "fun_prop"
        ],
        "body_tactics": [
          "funext",
          "exact",
          "have",
          "simp",
          "fun_prop"
        ],
        "new_tactics": [
          "funext",
          "simp",
          "exact",
          "fun_prop",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 1689,
      "before_code": "rcases eq_or_ne x 0 with rfl | hx0 <;>\n  simp_all [one_apply_of_ne_zero]",
      "suggestion": "\r\n  rw [Submonoid.nontrivial_iff_exists_ne_one]\r\n  exact \u27e8Units.mk0 (v x) h0, \u27e8x, rfl\u27e9, mt Units.ext_iff.mp h1\u27e9\r\n",
      "body": "Personally I would do the opposite and be more tactic-y for the first step and more term-y for the end.\r\n```suggestion\r\n  rw [Submonoid.nontrivial_iff_exists_ne_one]\r\n  exact \u27e8Units.mk0 (v x) h0, \u27e8x, rfl\u27e9, mt Units.ext_iff.mp h1\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "simp_all"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [
          "cases",
          "simp_all"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rcases",
          "one_apply_of_ne_zero",
          "simp_all",
          "rfl",
          "hx0",
          "eq_or_ne"
        ]
      }
    },
    {
      "id": 1692,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194 Nonempty (G.CompleteBipartiteSubgraph (card \u03b1) (card \u03b2)) where\r\n  mp := fun \u27e8f\u27e9 \u21a6 \u27e8CompleteBipartiteSubgraph.ofCopy f\u27e9\r\n  mpr := fun \u27e8B\u27e9 \u21a6 \u27e8B.toCopy.comp <| Iso.toCopy \u27e8(equivFin \u03b1).sumCongr (equivFin \u03b2), by simp\u27e9\u27e9\r\n",
      "body": "nit:\r\n```suggestion\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194 Nonempty (G.CompleteBipartiteSubgraph (card \u03b1) (card \u03b2)) where\r\n  mp := fun \u27e8f\u27e9 \u21a6 \u27e8CompleteBipartiteSubgraph.ofCopy f\u27e9\r\n  mpr := fun \u27e8B\u27e9 \u21a6 \u27e8B.toCopy.comp <| Iso.toCopy \u27e8(equivFin \u03b1).sumCongr (equivFin \u03b2), by simp\u27e9\u27e9\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 1702,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n  obtain \u27e8fs\u27e9 : Nonempty (Fin a \u21aa left) := by\r\n    apply Function.Embedding.nonempty_of_card_le\r\n    rw [Fintype.card_fin, card_coe, card_left]\r\n",
      "body": "```suggestion\r\n  obtain \u27e8fs\u27e9 : Nonempty (Fin a \u21aa left) := by\r\n    apply Function.Embedding.nonempty_of_card_le\r\n    rw [Fintype.card_fin, card_coe, card_left]\r\n```\r\nSame below",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "apply",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 1703,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n    | .inl p\u2081, .inl p\u2082 => simp\r\n    | .inr p\u2081, .inl p\u2082 =>\r\n      simpa using (h (fs p\u2082).prop (ft p\u2081).prop).ne'\r\n    | .inl p\u2081, .inr p\u2082 =>\r\n      simpa using (h (fs p\u2081).prop (ft p\u2082).prop).symm.ne'\r\n    | .inr p\u2081, .inr p\u2082 => simp\r\n",
      "body": "nit:\r\n```suggestion\r\n    | .inl p\u2081, .inl p\u2082 => simp\r\n    | .inr p\u2081, .inl p\u2082 =>\r\n      simpa using (h (fs p\u2082).prop (ft p\u2081).prop).ne'\r\n    | .inl p\u2081, .inr p\u2082 =>\r\n      simpa using (h (fs p\u2081).prop (ft p\u2082).prop).symm.ne'\r\n    | .inr p\u2081, .inr p\u2082 => simp\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 1727,
      "before_code": "lemma reciprocalFactors_odd {n : \u2115} (h1 : n \u2260 1) (h2 : Odd n) :\n    reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1) := by\n  have h0 : n \u2260 0 := by\n    rintro rfl\n    norm_num [\u2190 Nat.not_even_iff_odd] at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.not_even_iff_odd.2 h2)]",
      "suggestion": "\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n",
      "body": "this is 10x slower than the previous proof. What about changing it to something like this?\r\n```suggestion\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n```\r\nso same as before, but the `n \u2260 0` is by `grind`.",
      "path": "Mathlib/GroupTheory/CommutingProbability.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "grind"
        ],
        "removed_tactics": [
          "norm_num",
          "have"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "norm_num",
          "reciprocalFactors_odd",
          "lemma",
          "reciprocalFactors",
          "not_even_iff_odd",
          "Odd",
          "Nat",
          "dif_neg",
          "have",
          "rintro",
          "if_neg",
          "rfl"
        ]
      }
    },
    {
      "id": 1728,
      "before_code": "{k\u2081 : Function.LeftInverse \u03c6' \u03c6} {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    (inverse' f g k\u2082 h\u2081 h\u2082).comp f (\u03ba := CompTriple.comp_inv k\u2081) = MulActionHom.id M := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2081 x",
      "suggestion": "  simpa using h\u2081.eq _\n",
      "body": "```suggestion\n  simpa using h\u2081.eq _\n```",
      "path": "Mathlib/GroupTheory/GroupAction/Hom.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "RightInverse",
          "id_apply",
          "ext_iff",
          "exact",
          "comp_apply",
          "MulActionHom",
          "comp",
          "CompTriple",
          "simp",
          "intro",
          "LeftInverse",
          "Function",
          "comp_inv",
          "only",
          "inverse"
        ]
      }
    },
    {
      "id": 1729,
      "before_code": "{k\u2081 : Function.LeftInverse \u03c6' \u03c6} {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    (inverse' f g k\u2082 h\u2081 h\u2082).comp f (\u03ba := CompTriple.comp_inv k\u2081) = MulActionHom.id M := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2081 x\n\n@[to_additive]\ntheorem inverse'_comp {f : X \u2192\u2091[\u03c6] Y} {g : Y \u2192 X}\n    {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    f.comp (inverse' f g k\u2082 h\u2081 h\u2082) (\u03ba := CompTriple.comp_inv k\u2082) = MulActionHom.id N := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2082 x",
      "suggestion": "  simpa using h\u2082.eq _\n",
      "body": "```suggestion\n  simpa using h\u2082.eq _\n```",
      "path": "Mathlib/GroupTheory/GroupAction/Hom.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "to_additive",
          "RightInverse",
          "id_apply",
          "ext_iff",
          "theorem",
          "exact",
          "comp_apply",
          "MulActionHom",
          "comp",
          "CompTriple",
          "simp",
          "intro",
          "LeftInverse",
          "Function",
          "_comp",
          "comp_inv",
          "only",
          "inverse"
        ]
      }
    },
    {
      "id": 1732,
      "before_code": "(f.trans g).toLinearMap = g.toLinearMap.comp f.toLinearMap :=\n  rfl",
      "suggestion": "\r\ntheorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (f.prodCongr f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n",
      "body": "or instead\r\n```suggestion\r\ntheorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (f.prodCongr f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n```",
      "path": "Mathlib/Algebra/Algebra/Equiv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "trans",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 1733,
      "before_code": "(f.trans g).toLinearMap = g.toLinearMap.comp f.toLinearMap :=\n  rfl",
      "suggestion": "\r\ntheorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (Prod.map f f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n",
      "body": "I think it's better to use `Prod.map` on RHS, because it's a simp-normal form.\r\n```suggestion\r\ntheorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (Prod.map f f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n```",
      "path": "Mathlib/Algebra/Algebra/Equiv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "trans",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 1734,
      "before_code": "(f.trans g).toLinearMap = g.toLinearMap.comp f.toLinearMap :=\n  rfl",
      "suggestion": "\r\n@[simp] theorem linearEquivConj_mulLeft (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeft R x) = .mulLeft R (f x) := by\r\n  ext; simp [LinearEquiv.conj_apply]\r\n\r\n@[simp] theorem linearEquivConj_mulRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081) :\r\n    f.toLinearEquiv.conj (.mulRight R x) = .mulRight R (f x) := by\r\n  ext; simp [LinearEquiv.conj_apply]\r\n\r\n@[simp] theorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (Prod.map f f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n",
      "body": "```suggestion\r\n@[simp] theorem linearEquivConj_mulLeft (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeft R x) = .mulLeft R (f x) := by\r\n  ext; simp [LinearEquiv.conj_apply]\r\n\r\n@[simp] theorem linearEquivConj_mulRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081) :\r\n    f.toLinearEquiv.conj (.mulRight R x) = .mulRight R (f x) := by\r\n  ext; simp [LinearEquiv.conj_apply]\r\n\r\n@[simp] theorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mu",
      "path": "Mathlib/Algebra/Algebra/Equiv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "trans",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 1736,
      "before_code": "[DecidableEq S] [Nontrivial S] (f : \u2115 \u2192+* S) (hf : Function.Injective f) : \u2115\u221e \u2192+* WithTop S :=\n  {MonoidWithZeroHom.ENatMap f.toMonoidWithZeroHom hf, f.toAddMonoidHom.ENatMap with}",
      "suggestion": "@[simp]\nprotected lemma map_natCast_mul {R : Type*} [NonAssocSemiring R] [DecidableEq R] [CharZero R] (a b : \u2115\u221e) :\n",
      "body": "unless you have some reason that you explicitly eschewed this naming.\n```suggestion\n@[simp]\nprotected lemma map_natCast_mul {R : Type*} [NonAssocSemiring R] [DecidableEq R] [CharZero R] (a b : \u2115\u221e) :\n```",
      "path": "Mathlib/Data/ENat/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "nat",
          "algebra"
        ],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "Injective",
          "WithTop",
          "Nontrivial",
          "ENatMap",
          "toAddMonoidHom",
          "DecidableEq",
          "MonoidWithZeroHom",
          "Function",
          "toMonoidWithZeroHom"
        ]
      }
    },
    {
      "id": 1750,
      "before_code": "theorem coplanar_triple (p\u2081 p\u2082 p\u2083 : P) : Coplanar k ({p\u2081, p\u2082, p\u2083} : Set P) :=\n  (collinear_pair k p\u2082 p\u2083).coplanar_insert p\u2081",
      "suggestion": "\r\n  have h : s.points i = (-n : k) \u2022 (s.faceOppositeCentroid i -\u1d65 s.centroid) +\u1d65 s.centroid := by\r\n",
      "body": "```suggestion\r\n  have h : s.points i = (-n : k) \u2022 (s.faceOppositeCentroid i -\u1d65 s.centroid) +\u1d65 s.centroid := by\r\n```",
      "path": "Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "coplanar_triple",
          "Set",
          "Coplanar",
          "coplanar_insert",
          "collinear_pair"
        ]
      }
    },
    {
      "id": 1755,
      "before_code": "(fun _ _ _ _ he => AffineIndependent.injective s\u2081.independent he)\n      (fun _ _ _ _ he => AffineIndependent.injective s\u2082.independent he) h",
      "suggestion": "  exact affineSpan_mono _ (by simp) (s.faceOppositeCentroid_mem_affineSpan_face i)\n",
      "body": "```suggestion\n  exact affineSpan_mono _ (by simp) (s.faceOppositeCentroid_mem_affineSpan_face i)\n```\nDoes this work? If so, I wonder if this one-line should be an extra lemma. It seems to me that it can just be inlined when needed.",
      "path": "Mathlib/LinearAlgebra/AffineSpace/Simplex/Centroid.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "independent",
          "AffineIndependent",
          "injective"
        ]
      }
    },
    {
      "id": 1767,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_one' := by simp\r\n        mul_le' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_mul_le_add p.1 x y) <| add_le_add _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 _\r\n            \u00b7 use q y\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 _\r\n          \u00b7 simp_all\r\n        inv' x := by simp }\r\n",
      "body": "same proofs, just significantly shorter and easier to read\r\n\r\n```suggestion\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_one' := by simp\r\n        mul_le' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_mul_le_add p.1 x y) <| add_le_add _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "refine",
          "simp_all",
          "simp",
          "exact",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "com",
          "https",
          "add_apply",
          "theorem",
          "too",
          "pull",
          "skeleton",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "rfl",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 1768,
      "before_code": "instance : Inhabited (NonarchAddGroupSeminorm E) :=\n  \u27e80\u27e9\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_zero' := by simp\r\n        add_le_max' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_add_le_max p.1 x y) <| max_le_max _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 x\r\n            \u00b7 use q y\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 y\r\n          \u00b7 simp_all\r\n        neg' x := congr(\u2a06 _, $(map_neg_eq_map _ x)) }\r\n",
      "body": "```suggestion\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_zero' := by simp\r\n        add_le_max' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_add_le_max p.1 x y) <| max_le_max _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exa",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "com",
          "https",
          "Inhabited",
          "too",
          "pull",
          "skeleton",
          "NonarchAddGroupSeminorm",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "instance",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 1769,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "noncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n            all_goals\n              apply le_ciSup (f := (DFunLike.coe \u00b7 _) \u2218 Subtype.val) ?_ p\n              simpa [Set.range_comp] using Monotone.map_bddAbove (fun _ _ h' \u21a6 by exact h' _) h\n        inv' x := by simp }\n    else 0\n",
      "body": "I think `where` syntax is nicer here, and I provided a small golf to avoid the case split.\n```suggestion\nnoncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n     ",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa",
          "term_mode"
        ],
        "keywords": [
          "community",
          "com",
          "https",
          "add_apply",
          "theorem",
          "too",
          "pull",
          "skeleton",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "rfl",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 1770,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345\n@[to_additive]\ninstance : Max (GroupSeminorm E) :=",
      "suggestion": "\nlemma sSup_of_not_bddAbove {s : Set (GroupSeminorm E)} (hs : \u00acBddAbove s) :\n    sSup s = 0 := by\n  simp [SupSet.sSup, hs]\n\nlemma coe_sSup_apply {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = \u2a06 p : s, (p : GroupSeminorm E) x := by\n  simp [SupSet.sSup, hs]\n  rfl\n\nlemma coe_sSup_apply' {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = sSup ((\u00b7 x) '' s) := by\n  rw [coe_sSup_apply hs, \u2190 sSup_range]\n  congr\n  ext\n  simp\n\nlemma coe_iSup_apply {\u03b9 : Type*} (f : \u03b9 \u2192 GroupSeminorm E) (h : BddAbove (range f)) {x : E} :\n    \u21d1(\u2a06 i, f i) x = \u2a06 i, (f i : GroupSeminorm E) x := by\n  rw [\u2190 sSup_range, coe_sSup_apply h]\n  exact (Set.rangeFactorization_surjective.iSup_congr _ (by simp)) |>.symm\n\n@[to_additive]\ninstance : Max (GroupSeminorm E) :=\n",
      "body": "you should have these lemmas available for rewriting\n```suggestion\n\nlemma sSup_of_not_bddAbove {s : Set (GroupSeminorm E)} (hs : \u00acBddAbove s) :\n    sSup s = 0 := by\n  simp [SupSet.sSup, hs]\n\nlemma coe_sSup_apply {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = \u2a06 p : s, (p : GroupSeminorm E) x := by\n  simp [SupSet.sSup, hs]\n  rfl\n\nlemma coe_sSup_apply' {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = sSup ((\u00b7 x) '' s) := by\n  rw [coe_sSup_apply hs",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "exact",
          "rw",
          "simp",
          "congr"
        ],
        "body_tactics": [
          "ext",
          "exact",
          "have",
          "rw",
          "simp",
          "congr"
        ],
        "new_tactics": [
          "rw",
          "simp",
          "ext",
          "exact",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "skeleton",
          "GroupSeminorm",
          "github",
          "Max",
          "TODO",
          "SupSet",
          "to_additive",
          "add_apply",
          "leanprover",
          "com",
          "issuecomment",
          "rfl",
          "https",
          "theorem",
          "too",
          "pull",
          "mathlib",
          "from",
          "instance",
          "define"
        ]
      }
    },
    {
      "id": 1773,
      "before_code": "natDegree (\u2211 i \u2208 s, f i) \u2264 n :=\n  le_trans (natDegree_sum_le s f) <| (Finset.fold_max_le n).mpr <| by simpa",
      "suggestion": "  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n",
      "body": "```suggestion\n  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n```",
      "path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "body_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "natDegree_sum_le",
          "natDegree",
          "mpr",
          "fold_max_le",
          "Finset",
          "simpa",
          "le_trans"
        ]
      }
    },
    {
      "id": 1797,
      "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
      "suggestion": "  simpa only [angle_comm] using h.angle_eq_right p\u2083\n",
      "body": "```suggestion\n  simpa only [angle_comm] using h.angle_eq_right p\u2083\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "by_cases",
          "Sbtw",
          "symm",
          "simp"
        ]
      }
    },
    {
      "id": 1798,
      "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
      "suggestion": "  exact Sbtw.angle_eq_right _ \u27e8h, hp\u2083p\u2082, hp\u2083p\u27e9\n",
      "body": "```suggestion\n  exact Sbtw.angle_eq_right _ \u27e8h, hp\u2083p\u2082, hp\u2083p\u27e9\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "by_cases",
          "Sbtw",
          "symm",
          "simp"
        ]
      }
    },
    {
      "id": 1799,
      "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
      "suggestion": "  simpa only [angle_comm] using h.angle_eq_right p\u2083 hp\u2081p\u2082\n",
      "body": "```suggestion\n  simpa only [angle_comm] using h.angle_eq_right p\u2083 hp\u2081p\u2082\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "by_cases",
          "Sbtw",
          "symm",
          "simp"
        ]
      }
    },
    {
      "id": 1812,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n",
      "body": "```suggestion\n  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n```\n`by exact` should be dropped most of the time.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 1813,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "  have h : a \u2260 b := by intro hab; simp [hab] at h\u03bc0\n",
      "body": "```suggestion\n  have h : a \u2260 b := by intro hab; simp [hab] at h\u03bc0\n```\nNo need to `subst`, it's something `simp` can do.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simp",
          "have",
          "intro"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 1814,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]\n\n/-- The mean value theorem for integrals:\nThere exists a point in an interval such that the mean of a continuous function over the interval\nequals the value of the function at the point. -/\ntheorem exists_eq_interval_average\n    {f : \u211d \u2192 \u211d} {a b : \u211d} (hab : a \u2260 b) (hf : ContinuousOn f (uIcc a b)) :\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d (x : \u211d) in a..b, f x := by\n  wlog h : a < b generalizing a b\n  \u00b7 rw [uIcc_comm] at hf\n    have := this hab.symm hf (lt_of_le_of_ne (le_of_not_gt h) (Ne.symm hab))\n    rwa [uIoo_comm, interval_average_symm] at this\n  let ave := \u2a0d (x : \u211d) in a..b, f x\n  have h_vol_fin1 : volume (uIoc a b) \u2260 0 := by simpa [h.le] using h\n  have h_vol_fin2 : volume (uIoc a b) \u2260 \u22a4 := by simp [h.le]\n  have h_intble : IntegrableOn f (uIoc a b) := by\n    have : IntegrableOn f (uIcc a b) := hf.integrableOn_uIcc\n    rwa [uIcc_of_lt h,integrableOn_Icc_iff_integrableOn_Ioc, \u2190uIoc_of_le (le_of_lt h)] at this\n  let S1 := {x | x \u2208 uIoc a b \u2227 f x \u2264 ave}\n  let S2 := {x | x \u2208 uIoc a b \u2227 ave \u2264 f x}\n  have h_meas1 : volume (S1 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_le_setAverage_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  have h_meas2 : volume (S2 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_setAverage_le_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  obtain \u27e8c1, \u27e8hc1_mem, hc1_le\u27e9, hc1'\u27e9 := nonempty_of_measure_ne_zero h_meas1\n  have hc1' : c1 \u2208 Ioo a b := by\n    rw [Set.uIoc_of_le (le_of_lt h)] at hc1_mem\n    rw [notMem_singleton_iff] at hc1'\n    exact \u27e8hc1_mem.1, lt_of_le_of_ne hc1_mem.2 hc1'\u27e9\n  obtain \u27e8c2, \u27e8hc2_mem, hc2_ge\u27e9, hc2'\u27e9 := nonempty_of_measure_ne_zero h_meas2\n  have hc2' : c2 \u2208 Ioo a b := by\n    rw [Se",
      "suggestion": "    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n",
      "body": "```suggestion\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n```\nsimp lemmas that you register elsewhere in the PR make the proof very direct!",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "cases",
          "have",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "continuity",
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "rwa",
          "codiscreteWithin",
          "interval_average_symm",
          "intervalIntegral",
          "le_of_lt",
          "Ioo_subset_Icc_self",
          "have",
          "mem_Ioo",
          "Filter",
          "notMem_singleton_iff",
          "integrableOn_uIcc",
          "intro",
          "hc2_mem",
          "such",
          "uIoc_of_le",
          "hab",
          "that",
          "simp",
          "h_ave",
          "volume",
          "theorem",
          "h_vol_fin2",
          "h_meas1",
          "h_meas2",
          "value",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "lt_of_lt_of_le",
          "There",
          "point",
          "imp",
          "uIcc",
          "intermediate_value_uIcc",
          "h_intble",
          "uIoo",
          "IntegrableOn",
          "hc1_mem",
          "continuous",
          "hc1_le",
          "hc1",
          "generalizing",
          "lt_of_le_of_ne",
          "interval",
          "Icc",
          "ave",
          "hc2",
          "measure_diff_null",
          "Ioo",
          "hc2_ge",
          "integrals"
        ]
      }
    },
    {
      "id": 1825,
      "before_code": "@[deprecated (since := \"2025-05-05\")] alias mulVec_stdBasisMatrix := single_mulVec",
      "suggestion": "\r\n  rw [sum_apply, diagonal_apply, Finset.sum_eq_single j] <;> simp +contextual [single_def]\r\n",
      "body": "```suggestion\r\n  rw [sum_apply, diagonal_apply, Finset.sum_eq_single j] <;> simp +contextual [single_def]\r\n```",
      "path": "Mathlib/Data/Matrix/Basis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "alias",
          "mulVec_stdBasisMatrix",
          "since",
          "single_mulVec",
          "deprecated"
        ]
      }
    },
    {
      "id": 1844,
      "before_code": "(isMulCocycle\u2081_of_mem_cocycles\u2081 _ x.2) with \u27e8\u03b2, h\u03b2\u27e9\n    use \u03b2",
      "suggestion": "  have := FiniteCyclicGroup.groupCohomology\u03c0Odd_eq_zero_iff (ofAlgebraAutOnUnits K L) g hg\n",
      "body": "There are two consecutive spaces between `groupCohomology\u03c0Odd_eq_zero_iff` and `(ofAlgebraAutOnUnits K L)`. This should be a single space for consistent formatting.\n```suggestion\n  have := FiniteCyclicGroup.groupCohomology\u03c0Odd_eq_zero_iff (ofAlgebraAutOnUnits K L) g hg\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/Hilbert90.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "use"
        ]
      }
    },
    {
      "id": 1845,
      "before_code": "(isMulCocycle\u2081_of_mem_cocycles\u2081 _ x.2) with \u27e8\u03b2, h\u03b2\u27e9\n    use \u03b2",
      "suggestion": "    have hxinv : Algebra.norm K x\u207b\u00b9 = 1 := by simp [Algebra.norm_inv, hx]\n    obtain \u27e8y, hy\u27e9 := H _ hxinv\n    use y\n    rw [IsUnit.div_eq_iff y.isUnit] at hy\n    rw [hy]\n    field_simp\n",
      "body": "```suggestion\n    have hxinv : Algebra.norm K x\u207b\u00b9 = 1 := by simp [Algebra.norm_inv, hx]\n    obtain \u27e8y, hy\u27e9 := H _ hxinv\n    use y\n    rw [IsUnit.div_eq_iff y.isUnit] at hy\n    rw [hy]\n    field_simp\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/Hilbert90.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "field_simp",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "field_simp",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "field_simp",
          "rw",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "use"
        ]
      }
    },
    {
      "id": 1851,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "\r\n@[simp]\r\ntheorem T_eval_zero_of_even {n : \u2124} (hn : Even n) : (T R n).eval 0 = (n / 2).negOnePow := by\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem T_eval_zero_of_even {n : \u2124} (hn : Even n) : (T R n).eval 0 = (n / 2).negOnePow := by\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 1853,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "\r\n@[simp]\r\ntheorem T_eval_zero_of_odd {n : \u2124} (hn : Odd n) : (T R n).eval 0 = 0 := by\r\n  simp [T_eval_zero, \u2190 Int.not_odd_iff_even, hn]\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem T_eval_zero_of_odd {n : \u2124} (hn : Odd n) : (T R n).eval 0 = 0 := by\r\n  simp [T_eval_zero, \u2190 Int.not_odd_iff_even, hn]\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 1854,
      "before_code": "norm_num\n    ring",
      "suggestion": "\r\n@[simp]\r\ntheorem U_eval_zero_of_even {n : \u2124} (hn : Even n) : (U R n).eval 0 = (n / 2).negOnePow := by\r\n  simp [U_eval_zero, hn]\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem U_eval_zero_of_even {n : \u2124} (hn : Even n) : (U R n).eval 0 = (n / 2).negOnePow := by\r\n  simp [U_eval_zero, hn]\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "norm_num",
          "ring"
        ],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "norm_num",
          "ring"
        ]
      }
    },
    {
      "id": 1855,
      "before_code": "norm_num\n    ring",
      "suggestion": "\r\n@[simp]\r\ntheorem U_eval_zero_of_odd {n : \u2124} (hn : Odd n) : (U R n).eval 0 = 0 := by\r\n  simp [U_eval_zero, \u2190 Int.not_odd_iff_even, hn]\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem U_eval_zero_of_odd {n : \u2124} (hn : Odd n) : (U R n).eval 0 = 0 := by\r\n  simp [U_eval_zero, \u2190 Int.not_odd_iff_even, hn]\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "norm_num",
          "ring"
        ],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "norm_num",
          "ring"
        ]
      }
    },
    {
      "id": 1856,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9",
      "suggestion": "lemma tendsto_nhds_top_iff {\u03b1 : Type*} {f : Filter \u03b1} (x : \u03b1 \u2192 WithTop \u03b9) :\n    Tendsto x f (\ud835\udcdd \u22a4) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (a : \u03b1) in f, i < x a := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using .of_forall fun _ \u21a6 Subsingleton.elim ..\n  refine nhds_top_basis.tendsto_right_iff.trans ?_\n  rw [\u2190 Set.forall_mem_range (p := (\u2200\u1da0 a in f, \u00b7 < x a)), WithTop.range_coe]\n  simp\n",
      "body": "You can avoid the `Nonempty` hypothesis and simplify the proof like so:\n```suggestion\nlemma tendsto_nhds_top_iff {\u03b1 : Type*} {f : Filter \u03b1} (x : \u03b1 \u2192 WithTop \u03b9) :\n    Tendsto x f (\ud835\udcdd \u22a4) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (a : \u03b1) in f, i < x a := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using .of_forall fun _ \u21a6 Subsingleton.elim ..\n  refine nhds_top_basis.tendsto_right_iff.trans ?_\n  rw [\u2190 Set.forall_mem_range (p := (\u2200\u1da0 a in f, \u00b7 < x a)), WithTop.range_coe]\n  simp\n```",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 1858,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9\n\nend WithTop",
      "suggestion": "",
      "body": "If you add this lemma (in the `WithTop` namespace):\n```lean\nlemma tendsto_coe_atTop [NoMaxOrder \u03b9] :\n    Tendsto ((\u2191) : \u03b9 \u2192 WithTop \u03b9) atTop (\ud835\udcdd \u22a4) := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using Subsingleton.elim ..\n  rw [tendsto_nhds_top_iff]\n  intro i\n  filter_upwards [atTop_basis_Ioi.mem_of_mem (i := i) trivial]\n  simp\n```\nThen you can prove the highlighted lemma as simply as:\n```lean\ntheorem Tendsto.tendsto_withTop_atTop_nhds_top {\u03b9 : Type*}\n    [Nonempty \u03b9] [LinearOrder \u03b9] [",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "WithTop",
          "end",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 1864,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "        obtain \u27e8i, hi\u27e9 : \u2203 i, m i > n i := by\n          by_contra! hc\n          exact h_le (Finsupp.coe_le_coe.mp hc)\n",
      "body": "```suggestion\n        obtain \u27e8i, hi\u27e9 : \u2203 i, m i > n i := by\n          by_contra! hc\n          exact h_le (Finsupp.coe_le_coe.mp hc)\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain"
        ],
        "body_tactics": [
          "exact",
          "obtain"
        ],
        "new_tactics": [
          "exact",
          "obtain"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1865,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, n = p \u2022 m :=\n      \u27e8Finsupp.equivFunOnFinite.symm fun i => n i / p, by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, n = p \u2022 m :=\n      \u27e8Finsupp.equivFunOnFinite.symm fun i => n i / p, by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1867,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "@[simp]\ntheorem expand_eq_expand {\u03c6 : MvPolynomial \u03c3 R} :\n",
      "body": "Do you want to make this a simp lemma?\n```suggestion\n@[simp]\ntheorem expand_eq_expand {\u03c6 : MvPolynomial \u03c3 R} :\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1868,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8i, hi\u27e9 := h\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8i, hi\u27e9 := h\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1869,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8i, hi\u27e9 := h\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8i, hi\u27e9 := h\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1870,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, d = p \u2022 m := \u27e8Finsupp.equivFunOnFinite.symm fun i => d i / p,\n      by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, d = p \u2022 m := \u27e8Finsupp.equivFunOnFinite.symm fun i => d i / p,\n      by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n```\nAre there more examples of this pattern?",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1873,
      "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
      "suggestion": "/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced := by\n  rw [IsSimplyLaced, IsSimplyLaced, Pairwise, Pairwise, forall_comm]\n  aesop\n\ntheorem isSimplyLaced_A (n : \u2115) : IsSimplyLaced (A n) := by\n  intro i j h\n  simp only [A, of_apply]\n  grind\n\ntheorem isSimplyLaced_D (n : \u2115) : IsSimplyLaced (D n) := by\n  intro i j h\n  simp only [D, of_apply]\n  grind\n\ntheorem isSimplyLaced_E\u2086 : IsSimplyLaced E\u2086 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2086] at h \u22a2\n\ntheorem isSimplyLaced_E\u2087 : IsSimplyLaced E\u2087 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2087] at h \u22a2\n\ntheorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2\n",
      "body": "I've never seen being symmetric as a definition of begin simply laced before. Where does this come from?\n\nI would have expected something like:\n```suggestion\n/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced :",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "decide",
          "simp"
        ],
        "suggestion_tactics": [
          "aesop",
          "grind",
          "fin_cases",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "aesop",
          "grind",
          "have",
          "fin_cases",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "aesop",
          "grind",
          "fin_cases",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "decide"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "decide",
          "transpose",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1887,
      "before_code": "(\u22a4 : NonUnitalSubalgebra R A).toNonUnitalSubring = \u22a4 :=\n  rfl\n\n@[simp]\ntheorem toSubmodule_eq_top {S : NonUnitalSubalgebra R A} : S.toSubmodule = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toSubmodule'.injective.eq_iff' top_toSubmodule\n\n@[simp]\ntheorem toNonUnitalSubsemiring_eq_top {S : NonUnitalSubalgebra R A} :\n    S.toNonUnitalSubsemiring = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toNonUnitalSubsemiring_injective.eq_iff' top_toNonUnitalSubsemiring\n\n@[simp]\ntheorem to_subring_eq_top {R A : Type*} [CommRing R] [Ring A] [Algebra R A]",
      "suggestion": "\r\ntheorem toNonUnitalSubring_eq_top {R A : Type*} [CommRing R] [Ring A] [Algebra R A]\r\n",
      "body": "```suggestion\r\ntheorem toNonUnitalSubring_eq_top {R A : Type*} [CommRing R] [Ring A] [Algebra R A]\r\n```",
      "path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean",
      "tags": {
        "before_tactics": [
          "ring",
          "simp"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "Ring",
          "Type",
          "toSubmodule_eq_top",
          "toSubmodule",
          "top_toSubmodule",
          "injective",
          "toNonUnitalSubsemiring_eq_top",
          "top_toNonUnitalSubsemiring",
          "toNonUnitalSubsemiring",
          "CommRing",
          "NonUnitalSubalgebra",
          "toNonUnitalSubsemiring_injective",
          "simp",
          "rfl",
          "to_subring_eq_top",
          "theorem",
          "toNonUnitalSubring",
          "eq_iff",
          "Algebra"
        ]
      }
    },
    {
      "id": 1891,
      "before_code": "(\u22a4 : NonUnitalSubalgebra R A).toNonUnitalSubring = \u22a4 :=\n  rfl\n\n@[simp]\ntheorem toSubmodule_eq_top {S : NonUnitalSubalgebra R A} : S.toSubmodule = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toSubmodule'.injective.eq_iff' top_toSubmodule\n\n@[simp]\ntheorem toNonUnitalSubsemiring_eq_top {S : NonUnitalSubalgebra R A} :\n    S.toNonUnitalSubsemiring = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toNonUnitalSubsemiring_injective.eq_iff' top_toNonUnitalSubsemiring",
      "suggestion": "\r\n-- This lemma isn't simp because `NonUnitalSubalgebra.toSubmodule` is a \"fake\" projection,\r\n-- which is syntactically a constructor application.\r\n",
      "body": "Then it is proved by `simp only [Submodule.mk_eq_top, NonUnitalSubsemiring.toAddSubmonoid_eq_top, toNonUnitalSubsemiring_eq_top]`. I guess I should have said\r\n```suggestion\r\n-- This lemma isn't simp because `NonUnitalSubalgebra.toSubmodule` is a \"fake\" projection,\r\n-- which is syntactically a constructor application.\r\n```\r\ninstead",
      "path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "constructor",
          "simp"
        ],
        "body_tactics": [
          "have",
          "constructor",
          "simp"
        ],
        "new_tactics": [
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "use_simp"
        ],
        "keywords": [
          "toNonUnitalSubsemiring",
          "toSubmodule",
          "theorem",
          "top_toSubmodule",
          "NonUnitalSubalgebra",
          "toNonUnitalSubring",
          "eq_iff",
          "toNonUnitalSubsemiring_injective",
          "toSubmodule_eq_top",
          "simp",
          "rfl",
          "injective",
          "toNonUnitalSubsemiring_eq_top",
          "top_toNonUnitalSubsemiring"
        ]
      }
    },
    {
      "id": 1893,
      "before_code": "theorem mul_natCast_floor_div_cancel {n : \u2115} (hn : n \u2260 0) (a : R) : \u230aa * n\u230b / n = \u230aa\u230b := by\n  simpa using mul_cast_floor_div_cancel_of_pos (n := n) (by positivity) a",
      "suggestion": "\r\ntheorem mul_fract_eq_one_iff_exists_int {x : R} {k : R} (hk : 1 < k) :\r\n    k * fract x = 1 \u2194 \u2203 n : \u2124, k * x = k * n + 1 := by\r\n  rw [fract, mul_sub, sub_eq_iff_eq_add']\r\n  refine \u27e8fun hx \u21a6 \u27e8\u230ax\u230b, hx\u27e9, ?_\u27e9\r\n  rintro \u27e8n, hn\u27e9\r\n  convert hn\r\n  have hk0 : 0 < (k : R) := zero_le_one.trans_lt hk\r\n  rw [floor_eq_iff, \u2190 mul_le_mul_iff_right\u2080 hk0, \u2190 mul_lt_mul_iff_right\u2080 hk0, hn]\r\n  simp [mul_add, hk]\r\n",
      "body": "Better I think as\r\n```suggestion\r\ntheorem mul_fract_eq_one_iff_exists_int {x : R} {k : R} (hk : 1 < k) :\r\n    k * fract x = 1 \u2194 \u2203 n : \u2124, k * x = k * n + 1 := by\r\n  rw [fract, mul_sub, sub_eq_iff_eq_add']\r\n  refine \u27e8fun hx \u21a6 \u27e8\u230ax\u230b, hx\u27e9, ?_\u27e9\r\n  rintro \u27e8n, hn\u27e9\r\n  convert hn\r\n  have hk0 : 0 < (k : R) := zero_le_one.trans_lt hk\r\n  rw [floor_eq_iff, \u2190 mul_le_mul_iff_right\u2080 hk0, \u2190 mul_lt_mul_iff_right\u2080 hk0, hn]\r\n  simp [mul_add, hk]\r\n```",
      "path": "Mathlib/Algebra/Order/Floor/Ring.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "positivity"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have",
          "rw",
          "refine"
        ],
        "removed_tactics": [
          "simpa",
          "positivity"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mul_cast_floor_div_cancel_of_pos",
          "positivity",
          "theorem",
          "simpa",
          "mul_natCast_floor_div_cancel",
          "using"
        ]
      }
    },
    {
      "id": 1899,
      "before_code": "protected lemma Preconnected.mono {G G' : SimpleGraph V} (h : G \u2264 G') (hG : G.Preconnected) :\n    G'.Preconnected := fun u v => (hG u v).mono h",
      "suggestion": "  aesop (add simp Preconnected)\n",
      "body": "```suggestion\n  aesop (add simp Preconnected)\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Connected.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "lemma",
          "mono",
          "protected",
          "Preconnected",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1900,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\n  intro u c hc\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\n    have eneq : e \u2260 s(x,y) := fun h => h_bridge.2 c hc (h \u25b8 he)\n    simpa [eneq] using Walk.edges_subset_edgeSet c he)\n",
      "body": "Just style nits. The only one worth highlighting is that the pattern `apply my_lemma.mp` is almost always a synonym for `rw [my_lemma]`:\n```suggestion\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\n  intro u c hc\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\n    have eneq : e \u2260 s(x,y) := fun h => h_bridge.2 c hc (h \u25b8 he)\n    simpa [eneq] using Walk.edges_subset_edgeSet c he)\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "have",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "have",
          "intro"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1901,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "/-- A subgraph is maximal acyclic iff its reachability relation agrees with the larger graph. -/\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G \u2227 F.IsAcyclic) :\n    Maximal (fun H => H \u2264 G \u2227 H.IsAcyclic) F \u2194 F.Reachable = G.Reachable := by\n  refine \u27e8reachable_eq_of_maximal_isAcyclic F, fun h \u21a6 ?_\u27e9\n",
      "body": "We don't need to have both `maximal_isAcyclic_of_reachable_eq` and `maximal_isAcyclic_iff_reachable_eq` since the latter dominates the former so let's just collapse them together like this:\n```suggestion\n/-- A subgraph is maximal acyclic iff its reachability relation agrees with the larger graph. -/\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G \u2227 F.IsAcyclic) :\n    Maximal (fun H => H \u2264 G \u2227 H.IsAcyclic) F \u2194 F.Reachable = G.Reachable := by\n  refine \u27e8reachable_eq_of_ma",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine",
          "have"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1902,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "@[simp] theorem maximal_isAcyclic_iff_isTree [Nonempty V] {T : SimpleGraph V} :\n",
      "body": "```suggestion\n@[simp] theorem maximal_isAcyclic_iff_isTree [Nonempty V] {T : SimpleGraph V} :\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1903,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  simp [\u2190 connected_top.maximal_le_isAcyclic_iff_isTree le_top]\n",
      "body": "```suggestion\n  simp [\u2190 connected_top.maximal_le_isAcyclic_iff_isTree le_top]\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1904,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  have : Nonempty V := hG.nonempty\n  refine \u27e8fun h \u21a6 \u27e8\u27e8fun u v \u21a6 ?_\u27e9, h.1.2\u27e9, fun hT' \u21a6 ?_\u27e9\n  \u00b7 rw [G.reachable_eq_of_maximal_isAcyclic T h]\n    exact hG.preconnected u v\n  \u00b7 rw [maximal_isAcyclic_iff_reachable_eq \u27e8hT, hT'.IsAcyclic\u27e9]\n    replace hT' : T.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hT'.isConnected.preconnected\n    replace hG : G.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hG.preconnected\n    rw [hT', hG]\n",
      "body": "What you have is probably fine but I worry that the call to `grind` is maybe a bit brittle so let's try:\n```suggestion\n  have : Nonempty V := hG.nonempty\n  refine \u27e8fun h \u21a6 \u27e8\u27e8fun u v \u21a6 ?_\u27e9, h.1.2\u27e9, fun hT' \u21a6 ?_\u27e9\n  \u00b7 rw [G.reachable_eq_of_maximal_isAcyclic T h]\n    exact hG.preconnected u v\n  \u00b7 rw [maximal_isAcyclic_iff_reachable_eq \u27e8hT, hT'.IsAcyclic\u27e9]\n    replace hT' : T.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hT'.isConnected.preconnected\n    replace hG : G",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "exact",
          "refine",
          "rw",
          "have"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "rw"
        ],
        "new_tactics": [
          "have",
          "rw",
          "refine"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1905,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "",
      "body": "This looks redundant:\n```suggestion\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1906,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  obtain \u27e8\u27e8hF : F \u2264 G, hF' : F.IsAcyclic\u27e9, h\u27e9 := by simpa [Maximal] using h\n  ext u v\n  refine \u27e8fun h \u21a6 h.mono hF, ?_\u27e9\n  contrapose! h\n  obtain \u27e8\u27e8p : G.Walk u v\u27e9, h : \u00ac F.Reachable u v\u27e9 := h\n  let s : Set V := F.connectedComponentMk u\n  have hus : u \u2208 s := ConnectedComponent.connectedComponentMk_mem\n  have hvs : v \u2209 s := h \u2218 (F.connectedComponentMk u).reachable_of_mem_supp hus\n  obtain \u27e8\u27e8\u27e8u', v'\u27e9, huv : G.Adj u' v'\u27e9, -, hu : u' \u2208 s, hv : v' \u2209 s\u27e9 :=\n    p.exists_boundary_dart s hus hvs\n  suffices (F \u2294 fromEdgeSet {s(u', v')}).IsAcyclic by\n    refine \u27e8F \u2294 fromEdgeSet {s(u', v')}, ?_, this, le_sup_left, ?_\u27e9\n    \u00b7 have : G.Adj v' u' := G.symm huv\n      simp only [sup_le_iff, le_iff_adj, fromEdgeSet_adj, Set.mem_singleton_iff, Sym2.eq,\n        Sym2.rel_iff'] at hF \u22a2\n      grind\n    \u00b7 rw [le_iff_adj]\n      push_neg\n      refine \u27e8u', v', ?_, fun hc \u21a6 ?_\u27e9\n      \u00b7 simpa using Or.inr huv.ne\n      \u00b7 have := (F.connectedComponentMk u).mem_supp_congr_adj hc\n        grind\n  suffices \u00ac F.Reachable u'",
      "body": "The following is a slight golf. I was not trying to make it shorter though: I was trying to make it slightly more idiomatic and readable. I think what I've got is still not great but is acceptable (as was yours already). Two minor points I highlight are:\n\n- I've added various redundant type ascriptions (e.g., to the `obtain`s). These aid readability for a human.\n- I've use the `ext` tactic rather than directly calling the underlying very low-level `funext`, `propext`\n\nI also note that [Maximal](",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "funext",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "remove_redundant",
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1908,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "\r\n    (G \u2294 fromEdgeSet {s(x, y)}).IsAcyclic \u2194 IsAcyclic G := by\r\n  refine \u27e8fun h \u21a6 h.anti le_sup_left, fun hG \u21a6 ?_\u27e9\r\n  have x_neq_y : x \u2260 y := fun c => (c \u25b8 hxy) (Reachable.refl y)\r\n  have h_add_remove : (G \u2294 fromEdgeSet {s(x, y)}) \\ fromEdgeSet {s(x, y)} = G := by\r\n    simpa using fun h => hxy h.reachable\r\n  have h_bridge : (G \u2294 fromEdgeSet {s(x, y)}).IsBridge s(x, y) := by\r\n    simpa [isBridge_iff, x_neq_y, h_add_remove]\r\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\r\n  intro u c hc\r\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\r\n    have eneq : e \u2260 s(x, y) := fun h => h_bridge.2 c hc (h \u25b8 he)\r\n",
      "body": "```suggestion\r\n    (G \u2294 fromEdgeSet {s(x, y)}).IsAcyclic \u2194 IsAcyclic G := by\r\n  refine \u27e8fun h \u21a6 h.anti le_sup_left, fun hG \u21a6 ?_\u27e9\r\n  have x_neq_y : x \u2260 y := fun c => (c \u25b8 hxy) (Reachable.refl y)\r\n  have h_add_remove : (G \u2294 fromEdgeSet {s(x, y)}) \\ fromEdgeSet {s(x, y)} = G := by\r\n    simpa using fun h => hxy h.reachable\r\n  have h_bridge : (G \u2294 fromEdgeSet {s(x, y)}).IsBridge s(x, y) := by\r\n    simpa [isBridge_iff, x_neq_y, h_add_remove]\r\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1912,
      "before_code": "open WithZeroMulInt\n\nvariable {R K} in",
      "suggestion": "  exact h_mono <| v.intValuation.map_add x y\n",
      "body": "There are two spaces between `map_add` and `x`. This should be a single space for consistency with the rest of the codebase.\n```suggestion\n  exact h_mono <| v.intValuation.map_add x y\n```",
      "path": "Mathlib/RingTheory/DedekindDomain/AdicValuation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "open",
          "WithZeroMulInt",
          "variable"
        ]
      }
    },
    {
      "id": 1941,
      "before_code": "rcases h\u03be with \u27e8i, hin, hi, H\u27e9\n    exact \u27e8i, \u27e8hin, hi.symm\u27e9, H\u27e9",
      "suggestion": "\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n",
      "body": "```suggestion\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n```\r\nI think it\u2019s better practice to inline the \"haves\" when in term mode with a non-prop goal like this.\r\n\r\nalso, added the `@[simps! apply_coe]` adds the lemma saying that you\u2019re i",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact",
          "cases"
        ],
        "topics": [],
        "transforms": [
          "term_mode",
          "use_grind"
        ],
        "keywords": [
          "exact",
          "rcases",
          "symm",
          "hin"
        ]
      }
    },
    {
      "id": 1942,
      "before_code": "(x * y).leadingCoeff = x.leadingCoeff * y.leadingCoeff := by\n  simp only [leadingCoeff_eq, order_mul_of_nonzero h, coeff_mul_order_add_order]",
      "suggestion": "\r\n  apply leadingCoeff_mul_of_ne_zero\r\n",
      "body": "If you want to fix it, this should be\r\n```suggestion\r\n  apply leadingCoeff_mul_of_ne_zero\r\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "order_mul_of_nonzero",
          "leadingCoeff_eq",
          "simp",
          "leadingCoeff",
          "coeff_mul_order_add_order",
          "only"
        ]
      }
    },
    {
      "id": 1946,
      "before_code": "namespace Filtration",
      "suggestion": "@[simp] lemma rightCont_self (\ud835\udcd5 : Filtration \u03b9 m) : \ud835\udcd5\u208a\u208a = \ud835\udcd5\u208a := by\n",
      "body": "```suggestion\n@[simp] lemma rightCont_self (\ud835\udcd5 : Filtration \u03b9 m) : \ud835\udcd5\u208a\u208a = \ud835\udcd5\u208a := by\n```\nmaybe?",
      "path": "Mathlib/Probability/Process/Filtration.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Filtration",
          "namespace"
        ]
      }
    },
    {
      "id": 1967,
      "before_code": "alias \u27e8_, IsIdempotentElem.ext\u27e9 := IsIdempotentElem.ext_iff\n\ntheorem IsIdempotentElem.range_eq_ker {E : Type*} [AddCommGroup E] [Module S E]\n    {p : E \u2192\u2097[S] E} (hp : IsIdempotentElem p) : LinearMap.range p = LinearMap.ker (1 - p) :=\n  le_antisymm\n    (LinearMap.range_le_ker_iff.mpr hp.one_sub_mul_self)\n    fun x hx \u21a6 \u27e8x, by simpa [sub_eq_zero, eq_comm (a := x)] using hx\u27e9\n\nopen LinearMap in\ntheorem IsIdempotentElem.ker_eq_range {E : Type*} [AddCommGroup E] [Module S E]\n    {p : E \u2192\u2097[S] E} (hp : IsIdempotentElem p) : LinearMap.ker p = LinearMap.range (1 - p) := by\n  simpa using hp.one_sub.range_eq_ker.symm",
      "suggestion": "\r\n  simpa using hp.one_sub.range_eq_ker_one_sub.symm\r\n",
      "body": "```suggestion\r\n  simpa using hp.one_sub.range_eq_ker_one_sub.symm\r\n```",
      "path": "Mathlib/LinearAlgebra/Projection.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "range_eq_ker",
          "ker_eq_range",
          "mpr",
          "Module",
          "le_antisymm",
          "Type",
          "open",
          "alias",
          "eq_comm",
          "symm",
          "ext",
          "LinearMap",
          "IsIdempotentElem",
          "AddCommGroup",
          "one_sub_mul_self",
          "ker",
          "range",
          "sub_eq_zero",
          "range_le_ker_iff",
          "ext_iff",
          "theorem",
          "one_sub",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 1977,
      "before_code": "(x y : R\u27e6\u0393\u27e7) : (x * y).cardSupp \u2264 x.cardSupp * y.cardSupp :=\n  (mk_le_mk_of_subset (support_mul_subset ..)).trans mk_add_le",
      "suggestion": "\r\n  obtain rfl | hx := eq_or_ne x 0; \u00b7 simp\r\n",
      "body": "```suggestion\r\n  obtain rfl | hx := eq_or_ne x 0; \u00b7 simp\r\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Cardinal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support_mul_subset",
          "mk_le_mk_of_subset",
          "trans",
          "cardSupp",
          "mk_add_le"
        ]
      }
    },
    {
      "id": 1978,
      "before_code": "(x y : R\u27e6\u0393\u27e7) : (x * y).cardSupp \u2264 x.cardSupp * y.cardSupp :=\n  (mk_le_mk_of_subset (support_mul_subset ..)).trans mk_add_le",
      "suggestion": "    simpa [pow_succ] using (cardSupp_mul_le ..).trans <| mul_le_mul_left IH _\n",
      "body": "```suggestion\n    simpa [pow_succ] using (cardSupp_mul_le ..).trans <| mul_le_mul_left IH _\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Cardinal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "support_mul_subset",
          "mk_le_mk_of_subset",
          "trans",
          "cardSupp",
          "mk_add_le"
        ]
      }
    },
    {
      "id": 1979,
      "before_code": "Cat.Hom.inv_hom_id_toNatTrans_app]\n    simp [D.hom_self _ _ rfl]",
      "suggestion": "        simp_all [map_eq_pullHom] }\n",
      "body": "```suggestion\n        simp_all [map_eq_pullHom] }\n```",
      "path": "Mathlib/CategoryTheory/Sites/Descent/DescentData.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "inv_hom_id_toNatTrans_app",
          "Cat",
          "Hom",
          "simp",
          "rfl",
          "hom_self"
        ]
      }
    },
    {
      "id": 2022,
      "before_code": "section shift_invariance\n\nvariable {\ud835\udd5c F} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\n\n/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (s + z)) = fun t \u21a6 iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (z + s)) = fun t \u21a6 iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s",
      "suggestion": "  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n",
      "body": "```suggestion\n  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "funext",
          "induction",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "funext",
          "induction",
          "simp"
        ],
        "topics": [
          "norm",
          "list",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "funext",
          "lemma",
          "deriv_comp_add_const",
          "succ",
          "iterated",
          "iteratedDeriv_succ",
          "commutes",
          "section",
          "right",
          "iteratedDeriv_comp_const_add",
          "NormedAddCommGroup",
          "constant",
          "variable",
          "derivative",
          "shift_invariance",
          "induction",
          "simp",
          "iteratedDeriv_comp_add_const",
          "zero",
          "only",
          "iteratedDeriv",
          "NontriviallyNormedField",
          "deriv_comp_const_add",
          "function",
          "left",
          "NormedSpace",
          "simpa",
          "iteratedDeriv_zero",
          "shifting",
          "using"
        ]
      }
    },
    {
      "id": 2025,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "\r\n    conv_rhs => rw [K.norm_sq_eq_add_norm_sq_starProjection]\r\n    simp [starProjection_apply, orthogonalProjection_eq_linearProjOfIsCompl]\r\n",
      "body": "if you change the definition like I suggested above (and add the suggested lemmas), then the proof of this would be:\r\n```suggestion\r\n    conv_rhs => rw [K.norm_sq_eq_add_norm_sq_starProjection]\r\n    simp [starProjection_apply, orthogonalProjection_eq_linearProjOfIsCompl]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2033,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "@[simp]\ntheorem fst_orthogonalDecomposition_apply :\n",
      "body": "```suggestion\n@[simp]\ntheorem fst_orthogonalDecomposition_apply :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2034,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "@[simp]\ntheorem snd_orthogonalDecomposition_apply :\n",
      "body": "```suggestion\n@[simp]\ntheorem snd_orthogonalDecomposition_apply :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2037,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "@[simp]\ntheorem fstL_comp_coe_orthogonalDecomposition :\n",
      "body": "```suggestion\n@[simp]\ntheorem fstL_comp_coe_orthogonalDecomposition :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2038,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "@[simp]\ntheorem sndL_comp_coe_orthogonalDecomposition :\n",
      "body": "```suggestion\n@[simp]\ntheorem sndL_comp_coe_orthogonalDecomposition :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2042,
      "before_code": "sub_add_cancel_right, map_add, neg_add_rev]\n    abel_nf",
      "suggestion": "    rw [\u2190 map_add, AddMemClass.mk_add_mk, EquivLike.apply_eq_iff_eq, Subtype.mk_eq_mk, map_add,\n      map_add, add_sub_add_comm]\n",
      "body": "Style nit:\n```suggestion\n    rw [\u2190 map_add, AddMemClass.mk_add_mk, EquivLike.apply_eq_iff_eq, Subtype.mk_eq_mk, map_add,\n      map_add, add_sub_add_comm]\n```",
      "path": "Mathlib/Algebra/Lie/Extension.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "neg_add_rev",
          "map_add",
          "abel_nf",
          "sub_add_cancel_right"
        ]
      }
    },
    {
      "id": 2043,
      "before_code": "sub_add_cancel_right, map_add, neg_add_rev]\n    abel_nf",
      "suggestion": "    rw [RingHom.id_apply, \u2190 map_smul, EquivLike.apply_eq_iff_eq, SetLike.mk_smul_of_tower_mk,\n      Subtype.mk_eq_mk, LinearMap.map_smul_of_tower, smul_sub, LinearMap.map_smul_of_tower]\n",
      "body": "```suggestion\n    rw [RingHom.id_apply, \u2190 map_smul, EquivLike.apply_eq_iff_eq, SetLike.mk_smul_of_tower_mk,\n      Subtype.mk_eq_mk, LinearMap.map_smul_of_tower, smul_sub, LinearMap.map_smul_of_tower]\n```",
      "path": "Mathlib/Algebra/Lie/Extension.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "neg_add_rev",
          "map_add",
          "abel_nf",
          "sub_add_cancel_right"
        ]
      }
    },
    {
      "id": 2046,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "theorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 := by\n  rw [Int.floor_eq_iff]\n  grind [pi_gt_three, pi_lt_four]\n",
      "body": "I don't have a strong preference. But would this be a middle ground?\n```suggestion\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 := by\n  rw [Int.floor_eq_iff]\n  grind [pi_gt_three, pi_lt_four]\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "rw"
        ],
        "body_tactics": [
          "grind",
          "rw",
          "have"
        ],
        "new_tactics": [
          "grind",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 2047,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n",
      "body": "We can also\r\n```suggestion\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": []
      }
    },
    {
      "id": 2053,
      "before_code": "end LinearMap\n\nnamespace Equiv\nvariable {R A B : Type*} [CommSemiring R]",
      "suggestion": "\r\nvariable {R A A' B B' C C' : Type*}\r\nvariable [CommSemiring R] [AddCommMonoid A'] [AddCommMonoid B'] [AddCommMonoid C']\r\nvariable [Module R A'] [Module R B'] [Module R C']\r\n",
      "body": "nit:\r\n```suggestion\r\nvariable {R A A' B B' C C' : Type*}\r\nvariable [CommSemiring R] [AddCommMonoid A'] [AddCommMonoid B'] [AddCommMonoid C']\r\nvariable [Module R A'] [Module R B'] [Module R C']\r\n```\r\nfor slightly more semantic line breaks",
      "path": "Mathlib/LinearAlgebra/TensorProduct/Associator.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "end",
          "LinearMap",
          "variable",
          "Type",
          "Equiv",
          "CommSemiring",
          "namespace"
        ]
      }
    },
    {
      "id": 2055,
      "before_code": "linear_combination (norm := (push_cast; ring_nf))\n    h\u2081 + (n + 2) * h\u2082",
      "suggestion": "\r\n  linear_combination (norm := (push_cast; ring_nf)) h\r\n",
      "body": "```suggestion\r\n  linear_combination (norm := (push_cast; ring_nf)) h\r\n```\r\nI personally find this line break a bit weird but if you are attached to this style I don't particular want to block this PR because of it.",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring_nf",
          "push_cast"
        ],
        "suggestion_tactics": [
          "ring_nf",
          "push_cast"
        ],
        "body_tactics": [
          "ring_nf",
          "push_cast"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "push_cast",
          "ring_nf",
          "linear_combination",
          "norm"
        ]
      }
    },
    {
      "id": 2069,
      "before_code": "end card",
      "suggestion": "\r\n",
      "body": "I assume this is test code, and can be removed?\r\n```suggestion\r\n```",
      "path": "Mathlib/Order/Interval/Finset/Fin.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "end",
          "card"
        ]
      }
    },
    {
      "id": 2074,
      "before_code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  \u00b7 exact absurd hf <| h _ _ hxy\n  \u00b7 rfl\n  \u00b7 exact absurd hf.symm <| h _ _ hxy",
      "suggestion": "\r\n  exact injective_of_eq_imp_le f fun {x y} \u21a6\r\n    not_lt (\u03b1 := \u03b1) |>.eq \u25b8 imp_not_comm.mp (eq_comm.eq \u25b8 h y x)\r\n",
      "body": "if you move the new lemma before this one, you could do\r\n```suggestion\r\n  exact injective_of_eq_imp_le f fun {x y} \u21a6\r\n    not_lt (\u03b1 := \u03b1) |>.eq \u25b8 imp_not_comm.mp (eq_comm.eq \u25b8 h y x)\r\n```\r\nor\r\n```suggestion\r\n  grind [injective_of_eq_imp_le]\r\n```",
      "path": "Mathlib/Order/Monotone/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lt_trichotomy",
          "Injective",
          "symm",
          "theorem",
          "exact",
          "rcases",
          "absurd",
          "injective_of_lt_imp_ne",
          "LinearOrder",
          "intro",
          "hxy",
          "rfl"
        ]
      }
    },
    {
      "id": 2075,
      "before_code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  \u00b7 exact absurd hf <| h _ _ hxy\n  \u00b7 rfl\n  \u00b7 exact absurd hf.symm <| h _ _ hxy",
      "suggestion": "\r\n  exact Function.Injective.of_eq_imp_le _ (le_of_not_gt <| Imp.swap.mp (h _ _) \u00b7.symm)\r\n",
      "body": "I know, I had this before:\r\n```suggestion\r\n  exact Function.Injective.of_eq_imp_le _ (le_of_not_gt <| Imp.swap.mp (h _ _) \u00b7.symm)\r\n```\r\nthen I realized I can\r\n```suggestion\r\n  exact Function.Injective.of_eq_imp_le _ <| by grind\r\n```\r\nand then\r\n```suggestion\r\n  grind [Function.Injective.of_eq_imp_le]\r\n```\r\nand finally the current version, which doesn't need the new theorem.\r\nI don't think that going back to the explicit term is better.",
      "path": "Mathlib/Order/Monotone/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lt_trichotomy",
          "Injective",
          "symm",
          "theorem",
          "exact",
          "rcases",
          "absurd",
          "injective_of_lt_imp_ne",
          "LinearOrder",
          "intro",
          "hxy",
          "rfl"
        ]
      }
    },
    {
      "id": 2076,
      "before_code": "(SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n@[to_additive]\nlemma closure_pow_le : \u2200 {n}, n \u2260 0 \u2192 closure (s ^ n) \u2264 closure s\n  | 1, _ => by simp\n  | n + 2, _ =>",
      "suggestion": "\r\n  | 0 => by simp_all\r\n",
      "body": "```suggestion\r\n  | 0 => by simp_all\r\n```",
      "path": "Mathlib/Algebra/Group/Subgroup/Pointwise.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "lemma",
          "SetLike",
          "le_def",
          "subset_closure",
          "closure_pow_le",
          "closure",
          "le_sup_right",
          "simp"
        ]
      }
    },
    {
      "id": 2077,
      "before_code": "le_antisymm ((packingNumber_le_encard_self {x}).trans_eq (by simp)) <|\n    le_iSup_of_le {x} <| le_iSup_of_le (by simp) <| le_iSup_of_le (by simp) (by simp)",
      "suggestion": "lemma minimalCover_subset : minimalCover \u03b5 A \u2286 A := by\n  grind [minimalCover]\n",
      "body": "This and the next three lemmas can be proven with this, although for it to work on `finite_minimalCover`, you have to add\n```lean\nattribute [grind .] finite_empty\n```\nbut I think we should do that anyway.\n```suggestion\nlemma minimalCover_subset : minimalCover \u03b5 A \u2286 A := by\n  grind [minimalCover]\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "le_iSup_of_le",
          "trans_eq",
          "le_antisymm",
          "simp",
          "packingNumber_le_encard_self"
        ]
      }
    },
    {
      "id": 2078,
      "before_code": "le_antisymm ((packingNumber_le_encard_self {x}).trans_eq (by simp)) <|\n    le_iSup_of_le {x} <| le_iSup_of_le (by simp) <| le_iSup_of_le (by simp) (by simp)",
      "suggestion": "lemma maximalSeparatedSet_subset : maximalSeparatedSet \u03b5 A \u2286 A := by\n  by grind [maximalSeparatedSet]\n",
      "body": "This and the next two lemmas can be proven with this, although for it to work on `isSeparated_maximalSeparatedSet`, you have to add\n```lean\nattribute [grind .] IsSeparated.empty\n```\nbut I think we should do that anyway.\n\n```suggestion\nlemma maximalSeparatedSet_subset : maximalSeparatedSet \u03b5 A \u2286 A := by\n  by grind [maximalSeparatedSet]\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "le_iSup_of_le",
          "trans_eq",
          "le_antisymm",
          "simp",
          "packingNumber_le_encard_self"
        ]
      }
    },
    {
      "id": 2081,
      "before_code": "\u00b7 exact hf' x\n      \u00b7 simpa [edist_comm, hxy] using hf' y",
      "suggestion": "  by_cases! h_top : packingNumber \u03b5 A \u2260 \u22a4\n  \u00b7 rw [\u2190 encard_maximalSeparatedSet h_top]\n    exact isCover_maximalSeparatedSet h_top |>.coveringNumber_le_encard maximalSeparatedSet_subset\n  \u00b7 simp [h_top]\n",
      "body": "We now have `by_cases!` to automatically push your negations in the alternate branch. And we have this nice `IsCover.coveringNumber_le_encard` lemma, we might as well use it. :smiley:\n```suggestion\n  by_cases! h_top : packingNumber \u03b5 A \u2260 \u22a4\n  \u00b7 rw [\u2190 encard_maximalSeparatedSet h_top]\n    exact isCover_maximalSeparatedSet h_top |>.coveringNumber_le_encard maximalSeparatedSet_subset\n  \u00b7 simp [h_top]\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "edist_comm",
          "exact",
          "simpa",
          "hxy",
          "using"
        ]
      }
    },
    {
      "id": 2082,
      "before_code": "\u00b7 exact hf' x\n      \u00b7 simpa [edist_comm, hxy] using hf' y",
      "suggestion": "  rcases Set.eq_empty_or_nonempty A with (rfl | h_nonempty)\n  \u00b7 simp\n",
      "body": "```suggestion\n  rcases Set.eq_empty_or_nonempty A with (rfl | h_nonempty)\n  \u00b7 simp\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "simpa",
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "edist_comm",
          "exact",
          "simpa",
          "hxy",
          "using"
        ]
      }
    },
    {
      "id": 2087,
      "before_code": "rw [stdPart, dif_pos hx, \u2190 OrderRingHom.comp_apply, \u2190 OrderRingHom.comp_assoc,\n    OrderRingHom.comp_apply, OrderRingHom.apply_eq_self]",
      "suggestion": "    exact h\n",
      "body": "```suggestion\n    exact h\n```\nI think it is better to be explicit here, especially when it is not syntactically eq",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "stdPart",
          "OrderRingHom",
          "dif_pos",
          "comp_apply",
          "comp_assoc",
          "apply_eq_self"
        ]
      }
    },
    {
      "id": 2088,
      "before_code": "rw [stdPart, dif_pos hx, \u2190 OrderRingHom.comp_apply, \u2190 OrderRingHom.comp_assoc,\n    OrderRingHom.comp_apply, OrderRingHom.apply_eq_self]",
      "suggestion": "\r\n    exact map_nonneg _ h\r\n",
      "body": "```suggestion\r\n    exact map_nonneg _ h\r\n```",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "stdPart",
          "OrderRingHom",
          "dif_pos",
          "comp_apply",
          "comp_assoc",
          "apply_eq_self"
        ]
      }
    },
    {
      "id": 2091,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by simpa [inverse, H] using hf\n  simp_all [Subsingleton.elim f 0]\n",
      "body": "```suggestion\n  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by simpa [inverse, H] using hf\n  simp_all [Subsingleton.elim f 0]\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "body_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 2092,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M\u2082 \u2227 Subsingleton M := by simpa [inverse, H] using hf\r\n",
      "body": "It's the other way around for some reason, or you can add `and_comm` to the `simpa` I guess:\r\n```suggestion\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M\u2082 \u2227 Subsingleton M := by simpa [inverse, H] using hf\r\n```\r\nor\r\n```suggestion\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by aesop\r\n```\r\nor even better (or change the `M` to `M\u2082`):\r\n```suggestion\r\n  have : Subsingleton M := by aesop\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain"
        ],
        "body_tactics": [
          "simpa",
          "obtain",
          "aesop",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "obtain"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 2093,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "\nprotected theorem inverse_inverse (hf : f.IsInvertible) : f.inverse.inverse = f := by\n  rcases hf with \u27e8e, rfl\u27e9\n  simp\n\n",
      "body": "Do you think it is useful to add\n```suggestion\n\nprotected theorem inverse_inverse (hf : f.IsInvertible) : f.inverse.inverse = f := by\n  rcases hf with \u27e8e, rfl\u27e9\n  simp\n\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 2094,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "\r\n@[simp]\r\nprotected theorem inverse_inverse (hf : f.IsInvertible) : f.inverse.inverse = f := by\r\n",
      "body": "simp?\r\n```suggestion\r\n@[simp]\r\nprotected theorem inverse_inverse (hf : f.IsInvertible) : f.inverse.inverse = f := by\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 2117,
      "before_code": "/-- If `S` is a multiplicative subset of a ring `R` and `M` an `R`-module, then\nwe can localize `M` by `S`.\n-/\ndef _root_.LocalizedModule : Type max u v :=\n  Quotient (r.setoid S M)\n\nsection\n\nvariable {M S}\n\n/-- The canonical map sending `(m, s) \u21a6 m/s` -/\ndef mk (m : M) (s : S) : LocalizedModule S M :=\n  Quotient.mk' \u27e8m, s\u27e9\n\ntheorem mk_eq {m m' : M} {s s' : S} : mk m s = mk m' s' \u2194 \u2203 u : S, u \u2022 s' \u2022 m = u \u2022 s \u2022 m' :=\n  Quotient.eq'",
      "suggestion": "  exact congr($(oreEqv_iff_r S M) \u27e8m, s\u27e9 \u27e8m', s'\u27e9)\n",
      "body": "```suggestion\n  exact congr($(oreEqv_iff_r S M) \u27e8m, s\u27e9 \u27e8m', s'\u27e9)\n```\nmaybe?",
      "path": "Mathlib/Algebra/Module/LocalizedModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "congr"
        ],
        "body_tactics": [
          "exact",
          "congr"
        ],
        "new_tactics": [
          "exact",
          "congr"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "multiplicative",
          "mk_eq",
          "Type",
          "section",
          "Quotient",
          "_root_",
          "map",
          "max",
          "can",
          "then",
          "def",
          "LocalizedModule",
          "variable",
          "module",
          "sending",
          "ring",
          "setoid",
          "subset",
          "theorem",
          "localize",
          "canonical"
        ]
      }
    },
    {
      "id": 2120,
      "before_code": "-/\ndef liftOn\u2082 {\u03b1 : Type*} (x y : LocalizedModule S M) (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') : \u03b1 :=\n  Quotient.liftOn\u2082 x y f wd\n\ntheorem liftOn\u2082_mk {\u03b1 : Type*} (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') (m m' : M)\n    (s s' : S) : liftOn\u2082 (mk m s) (mk m' s') f wd = f \u27e8m, s\u27e9 \u27e8m', s'\u27e9 := by\n  convert Quotient.liftOn\u2082_mk f wd _ _\n\ninstance : Zero (LocalizedModule S M) :=\n  \u27e8mk 0 1\u27e9\n\n/-- If `S` contains `0` then the localization at `S` is trivial. -/\ntheorem subsingleton (h : 0 \u2208 S) : Subsingleton (LocalizedModule S M) := by\n  refine \u27e8fun a b \u21a6 ?_\u27e9\n  induction a,b using LocalizedModule.induction_on\u2082\n  exact mk_eq.mpr \u27e8\u27e80, h\u27e9, by simp only [Submonoid.mk_smul, zero_smul]\u27e9\n\n@[simp]\ntheorem zero_mk (s : S) : mk (0 : M) s = 0 :=\n  mk_eq.mpr \u27e81, by rw [one_smul, smul_zero, smul_zero, one_smul]\u27e9\n\ninstance : Add (LocalizedModule S M) where\n  add p1 p2 :=\n    liftOn\u2082 p1 p2 (fun x y => mk (y.2 \u2022 x.1 + x.2 \u2022 y.1) (x.2 * y.2)) <|\n      fun \u27e8m1, s1\u27e9 \u27e8m2, s2\u27e9 \u27e8m1', s1'\u27e9 \u27e8m2', s2'\u27e9 \u27e8u1, hu1\u27e9 \u27e8u2, hu2\u27e9 =>\n          mk_eq.mpr\n            \u27e8u1 * u2, by\n              -- Put everything in the same shape, sorting the terms using `simp`\n              have hu1' := congr_arg ((u2 * s2 * s2') \u2022 \u00b7) hu1\n              have hu2' := congr_arg ((u1 * s1 * s1') \u2022 \u00b7) hu2\n              simp only [smul_add, \u2190 mul_smul, mul_comm,\n                mul_left_comm] at hu1' hu2' \u22a2\n              rw [hu1', hu2']\u27e9\n\ntheorem mk_add_mk {m1 m2 : M} {s1 s2 : S} :\n    mk m1 s1 + mk m2 s2 = mk (s2 \u2022 m1 + s1 \u2022 m2) (s1 * s2) :=\n  mk_eq.mpr <| \u27e81, rfl\u27e9\n\nprivate theorem add_assoc' (x y z : LocalizedModule S M) : x + y + z = x + (y + z) := by\n  induction x with | _ mx sx\n  induction y with | _ my sy\n  induction z with | _ mz sz\n  simp only [mk_add_mk, smul_add]\n  refine mk_eq.mpr \u27e81, ?_\u27e9\n  rw [one_smul, one_smul]\n  congr 1\n  \u00b7 rw [mul_assoc]\n  \u00b7 rw [eq_comm, mul_comm, add_assoc, mul_smul, mul_smul, \u2190 mul_smul sx sz, mul_comm,",
      "suggestion": "instance (priority := 900) {A : Type*} [Semiring A] [Algebra R A] {S : Submonoid R} :\n    Monoid (LocalizedModule S A) :=\n  fast_instance%\n  { __ := inferInstanceAs (One (LocalizedModule S A))\n    mul := LocalizedModule.mul\n    one_mul := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [one_mul, mul_one, one_smul]\u27e9\n    mul_one := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [mul_one, one_smul, one_mul]\u27e9\n    mul_assoc := by with_unfolding_all\n      rintro \u27e8a\u2081, s\u2081\u27e9 \u27e8a\u2082, s\u2082\u27e9 \u27e8a\u2083, s\u2083\u27e9\n      apply mk_eq.mpr _\n      use 1\n      simp only [one_mul, smul_smul, \u2190 mul_assoc, mul_right_comm] }\n",
      "body": "```suggestion\ninstance (priority := 900) {A : Type*} [Semiring A] [Algebra R A] {S : Submonoid R} :\n    Monoid (LocalizedModule S A) :=\n  fast_instance%\n  { __ := inferInstanceAs (One (LocalizedModule S A))\n    mul := LocalizedModule.mul\n    one_mul := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [one_mul, mul_one, one_smul]\u27e9\n    mul_one := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [mul_one, one_smul, one_mul]\u27e9\n    mul_as",
      "path": "Mathlib/Algebra/Module/LocalizedModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "simpa",
          "rw",
          "simp",
          "induction",
          "congr",
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "induction",
          "congr",
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Module",
          "mpr",
          "Monoid",
          "neg",
          "zero_add",
          "hasNatSMul",
          "Type",
          "succ",
          "mul_smul_comm",
          "terms",
          "mul",
          "add",
          "eq_comm",
          "mul_right_comm",
          "Neg",
          "Quotient",
          "private",
          "liftOn",
          "zero_mk",
          "neg_add_cancel",
          "hu1",
          "have",
          "smul_smul",
          "hu2",
          "CommSemiring",
          "fix",
          "CommRing",
          "trivial",
          "def",
          "mul_comm",
          "mul_one",
          "simp",
          "rfl",
          "Add",
          "theorem",
          "add_assoc",
          "trans",
          "localization",
          "smul_smul_smul_comm",
          "SMul",
          "mul_smul",
          "sorting",
          "Zero",
          "smul",
          "show",
          "mk_eq",
          "induction_on",
          "TODO",
          "mk_add_mk",
          "apply"
        ]
      }
    },
    {
      "id": 2133,
      "before_code": "rw [ShortComplex.ab_exact_iff] at this\n  exact this x\u2083 hx\u2083",
      "suggestion": "  rw [\u2190 AddMonoidHom.ker_eq_bot_iff, AddSubgroup.eq_bot_iff_forall]\n  intro x hx\n  obtain \u27e8f, rfl\u27e9 := Ext.addEquiv\u2080.symm.surjective x\n  simpa [\u2190 cancel_epi g] using hx\n",
      "body": "```suggestion\n  rw [\u2190 AddMonoidHom.ker_eq_bot_iff, AddSubgroup.eq_bot_iff_forall]\n  intro x hx\n  obtain \u27e8f, rfl\u27e9 := Ext.addEquiv\u2080.symm.surjective x\n  simpa [\u2190 cancel_epi g] using hx\n```",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "ext",
          "simpa",
          "obtain",
          "rw",
          "intro"
        ],
        "body_tactics": [
          "ext",
          "simpa",
          "obtain",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "intro",
          "ext"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "ShortComplex",
          "exact",
          "this",
          "ab_exact_iff"
        ]
      }
    },
    {
      "id": 2141,
      "before_code": "simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_iff_left_iff_imp]\n  exact fun hz \u21a6 UpperHalfPlane.coe_mem_integerComplement \u27e8z, hz\u27e9",
      "suggestion": "\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n",
      "body": "If you put this in `UpperHalfPlane` then you can dot-notate. Also `n` can be implicit since you have `hm`. \r\n```suggestion\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n```",
      "path": "Mathlib/Analysis/Complex/IntegerCompl.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mem_setOf_eq",
          "exact",
          "Set",
          "mem_inter_iff",
          "UpperHalfPlane",
          "coe_mem_integerComplement",
          "simp",
          "and_iff_left_iff_imp",
          "only"
        ]
      }
    },
    {
      "id": 2142,
      "before_code": "@[simp, norm_cast]\nlemma coe_I : I = Complex.I := rfl",
      "suggestion": "\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffices 0 < n * z.im / Complex.normSq z by simpa [Complex.div_im, neg_div]\r\n  positivity [NeZero.ne n, z.normSq_pos]\r\n",
      "body": "This is in the `UpperHalfPlane` namespace so you don't really need `UpperHalfPlane` in the statment. My instinct would be to formulate using `Nat` with a `[NeZero]` typeclass assumption, rather than `PNat`, but I haven't checked how that plays together with the usage of this lemma later. \r\n\r\nIf you move this to a few lines later in the file (maybe after `ne_int`) then you can do the following:\r\n```suggestion\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffi",
      "path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa",
          "positivity"
        ],
        "body_tactics": [
          "simpa",
          "positivity"
        ],
        "new_tactics": [
          "simpa",
          "positivity"
        ],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "complex",
          "norm"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "coe_I",
          "lemma",
          "Complex",
          "simp",
          "rfl",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2143,
      "before_code": "exact Real.rpow_le_rpow_of_nonpos (r_pos _) (r_lower_bound_on_verticalStrip z hB hz)\n    (neg_nonpos.mpr hk)\n\nlemma linear_isTheta_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\n  refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real)\n  rw [isLittleO_const_left]\n  exact Or.inr\n    (tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real)",
      "suggestion": "\r\nlemma linear_isTheta_right_add (c e : \u2124) (z : \u2102) :\r\n    (fun d : \u2124 \u21a6 c * z + d + e) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\r\n  apply IsTheta.add_isLittleO <;>\r\n  [refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real); skip] <;>\r\n  simpa [-Int.cofinite_eq] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real\r\n",
      "body": "optional golf (might be a bit convoluted):\r\n```suggestion\r\nlemma linear_isTheta_right_add (c e : \u2124) (z : \u2102) :\r\n    (fun d : \u2124 \u21a6 c * z + d + e) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\r\n  apply IsTheta.add_isLittleO <;>\r\n  [refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real); skip] <;>\r\n  simpa [-Int.cofinite_eq] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real\r\n```\r\n(This makes me wonder if `Int.cofinite_eq` should not",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "apply"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "lemma",
          "neg_nonpos",
          "cofinite",
          "isLittleO_const_left",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "refine",
          "rpow_le_rpow_of_nonpos",
          "isClosedEmbedding_coe_real",
          "add_isTheta",
          "linear_isTheta_right",
          "Int",
          "IsLittleO",
          "Real",
          "r_pos",
          "r_lower_bound_on_verticalStrip",
          "Asymptotics",
          "exact",
          "cast_complex_isTheta_cast_real",
          "inr"
        ]
      }
    },
    {
      "id": 2144,
      "before_code": "\u00b7 simp only [isLittleO_const_left, Int.cast_eq_zero,\n      tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real, or_true]\n\nlemma linear_inv_isBigO_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_right c z).inv.isBigO\n\nlemma linear_inv_isBigO_left (d : \u2124) {z : \u2102} (hz : z \u2260 0) :\n    (fun (c : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_left d hz).inv.isBigO",
      "suggestion": "\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n",
      "body": "`Asymptotics` is already open, and `simpa` uses `this` by default:\r\n```suggestion\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigO",
          "cast_eq_zero",
          "lemma",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "linear_isTheta_right",
          "Int",
          "linear_inv_isBigO_left",
          "or_true",
          "inv",
          "linear_isTheta_left",
          "simp",
          "cofinite",
          "isClosedEmbedding_coe_real",
          "isLittleO_const_left",
          "only",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2146,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]",
      "suggestion": "\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul\r\n      (linear_inv_isBigO_right_add c\u2081 0 z).comp_neg_int\r\n",
      "body": "```suggestion\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul\r\n      (linear_inv_isBigO_right_add c\u2081 0 z).comp_neg_int\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "pow_two",
          "Real",
          "abs_mul_abs_self",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "only",
          "rpow_two",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2147,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul \r\n    (linear_inv_isBigO_right_add c\u2081 1 z)\r\n",
      "body": "```suggestion\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul \r\n    (linear_inv_isBigO_right_add c\u2081 1 z)\r\n```\r\n(It's a pity we don't have an automatic way to \"anti-squeeze\" a simp, i.e. remove explicitly-listed lemmas where they aren't needed.) Ditto in the next lemma.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2148,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _)]\r\n  aesop\r\n",
      "body": "I'm not a fan of `simp only [massive list of stuff] at *`, it seems a bit of a \"scattergun\" approach. Here's a shorter and cleaner version:\r\n```suggestion\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "aesop",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp",
          "use_aesop"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2149,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n",
      "body": "```suggestion\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n```\r\nThe statement can be made far more general, you could do e.g.\r\n```\r\nlemma isLittleO_const_left_of_properSpace_of_discreteTopology\r\n    {\u03b1 : Type*} (a : \u03b1) [NormedAddCommGroup \u03b1] [DiscreteTopology \u03b1]\r\n    [ProperSpace \u03b1] : (fun _ : \u03b1 \u21a6 a) =",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2150,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n",
      "body": "```suggestion\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2152,
      "before_code": "rw [modular_T_zpow_smul z (N * n)]\n  simpa only [Int.cast_mul, Int.cast_natCast] using vAdd_width_periodic N k n f z",
      "suggestion": "\r\n    (f \u2223[k] ModularGroup.S) z = f (.mk _ z.im_inv_neg_coe_pos) * z ^ (-k) := by\r\n  rw [SL_slash_apply, modular_S_smul]\r\n  simp [ModularGroup.S, denom]\r\n",
      "body": "```suggestion\r\n    (f \u2223[k] ModularGroup.S) z = f (.mk _ z.im_inv_neg_coe_pos) * z ^ (-k) := by\r\n  rw [SL_slash_apply, modular_S_smul]\r\n  simp [ModularGroup.S, denom]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/Identities.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "modular_T_zpow_smul",
          "Int",
          "simpa",
          "cast_natCast",
          "cast_mul",
          "vAdd_width_periodic",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 2153,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "simpa",
          "exact"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 2155,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  have := tendsto_tsum_of_dominated_convergence (\ud835\udcd5 := atTop) (g := fun _ \u21a6 0)\r\n    (f := fun d n : \u2115+ \u21a6 r ^ (n * d : \u2115)) (bound := fun n \u21a6 (\u2016r ^ (n : \u2115)\u2016))\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  have := tendsto_tsum_of_dominated_convergence (\ud835\udcd5 := atTop) (g := fun _ \u21a6 0)\r\n    (f := fun d n : \u2115+ \u21a6 r ^ (n * d : \u2115)) (bound := fun n \u21a6 (\u2016r ^ (n : \u2115)\u2016))\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 2156,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n```\r\n(It's a pity that none of the auto-tactics seem to work on the last line.)",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 2157,
      "before_code": "@[deprecated (since := \"2025-09-31\")]\nalias pnat_multipliable_iff_multipliable_succ := multipliable_pnat_iff_multipliable_succ",
      "suggestion": "\r\n  rw [multipliable_pnat_iff_multipliable_succ, multipliable_nat_add_iff]\r\n",
      "body": "```suggestion\r\n  rw [multipliable_pnat_iff_multipliable_succ, multipliable_nat_add_iff]\r\n```\r\nWe should have a text-level linter against \"[space]+[comma]\".",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "alias",
          "pnat_multipliable_iff_multipliable_succ",
          "since",
          "multipliable_pnat_iff_multipliable_succ",
          "deprecated"
        ]
      }
    },
    {
      "id": 2158,
      "before_code": "f 0 * \u220f' n : \u2115+, f \u2191n = \u220f' n, f n := by\n  simpa [hf.tprod_eq_zero_mul] using tprod_pnat_eq_tprod_succ\n\n@[to_additive tsum_int_eq_zero_add_two_mul_tsum_pnat]\ntheorem tprod_int_eq_zero_mul_tprod_pnat_sq [UniformSpace G] [IsUniformGroup G] [CompleteSpace G]\n    [T2Space G] {f : \u2124 \u2192 G} (hf : \u2200 n : \u2124, f (-n) = f n) (hf2 : Multipliable f) :\n    \u220f' n, f n = f 0 * (\u220f' n : \u2115+, f n) ^ 2 := by\n  have hf3 : Multipliable fun n : \u2115 \u21a6 f n :=\n    (multipliable_int_iff_multipliable_nat_and_neg.mp hf2).1\n  have hf4 : Multipliable fun n : \u2115+ \u21a6 f n := by\n    rwa [multipliable_pnat_iff_multipliable_succ (f := (f \u00b7)),\n      multipliable_nat_add_iff 1 (f := (f \u00b7))]\n  have := tprod_nat_mul_neg hf2\n  rw [\u2190 tprod_zero_pnat_eq_tprod_nat (by simpa [hf] using hf3.mul hf3), mul_comm _ (f 0)] at this\n  simp only [hf, Nat.cast_zero, mul_assoc, mul_right_inj] at this\n  rw [\u2190 this, mul_right_inj, hf4.tprod_mul hf4, sq]",
      "suggestion": "\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n",
      "body": "Indentation is off here. But the proof can also be hugely shortened:\r\n```suggestion\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n```\r\nYou could also use `Function.Even` as the hypothesis, at the cost of an extra import; note that if you do `(hf : Function.Even f)` then you need `hf _` in the simp call, not just `hf`.",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "topics": [
          "int",
          "finset",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "CompleteSpace",
          "rwa",
          "Multipliable",
          "multipliable_nat_add_iff",
          "tsum_int_eq_zero_add_two_mul_tsum_pnat",
          "mul",
          "to_additive",
          "IsUniformGroup",
          "multipliable_int_iff_multipliable_nat_and_neg",
          "hf4",
          "Nat",
          "cast_zero",
          "have",
          "tprod_zero_pnat_eq_tprod_nat",
          "hf3",
          "mul_right_inj",
          "multipliable_pnat_iff_multipliable_succ",
          "tprod_pnat_eq_tprod_succ",
          "T2Space",
          "mul_comm",
          "simp",
          "tprod_eq_zero_mul",
          "only",
          "mul_assoc",
          "theorem",
          "UniformSpace",
          "hf2",
          "tprod_nat_mul_neg",
          "tprod_mul",
          "this",
          "simpa",
          "tprod_int_eq_zero_mul_tprod_pnat_sq",
          "using"
        ]
      }
    },
    {
      "id": 2163,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  \u00b7 have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -(y * log y ^ 2)\u207b\u00b9 := by\n",
      "body": "```suggestion\n  \u00b7 have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -(y * log y ^ 2)\u207b\u00b9 := by\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2166,
      "before_code": "convert sum_mul_eq_sub_integral_mul\u2080 c hc m hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]",
      "suggestion": "    have H\u2081 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, c n = 0 := by grind [(Nat.floor_lt' two_ne_zero).mpr hb]\n    have H\u2082 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, f n * c n = 0 := by grind\n    simp [sum_eq_zero H\u2081, sum_eq_zero H\u2082, Set.Ioc_eq_empty_of_le hb.le]\n  --Split off the first two terms of the sum\n  have : 2 \u2264 \u230ab\u230b\u208a := Nat.le_floor hb\n  have H : \u2211 k \u2208 Icc 0 \u230ab\u230b\u208a, f \u2191k * c k = f (2 :) * c 2 + \u2211 k \u2208 Ioc 2 \u230ab\u230b\u208a, f \u2191k * c k := by\n    rw [add_sum_Ioc_eq_sum_Icc (f := fun (k : \u2115) \u21a6 f k * c k) this,\n      show Icc 0 \u230ab\u230b\u208a = {0, 1} \u222a Icc 2 \u230ab\u230b\u208a by grind]\n    exact sum_union_eq_right fun k hk hk' \u21a6 by grind\n  rw [H]\n  --Apply Abel summation to the remainder\n  nth_rewrite 3 [show 2 = \u230a(2 : \u211d)\u230b\u208a by simp]\n  rw [sum_mul_eq_sub_sub_integral_mul c zero_le_two hb hf_diff hf_int]\n  simp [show Icc 0 2 = {0, 1, 2} by rfl, hc, hc1]\n  grind\n",
      "body": "```suggestion\n    have H\u2081 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, c n = 0 := by grind [(Nat.floor_lt' two_ne_zero).mpr hb]\n    have H\u2082 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, f n * c n = 0 := by grind\n    simp [sum_eq_zero H\u2081, sum_eq_zero H\u2082, Set.Ioc_eq_empty_of_le hb.le]\n  --Split off the first two terms of the sum\n  have : 2 \u2264 \u230ab\u230b\u208a := Nat.le_floor hb\n  have H : \u2211 k \u2208 Icc 0 \u230ab\u230b\u208a, f \u2191k * c k = f (2 :) * c 2 + \u2211 k \u2208 Ioc 2 \u230ab\u230b\u208a, f \u2191k * c k := by\n    rw [add_sum_Ioc_eq_sum_Icc (f := fun (k : \u2115) \u21a6 f k * c k) this,\n      show Icc 0 \u230ab\u230b\u208a = ",
      "path": "Mathlib/NumberTheory/AbelSummation.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "all_goals",
          "convert",
          "Nat",
          "floor_natCast",
          "hf_int",
          "hf_diff"
        ]
      }
    },
    {
      "id": 2167,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have : x * log x ^ 2 \u2260 0 := mul_ne_zero this <| by simp; grind\n",
      "body": "```suggestion\n  have : x * log x ^ 2 \u2260 0 := mul_ne_zero this <| by simp; grind\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "have",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "have",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2168,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  -- Rewrite in a form to which Abel summation can be applied\n",
      "body": "```suggestion\n  -- Rewrite in a form to which Abel summation can be applied\n```\netc.",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2169,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  \u00b7 refine sum_congr rfl fun n hn \u21a6 ?_\n    split_ifs with h\n    \u00b7 have : log n \u2260 0 := log_ne_zero_of_pos_of_ne_one (mod_cast h.pos) (mod_cast h.ne_one)\n      simp [a, h, field]\n    \u00b7 simp [a, h]\n",
      "body": "```suggestion\n  \u00b7 refine sum_congr rfl fun n hn \u21a6 ?_\n    split_ifs with h\n    \u00b7 have : log n \u2260 0 := log_ne_zero_of_pos_of_ne_one (mod_cast h.pos) (mod_cast h.ne_one)\n      simp [a, h, field]\n    \u00b7 simp [a, h]\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "new_tactics": [
          "have",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2170,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "      replace hu : 2 \u2264 u := ((Set.uIcc_of_le hx) \u25b8 hu).1\n      simp [deriv_log_inv (by linarith) (by linarith) (by linarith), field]\n",
      "body": "```suggestion\n      replace hu : 2 \u2264 u := ((Set.uIcc_of_le hx) \u25b8 hu).1\n      simp [deriv_log_inv (by linarith) (by linarith) (by linarith), field]\n```\nNote that this is one of the places where `deric_log_inv` without side conditions would simplify things.",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "linarith"
        ],
        "body_tactics": [
          "simp",
          "linarith"
        ],
        "new_tactics": [
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2172,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
      "body": "```suggestion\n    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "exact",
          "have",
          "fun_prop",
          "linarith",
          "congr"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "have",
          "fun_prop",
          "linarith",
          "congr"
        ],
        "new_tactics": [
          "refine",
          "exact",
          "congr",
          "have",
          "linarith",
          "fun_prop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_linarith",
          "use_fun_prop"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2173,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  calc\n  _ \u2264 \u222b x in a..b, 1 / log a ^ 2 := by\n      refine intervalIntegral.integral_mono_on hab ?_ (by simp) fun x \u27e8hx, _\u27e9 \u21a6 by gcongr <;> bound\n      apply intervalIntegrable_one_div_log_sq <;> linarith\n  _ \u2264 _ := by simp [field]\n",
      "body": "```suggestion\n  calc\n  _ \u2264 \u222b x in a..b, 1 / log a ^ 2 := by\n      refine intervalIntegral.integral_mono_on hab ?_ (by simp) fun x \u27e8hx, _\u27e9 \u21a6 by gcongr <;> bound\n      apply intervalIntegrable_one_div_log_sq <;> linarith\n  _ \u2264 _ := by simp [field]\n```\n* `calc` proofs are usually easier to read than proofs using `trans`\n* `refine` allows to fold `intro` (or `use`, ...)",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "simp",
          "linarith"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "simp",
          "intro",
          "linarith"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2174,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have two_le_sqrt : 2 \u2264 x.sqrt := Real.le_sqrt_of_sq_le <| by norm_num [hx]\n",
      "body": "```suggestion\n  have two_le_sqrt : 2 \u2264 x.sqrt := Real.le_sqrt_of_sq_le <| by norm_num [hx]\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "norm_num",
          "have"
        ],
        "body_tactics": [
          "norm_num",
          "have"
        ],
        "new_tactics": [
          "norm_num",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2175,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have sqrt_le_x : x.sqrt \u2264 x := sqrt_le_left (by linarith) |>.mpr (by bound)\n",
      "body": "```suggestion\n  have sqrt_le_x : x.sqrt \u2264 x := sqrt_le_left (by linarith) |>.mpr (by bound)\n```\n(Same proofs, only a bit more condensed.)",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have",
          "linarith"
        ],
        "body_tactics": [
          "have",
          "linarith"
        ],
        "new_tactics": [
          "have",
          "linarith"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2178,
      "before_code": "\u220f' i, (1 + f i) = \u2211' s, \u220f i \u2208 s, f i :=\n  HasProd.tprod_eq <| hasProd_one_add_of_hasSum_prod h.hasSum",
      "suggestion": "  exact tprod_one_add_ordered hsum' hprod\n",
      "body": "```suggestion\n  exact tprod_one_add_ordered hsum' hprod\n```",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/Ring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "HasProd",
          "tprod_eq",
          "hasProd_one_add_of_hasSum_prod",
          "hasSum"
        ]
      }
    },
    {
      "id": 2180,
      "before_code": "rw [\u2190 h\u03c3]\n      convert le_ciSup (Finite.bddAbove_range _) \u03c3",
      "suggestion": "\r\n      apply le_ciSup (Finite.bddAbove_range _) \u03c3\r\n",
      "body": "```suggestion\r\n      apply le_ciSup (Finite.bddAbove_range _) \u03c3\r\n```\r\nIf you're already golfing this random proof, may as well to it properly. This `apply` closes the goal (and `exact` doesn't, somehow because of elaboration order)",
      "path": "Mathlib/Analysis/Normed/Unbundled/SpectralNorm.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "exact",
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finite",
          "le_ciSup",
          "bddAbove_range",
          "convert"
        ]
      }
    },
    {
      "id": 2189,
      "before_code": "hW := .sup D\u2081.hW D\u2082.hW (Cardinal.IsRegular.aleph0_le Fact.out)\n  hP := .sup D\u2081.hP D\u2082.hP (Cardinal.IsRegular.aleph0_le Fact.out)",
      "suggestion": "@[simps!]\ndef D\u2080 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) :\n    Diagram J \u03ba :=\n  Diagram.iSup (fun i \u21a6 (D i).toDiagram) h\u03b9\n\n@[simps!]\ndef D\u2081 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) (m : J) :\n    Diagram J \u03ba :=\n  (D\u2080 J \u03ba D h\u03b9).sup (.single m)\n\n@[simps!]\ndef D\u2082 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba)\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) (m : J) (u : (i : \u03b9) \u2192 (D i).top \u27f6 m) :\n    Diagram J \u03ba where\n  W := (D\u2081 J \u03ba D h\u03b9 m).W \u2294 MorphismProperty.ofHoms\n    fun (x : (\u03a3 (i : \u03b9), (Subtype (D i).P))) \u21a6 (D x.1).isTerminal.lift x.2.2 \u226b u x.1\n  P := (D\u2081 J \u03ba D h\u03b9 m).P\n  src := by\n    simp only [D\u2081_W, D\u2081_P]\n    rintro _ _ _ ((hf | \u27e8\u27e8\u27e9\u27e9) | \u27e8i, j, hj\u27e9)\n    \u00b7 simp only [MorphismProperty.iSup_iff] at hf\n      obtain \u27e8i, hf\u27e9 := hf\n      exact Or.inl \u27e8i, (D i).src hf\u27e9\n    \u00b7 exact Or.inr rfl\n    \u00b7 exact Or.inl \u27e8i, hj\u27e9\n  tgt := by\n    simp only [D\u2081_W, D\u2081_P]\n    rintro _ _ _ ((hf | \u27e8\u27e8\u27e9\u27e9) | \u27e8i, j, hj\u27e9)\n   ",
      "body": "```suggestion\n@[simps!]\ndef D\u2080 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) :\n    Diagram J \u03ba :=\n  Diagram.iSup (fun i \u21a6 (D i).toDiagram) h\u03b9\n\n@[simps!]\ndef D\u2081 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) (m : J) :\n    Diagram J \u03ba :=\n  (D\u2080 J \u03ba D h\u03b9).sup (.single m)\n\n@[simps!]\ndef D\u2082 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba)\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) (m : J) (u : (i : \u03b9) \u2192 (D i).top \u27f6 m) :\n  ",
      "path": "Mathlib/CategoryTheory/Presentable/Directed.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "out",
          "aleph0_le",
          "Fact",
          "sup",
          "IsRegular",
          "Cardinal"
        ]
      }
    },
    {
      "id": 2210,
      "before_code": "(fun i j Z gi gj \u21a6 hx gi gj (ofArrows.mk _) (ofArrows.mk _))\n    exact \u27e8t, fun Y f \u27e8i\u27e9 \u21a6 hA i, fun y hy \u21a6 ht y (fun i \u21a6 hy (\u03c0 i) (ofArrows.mk _))\u27e9",
      "suggestion": "\r\n  property i j Z gi gj h := by\r\n    simp [\u2190 FunctorToTypes.map_comp_apply, \u2190 op_comp, h]\r\n",
      "body": "```suggestion\r\n  property i j Z gi gj h := by\r\n    simp [\u2190 FunctorToTypes.map_comp_apply, \u2190 op_comp, h]\r\n```",
      "path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "ofArrows"
        ]
      }
    },
    {
      "id": 2215,
      "before_code": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]",
      "suggestion": "\r\n  exact Iff.symm e.forall_congr_left\r\n",
      "body": "```suggestion\r\n  exact Iff.symm e.forall_congr_left\r\n```",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "Basis",
          "fundamentalDomain_reindex",
          "ext",
          "theorem",
          "fundamentalDomain",
          "forall_congr",
          "Type",
          "reindex",
          "implies_true",
          "Equiv",
          "mem_fundamentalDomain",
          "simp_rw",
          "repr_reindex_apply"
        ]
      }
    },
    {
      "id": 2216,
      "before_code": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]",
      "suggestion": "simpa using e.forall_congr_left.symm\n",
      "body": "````suggestion\nsimpa using e.forall_congr_left.symm\n````\n(haven't tested but this is the idiomatic way to write this)",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Basis",
          "fundamentalDomain_reindex",
          "ext",
          "theorem",
          "fundamentalDomain",
          "forall_congr",
          "Type",
          "reindex",
          "implies_true",
          "Equiv",
          "mem_fundamentalDomain",
          "simp_rw",
          "repr_reindex_apply"
        ]
      }
    },
    {
      "id": 2219,
      "before_code": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]",
      "suggestion": "\r\n  simp [e.forall_congr_left]\r\n",
      "body": "yeah it's having trouble unifying because `e.symm.symm` looks different to `e`\r\n\r\nI found a fix though; `exact` followed by an iff statement is generally a sign that `simp` or `rw` will work\r\n\r\n````suggestion\r\n  simp [e.forall_congr_left]\r\n````",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "Basis",
          "fundamentalDomain_reindex",
          "ext",
          "theorem",
          "fundamentalDomain",
          "forall_congr",
          "Type",
          "reindex",
          "implies_true",
          "Equiv",
          "mem_fundamentalDomain",
          "simp_rw",
          "repr_reindex_apply"
        ]
      }
    },
    {
      "id": 2227,
      "before_code": "-FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=\n  rfl\n\ntheorem not_isUnit_iff_mk_pos {x : FiniteElement K} : \u00ac IsUnit x \u2194 0 < mk x.1 :=\n  Valuation.Integer.not_isUnit_iff_valuation_lt_one\n\ntheorem isUnit_iff_mk_eq_zero {x : FiniteElement K} : IsUnit x \u2194 mk x.1 = 0 := by\n  rw [\u2190 not_iff_not, not_isUnit_iff_mk_pos, lt_iff_not_ge, x.2.ge_iff_eq']",
      "suggestion": "\r\n@[simp] theorem mk_ratCast (q : \u211a) : FiniteElement.mk (q : K) (mk_ratCast_nonneg q) = q := rfl\r\n",
      "body": "```suggestion\r\n@[simp] theorem mk_ratCast (q : \u211a) : FiniteElement.mk (q : K) (mk_ratCast_nonneg q) = q := rfl\r\n```\r\nthen your users don't have any proof obligation when rewriting backwards",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "ge_iff_eq",
          "lt_iff_not_ge",
          "IsUnit",
          "rwa",
          "Integer",
          "isUnit_iff_mk_eq_zero",
          "FiniteElement",
          "not_iff_not",
          "not_isUnit_iff_valuation_lt_one",
          "Valuation",
          "theorem",
          "mk_neg",
          "not_isUnit_iff_mk_pos",
          "rfl"
        ]
      }
    },
    {
      "id": 2229,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "  have pow_ne_zero : p ^ k \u2260 0 := pow_ne_zero k hp.ne_zero\n",
      "body": "```suggestion\n  have pow_ne_zero : p ^ k \u2260 0 := pow_ne_zero k hp.ne_zero\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 2230,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "  apply Nat.eq_of_factorization_eq\n  \u00b7 exact pos_iff_ne_zero.mp (ordProj_pos (p ^ k) p)\n  \u00b7 exact pow_ne_zero k hp.ne_zero\n  \u00b7 simp [Prime.factorization_pow hp]\n",
      "body": "```suggestion\n  apply Nat.eq_of_factorization_eq\n  \u00b7 exact pos_iff_ne_zero.mp (ordProj_pos (p ^ k) p)\n  \u00b7 exact pow_ne_zero k hp.ne_zero\n  \u00b7 simp [Prime.factorization_pow hp]\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "apply"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 2231,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "  apply Nat.eq_of_factorization_eq\n  \u00b7 exact pos_iff_ne_zero.mp (ordCompl_pos p (pow_ne_zero k hp.ne_zero))\n",
      "body": "```suggestion\n  apply Nat.eq_of_factorization_eq\n  \u00b7 exact pos_iff_ne_zero.mp (ordCompl_pos p (pow_ne_zero k hp.ne_zero))\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "apply"
        ],
        "body_tactics": [
          "exact",
          "apply"
        ],
        "new_tactics": [
          "exact",
          "apply"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 2245,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n",
      "body": "It's easier if you case split on whether the range of the function from the subtype is bounded above or not.\n```suggestion\n  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "exact",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "exact",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "aesop",
          "refine",
          "simp",
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 2246,
      "before_code": "{ a : \u0393' | (VAddAntidiagonal x.isPWO_support\n              ((of R).symm y).isPWO_support a).Nonempty } := by\n          intro a ha\n          simp only [Set.mem_setOf_eq]\n          contrapose! ha\n          simp [ha]",
      "suggestion": "\r\n          simp only [Set.mem_setOf_eq]\r\n          contrapose! ha\r\n          simp [ha]\r\n",
      "body": "```suggestion\r\n          simp only [Set.mem_setOf_eq]\r\n          contrapose! ha\r\n          simp [ha]\r\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "contrapose",
          "symm",
          "Nonempty",
          "mem_setOf_eq",
          "Set",
          "simp",
          "intro",
          "isPWO_support",
          "VAddAntidiagonal",
          "only"
        ]
      }
    },
    {
      "id": 2249,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    toEuclidean '' Euclidean.closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [Euclidean.closedBall, Euclidean.dist]\r\n",
      "body": "```suggestion\r\n    toEuclidean '' Euclidean.closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [Euclidean.closedBall, Euclidean.dist]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "new_tactics": [
          "simpa",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2250,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n  \u00b7 norm_num [dist_eq_norm, EuclideanSpace.norm_eq]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9]\r\n    \u00b7 simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n    \u00b7 intro b _ hnb\r\n      simp [hnb, x\u2081, x\u2082]\r\n    \u00b7 simp\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n  \u00b7 norm_num [dist_eq_norm, EuclideanSpace.norm_eq]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9]\r\n    \u00b7 simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n    \u00b7 intro b _ hnb\r\n      simp [hnb, x\u2081, x\u2082]\r\n    \u00b7 simp\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "norm_num",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "norm_num",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "norm_num",
          "rw",
          "simp",
          "intro"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2251,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  by_cases hr : r = 0 <;> simp [\u2190 _root_.closure_ball, hr]\r\n",
      "body": "```suggestion\r\n  by_cases hr : r = 0 <;> simp [\u2190 _root_.closure_ball, hr]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2254,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 ((by simp_all [x\u2081, x\u2082])) (by simp)]\r\n    simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n  \u00b7 simp [x\u2081, abs_of_nonneg, hr]\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n",
      "body": "More compact this way:\r\n```suggestion\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 ((by simp_all [x\u2081, x\u2082])) (by simp)]\r\n    simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n  \u00b7 simp [x\u2081, abs_of_nonneg, hr]\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine",
          "rw",
          "simp_all"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2256,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  let x\u2081 := toEuclidean x + EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  let x\u2082 := toEuclidean x - EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 (by simp_all [x\u2081, x\u2082]) (by simp)]\r\n",
      "body": "```suggestion\r\n  let x\u2081 := toEuclidean x + EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  let x\u2082 := toEuclidean x - EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 (by simp_all [x\u2081, x\u2082]) (by simp)]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine",
          "rw",
          "simp_all"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2257,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    toEuclidean '' closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [closedBall, dist]\r\n",
      "body": "```suggestion\r\n    toEuclidean '' closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [closedBall, dist]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "new_tactics": [
          "simpa",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2261,
      "before_code": "theorem convex_closedBall (a : E) (r : \u211d) : Convex \u211d (Metric.closedBall a r) := by\n  simpa only [Metric.closedBall, sep_univ] using (convexOn_univ_dist a).convex_le r\n\nvariable {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F]",
      "suggestion": "\r\nlemma Metric.diam_ball_eq (x : F) {r : \u211d} (hr : 0 \u2264 r) :\r\n    diam (ball x r) = 2 * r := by\r\n  if hr' : r = 0 then simp [hr'] else\r\n  rw [\u2190 diam_closure, closure_ball _ hr', diam_closedBall_eq _ hr]\r\n",
      "body": "```suggestion\r\nlemma Metric.diam_ball_eq (x : F) {r : \u211d} (hr : 0 \u2264 r) :\r\n    diam (ball x r) = 2 * r := by\r\n  if hr' : r = 0 then simp [hr'] else\r\n  rw [\u2190 diam_closure, closure_ball _ hr', diam_closedBall_eq _ hr]\r\n```",
      "path": "Mathlib/Analysis/Normed/Module/Convex.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "norm",
          "real",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "convex_closedBall",
          "variable",
          "theorem",
          "Type",
          "Metric",
          "NormedSpace",
          "simpa",
          "closedBall",
          "Convex",
          "sep_univ",
          "convexOn_univ_dist",
          "NormedAddCommGroup",
          "convex_le",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 2264,
      "before_code": "@[deprecated (since := \"2025-12-05\")] alias toSpanSingleton_one := toSpanSingleton_apply_one",
      "suggestion": "\r\n@[simp] theorem toSpanSingleton_map_one (c : R\u2081 \u2192L[R\u2081] M\u2082) : toSpanSingleton R\u2081 (c 1) = c :=\r\n",
      "body": "wait... this or?\r\n```suggestion\r\n@[simp] theorem toSpanSingleton_map_one (c : R\u2081 \u2192L[R\u2081] M\u2082) : toSpanSingleton R\u2081 (c 1) = c :=\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/LinearMap.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "alias",
          "since",
          "toSpanSingleton_apply_one",
          "deprecated",
          "toSpanSingleton_one"
        ]
      }
    },
    {
      "id": 2268,
      "before_code": "instance instFourierPairInv : FourierInvPair \ud835\udce2'(E, F) \ud835\udce2'(E, F) where\n  fourier_fourierInv_eq f := by ext; simp",
      "suggestion": "    \ud835\udcd5\u207b (f : \ud835\udce2'(E, F)) = \ud835\udcd5\u207b f := calc\n  _ = \ud835\udcd5\u207b (toTemperedDistributionCLM E F volume (\ud835\udcd5 (\ud835\udcd5\u207b f))) := by\n    congr; exact (fourier_fourierInv_eq f).symm\n  _ = \ud835\udcd5\u207b (\ud835\udcd5 (toTemperedDistributionCLM E F volume (\ud835\udcd5\u207b f))) := by\n    rw [fourierTransform_toTemperedDistributionCLM_eq]\n  _ = _ := fourierInv_fourier_eq _\n",
      "body": "style nit. I didn't actually test that it still elaborates properly with the starting and ending `_`, but I don't see which it shouldn't.\n```suggestion\n    \ud835\udcd5\u207b (f : \ud835\udce2'(E, F)) = \ud835\udcd5\u207b f := calc\n  _ = \ud835\udcd5\u207b (toTemperedDistributionCLM E F volume (\ud835\udcd5 (\ud835\udcd5\u207b f))) := by\n    congr; exact (fourier_fourierInv_eq f).symm\n  _ = \ud835\udcd5\u207b (\ud835\udcd5 (toTemperedDistributionCLM E F volume (\ud835\udcd5\u207b f))) := by\n    rw [fourierTransform_toTemperedDistributionCLM_eq]\n  _ = _ := fourierInv_fourier_eq _\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "exact",
          "congr",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "congr",
          "rw"
        ],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "instFourierPairInv",
          "ext",
          "fourier_fourierInv_eq",
          "simp",
          "instance",
          "FourierInvPair"
        ]
      }
    },
    {
      "id": 2304,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "  rw [Nat.le_div_iff_mul_le (by positivity), Nat.mul_comm,\n    \u2190 Nat.add_mul_div_right _ _ (by positivity),\n    Nat.le_div_iff_mul_le (by positivity)]\n  have := (Commute.all (b : \u2124) (a - b)).pow_add_mul_le_add_pow_of_sq_nonneg\n    (by positivity) (sq_nonneg _) (sq_nonneg _) (by grind) (n + 1)\n  -- `grind` should solve this, but:  https://github.com/leanprover/lean4/issues/11539\n  simp [mul_sub, \u2190 add_sub_assoc] at this\n  norm_cast at this\n  grind \n",
      "body": "This worked last week\n```suggestion\n  rw [Nat.le_div_iff_mul_le (by positivity), Nat.mul_comm,\n    \u2190 Nat.add_mul_div_right _ _ (by positivity),\n    Nat.le_div_iff_mul_le (by positivity)]\n  have := (Commute.all (b : \u2124) (a - b)).pow_add_mul_le_add_pow_of_sq_nonneg\n    (by positivity) (sq_nonneg _) (sq_nonneg _) (by grind) (n + 1)\n  -- `grind` should solve this, but:  https://github.com/[user]r/lean4/issues/11539\n  simp [mul_sub, \u2190 add_sub_assoc] at this\n  norm_cast at this\n  grind \n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "grind",
          "have",
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "positivity",
          "grind",
          "have",
          "rw",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "positivity",
          "rw",
          "simp",
          "grind",
          "have",
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 2305,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "  have H : \u2203 c, a < (c + 1) ^ (n + 1) := \u27e8a, Nat.le_self_pow (by positivity) (a + 1)\u27e9\n  let +nondep (eq := hc) c := Nat.find H\n  refine \u27e8c, ?_, hc \u25b8 Nat.find_spec H\u27e9\n  cases c with\n  | zero => simp\n  | succ k => simpa using Nat.find_min H hc.le\n",
      "body": "Here's a nice little trick for you. This introduces a new name `c` which is equal (propositionally) to `Nat.find H`, but it doesn't reduce to that. This allows us to perform a nice case split on `c` which simplifies the argument.\n```suggestion\n  have H : \u2203 c, a < (c + 1) ^ (n + 1) := \u27e8a, Nat.le_self_pow (by positivity) (a + 1)\u27e9\n  let +nondep (eq := hc) c := Nat.find H\n  refine \u27e8c, ?_, hc \u25b8 Nat.find_spec H\u27e9\n  cases c with\n  | zero => simp\n  | succ k => simpa using Nat.find_min H hc.le\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "refine",
          "cases",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "positivity",
          "refine",
          "cases",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "positivity",
          "refine",
          "simp",
          "cases",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 2306,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff\n\n/--\nAn auxiliary lemma saying that if `b \u2260 0`,\nthen `(a / b ^ n + n * b) / (n + 1) + 1` is a strict upper estimate on `\u221a[n + 1] a`.\n\nCurrently, the proof relies on the weighted AM-GM inequality,\nwhich increases the dependency closure of this file by a lot.\n\nA PR proving this inequality by more elementary means is very welcome.\n-/\ntheorem nthRoot.lt_pow_go_succ_aux (hb : b \u2260 0) :\n    a < ((a / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n  rcases Nat.eq_zero_or_pos n with rfl | hn; \u00b7 simp\n  rw [\u2190 Nat.add_mul_div_left a, Nat.div_div_eq_div_mul] <;> try positivity\n  rify\n  calc\n    (a : \u211d) = ((a / b ^ n) ^ (1 / (n + 1) : \u211d) * b ^ (n / (n + 1) : \u211d)) ^ (n + 1) := by\n      rw [mul_pow, \u2190 Real.rpow_mul_natCast, \u2190 Real.rpow_mul_natCast] <;> try positivity\n      simp (disch := positivity) [div_mul_cancel\u2080]\n    _ \u2264 ((1 / (n + 1)) * (a / b ^ n) + (n / (n + 1)) * b) ^ (n + 1) := by\n      gcongr\n      apply Real.geom_mean_le_arith_mean2_weighted <;> try positivity\n      simp [field, add_comm]\n    _ = ((a + b ^ n * (n * b)) / (b ^ n * (n + 1))) ^ (n + 1) := by\n      congr 1\n      field\n    _ < _ := by\n      gcongr ?_ ^ _\n      convert lt_floor_add_one (R := \u211d) _ using 1\n      norm_cast\n      rw [Nat.floor_div_natCast, Nat.floor_natCast]",
      "suggestion": "    _ \u2264 ((c ^ (n + 1) / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n      gcongr\n      exact nthRoot.lt_pow_go_succ_aux0 hb\n    _ \u2264 ((a / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n      gcongr\n",
      "body": "style nit\n```suggestion\n    _ \u2264 ((c ^ (n + 1) / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n      gcongr\n      exact nthRoot.lt_pow_go_succ_aux0 hb\n    _ \u2264 ((a / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n      gcongr\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "positivity",
          "gcongr",
          "cases",
          "rw",
          "simp",
          "congr",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "exact",
          "gcongr"
        ],
        "body_tactics": [
          "exact",
          "gcongr"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "apply",
          "positivity",
          "cases",
          "rw",
          "simp",
          "congr",
          "norm_cast"
        ],
        "topics": [
          "real",
          "order",
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "add_mul_div_left",
          "file",
          "lemma",
          "Currently",
          "calc",
          "lt_pow_go_succ_aux",
          "convert",
          "try",
          "closure",
          "which",
          "increases",
          "eq_zero_or_pos",
          "relies",
          "proving",
          "elementary",
          "add_comm",
          "floor_natCast",
          "estimate",
          "floor_div_natCast",
          "rcases",
          "strict",
          "field",
          "rify",
          "pow_nthRoot_le_iff",
          "alias",
          "welcome",
          "geom_mean_le_arith_mean2_weighted",
          "apply",
          "positivity",
          "gcongr",
          "pow_nthRoot_le",
          "Nat",
          "more",
          "disch",
          "norm_cast",
          "div_div_eq_div_mul",
          "then",
          "inequality",
          "Real",
          "that",
          "simp",
          "lt_floor_add_one",
          "upper",
          "rfl",
          "congr",
          "mul_pow",
          "nthRoot",
          "lot",
          "theorem",
          "auxiliary"
        ]
      }
    },
    {
      "id": 2310,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n  have {x} (hx : x \u2208 s) : \u2203 K' : \u211d\u22650, \u2200 y \u2208 s.diff (ball x (\u03b5 x hx)),\r\n",
      "body": "Should this be stated as\r\n```suggestion\r\n  have {x} (hx : x \u2208 s) : \u2203 K' : \u211d\u22650, \u2200 y \u2208 s.diff (ball x (\u03b5 x hx)),\r\n```\r\nso you can avoid the `fun x hx` at the beginning of hte proof?",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 2312,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n      gcongr\r\n      exact (add_le_add_left (mul_le_mul_of_nonneg_left h (by positivity)) _).trans (by linarith)\r\n",
      "body": "```suggestion\r\n      gcongr\r\n      exact (add_le_add_left (mul_le_mul_of_nonneg_left h (by positivity)) _).trans (by linarith)\r\n```",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "body_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "new_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 2315,
      "before_code": "(by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n\nend MeromorphicOn",
      "suggestion": "@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3)) :\n    Meromorphic (\u2211 n \u2208 s, G n) := fun x \u21a6 MeromorphicAt.sum (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma sub (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f - g) := fun x \u21a6 (hf x).sub (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma mul {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f * g) := fun x \u21a6 (hf x).mul (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem prod (h : \u2200 \u03c3, Meromorphic (F \u03c3)) :\n    Meromorphic (\u220f n \u2208 s, F n) := fun x \u21a6 MeromorphicAt.prod (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma div {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f / g) := fun x \u21a6 (hf x).div (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma pow",
      "body": "There is some new metaprogramming that can help here: the `to_fun` attribute.\nTo get access, you need to add `import Mathlib.Tactic.ToFun` to the imports (doesn't need `public`).\n\n```suggestion\n@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "restrict",
          "measurable_of_countable",
          "end",
          "mem_compl_iff",
          "simp",
          "MeromorphicOn",
          "measurable"
        ]
      }
    },
    {
      "id": 2316,
      "before_code": "rintro x rfl\n  exact heval _",
      "suggestion": "  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero _ hf\n",
      "body": "only because I was confused why `hf` wasn't an explicit argument, and then after looking above, I realized it is.\n```suggestion\n  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero _ hf\n```",
      "path": "Mathlib/Algebra/Polynomial/Roots.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "rfl",
          "heval",
          "rintro"
        ]
      }
    },
    {
      "id": 2334,
      "before_code": "n.totient_eq_card_lt_and_coprime]\n    simp only [Nat.gcd_comm]",
      "suggestion": "\r\n  wlog hp : 0 < p generalizing p; swap\r\n  \u00b7 have := Fact.mk hp\r\n",
      "body": "Here's how I'd write this. This is subjective, so feel free to accept or reject this as you choose.\r\n```suggestion\r\n  wlog hp : 0 < p generalizing p; swap\r\n  \u00b7 have := Fact.mk hp\r\n```",
      "path": "Mathlib/Topology/Instances/AddCircle/Defs.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "nat",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "gcd_comm",
          "totient_eq_card_lt_and_coprime",
          "Nat",
          "simp",
          "only"
        ]
      }
    },
    {
      "id": 2347,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "  rcases (by lia : finrank R V = 0 \u2228 finrank R V = 1) with h0 | h1\n  \u00b7 have : Subsingleton V := (finrank_eq_zero_iff_of_free R V).mp h0\n    simp [Subsingleton.eq_zero v]\n",
      "body": "```suggestion\n  rcases (by lia : finrank R V = 0 \u2228 finrank R V = 1) with h0 | h1\n  \u00b7 have : Subsingleton V := (finrank_eq_zero_iff_of_free R V).mp h0\n    simp [Subsingleton.eq_zero v]\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "have"
        ],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 2348,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "      rw [this v, map_smul, smul_eq_mul, mul_comm] at hfv\n      rw [this x, this v, map_smul, smul_eq_mul, \u2190 mul_smul, mul_assoc, hfv, mul_zero, zero_smul]\n",
      "body": "These are just nitpicks but I think it does make it easier to glance over the proof:\n```suggestion\n      rw [this v, map_smul, smul_eq_mul, mul_comm] at hfv\n      rw [this x, this v, map_smul, smul_eq_mul, \u2190 mul_smul, mul_assoc, hfv, mul_zero, zero_smul]\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 2352,
      "before_code": "ext i\n  simp [basis_repr_comp_apply]\n\nvariable [Module.Free R V]\n\ninclude ibc in\ntheorem free : Module.Free S W :=\n  Module.Free.of_basis (ibc.basis (Module.Free.chooseBasis R V))\n\nend IsBaseChange",
      "suggestion": "    -- simp? [Fintype.linearCombination_apply] says:\n    simp only [LinearEquiv.ofBijective_apply, LinearMap.coe_comp, LinearEquiv.coe_coe,\n      Function.comp_apply, Fintype.linearCombination_apply]\n",
      "body": "```suggestion\n    -- simp? [Fintype.linearCombination_apply] says:\n    simp only [LinearEquiv.ofBijective_apply, LinearMap.coe_comp, LinearEquiv.coe_coe,\n      Function.comp_apply, Fintype.linearCombination_apply]\n```\n\nThis is up to you, and some people disagree with me, but I prefer (mostly) auto-generated simp only blocks to rw blocks, because it makes the proof more maintainable (if the proof breaks in the future, the `simp?` statement that generated it can sometimes help fix it (which is why",
      "path": "Mathlib/RingTheory/TensorProduct/IsBaseChangeFree.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "use_simp",
          "line_break"
        ],
        "keywords": [
          "Module",
          "Free",
          "end",
          "ext",
          "basis_repr_comp_apply",
          "variable",
          "IsBaseChange",
          "theorem",
          "include",
          "chooseBasis",
          "of_basis",
          "simp",
          "ibc",
          "free",
          "basis"
        ]
      }
    },
    {
      "id": 2358,
      "before_code": "intro B n\n  induction n with\n  | zero => simp only [zpow_zero, one_smul]\n  | succ n hn =>\n    simpa only [add_comm (n:\u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc, prop_red_T hS hT]",
      "suggestion": "\r\n  | succ n hn =>\r\n    simpa only [add_comm (n : \u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc,\r\n      prop_red_T hS hT]\r\n",
      "body": "```suggestion\r\n  | succ n hn =>\r\n    simpa only [add_comm (n : \u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc,\r\n      prop_red_T hS hT]\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/FixedDetMatrices.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "induction",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "induction",
          "simp",
          "intro"
        ],
        "topics": [
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "zpow_add",
          "add_comm",
          "one_smul",
          "prop_red_T",
          "succ",
          "zpow_zero",
          "simpa",
          "zpow_one",
          "induction",
          "simp",
          "intro",
          "zero",
          "smul_eq_mul",
          "only",
          "smul_assoc"
        ]
      }
    },
    {
      "id": 2372,
      "before_code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible",
      "suggestion": "    obtain \u27e8u, -, h\u27e9 := isUnit_iff.mp h\n    apply ha\n    simpa using congr(coeff $h 1).symm\n",
      "body": "```suggestion\n    obtain \u27e8u, -, h\u27e9 := isUnit_iff.mp h\n    apply ha\n    simpa using congr(coeff $h 1).symm\n```",
      "path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "obtain",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "obtain",
          "congr"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "obtain",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Monic",
          "irreducible",
          "theorem",
          "Irreducible",
          "hp1",
          "prime_of_degree_eq_one",
          "irreducible_of_degree_eq_one",
          "degree"
        ]
      }
    },
    {
      "id": 2373,
      "before_code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible",
      "suggestion": "    \u00b7 push_neg at H\n      rw [mul_comm] at h\n      exact exact (this g f h H.le).symm\n",
      "body": "```suggestion\n    \u00b7 push_neg at H\n      rw [mul_comm] at h\n      exact exact (this g f h H.le).symm\n```",
      "path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Monic",
          "irreducible",
          "theorem",
          "Irreducible",
          "hp1",
          "prime_of_degree_eq_one",
          "irreducible_of_degree_eq_one",
          "degree"
        ]
      }
    },
    {
      "id": 2374,
      "before_code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible",
      "suggestion": "    have hd := congr(degree $h)\n    have aux : (a \u2022 (X : R[X]) + C b).degree = 1 := by compute_degree!\n    rw [degree_mul, aux, eq_comm, Nat.WithBot.add_eq_one_iff] at hd\n    obtain \u27e8hf, -\u27e9 : f.degree = 0 \u2227 g.degree = 1 := by\n      apply hd.resolve_right\n      rintro \u27e8hf0, hfg\u27e9\n      simp_all [(zero_lt_one' (WithBot \u2115)).not_ge]\n    left\n    replace hf := f.eq_C_of_degree_eq_zero hf\n    suffices IsUnit (f.coeff 0) by\n      rw [isUnit_iff]\n      exact \u27e8f.coeff 0, this, hf.symm\u27e9\n    rw [hf, \u2190 smul_eq_C_mul] at h\n    apply hab\n    \u00b7 use g.coeff 1\n      simpa using congr(coeff $h 1)\n    \u00b7 use g.coeff 0\n      simpa using congr(coeff $h 0)\n",
      "body": "```suggestion\n    have hd := congr(degree $h)\n    have aux : (a \u2022 (X : R[X]) + C b).degree = 1 := by compute_degree!\n    rw [degree_mul, aux, eq_comm, Nat.WithBot.add_eq_one_iff] at hd\n    obtain \u27e8hf, -\u27e9 : f.degree = 0 \u2227 g.degree = 1 := by\n      apply hd.resolve_right\n      rintro \u27e8hf0, hfg\u27e9\n      simp_all [(zero_lt_one' (WithBot \u2115)).not_ge]\n    left\n    replace hf := f.eq_C_of_degree_eq_zero hf\n    suffices IsUnit (f.coeff 0) by\n      rw [isUnit_iff]\n      exact \u27e8f.coeff 0, this, hf.symm\u27e9\n    r",
      "path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Monic",
          "irreducible",
          "theorem",
          "Irreducible",
          "hp1",
          "prime_of_degree_eq_one",
          "irreducible_of_degree_eq_one",
          "degree"
        ]
      }
    },
    {
      "id": 2380,
      "before_code": "theorem log_exp (x : \u211d) : log (exp x) = x :=\n  exp_injective <| exp_log (exp_pos x)",
      "suggestion": "@[simp] theorem log_comp_exp : log \u2218 exp = id := funext log_exp\n",
      "body": "```suggestion\n@[simp] theorem log_comp_exp : log \u2218 exp = id := funext log_exp\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "funext",
          "simp"
        ],
        "body_tactics": [
          "funext",
          "simp"
        ],
        "new_tactics": [
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "exp",
          "log",
          "theorem",
          "exp_injective",
          "exp_log",
          "log_exp",
          "exp_pos"
        ]
      }
    },
    {
      "id": 2399,
      "before_code": "grw [\u2190 H2]\n  ring_nf; rfl",
      "suggestion": "\r\n  grind [abs, norm_smul, Real.norm_eq_abs, norm_zero, inner_eq_mul_norm_iff_angle_eq_zero, inner_eq_neg_mul_norm_iff_angle_eq_pi]\r\n",
      "body": "```suggestion\r\n  grind [abs, norm_smul, Real.norm_eq_abs, norm_zero, inner_eq_mul_norm_iff_angle_eq_zero, inner_eq_neg_mul_norm_iff_angle_eq_pi]\r\n```\r\n(there's an open PR tagging `abs` with `grind`, so that will soon be a redundant argument.",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "ring_nf"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "ring_nf"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "remove_redundant",
          "use_grind"
        ],
        "keywords": [
          "rfl",
          "grw",
          "ring_nf"
        ]
      }
    },
    {
      "id": 2401,
      "before_code": "simpa using angle_le_angle_add_angle_of_norm_eq_one (norm_normalize_eq_one_iff.mpr hx)\n    (norm_normalize_eq_one_iff.mpr hy) (norm_normalize_eq_one_iff.mpr hz)",
      "suggestion": "\r\n      obtain \u27e8_, \u27e8r2, \u27e8H5, rfl\u27e9\u27e9\u27e9 := H2\r\n      lift r2 to \u211d\u22650 using H5.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n    have H2 : Real.sin (angle x z) \u2260 0 := by\r\n      grind [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi]\r\n    obtain hx | hx := eq_or_ne x 0\r\n    \u00b7 subst x; simp only [angle_zero_left, left_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H3, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H3.le\r\n      rw [\u2190 NNReal.smul_def, Submodule.span_insert_zero, Submodule.span_singleton_smul_eq]\r\n      \u00b7 simp\r\n      norm_cast at H3\r\n      grind [isUnit_iff_ne_zero]\r\n    obtain hz | hz := eq_or_ne z 0\r\n    \u00b7 subst z; simp only [angle_zero_right, right_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H1, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H1.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n",
      "body": "```suggestion\r\n      obtain \u27e8_, \u27e8r2, \u27e8H5, rfl\u27e9\u27e9\u27e9 := H2\r\n      lift r2 to \u211d\u22650 using H5.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n    have H2 : Real.sin (angle x z) \u2260 0 := by\r\n      grind [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi]\r\n    obtain hx | hx := eq_or_ne x 0\r\n    \u00b7 subst x; simp only [angle_zero_left, left_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H3, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H3.le\r\n      rw [\u2190 NNReal.smul_d",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp_all",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp",
          "norm_cast"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "simpa",
          "angle_le_angle_add_angle_of_norm_eq_one",
          "using",
          "norm_normalize_eq_one_iff"
        ]
      }
    },
    {
      "id": 2420,
      "before_code": "(Set.univ : Set (G.Walk u v)).Nonempty :=\n  hconn.preconnected.set_univ_walk_nonempty u v",
      "suggestion": "\r\n  obtain \u27e8u, huv\u27e9 := exists_ne v\r\n  obtain \u27e8w\u27e9 := h v u\r\n  exact \u27e8w.snd, w.adj_snd (w.not_nil_of_ne huv.symm)\u27e9\r\n",
      "body": "```suggestion\r\n  obtain \u27e8u, huv\u27e9 := exists_ne v\r\n  obtain \u27e8w\u27e9 := h v u\r\n  exact \u27e8w.snd, w.adj_snd (w.not_nil_of_ne huv.symm)\u27e9\r\n```\r\nPersonally I prefer this version but these are style choices and are up to you:\r\n```suggestion\r\n  have \u27e8u, huv\u27e9 := exists_ne v\r\n  have \u27e8w\u27e9 := h v u\r\n  exact \u27e8_, w.adj_snd <| w.not_nil_of_ne huv.symm\u27e9\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Connected.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "obtain"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "exact",
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "Walk",
          "Nonempty",
          "univ",
          "hconn",
          "Set",
          "set_univ_walk_nonempty",
          "preconnected"
        ]
      }
    },
    {
      "id": 2421,
      "before_code": "(H \u2294 K).Connected :=\n  Subgraph.connected_sup hH.preconnected hK.preconnected hn",
      "suggestion": "\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degree_pos_of_nontrivial v\r\n",
      "body": "Even though you know the graph is nonempty I think it's better to assume the weaker `Preconnected` instead of `Connected`.\r\nAlso, the `by_contra` is redundant here.\r\n```suggestion\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degre",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa",
          "remove_redundant"
        ],
        "keywords": [
          "Connected",
          "connected_sup",
          "Subgraph",
          "preconnected"
        ]
      }
    },
    {
      "id": 2422,
      "before_code": "(H \u2294 K).Connected :=\n  Subgraph.connected_sup hH.preconnected hK.preconnected hn",
      "suggestion": "\r\nlemma Preconnected.exists_adj_of_nontrivial {H : G.Subgraph} [Nontrivial H.verts]\r\n    (h : H.Preconnected) (v : H.verts) : \u2203 u, H.Adj v u := by\r\n  have := h.coe.exists_adj_of_nontrivial v\r\n",
      "body": "```suggestion\r\nlemma Preconnected.exists_adj_of_nontrivial {H : G.Subgraph} [Nontrivial H.verts]\r\n    (h : H.Preconnected) (v : H.verts) : \u2203 u, H.Adj v u := by\r\n  have := h.coe.exists_adj_of_nontrivial v\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Connected",
          "connected_sup",
          "Subgraph",
          "preconnected"
        ]
      }
    },
    {
      "id": 2425,
      "before_code": "have h2 : 0 \u2264 r := nonneg_of_mul_nonneg_left h1 (dist_pos.mpr hab\u2081)\n    exact (sq_eq_sq\u2080 dist_nonneg (mul_nonneg h2 dist_nonneg)).mp h'",
      "suggestion": "\r\ntheorem exterior_angle_eq_angle_add_angle {p\u2081 p\u2082 p\u2083 : P} (p : P) (h : Sbtw \u211d p p\u2081 p\u2082) :\r\n    \u2220 p\u2083 p\u2081 p = \u2220 p\u2081 p\u2083 p\u2082 + \u2220 p\u2083 p\u2082 p\u2081 := by\r\n  have H := (EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n  rw [show \u2220 p\u2083 p\u2081 p\u2082 = \u2220 p\u2082 p\u2081 p\u2083 by simp only [angle_comm],\r\n      add_comm,\r\n      \u2190 angle_add_angle_add_angle_eq_pi p\u2083 ((Sbtw.right_ne h).symm),\r\n      add_assoc] at H\r\n  simp only [add_right_inj] at H\r\n  rw [H]\r\n",
      "body": "Thanks for the PR! I think we can shorten this proof. Here is a suggestion: \r\n```suggestion\r\ntheorem exterior_angle_eq_angle_add_angle {p\u2081 p\u2082 p\u2083 : P} (p : P) (h : Sbtw \u211d p p\u2081 p\u2082) :\r\n    \u2220 p\u2083 p\u2081 p = \u2220 p\u2081 p\u2083 p\u2082 + \u2220 p\u2083 p\u2082 p\u2081 := by\r\n  have H := (EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n  rw [show \u2220 p\u2083 p\u2081 p\u2082 = \u2220 p\u2082 p\u2081 p\u2083 by simp only [angle_comm],\r\n      add_comm,\r\n      \u2190 angle_add_angle_add_angle_eq_pi p\u2083 ((Sbtw.right_ne h).symm),\r\n      add_assoc] at",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "mpr",
          "nonneg_of_mul_nonneg_left",
          "exact",
          "have",
          "dist_pos",
          "dist_nonneg",
          "mul_nonneg"
        ]
      }
    },
    {
      "id": 2426,
      "before_code": "vsub_sub_vsub_cancel_right p\u2083 p\u2082 p\u2081, \u2190 vsub_sub_vsub_cancel_right p\u2082 p\u2083 p\u2081]\n  exact angle_add_angle_sub_add_angle_sub_eq_pi _ fun he => h (vsub_eq_zero_iff_eq.1 he)",
      "suggestion": "\r\n  have H := (angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n",
      "body": "This works, right?\r\n```suggestion\r\n  have H := (angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "vsub_eq_zero_iff_eq",
          "vsub_sub_vsub_cancel_right",
          "angle_add_angle_sub_add_angle_sub_eq_pi"
        ]
      }
    },
    {
      "id": 2427,
      "before_code": "vsub_sub_vsub_cancel_right p\u2083 p\u2082 p\u2081, \u2190 vsub_sub_vsub_cancel_right p\u2082 p\u2083 p\u2081]\n  exact angle_add_angle_sub_add_angle_sub_eq_pi _ fun he => h (vsub_eq_zero_iff_eq.1 he)",
      "suggestion": "\r\n  rw [angle_comm p\u2083 p\u2081 p\u2082, add_comm, \u2190 angle_add_angle_add_angle_eq_pi p\u2083 h.ne_right]\r\n",
      "body": "Please also use dot notation here. In fact, `ne_right` is shorter than `.right_ne.symm`:\r\n```suggestion\r\n  rw [angle_comm p\u2083 p\u2081 p\u2082, add_comm, \u2190 angle_add_angle_add_angle_eq_pi p\u2083 h.ne_right]\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "vsub_eq_zero_iff_eq",
          "vsub_sub_vsub_cancel_right",
          "angle_add_angle_sub_add_angle_sub_eq_pi"
        ]
      }
    },
    {
      "id": 2428,
      "before_code": "vsub_sub_vsub_cancel_right p\u2083 p\u2082 p\u2081, \u2190 vsub_sub_vsub_cancel_right p\u2082 p\u2083 p\u2081]\n  exact angle_add_angle_sub_add_angle_sub_eq_pi _ fun he => h (vsub_eq_zero_iff_eq.1 he)",
      "suggestion": "\r\n  linarith [angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 h.angle\u2081\u2082\u2083_eq_pi,\r\n    angle_add_angle_add_angle_eq_pi p\u2083 h.right_ne.symm, angle_comm p\u2083 p\u2081 p\u2082]\r\n",
      "body": "here is a golf\r\n```suggestion\r\n  linarith [angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 h.angle\u2081\u2082\u2083_eq_pi,\r\n    angle_add_angle_add_angle_eq_pi p\u2083 h.right_ne.symm, angle_comm p\u2083 p\u2081 p\u2082]\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "linarith"
        ],
        "body_tactics": [
          "linarith"
        ],
        "new_tactics": [
          "linarith"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "exact",
          "vsub_eq_zero_iff_eq",
          "vsub_sub_vsub_cancel_right",
          "angle_add_angle_sub_add_angle_sub_eq_pi"
        ]
      }
    },
    {
      "id": 2443,
      "before_code": "simp [sub_val_of_le hij, Nat.sub_lt_sub_right hij j.isLt]\n\nlemma castLT_sub_nezero {n : \u2115} {i j : Fin n} (hij : i < j) :\n    letI : NeZero (n - i.1) := neZero_iff.mpr (by lia)\n    (j - i).castLT (sub_val_lt_sub (Fin.le_of_lt hij)) \u2260 0 := by\n  refine Ne.symm (ne_of_val_ne ?_)\n  simpa [coe_sub_iff_le.mpr (Fin.le_of_lt hij)] using by lia\n\nlemma one_le_of_ne_zero {n : \u2115} [NeZero n] {k : Fin n} (hk : k \u2260 0) : 1 \u2264 k := by\n  obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_succ_of_ne_zero (NeZero.ne n)\n  cases n with\n  | zero => simp only [Fin.isValue, Fin.zero_le]\n  | succ n => rwa [Fin.le_iff_val_le_val, Fin.val_one, Nat.one_le_iff_ne_zero, val_ne_zero_iff]\n\nlemma val_sub_one_of_ne_zero [NeZero n] {i : Fin n} (hi : i \u2260 0) : (i - 1).val = i - 1 := by",
      "suggestion": "\r\n  have := i.neZero\r\n",
      "body": "```suggestion\r\n  have := i.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "refine",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "lemma",
          "rwa",
          "hij",
          "zero_le",
          "succ",
          "obtain",
          "sub_val_lt_sub",
          "castLT",
          "le_iff_val_le_val",
          "le_of_lt",
          "symm",
          "refine",
          "val_one",
          "Nat",
          "cases",
          "sub_lt_sub_right",
          "sub_val_of_le",
          "castLT_sub_nezero",
          "lia",
          "val_ne_zero_iff",
          "neZero_iff",
          "isLt",
          "isValue",
          "simp",
          "rfl",
          "zero",
          "val",
          "only",
          "letI",
          "one_le_iff_ne_zero",
          "val_sub_one_of_ne_zero",
          "NeZero",
          "ne_of_val_ne",
          "simpa",
          "one_le_of_ne_zero",
          "Fin",
          "exists_eq_succ_of_ne_zero",
          "coe_sub_iff_le",
          "using"
        ]
      }
    },
    {
      "id": 2444,
      "before_code": "theorem val_cast_of_lt {n : \u2115} [NeZero n] {a : \u2115} (h : a < n) : (a : Fin n).val = a :=\n  Nat.mod_eq_of_lt h\n\n/-- If `n` is non-zero, converting the value of a `Fin n` to `Fin n` results\nin the same value. -/\n@[simp, norm_cast] theorem cast_val_eq_self {n : \u2115} [NeZero n] (a : Fin n) : (a.val : Fin n) = a :=",
      "suggestion": "\r\n    have := a.neZero\r\n",
      "body": "```suggestion\r\n    have := a.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "mod_eq_of_lt",
          "converting",
          "val_cast_of_lt",
          "theorem",
          "Nat",
          "results",
          "value",
          "NeZero",
          "same",
          "cast_val_eq_self",
          "non",
          "simp",
          "Fin",
          "zero",
          "val",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2445,
      "before_code": "theorem val_cast_of_lt {n : \u2115} [NeZero n] {a : \u2115} (h : a < n) : (a : Fin n).val = a :=\n  Nat.mod_eq_of_lt h\n\n/-- If `n` is non-zero, converting the value of a `Fin n` to `Fin n` results\nin the same value. -/\n@[simp, norm_cast] theorem cast_val_eq_self {n : \u2115} [NeZero n] (a : Fin n) : (a.val : Fin n) = a :=",
      "suggestion": "\r\n  have := a.neZero\r\n",
      "body": "```suggestion\r\n  have := a.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "mod_eq_of_lt",
          "converting",
          "val_cast_of_lt",
          "theorem",
          "Nat",
          "results",
          "value",
          "NeZero",
          "same",
          "cast_val_eq_self",
          "non",
          "simp",
          "Fin",
          "zero",
          "val",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2460,
      "before_code": "end Northcott",
      "suggestion": "  have : NeZero n := \u27e8hn\u27e9\n  suffices \u220f x \u2208 primitiveRoots n \u2102, max 1 \u2016x\u2016 = 1 by\n    simpa [mahlerMeasure_eq_leadingCoeff_mul_prod_roots, cyclotomic.monic n \u2102,\n      Polynomial.cyclotomic.roots_eq_primitiveRoots_val]\n  suffices \u2200 a \u2208 primitiveRoots n \u2102, \u2016a\u2016 \u2264 1 from Multiset.prod_eq_one (by simpa)\n  intro z hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le\n",
      "body": "```suggestion\n  have : NeZero n := \u27e8hn\u27e9\n  suffices \u220f x \u2208 primitiveRoots n \u2102, max 1 \u2016x\u2016 = 1 by\n    simpa [mahlerMeasure_eq_leadingCoeff_mul_prod_roots, cyclotomic.monic n \u2102,\n      Polynomial.cyclotomic.roots_eq_primitiveRoots_val]\n  suffices \u2200 a \u2208 primitiveRoots n \u2102, \u2016a\u2016 \u2264 1 from Multiset.prod_eq_one (by simpa)\n  intro z hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Northcott",
          "end"
        ]
      }
    },
    {
      "id": 2465,
      "before_code": "rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h",
      "suggestion": "\r\n  refine \u27e8fun h hn' \u21a6 ?_, fun h => separable_X_pow_sub_C_unit (Units.mk0 x hx) (IsUnit.mk0 _ h)\u27e9\r\n  exact not_isUnit_of_natDegree_pos (X ^ n - C x) (by simp [hn]) <| by\r\n    simpa [separable_def, derivative_X_pow, hn', isCoprime_zero_right] using h\r\n",
      "body": "````suggestion\r\n  refine \u27e8fun h hn' \u21a6 ?_, fun h => separable_X_pow_sub_C_unit (Units.mk0 x hx) (IsUnit.mk0 _ h)\u27e9\r\n  exact not_isUnit_of_natDegree_pos (X ^ n - C x) (by simp [hn]) <| by\r\n    simpa [separable_def, derivative_X_pow, hn', isCoprime_zero_right] using h\r\n````\r\nI know you copied the proof from the previous lemma, but that old proof is honestly pretty bizzare. Here's a shorter version doing exactly the same steps.",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "exact",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "exact",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "C_0",
          "isCoprime_zero_right",
          "not_isUnit_X_pow_sub_one",
          "zero_mul"
        ]
      }
    },
    {
      "id": 2472,
      "before_code": "rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]\n  grw [\u2190 le_max_left]",
      "suggestion": "  intro \u03b5 h\u03b5\n",
      "body": "You can also just use `intro` here if you want. Same below.\n```suggestion\n  intro \u03b5 h\u03b5\n```\nThanks!\nmaintainer delegate",
      "path": "Mathlib/MeasureTheory/Function/UniformIntegrable.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "intro"
        ],
        "body_tactics": [
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "norm_indicator_eq_indicator_norm",
          "grw",
          "le_max_left"
        ]
      }
    },
    {
      "id": 2473,
      "before_code": "\u00b7 rw [\u2190 ENNReal.tendsto_toNNReal_iff ENNReal.zero_ne_top (hfin \u03b5)]\n    exact h \u03b5 h\u03b5\n\nlemma TendstoInMeasure.mono [EDist E] {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E} {u v : Filter \u03b9} (huv : v \u2264 u)\n    (hg : TendstoInMeasure \u03bc f u g) : TendstoInMeasure \u03bc f v g :=\n  fun \u03b5 h\u03b5 => (hg \u03b5 h\u03b5).mono_left huv\n\nlemma TendstoInMeasure.comp [EDist E] {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E} {u : Filter \u03b9}\n    {v : Filter \u03ba} {ns : \u03ba \u2192 \u03b9} (hg : TendstoInMeasure \u03bc f u g) (hns : Tendsto ns v u) :\n    TendstoInMeasure \u03bc (f \u2218 ns) v g := fun \u03b5 h\u03b5 \u21a6 (hg \u03b5 h\u03b5).comp hns\n\nnamespace TendstoInMeasure\n\nvariable [EDist E] {l : Filter \u03b9} {f f' : \u03b9 \u2192 \u03b1 \u2192 E} {g g' : \u03b1 \u2192 E}",
      "suggestion": "    by_cases x \u2208 s <;> simp_all\n",
      "body": "```suggestion\n    by_cases x \u2208 s <;> simp_all\n```\nThis is a more standard spelling than `repeat`",
      "path": "Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "ENNReal",
          "lemma",
          "huv",
          "mono",
          "hfin",
          "variable",
          "exact",
          "Tendsto",
          "TendstoInMeasure",
          "mono_left",
          "Filter",
          "comp",
          "EDist",
          "hns",
          "zero_ne_top",
          "tendsto_toNNReal_iff",
          "namespace"
        ]
      }
    },
    {
      "id": 2478,
      "before_code": "| refl => exact hr _\n  | tail _ hbc ih => exact ht ih (h _ _ hbc)",
      "suggestion": "  simpa [reflTransGen_eq_self hr ht] using ReflTransGen.mono h h'\n",
      "body": "```suggestion\n  simpa [reflTransGen_eq_self hr ht] using ReflTransGen.mono h h'\n```\nThis is the proof that the lemma you removed used.",
      "path": "Mathlib/Logic/Relation.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "refl",
          "hbc",
          "tail"
        ]
      }
    },
    {
      "id": 2479,
      "before_code": "simp [LinearMap.comp_assoc]\n\nend Finsupp",
      "suggestion": "    coassoc := by ext; simp [coalgebraStruct] }\n",
      "body": "```suggestion\n    coassoc := by ext; simp [coalgebraStruct] }\n```",
      "path": "Mathlib/RingTheory/Coalgebra/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "end",
          "LinearMap",
          "comp_assoc",
          "simp"
        ]
      }
    },
    {
      "id": 2517,
      "before_code": "exactAt i' hi' :=\n    (K.exactAt_of_isSupported e i' hi').of_iso e'",
      "suggestion": "\r\n  simp [isSupported_iff, exactAt_iff_of_quasiIsoAt \u03c6]\r\n",
      "body": "```suggestion\r\n  simp [isSupported_iff, exactAt_iff_of_quasiIsoAt \u03c6]\r\n```",
      "path": "Mathlib/Algebra/Homology/Embedding/IsSupported.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exactAt",
          "of_iso",
          "exactAt_of_isSupported"
        ]
      }
    },
    {
      "id": 2523,
      "before_code": "end",
      "suggestion": "    refine J.superset_covering ?_ hs\n    dsimp [Sieve.overEquiv]\n    simp only [\u2190 Sieve.functorPushforward_comp, \u2190 Over.iteratedSliceForward_forget]\n    have := (Sieve.essSurjFullFunctorGaloisInsertion f.iteratedSliceEquiv.functor _).l_u_eq s\n    dsimp at this\n    simp only [Sieve.functorPushforward_comp]\n    rw [this]\n",
      "body": "```suggestion\n    refine J.superset_covering ?_ hs\n    dsimp [Sieve.overEquiv]\n    simp only [\u2190 Sieve.functorPushforward_comp, \u2190 Over.iteratedSliceForward_forget]\n    have := (Sieve.essSurjFullFunctorGaloisInsertion f.iteratedSliceEquiv.functor _).l_u_eq s\n    dsimp at this\n    simp only [Sieve.functorPushforward_comp]\n    rw [this]\n```\n\nA similar golf to the one above works here as well.",
      "path": "Mathlib/CategoryTheory/Sites/Over.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2525,
      "before_code": "PreservesSheafification.transport (A := A) J\n    ((equivSmallModel C).inverse.inducedTopology J) (equivSmallModel C).inverse B F",
      "suggestion": "    constructor\n    \u00b7 intro H\n      refine J.superset_covering ?_ (e.functor.cover_lift J K H)\n      rw [(Sieve.fullyFaithfulFunctorGaloisCoinsertion e.functor X).u_l_eq S]\n    \u00b7 intro H\n      refine K.superset_covering ?_\n        (e.inverse.cover_lift K J (J.pullback_stable (inv <| e.unit.app X) H))\n      intro Y f (H : S _)\n      refine \u27e8_, _, inv (e.counit.app Y), H, ?_\u27e9\n      simp only [comp_obj, id_obj, map_comp, Equivalence.fun_inv_map, \u2190 Category.assoc,\n        Functor.map_inv, IsIso.inv_hom_id, Category.id_comp, \u2190 IsIso.comp_inv_eq, IsIso.inv_inv,\n        NatIso.inv_inv_app]\n      simp\n",
      "body": "```suggestion\n    constructor\n    \u00b7 intro H\n      refine J.superset_covering ?_ (e.functor.cover_lift J K H)\n      rw [(Sieve.fullyFaithfulFunctorGaloisCoinsertion e.functor X).u_l_eq S]\n    \u00b7 intro H\n      refine K.superset_covering ?_\n        (e.inverse.cover_lift K J (J.pullback_stable (inv <| e.unit.app X) H))\n      intro Y f (H : S _)\n      refine \u27e8_, _, inv (e.counit.app Y), H, ?_\u27e9\n      simp only [comp_obj, id_obj, map_comp, Equivalence.fun_inv_map, \u2190 Category.assoc,\n        Functor.map_i",
      "path": "Mathlib/CategoryTheory/Sites/Equivalence.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "constructor"
        ],
        "body_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "constructor"
        ],
        "new_tactics": [
          "rw",
          "refine",
          "simp",
          "intro",
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "inducedTopology",
          "PreservesSheafification",
          "transport",
          "equivSmallModel",
          "inverse"
        ]
      }
    },
    {
      "id": 2529,
      "before_code": "(h : \u2200 F : Set \u03a9, IsClosed F \u2192\n      limsup (fun i \u21a6 (\u03bcs i : Measure \u03a9).real F) L \u2264 (\u03bc : Measure \u03a9).real F) :\n    Tendsto \u03bcs L (\ud835\udcdd \u03bc) := by\n  refine tendsto_of_forall_isClosed_limsup_le' fun F hF \u21a6 ?_\n  rcases L.eq_or_neBot with rfl | hne\n  \u00b7 simp\n  specialize h F hF\n  simp only [Measure.real_def] at h\n  rwa [ENNReal.limsup_toReal_eq (b := 1) (by simp) (.of_forall fun i \u21a6 prob_le_one),\n    ENNReal.toReal_le_toReal _ (by finiteness)] at h\n  refine ne_top_of_le_ne_top (b := 1) (by simp) ?_\n  refine limsup_le_of_le ?_ (.of_forall fun i \u21a6 prob_le_one)\n  exact isCoboundedUnder_le_of_le L (x := 0) (by simp)",
      "suggestion": "Tendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n",
      "body": "````suggestion\nTendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n````",
      "path": "Mathlib/MeasureTheory/Measure/Portmanteau.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "simp",
          "refine"
        ],
        "topics": [
          "measurability",
          "order",
          "topology"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "of_forall",
          "rwa",
          "real",
          "rcases",
          "limsup_le_of_le",
          "finiteness",
          "refine",
          "specialize",
          "real_def",
          "Measure",
          "isCoboundedUnder_le_of_le",
          "limsup",
          "eq_or_neBot",
          "hne",
          "Tendsto",
          "simp",
          "prob_le_one",
          "rfl",
          "IsClosed",
          "only",
          "ne_top_of_le_ne_top",
          "ENNReal",
          "exact",
          "Set",
          "tendsto_of_forall_isClosed_limsup_le",
          "limsup_toReal_eq",
          "toReal_le_toReal"
        ]
      }
    },
    {
      "id": 2530,
      "before_code": "\u222b\u207b b in s, Kernel.condKernel \u03ba (a, b) t \u2202(Kernel.fst \u03ba a) = \u03ba a (s \u00d7\u02e2 t) := by\n  have : \u03ba a (s \u00d7\u02e2 t) = (Kernel.fst \u03ba \u2297\u2096 Kernel.condKernel \u03ba) a (s \u00d7\u02e2 t) := by\n    congr; exact (\u03ba.disintegrate _).symm\n  rw [this, Kernel.compProd_apply (hs.prod ht)]\n  classical\n  have : \u2200 b, Kernel.condKernel \u03ba (a, b) {c | (b, c) \u2208 s \u00d7\u02e2 t}\n      = s.indicator (fun b \u21a6 Kernel.condKernel \u03ba (a, b) t) b := by\n    intro b\n    by_cases hb : b \u2208 s <;> simp [hb]\n  simp_rw [Set.preimage, this]\n  rw [lintegral_indicator hs]",
      "suggestion": "simpa [this] using (Kernel.compProd_apply_prod hs ht).symm\n",
      "body": "````suggestion\nsimpa [this] using (Kernel.compProd_apply_prod hs ht).symm\n````",
      "path": "Mathlib/Probability/Kernel/Disintegration/Integral.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "have",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "compProd_apply",
          "classical",
          "condKernel",
          "symm",
          "by_cases",
          "fst",
          "have",
          "lintegral_indicator",
          "intro",
          "preimage",
          "simp_rw",
          "prod",
          "Kernel",
          "disintegrate",
          "simp",
          "congr",
          "indicator",
          "exact",
          "Set",
          "this"
        ]
      }
    },
    {
      "id": 2532,
      "before_code": "refine (e.forall_congr ?_).symm\n    intro i\n    rw [MeasurableEquiv.piCongrLeft_apply_apply e x i]\n  rw [this, pi_pi, Finset.prod_equiv e.symm]\n  \u00b7 simp only [Finset.mem_univ, implies_true]\n  intro i _\n  simp only [s']\n  congr\n  all_goals rw [e.apply_symm_apply]",
      "suggestion": "\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n",
      "body": "````suggestion\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n````",
      "path": "Mathlib/MeasureTheory/Constructions/Pi.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "topics": [
          "measurability",
          "set_theory",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply_symm_apply",
          "symm",
          "refine",
          "all_goals",
          "mem_univ",
          "forall_congr",
          "piCongrLeft_apply_apply",
          "Finset",
          "implies_true",
          "pi_pi",
          "congr",
          "this",
          "simp",
          "intro",
          "MeasurableEquiv",
          "prod_equiv",
          "only"
        ]
      }
    },
    {
      "id": 2535,
      "before_code": "def restr {k n : \u2115} (f : MultilinearMap R (fun _ : Fin n => M') M\u2082) (s : Finset (Fin n))\n    (hk : #s = k) (z : M') : MultilinearMap R (fun _ : Fin k => M') M\u2082 where\n  toFun v := f fun j => if h : j \u2208 s then v ((s.orderIsoOfFin hk).symm \u27e8j, h\u27e9) else z\n  map_update_add' v i x y := by\n    erw [dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv]\n    simp\n  map_update_smul' v i c x := by\n    erw [dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv]\n    simp",
      "suggestion": "    rw [OrderIso.coe_symm_toEquiv] at this\n    simp [this]\n",
      "body": "Noting that here and below one could also write:\n```suggestion\n    rw [OrderIso.coe_symm_toEquiv] at this\n    simp [this]\n```\nthough personally I prefer the `simp_all`",
      "path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "erw",
          "restr",
          "MultilinearMap",
          "symm",
          "else",
          "def",
          "then",
          "Finset",
          "toFun",
          "map_update_smul",
          "orderIsoOfFin",
          "map_update_add",
          "simp",
          "toEquiv",
          "Fin",
          "dite_comp_equiv_update"
        ]
      }
    },
    {
      "id": 2539,
      "before_code": "dualDistrib R M N (f \u2297\u209c g) (m \u2297\u209c n) = f m * g n :=\n  rfl",
      "suggestion": "lemma dualDistrib_apply_comm (w : Dual R N \u2297[R] Dual R M) (z : M \u2297[R] N) :\n    dualDistrib R N M w (TensorProduct.comm R M N z) =\n       dualDistrib R M N (TensorProduct.comm R _ _ w) z := by\n  induction w <;> induction z <;> simp_all [mul_comm]\n",
      "body": "How about:\n```suggestion\nlemma dualDistrib_apply_comm (w : Dual R N \u2297[R] Dual R M) (z : M \u2297[R] N) :\n    dualDistrib R N M w (TensorProduct.comm R M N z) =\n       dualDistrib R M N (TensorProduct.comm R _ _ w) z := by\n  induction w <;> induction z <;> simp_all [mul_comm]\n```",
      "path": "Mathlib/LinearAlgebra/Dual/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "induction",
          "simp_all"
        ],
        "body_tactics": [
          "induction",
          "simp_all"
        ],
        "new_tactics": [
          "induction",
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "dualDistrib"
        ]
      }
    },
    {
      "id": 2549,
      "before_code": "end IsTightMeasureSet",
      "suggestion": "  rw [\u2190 coe_ofNat, \u2190 ENNReal.coe_zpow (by simp), \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n",
      "body": "Please mind the spacing. You can put the `simp` inside the `rw`. Also you don't need the `ENNReal` namespace.\n```suggestion\n  rw [\u2190 coe_ofNat, \u2190 ENNReal.coe_zpow (by simp), \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsTightMeasureSet",
          "end"
        ]
      }
    },
    {
      "id": 2552,
      "before_code": "end IsTightMeasureSet",
      "suggestion": "    simp [add_comm]\n",
      "body": "```suggestion\n    simp [add_comm]\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsTightMeasureSet",
          "end"
        ]
      }
    },
    {
      "id": 2556,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "private lemma lt_geom_series {D : \u2115 \u2192 \ud835\udce7} {\u03b5 : \u211d\u22650\u221e} {\u03bc : ProbabilityMeasure \ud835\udce7} {km : \u2115 \u2192 \u2115}\n    {u : \u2115 \u2192 \u211d} (hu_anti : Antitone u)\n    (hbound : \u2200 k : \u2115, 1 - \u03b5 * 2 ^ (-k : \u2124) < \u03bc (\u22c3 i \u2264 km k, ball (D i) (u k))) :\n    \u2211' (m : \u2115), (1 - \u03bc.toMeasure (\u22c3 i \u2264 km (m + 1), closure (ball (D i) (u m)))) \u2264\n    \u2211' (m : \u2115), (\u03b5 : \u211d\u22650\u221e) * 2 ^ (-((m : \u2124) + 1)) := by\n  refine ENNReal.tsum_le_tsum fun m \u21a6 tsub_le_iff_tsub_le.mp ?_\n  specialize hbound (m+1)\n  apply le_of_lt at hbound\n  simp_all only [neg_add_rev, Int.reduceNeg, tsub_le_iff_right, Nat.cast_add, Nat.cast_one,\n      \u2190 coe_ofNat, \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n  grw [hbound]\n  gcongr\n  \u00b7 refine apply_mono \u03bc <| iUnion\u2082_mono <| fun i hi \u21a6 ?_\n    grw [\u2190 subset_closure (s := ball (D i) (u m)), ball_subset_ball]\n    exact hu_anti (by grind)\n",
      "body": "Changes:\n- use a generic antitone sequence `u` instead of `1/(m+1)`\n- spacing of the statement\n- some spaces added (after `\u2190`, before `:=`)\n```suggestion\nprivate lemma lt_geom_series {D : \u2115 \u2192 \ud835\udce7} {\u03b5 : \u211d\u22650\u221e} {\u03bc : ProbabilityMeasure \ud835\udce7} {km : \u2115 \u2192 \u2115}\n    {u : \u2115 \u2192 \u211d} (hu_anti : Antitone u)\n    (hbound : \u2200 k : \u2115, 1 - \u03b5 * 2 ^ (-k : \u2124) < \u03bc (\u22c3 i \u2264 km k, ball (D i) (u k))) :\n    \u2211' (m : \u2115), (1 - \u03bc.toMeasure (\u22c3 i \u2264 km (m + 1), closure (ball (D i) (u m)))) \u2264\n    \u2211' (m : \u2115), (\u03b5 : \u211d\u22650\u221e) * 2 ^ (-((m : \u2124) + 1)) ",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "grind",
          "simp_all"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "grind",
          "simp_all"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "grind",
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2557,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "theorem isTightMeasureSet_of_isCompact_closure (hcomp : IsCompact (closure S)) :\n    IsTightMeasureSet {((\u03bc : ProbabilityMeasure \ud835\udce7) : Measure \ud835\udce7) | \u03bc \u2208 S} := by\n  rw [IsTightMeasureSet_iff_exists_isCompact_measure_compl_le]\n  rcases isEmpty_or_nonempty \ud835\udce7 with hempty | hempty\n  \u00b7 intro \u03b5 \u03b5pos\n    use \u2205\n    constructor\n    \u00b7 exact isCompact_empty\n    rw [\u2190 univ_eq_empty_iff] at hempty\n    simp only [mem_setOf_eq, compl_empty, hempty, measure_empty, zero_le, implies_true]\n  obtain \u27e8D, hD\u27e9 := exists_dense_seq \ud835\udce7\n  obtain \u27e8u, hu_anti, hu_pos, hu\u27e9 : \u2203 u, StrictAnti u \u2227 (\u2200 n, 0 < u n) \u2227 Tendsto u atTop (\ud835\udcdd 0) :=\n    exists_seq_strictAnti_tendsto (0 : \u211d)\n  have hcov (m : \u2115) : \u22c3 i, ball (D i) (u m) = univ := by\n    rw [denseRange_iff] at hD\n    ext p\n    exact \u27e8fun a \u21a6 trivial, fun _ \u21a6 mem_iUnion.mpr <| hD p (u m) (hu_pos m)\u27e9\n  intro \u03b5 \u03b5pos\n  by_cases h\u03b5bound : 1 < \u03b5\n  \u00b7 use \u2205\n    constructor\n    \u00b7 exact isCompact_empty\n    intro \u03bc h\u03bc\n    simp only [mem_setOf_eq] at h\u03bc\n    obtain \u27e8\u03bc', h\u03bc', rfl\u27e9 :=",
      "body": "Changes:\n- use a generic sequence `u` with `StrictAnti u \u2227 (\u2200 n, 0 < u n) \u2227 Tendsto u atTop (\ud835\udcdd 0)` instead of `1/(m+1)`. It leads to shorter expressions and makes it easier to see what are the properties used. Also replace the inverse of delta by `have \u27e8\u03b4_inv, h\u03b4_inv\u27e9 : \u2203 x, u x < \u03b4`.\n- use `simpa` more\n- fix spaces here and there\n- replace instances of `use x; constructor; intro y`... on multiple lines by a one-line `refine`\n```suggestion\ntheorem isTightMeasureSet_of_isCompact_closure (hcomp : ",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "ext",
          "exact",
          "cases",
          "linarith",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "constructor",
          "intro",
          "congr",
          "measurability",
          "ring_nf"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "ext",
          "exact",
          "cases",
          "linarith",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "constructor",
          "intro",
          "congr",
          "measurability",
          "ring_nf"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "simp",
          "congr",
          "measurability",
          "ring_nf",
          "apply",
          "gcongr",
          "refine",
          "ext",
          "cases",
          "have",
          "simpa",
          "constructor",
          "intro",
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_simpa",
          "use_linarith",
          "cleanup_simp"
        ],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2559,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  have \u03b5fin : \u03b5 \u2260 \u221e := ne_top_of_le_ne_top (by simp) h\u03b5bound\n",
      "body": "- use `\u221e` for top in ENNReal\n- shorter proof\n```suggestion\n  have \u03b5fin : \u03b5 \u2260 \u221e := ne_top_of_le_ne_top (by simp) h\u03b5bound\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2560,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  obtain \u27e8\u03b5, h\u03b5'\u27e9 := \u03b5\n",
      "body": "```suggestion\n  obtain \u27e8\u03b5, h\u03b5'\u27e9 := \u03b5\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2561,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  have Measurebound n : (\u03bclim (\u22c3 (i \u2264 n), U i) : \u211d) \u2264 1 - \u03b5 := calc\n",
      "body": "For readability, let's add the type.\n```suggestion\n  have Measurebound n : (\u03bclim (\u22c3 (i \u2264 n), U i) : \u211d) \u2264 1 - \u03b5 := calc\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2562,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "            fun _ d hyp \u21a6 (hyp d (by simp)).trans (by simp)\n",
      "body": "```suggestion\n            fun _ d hyp \u21a6 (hyp d (by simp)).trans (by simp)\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2564,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "      Tendsto.eventually_const_le (v := 1) (by simp; positivity) accumulation\n",
      "body": "```suggestion\n      Tendsto.eventually_const_le (v := 1) (by simp; positivity) accumulation\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "positivity",
          "simp"
        ],
        "body_tactics": [
          "positivity",
          "simp"
        ],
        "new_tactics": [
          "positivity",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2566,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  \u00b7 rw [\u2190 univ_eq_empty_iff] at hempty\n    exact fun \u03b5 \u03b5pos \u21a6 \u27e8\u2205, isCompact_empty, by simp [hempty]\u27e9\n",
      "body": "```suggestion\n  \u00b7 rw [\u2190 univ_eq_empty_iff] at hempty\n    exact fun \u03b5 \u03b5pos \u21a6 \u27e8\u2205, isCompact_empty, by simp [hempty]\u27e9\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2589,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "theorem continuousOn_arcosh : ContinuousOn arcosh (Ici 1) :=\n  have {x : \u211d} (hx : x \u2208 Ici 1) : 0 < x + \u221a(x ^ 2 - 1) :=\n    add_pos_of_pos_of_nonneg (show 0 < x by grind) (sqrt_nonneg _)\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (fun _ _ => by grind)\n",
      "body": "It's very minor, but why not?\n\n```suggestion\ntheorem continuousOn_arcosh : ContinuousOn arcosh (Ici 1) :=\n  have {x : \u211d} (hx : x \u2208 Ici 1) : 0 < x + \u221a(x ^ 2 - 1) :=\n    add_pos_of_pos_of_nonneg (show 0 < x by grind) (sqrt_nonneg _)\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (fun _ _ => by grind)\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "body_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "new_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 2591,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "\r\n  rw [\u2190 sinh_arcosh (le_of_lt hx)]\r\n  refine coshOpenPartialHomeomorph.hasStrictDerivAt_symm hx ?_ (hasStrictDerivAt_cosh _)\r\n  rw [ne_eq, sinh_eq_zero]\r\n  exact ne_of_gt (arcosh_pos hx)\r\n",
      "body": "I really like `convert`, but AFAIK it's usually considered brittle and Mathlib prefers to avoid it if it's not too difficult.\r\n```suggestion\r\n  rw [\u2190 sinh_arcosh (le_of_lt hx)]\r\n  refine coshOpenPartialHomeomorph.hasStrictDerivAt_symm hx ?_ (hasStrictDerivAt_cosh _)\r\n  rw [ne_eq, sinh_eq_zero]\r\n  exact ne_of_gt (arcosh_pos hx)\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "new_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 2592,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "\r\n  exact (arcosh_pos hx).ne'\r\n",
      "body": "```suggestion\r\n  exact (arcosh_pos hx).ne'\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 2597,
      "before_code": "theorem degree_add (a b : \u03c3 \u2192\u2080 R) : (a + b).degree = a.degree + b.degree :=\n  sum_add_index' (h := fun _ \u21a6 id) (congrFun rfl) fun _ _ \u21a6 congrFun rfl",
      "suggestion": "  refine s.induction rfl ?_\n",
      "body": "```suggestion\n  refine s.induction rfl ?_\n```",
      "path": "Mathlib/Data/Finsupp/Weight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "induction",
          "refine"
        ],
        "body_tactics": [
          "induction",
          "refine"
        ],
        "new_tactics": [
          "induction",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "degree_add",
          "theorem",
          "sum_add_index",
          "congrFun",
          "rfl",
          "degree"
        ]
      }
    },
    {
      "id": 2603,
      "before_code": "theorem isHomogeneous_C (r : R) : IsHomogeneous (C r : MvPolynomial \u03c3 R) 0 := by\n  apply isHomogeneous_monomial\n  simp only [Finsupp.degree, Finsupp.zero_apply, Finset.sum_const_zero]",
      "suggestion": "  simp only [Finsupp.degree_def, Finsupp.zero_apply, Finset.sum_const_zero]\n",
      "body": "```suggestion\n  simp only [Finsupp.degree_def, Finsupp.zero_apply, Finset.sum_const_zero]\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Homogeneous.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "list",
          "order",
          "finset"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Finsupp",
          "apply",
          "MvPolynomial",
          "theorem",
          "Finset",
          "zero_apply",
          "isHomogeneous_C",
          "sum_const_zero",
          "IsHomogeneous",
          "simp",
          "degree",
          "only",
          "isHomogeneous_monomial"
        ]
      }
    },
    {
      "id": 2605,
      "before_code": "end",
      "suggestion": "\r\n  letI gen : M.GeneratingSections :=\r\n    { I := \u03c3\r\n      s := M.freeHomEquiv g\r\n      epi := by simpa using epi_of_isColimit_cofork H'}\r\n  haveI eq_aux : gen.\u03c0 = g := Equiv.symm_apply_apply M.freeHomEquiv g\r\n  haveI comp_zero : f \u226b gen.\u03c0 = 0 := eq_aux \u25b8 H\r\n  { generators := gen\r\n    relations :=\r\n      { I := \u03b9\r\n        s := (kernel gen.\u03c0).freeHomEquiv <| kernel.lift gen.\u03c0 f comp_zero\r\n        epi := by\r\n          let h : cokernel f \u2245 M := (H'.coconePointUniqueUpToIso (colimit.isColimit _)).symm\r\n          let h' : Abelian.image f \u2245 kernel gen.\u03c0 :=\r\n            kernel.mapIso (cokernel.\u03c0 f) gen.\u03c0 (Iso.refl _) h (by simp [h, eq_aux])\r\n          have comp_aux : Abelian.factorThruImage f \u226b h'.hom =\r\n            (kernel.lift gen.\u03c0 f comp_zero) := equalizer.hom_ext <| by simp [h']\r\n          rw [\u2190 comp_aux, Equiv.symm_apply_apply]\r\n          infer_instance }}\r\n",
      "body": "```suggestion\r\n  letI gen : M.GeneratingSections :=\r\n    { I := \u03c3\r\n      s := M.freeHomEquiv g\r\n      epi := by simpa using epi_of_isColimit_cofork H'}\r\n  haveI eq_aux : gen.\u03c0 = g := Equiv.symm_apply_apply M.freeHomEquiv g\r\n  haveI comp_zero : f \u226b gen.\u03c0 = 0 := eq_aux \u25b8 H\r\n  { generators := gen\r\n    relations :=\r\n      { I := \u03b9\r\n        s := (kernel gen.\u03c0).freeHomEquiv <| kernel.lift gen.\u03c0 f comp_zero\r\n        epi := by\r\n          let h : cokernel f \u2245 M := (H'.coconePointUniqueUpToIso (colimit.is",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2606,
      "before_code": "end",
      "suggestion": "\r\ndef Presentation.isColimit {M : SheafOfModules.{u} R} (P : Presentation M) :\r\n    IsColimit (CokernelCofork.of\u03c0\r\n      (f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))\r\n      P.generators.\u03c0 (by simp)) :=\r\n  isCokernelEpiComp (c := CokernelCofork.of\u03c0 _ (kernel.condition P.generators.\u03c0))\r\n      (Abelian.epiIsCokernelOfKernel _ <| limit.isLimit _) _ rfl\r\n",
      "body": "I find it a bit akward to state things using this Sigma-type given that here all the data are explicit and already known:\r\n\r\n```suggestion\r\ndef Presentation.isColimit {M : SheafOfModules.{u} R} (P : Presentation M) :\r\n    IsColimit (CokernelCofork.of\u03c0\r\n      (f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))\r\n      P.generators.\u03c0 (by simp)) :=\r\n  isCokernelEpiComp (c := CokernelCofork.of\u03c0 _ (kernel.condition P.generators.\u03c0))\r\n      (Abelian.epiIsCokernelOfKernel _ <| limit.isLimit _) _ rf",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2607,
      "before_code": "end",
      "suggestion": "\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map f \u226b\r\n    (PreservesCoproduct.iso F _).hom \u226b (Sigma.mapIso fun b \u21a6 hf').hom\r\n  letI g_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map g\r\n  haveI H' : f_new \u226b g_new = 0 := by\r\n    simp_rw [f_new, g_new, Category.assoc, Iso.hom_inv_id_assoc,\r\n      Preadditive.IsIso.comp_left_eq_zero, IsHomLift.eq_of_isHomLift F (F.map f \u226b F.map g) (f \u226b g),\r\n      H, Functor.map_zero]\r\n  letI h' : IsColimit (CokernelCofork.of\u03c0 g_new H') := by\r\n    refine IsColimit.ofIsoColimit ((IsColimit.precomposeHom",
      "body": "This suggestion uses the modification suggested above for `Presentation.isColimit`\r\n\r\n```suggestion\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_ne",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2610,
      "before_code": "end",
      "suggestion": "/-- Given two morphisms of sheaves of `R`-modules `f : free \u03b9 \u27f6 free \u03c3` and `g : free \u03c3 \u27f6 M`\nsatisfying `H : f \u226b g = 0` and `IsColimit (CokernelCofork.of\u03c0 g H)`, we obtain a `Presentation M`. -/\n",
      "body": "```suggestion\n/-- Given two morphisms of sheaves of `R`-modules `f : free \u03b9 \u27f6 free \u03c3` and `g : free \u03c3 \u27f6 M`\nsatisfying `H : f \u226b g = 0` and `IsColimit (CokernelCofork.of\u03c0 g H)`, we obtain a `Presentation M`. -/\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2613,
      "before_code": "end",
      "suggestion": "  letI f := (map_free F hf' P.relations.I).inv \u226b F.map ((freeHomEquiv _).symm P.relations.s) \u226b\n    F.map (kernel.\u03b9 _) \u226b (map_free F hf' P.generators.I).hom\n  letI g := (map_free F hf' P.generators.I).inv \u226b F.map (P.generators.\u03c0)\n  presentationOfIsCokernelFree f g (by simp [f, g, \u2190 Functor.map_comp]) <|\n    cokernel.cokernelIso f g ((((cokernel.mapIso (F.map\n      ((freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))) f\n        (map_free F hf' P.relations.I) (map_free F hf' P.generators.I) (by simp [f])).symm) \u226a\u226b\n          (Limits.PreservesCokernel.iso F ((freeHomEquiv _).symm P.relations.s \u226b\n            (kernel.\u03b9 _))).symm) \u226a\u226b F.mapIso (Limits.IsColimit.coconePointUniqueUpToIso\n              (colimit.isColimit _) P.isColimit)) (by simp [\u2190 Functor.map_comp, g])\n",
      "body": "```suggestion\n  letI f := (map_free F hf' P.relations.I).inv \u226b F.map ((freeHomEquiv _).symm P.relations.s) \u226b\n    F.map (kernel.\u03b9 _) \u226b (map_free F hf' P.generators.I).hom\n  letI g := (map_free F hf' P.generators.I).inv \u226b F.map (P.generators.\u03c0)\n  presentationOfIsCokernelFree f g (by simp [f, g, \u2190 Functor.map_comp]) <|\n    cokernel.cokernelIso f g ((((cokernel.mapIso (F.map\n      ((freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))) f\n        (map_free F hf' P.relations.I) (map_free F hf' P.generat",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2635,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "    have : (2 * X * T R (n + 1)).degree = \u2191(n + 2) := by\n      change (C 2 * X * T R (n + 1)).degree = \u2191(n + 2)\n      rw [mul_assoc, degree_C_mul (NeZero.ne 2), mul_comm, degree_mul_X, ih1]\n      rfl\n    rw [T_add_two, degree_sub_eq_left_of_degree_lt]\n    \u00b7 rw [this]; rfl\n    \u00b7 rw [ih2, this]; tauto\n  | neg n ih => simp [ih]\n",
      "body": "```suggestion\n    have : (2 * X * T R (n + 1)).degree = \u2191(n + 2) := by\n      change (C 2 * X * T R (n + 1)).degree = \u2191(n + 2)\n      rw [mul_assoc, degree_C_mul (NeZero.ne 2), mul_comm, degree_mul_X, ih1]\n      rfl\n    rw [T_add_two, degree_sub_eq_left_of_degree_lt]\n    \u00b7 rw [this]; rfl\n    \u00b7 rw [ih2, this]; tauto\n  | neg n ih => simp [ih]\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 2636,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "      rw [mul_assoc, degree_C_mul (NeZero.ne 2), mul_comm, degree_mul_X, degree_T, degree_T]\n      tauto\n  | neg n ih => simp [ih]\n",
      "body": "```suggestion\n      rw [mul_assoc, degree_C_mul (NeZero.ne 2), mul_comm, degree_mul_X, degree_T, degree_T]\n      tauto\n  | neg n ih => simp [ih]\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 2637,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "  | neg n ih => simp [ih]\n",
      "body": "```suggestion\n  | neg n ih => simp [ih]\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 2638,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "    \u00b7 simp only [T_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, ih1, Int.negOnePow_add,\n        Int.negOnePow_one, Units.val_neg, Int.cast_neg, ih2, Int.negOnePow_even 2 even_two]\n      ring_nf\n",
      "body": "Avoid non-terminal `simp`:\n\n```suggestion\n    \u00b7 simp only [T_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, ih1, Int.negOnePow_add,\n        Int.negOnePow_one, Units.val_neg, Int.cast_neg, ih2, Int.negOnePow_even 2 even_two]\n      ring_nf\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "ring_nf",
          "simp"
        ],
        "body_tactics": [
          "ring_nf",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "ring_nf"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 2640,
      "before_code": "sum_insert (notMem_singleton.mpr hxy), sum_singleton, basis_pair_left hxy,\n    basis_pair_right hxy, id, id]",
      "suggestion": "  have : (\u220f j \u2208 s.erase i, (X - C (v j))).coeff (#s - 1) = 1 := by\n    simpa [hi] using (monic_prod_X_sub_C v (s.erase i)).coeff_natDegree\n  simp_rw [leadingCoeff, natDegree_basis hvs hi, Lagrange.basis]\n  simp [basisDivisor, Finset.prod_mul_distrib, \u2190 map_prod, this]\n",
      "body": "```suggestion\n  have : (\u220f j \u2208 s.erase i, (X - C (v j))).coeff (#s - 1) = 1 := by\n    simpa [hi] using (monic_prod_X_sub_C v (s.erase i)).coeff_natDegree\n  simp_rw [leadingCoeff, natDegree_basis hvs hi, Lagrange.basis]\n  simp [basisDivisor, Finset.prod_mul_distrib, \u2190 map_prod, this]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "basis_pair_left",
          "sum_singleton",
          "notMem_singleton",
          "basis_pair_right",
          "hxy",
          "sum_insert"
        ]
      }
    },
    {
      "id": 2641,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  \u00b7 rwa [ht]\n  \u00b7 intro x hx\n    obtain \u27e8i, hi, rfl\u27e9 := Finset.mem_image.mp hx\n    rw [eval_interpolate_at_node _ hvs hi]\n",
      "body": "```suggestion\n  \u00b7 rwa [ht]\n  \u00b7 intro x hx\n    obtain \u27e8i, hi, rfl\u27e9 := Finset.mem_image.mp hx\n    rw [eval_interpolate_at_node _ hvs hi]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "obtain",
          "rw",
          "intro"
        ],
        "body_tactics": [
          "obtain",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 2643,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n",
      "body": "```suggestion\n    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind",
          "simp_all",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp_all",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "simp_all",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 2644,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n",
      "body": "```suggestion\n  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind",
          "have",
          "simp_all"
        ],
        "body_tactics": [
          "grind",
          "have",
          "simp_all"
        ],
        "new_tactics": [
          "grind",
          "simp_all",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 2662,
      "before_code": "def limitConeIsLimit {J : Type v} [SmallCategory J] (F : J \u2964 CompHaus.{max v u}) :\n    Limits.IsLimit.{v} (limitCone.{v,u} F) :=\n  letI FF : J \u2964 TopCat := F \u22d9 compHausToTop\n  { lift := fun S => (TopCat.limitConeIsLimit FF).lift (compHausToTop.mapCone S)\n    fac := fun S => (TopCat.limitConeIsLimit FF).fac (compHausToTop.mapCone S)\n    uniq := fun S => (TopCat.limitConeIsLimit FF).uniq (compHausToTop.mapCone S) }",
      "suggestion": "        simp [\u2190 hm]\n        rfl )) }\n",
      "body": "```suggestion\n        simp [\u2190 hm]\n        rfl )) }\n```",
      "path": "Mathlib/Topology/Category/CompHaus/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fac",
          "letI",
          "Limits",
          "def",
          "uniq",
          "Type",
          "SmallCategory",
          "IsLimit",
          "lift",
          "limitCone",
          "CompHaus",
          "mapCone",
          "max",
          "compHausToTop",
          "TopCat",
          "limitConeIsLimit"
        ]
      }
    },
    {
      "id": 2663,
      "before_code": "(F : J \u2964 LightProfinite.{max u v}) :\n    Limits.IsLimit (limitCone F) where\n  lift S :=\n    (CompHaus.limitConeIsLimit.{v, u} (F \u22d9 lightProfiniteToCompHaus)).lift\n      (lightProfiniteToCompHaus.mapCone S)\n  uniq S _ h := (CompHaus.limitConeIsLimit.{v, u} _).uniq (lightProfiniteToCompHaus.mapCone S) _ h",
      "suggestion": "    simp [\u2190 h]\n",
      "body": "```suggestion\n    simp [\u2190 h]\n```",
      "path": "Mathlib/Topology/Category/LightProfinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Limits",
          "uniq",
          "IsLimit",
          "lift",
          "limitCone",
          "LightProfinite",
          "mapCone",
          "max",
          "CompHaus",
          "limitConeIsLimit",
          "lightProfiniteToCompHaus"
        ]
      }
    },
    {
      "id": 2664,
      "before_code": "def limitConeIsLimit {J : Type v} [SmallCategory J] (F : J \u2964 Profinite.{max u v}) :\n    Limits.IsLimit (limitCone F) where\n  lift S :=\n    (CompHaus.limitConeIsLimit.{v, u} (F \u22d9 profiniteToCompHaus)).lift\n      (profiniteToCompHaus.mapCone S)\n  uniq S _ h := (CompHaus.limitConeIsLimit.{v, u} _).uniq (profiniteToCompHaus.mapCone S) _ h",
      "suggestion": "          simp [\u2190 h]\n          rfl))\n",
      "body": "```suggestion\n          simp [\u2190 h]\n          rfl))\n```",
      "path": "Mathlib/Topology/Category/Profinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "profiniteToCompHaus",
          "Limits",
          "def",
          "uniq",
          "Type",
          "SmallCategory",
          "IsLimit",
          "lift",
          "Profinite",
          "limitCone",
          "mapCone",
          "max",
          "CompHaus",
          "limitConeIsLimit"
        ]
      }
    },
    {
      "id": 2665,
      "before_code": "-- TODO: generalize to `InducedCategory.forget\u2082_full`?\ninstance forgetToTop_full : (forget\u2082 AlexDisc TopCat).Full where\n  map_surjective f := \u27e8f, rfl\u27e9\n\ninstance forgetToTop_faithful : (forget\u2082 AlexDisc TopCat).Faithful where",
      "suggestion": "    exact ConcreteCategory.congr_hom h x\n",
      "body": "```suggestion\n    exact ConcreteCategory.congr_hom h x\n```",
      "path": "Mathlib/Topology/Order/Category/AlexDisc.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "forgetToTop_full",
          "map_surjective",
          "Faithful",
          "AlexDisc",
          "generalize",
          "forgetToTop_faithful",
          "rfl",
          "TopCat",
          "instance",
          "Full",
          "InducedCategory",
          "TODO"
        ]
      }
    },
    {
      "id": 2668,
      "before_code": "\u00b7 rw [\u2190 P.finrank_corootSpan_eq', h, finrank_top, P.toPerfPair.finrank_eq,\n      Subspace.dual_finrank_eq]",
      "suggestion": "@[simp]\nlemma polarizationEquiv_apply (m : M) :\n",
      "body": "Should this be simp, or did you leave the attr out for a reason? (If so, maybe add a short comment.)\n```suggestion\n@[simp]\nlemma polarizationEquiv_apply (m : M) :\n```",
      "path": "Mathlib/LinearAlgebra/RootSystem/Finite/Nondegenerate.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Subspace",
          "toPerfPair",
          "finrank_eq",
          "dual_finrank_eq",
          "finrank_corootSpan_eq",
          "finrank_top"
        ]
      }
    },
    {
      "id": 2670,
      "before_code": "intro x hx\n  simp [hx]",
      "suggestion": "  have h\u2081' := h\u2081.to_subtype\n  have h\u2082 : IsOpen s := isOpen_analyticAt \ud835\udd5c f\n  have h\u2083 : ContinuousOn f s := fun z hz \u21a6 hz.continuousAt.continuousWithinAt\n  exact .of_union_range_cover (.subtype_coe h\u2082.measurableSet) (.subtype_coe h\u2081.measurableSet)\n    (by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n",
      "body": "I think this is easier. If `s` is a measurable set, and `f` is measurable on both `s` and `s\u1d9c` (the former because it's continuous there, the latter because `s\u1d9c` is countable), then `f` is measurable.\n```suggestion\n  have h\u2081' := h\u2081.to_subtype\n  have h\u2082 : IsOpen s := isOpen_analyticAt \ud835\udd5c f\n  have h\u2083 : ContinuousOn f s := fun z hz \u21a6 hz.continuousAt.continuousWithinAt\n  exact .of_union_range_cover (.subtype_coe h\u2082.measurableSet) (.subtype_coe h\u2081.measurableSet)\n    (by simp [- mem_compl_iff]) h\u2083.rest",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "have"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "intro"
        ]
      }
    },
    {
      "id": 2687,
      "before_code": "variable [NonAssocRing R] [Pow R \u2115] [BinomialRing R]",
      "suggestion": "  congr\n  abel\n",
      "body": "I realize it's longer, but `abel` is meant to be a finishing tactic.\n```suggestion\n  congr\n  abel\n```",
      "path": "Mathlib/RingTheory/Binomial.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr"
        ],
        "body_tactics": [
          "congr"
        ],
        "new_tactics": [
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "Pow",
          "NonAssocRing",
          "variable",
          "BinomialRing"
        ]
      }
    },
    {
      "id": 2704,
      "before_code": "rw [norm_pow, norm_norm, one_mul, add_pow_two]\n    exact le_add_of_nonneg_left (by positivity)",
      "suggestion": "    rintro - \u27e8y, rfl\u27e9\n    simp only [Set.mem_setOf_eq, t]\n    exact lt_add_of_lt_add_left (c := 0) (by norm_num) (by positivity)\n  have hdiff : ContDiffOn \u211d \u221e (fun x \u21a6 x ^ r) t :=\n    contDiffOn_id.rpow_const_of_ne fun x hx \u21a6 (lt_trans (by norm_num) hx).ne'\n",
      "body": "```suggestion\n    rintro - \u27e8y, rfl\u27e9\n    simp only [Set.mem_setOf_eq, t]\n    exact lt_add_of_lt_add_left (c := 0) (by norm_num) (by positivity)\n  have hdiff : ContDiffOn \u211d \u221e (fun x \u21a6 x ^ r) t :=\n    contDiffOn_id.rpow_const_of_ne fun x hx \u21a6 (lt_trans (by norm_num) hx).ne'\n```",
      "path": "Mathlib/Analysis/Distribution/TemperateGrowth.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "suggestion_tactics": [
          "norm_num",
          "positivity",
          "exact",
          "have",
          "simp"
        ],
        "body_tactics": [
          "norm_num",
          "positivity",
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "norm_num",
          "simp",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "norm_pow",
          "positivity",
          "le_add_of_nonneg_left",
          "add_pow_two",
          "exact",
          "norm_norm",
          "one_mul"
        ]
      }
    },
    {
      "id": 2734,
      "before_code": "def map (\u03b1 : F \u27f6 G) : \u222b\u1d9c F \u2964 \u222b\u1d9c G where\n  obj a := {\n    base := a.base\n    fiber := (\u03b1.app \u27e8op a.base\u27e9).obj a.fiber }\n  map {a b} f := {\n    base := f.1\n    fiber := (\u03b1.app \u27e8op a.base\u27e9).map f.2 \u226b (\u03b1.naturality f.1.op.toLoc).hom.app b.fiber }\n  map_id a := by\n    ext1\n    \u00b7 dsimp\n    \u00b7 simp [StrongTrans.naturality_id_hom_app, \u2190 Functor.map_comp_assoc]\n  map_comp {a b c} f g := by\n    ext\n    \u00b7 dsimp\n    \u00b7 dsimp\n      simp only [StrongTrans.naturality_comp_hom_app, map_comp, assoc, comp_id]\n      slice_lhs 2 4 => simp only [\u2190 Functor.map_comp, Iso.inv_hom_id_app, Cat.comp_obj, comp_id]\n      simp [\u2190 Functor.comp_map]",
      "suggestion": "      slice_lhs 2 4 => simp [\u2190 Cat.Hom.toNatIso_inv, Cat.Hom.comp_toFunctor,\n        \u2190 Cat.Hom.toNatIso_hom, \u2190 map_comp, Iso.inv_hom_id_app, comp_obj, map_id, comp_id]\n      simp only [assoc, \u2190 reassoc_of% Cat.Hom.comp_map, \n        (\u03b1.naturality f.base.op.toLoc).hom.toNatTrans.naturality_assoc]\n",
      "body": "```suggestion\n      slice_lhs 2 4 => simp [\u2190 Cat.Hom.toNatIso_inv, Cat.Hom.comp_toFunctor,\n        \u2190 Cat.Hom.toNatIso_hom, \u2190 map_comp, Iso.inv_hom_id_app, comp_obj, map_id, comp_id]\n      simp only [assoc, \u2190 reassoc_of% Cat.Hom.comp_map, \n        (\u03b1.naturality f.base.op.toLoc).hom.toNatTrans.naturality_assoc]\n```",
      "path": "Mathlib/CategoryTheory/Bicategory/Grothendieck.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "hom",
          "comp_id",
          "StrongTrans",
          "base",
          "inv_hom_id_app",
          "assoc",
          "comp_map",
          "ext",
          "map_comp",
          "map",
          "toLoc",
          "Iso",
          "ext1",
          "naturality_comp_hom_app",
          "def",
          "Functor",
          "Cat",
          "app",
          "naturality",
          "naturality_id_hom_app",
          "simp",
          "dsimp",
          "only",
          "obj",
          "map_id",
          "fiber",
          "slice_lhs",
          "comp_obj",
          "map_comp_assoc"
        ]
      }
    },
    {
      "id": 2736,
      "before_code": "# Stieltjes measures on the real line\n\nConsider a function `f : \u211d \u2192 \u211d` which is monotone and right-continuous. Then one can define a\ncorresponding measure, giving mass `f b - f a` to the interval `(a, b]`.\n\n## Main definitions\n\n* `StieltjesFunction` is a structure containing a function from `\u211d \u2192 \u211d`, together with the\n  assertions that it is monotone and right-continuous. To `f : StieltjesFunction`, one associates\n  a Borel measure `f.measure`.\n* `f.measure_Ioc` asserts that `f.measure (Ioc a b) = ofReal (f b - f a)`\n* `f.measure_Ioo` asserts that `f.measure (Ioo a b) = ofReal (leftLim f b - f a)`.\n* `f.measure_Icc` and `f.measure_Ico` are analogous.\n-/\n\n@[expose] public section\n\nnoncomputable section\n\nopen Set Filter Function ENNReal NNReal Topology MeasureTheory\n\nopen ENNReal (ofReal)",
      "suggestion": "  \u00b7 simp\n\nlemma notMem_botSet_of_lt {x y : R} (h : x < y) : y \u2209 botSet := by\n",
      "body": "```suggestion\n  \u00b7 simp\n\nlemma notMem_botSet_of_lt {x y : R} (h : x < y) : y \u2209 botSet := by\n```",
      "path": "Mathlib/MeasureTheory/Measure/Stieltjes.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "list",
          "set_theory",
          "order",
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "analogous",
          "expose",
          "Topology",
          "real",
          "leftLim",
          "which",
          "associates",
          "ofReal",
          "giving",
          "measure_Icc",
          "assertions",
          "Main",
          "Function",
          "Ioo",
          "open",
          "section",
          "measures",
          "right",
          "noncomputable",
          "asserts",
          "monotone",
          "corresponding",
          "structure",
          "Filter",
          "are",
          "measure_Ioc",
          "one",
          "can",
          "public",
          "together",
          "definitions",
          "measure_Ioo",
          "that",
          "measure_Ico",
          "mass",
          "line",
          "Consider",
          "ENNReal",
          "function",
          "Borel",
          "StieltjesFunction",
          "Set",
          "Stieltjes",
          "continuous",
          "measure",
          "MeasureTheory",
          "Then",
          "Ioc",
          "from",
          "interval"
        ]
      }
    },
    {
      "id": 2743,
      "before_code": "theorem isCompact_generateFrom' [T : TopologicalSpace X]\n    {S : Set (Set X)} (hTS : T = generateFrom S) {s : Set X}\n    (h : \u2200 (\u03b9 : Type u) (U : \u03b9 \u2192 S), s \u2286 \u22c3 i, U i \u2192 \u2203 J : Set \u03b9, J.Finite \u2227 s \u2286 \u22c3 i \u2208 J, U i) :\n    IsCompact s := by\n  apply isCompact_generateFrom hTS\n  intro P hP hs\n  rw [Set.sUnion_eq_iUnion] at hs\n  obtain \u27e8J, hJ, cover\u27e9 := h P (fun a \u21a6 \u27e8a.1, hP a.2\u27e9) hs\n  refine \u27e8(fun x \u21a6 x.1) '' J, \u27e8by simp, Set.Finite.image _ hJ, ?_\u27e9\u27e9\n  simpa only [Set.sUnion_eq_iUnion, Set.iUnion_coe_set, Set.mem_image, Subtype.exists,\n    exists_and_right, exists_eq_right, Set.iUnion_exists] using cover",
      "suggestion": "\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n",
      "body": "```suggestion\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "simpa",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "Subtype",
          "exists_eq_right",
          "Type",
          "obtain",
          "exists",
          "apply",
          "refine",
          "intro",
          "sUnion_eq_iUnion",
          "IsCompact",
          "hTS",
          "TopologicalSpace",
          "exists_and_right",
          "simp",
          "generateFrom",
          "only",
          "isCompact_generateFrom",
          "Finite",
          "cover",
          "mem_image",
          "theorem",
          "Set",
          "iUnion_coe_set",
          "simpa",
          "image",
          "iUnion_exists",
          "using"
        ]
      }
    },
    {
      "id": 2744,
      "before_code": "\u2203 x, ClusterPt x f := by\n  simpa using isCompact_univ (show f \u2264 \ud835\udcdf univ by simp)\n\nnonrec theorem Ultrafilter.le_nhds_lim [CompactSpace X] (F : Ultrafilter X) : \u2191F \u2264 \ud835\udcdd F.lim := by\n  rcases isCompact_univ.ultrafilter_le_nhds F (by simp) with \u27e8x, -, h\u27e9\n  exact le_nhds_lim \u27e8x, h\u27e9\n\ntheorem CompactSpace.elim_nhds_subcover [CompactSpace X] (U : X \u2192 Set X) (hU : \u2200 x, U x \u2208 \ud835\udcdd x) :\n    \u2203 t : Finset X, \u22c3 x \u2208 t, U x = \u22a4 := by\n  obtain \u27e8t, -, s\u27e9 := IsCompact.elim_nhds_subcover isCompact_univ U fun x _ => hU x\n  exact \u27e8t, top_unique s\u27e9",
      "suggestion": "\r\n  have \u27e8t, _, s\u27e9 := isCompact_univ.elim_nhds_subcover U fun x _ \u21a6 hU x\r\n",
      "body": "```suggestion\r\n  have \u27e8t, _, s\u27e9 := isCompact_univ.elim_nhds_subcover U fun x _ \u21a6 hU x\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "topics": [
          "order",
          "finset",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "show",
          "le_nhds_lim",
          "top_unique",
          "rcases",
          "obtain",
          "nonrec",
          "isCompact_univ",
          "Finset",
          "CompactSpace",
          "ClusterPt",
          "elim_nhds_subcover",
          "IsCompact",
          "univ",
          "ultrafilter_le_nhds",
          "simp",
          "lim",
          "theorem",
          "exact",
          "Set",
          "Ultrafilter",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 2767,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
      "suggestion": "theorem house_pow_le (\u03b1 : K) (i : \u2115) : house (\u03b1^i) \u2264 house \u03b1 ^ i := by\n  simpa only [house, map_pow] using norm_pow_le ((canonicalEmbedding K) \u03b1) i\n",
      "body": "```suggestion\ntheorem house_pow_le (\u03b1 : K) (i : \u2115) : house (\u03b1^i) \u2264 house \u03b1 ^ i := by\n  simpa only [house, map_pow] using norm_pow_le ((canonicalEmbedding K) \u03b1) i\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "house",
          "apply",
          "theorem",
          "map_mul",
          "simp",
          "house_mul_le",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2768,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
      "suggestion": "theorem house_nat_mul (\u03b1 : K) (c : \u2115) :\n    house (c * \u03b1) = c * house \u03b1 := by\n  rw [house_eq_sup', house_eq_sup', Finset.sup'_eq_sup, Finset.sup'_eq_sup]\n  norm_cast\n  simp [NNReal.mul_finset_sup]\n",
      "body": "```suggestion\ntheorem house_nat_mul (\u03b1 : K) (c : \u2115) :\n    house (c * \u03b1) = c * house \u03b1 := by\n  rw [house_eq_sup', house_eq_sup', Finset.sup'_eq_sup, Finset.sup'_eq_sup]\n  norm_cast\n  simp [NNReal.mul_finset_sup]\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "rw",
          "norm_cast"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "theorem",
          "map_mul",
          "simp",
          "house_mul_le",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2769,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
      "suggestion": "theorem house_num_mul_int (\u03b1 : K) (c' : \u2124) (hc : 0 \u2264 c') :\n    house ((c' : K) * \u03b1) = |(c' : \u211d)| * house (\u03b1) := by\n  lift c' to \u2115 using hc\n  simpa using house_nat_mul \u03b1 c'\n",
      "body": "You can use the `lift` tactic in a situation like this.\n```suggestion\ntheorem house_num_mul_int (\u03b1 : K) (c' : \u2124) (hc : 0 \u2264 c') :\n    house ((c' : K) * \u03b1) = |(c' : \u211d)| * house (\u03b1) := by\n  lift c' to \u2115 using hc\n  simpa using house_nat_mul \u03b1 c'\n```\nSo I think you can drop this lemma.\n\n```suggestion\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "house",
          "apply",
          "theorem",
          "map_mul",
          "simp",
          "house_mul_le",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2770,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "/-- Let `\u03b1` be a non-zero algebraic integer. Then `\u03b1` has a conjugate `\u03c3 \u03b1` with `\u2016\u03c3 \u03b1\u2016 \u2265 1`. -/\nlemma exists_conjugate_one_le_norm {\u03b1 : \ud835\udcde K} (h\u03b10 : \u03b1 \u2260 0) :\n    \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016 := by\n  obtain \u27e8w, hw\u27e9 : \u2203 w : InfinitePlace K, 1 \u2264 w \u03b1 := by\n    by_contra! h_neg\n    let w\u2080 := Classical.arbitrary (InfinitePlace K)\n    have h_ge_one : 1 \u2264 w\u2080 \u03b1 := InfinitePlace.one_le_of_lt_one h\u03b10 (fun z _ \u21a6 h_neg z)\n    exact (h_neg w\u2080).not_ge h_ge_one\n  use w.embedding\n  rwa [InfinitePlace.norm_embedding_eq]\n",
      "body": "```suggestion\n/-- Let `\u03b1` be a non-zero algebraic integer. Then `\u03b1` has a conjugate `\u03c3 \u03b1` with `\u2016\u03c3 \u03b1\u2016 \u2265 1`. -/\nlemma exists_conjugate_one_le_norm {\u03b1 : \ud835\udcde K} (h\u03b10 : \u03b1 \u2260 0) :\n    \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016 := by\n  obtain \u27e8w, hw\u27e9 : \u2203 w : InfinitePlace K, 1 \u2264 w \u03b1 := by\n    by_contra! h_neg\n    let w\u2080 := Classical.arbitrary (InfinitePlace K)\n    have h_ge_one : 1 \u2264 w\u2080 \u03b1 := InfinitePlace.one_le_of_lt_one h\u03b10 (fun z _ \u21a6 h_neg z)\n    exact (h_neg w\u2080).not_ge h_ge_one\n  use w.embedding\n  rwa [InfinitePlace.n",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2771,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n",
      "body": "```suggestion\nlemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "rw",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "rw",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2772,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma house_prod_le (s : Finset K) : house (\u220f x \u2208 s, x) \u2264 \u220f x \u2208 s, house x := by\n  simpa [house, map_prod] using Finset.norm_prod_le _ _\n",
      "body": "Please move this right after `house_mul_le`.\n```suggestion\nlemma house_prod_le (s : Finset K) : house (\u220f x \u2208 s, x) \u2264 \u220f x \u2208 s, house x := by\n  simpa [house, map_prod] using Finset.norm_prod_le _ _\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2773,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma norm_embedding_le_house (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) : \u2016\u03c3 \u03b1\u2016 \u2264 house \u03b1 := by\n  rw [house_eq_sup']\n  exact Finset.le_sup' (f := (\u2016\u00b7 \u03b1\u2016\u208a)) (Finset.mem_univ \u03c3)\n",
      "body": "```suggestion\nlemma norm_embedding_le_house (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) : \u2016\u03c3 \u03b1\u2016 \u2264 house \u03b1 := by\n  rw [house_eq_sup']\n  exact Finset.le_sup' (f := (\u2016\u00b7 \u03b1\u2016\u208a)) (Finset.mem_univ \u03c3)\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2775,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma norm_norm_le_norm_mul_house_pow (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) :\n    \u2016Algebra.norm \u211a \u03b1\u2016 \u2264 \u2016\u03c3 \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by\n  classical\n  set \u03c3' := \u03c3.toRatAlgHom\n  calc _ = \u2016\u220f \u03c4 : K \u2192\u2090[\u211a] \u2102, \u03c4 \u03b1\u2016 := ?_\n       _ = \u2016(\u03c3' \u03b1) * \u220f \u03c4 \u2208 univ.erase \u03c3', \u03c4 \u03b1\u2016 := by rw [mul_prod_erase univ (\u00b7 \u03b1) (mem_univ \u03c3')]\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', \u2016\u03c4 \u03b1\u2016 := ?_\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', house \u03b1 := by gcongr; apply norm_embedding_le_house\n       _ = \u2016\u03c3' \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by simp\n  \u00b7 rw [\u2190 Algebra.norm_eq_prod_embeddings, \u2190 Rat.norm_cast_real,\n      Real.norm_eq_abs, eq_ratCast, Complex.norm_ratCast]\n  \u00b7 rw [Complex.norm_mul]\n    gcongr\n    exact norm_prod_le (univ.erase \u03c3') (\u00b7 \u03b1)\n",
      "body": "```suggestion\nlemma norm_norm_le_norm_mul_house_pow (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) :\n    \u2016Algebra.norm \u211a \u03b1\u2016 \u2264 \u2016\u03c3 \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by\n  classical\n  set \u03c3' := \u03c3.toRatAlgHom\n  calc _ = \u2016\u220f \u03c4 : K \u2192\u2090[\u211a] \u2102, \u03c4 \u03b1\u2016 := ?_\n       _ = \u2016(\u03c3' \u03b1) * \u220f \u03c4 \u2208 univ.erase \u03c3', \u03c4 \u03b1\u2016 := by rw [mul_prod_erase univ (\u00b7 \u03b1) (mem_univ \u03c3')]\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', \u2016\u03c4 \u03b1\u2016 := ?_\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', house \u03b1 := by gcongr; apply norm_embedding_le_house\n       _ = \u2016\u03c3' \u03b1\u2016 * house \u03b1 ",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "gcongr",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2776,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "    suffices B x y \u2264 0 by simpa [hc, \u2190 hB.le_zero_iff, B.toQuadraticMap_apply]\n    suffices 0 \u2264 \u2211 x \u2208 s with c x < 0, \u2211 i \u2208 s with 0 \u2264 c i, c x * (c i * (B (v i)) (v x)) by\n      simpa [hx, hy, map_neg, Finset.mul_sum]\n",
      "body": "```suggestion\n    suffices B x y \u2264 0 by simpa [hc, \u2190 hB.le_zero_iff, B.toQuadraticMap_apply]\n    suffices 0 \u2264 \u2211 x \u2208 s with c x < 0, \u2211 i \u2208 s with 0 \u2264 c i, c x * (c i * (B (v i)) (v x)) by\n      simpa [hx, hy, map_neg, Finset.mul_sum]\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 2777,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "  rw [\u2190 s.sum_filter_add_sum_filter_not (p := fun i \u21a6 0 \u2264 c i), add_eq_zero_iff_eq_neg] at hc\n  set x := \u2211 i \u2208 s with 0 \u2264 c i, c i \u2022 v i with hx\n  set y := \u2211 i \u2208 s with c i < 0, (-c i) \u2022 v i with hy\n  replace hc : x = y := by simpa [hy] using hc\n",
      "body": "Extreme nitpicking\n```suggestion\n  rw [\u2190 s.sum_filter_add_sum_filter_not (p := fun i \u21a6 0 \u2264 c i), add_eq_zero_iff_eq_neg] at hc\n  set x := \u2211 i \u2208 s with 0 \u2264 c i, c i \u2022 v i with hx\n  set y := \u2211 i \u2208 s with c i < 0, (-c i) \u2022 v i with hy\n  replace hc : x = y := by simpa [hy] using hc\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 2778,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "  apply_fun f at hx hy\n  replace hx : \u2211 i \u2208 s with 0 \u2264 c i, c i * f (v i) = 0 := by simpa [hx\u2080] using hx.symm\n  replace hy : \u2211 i \u2208 s with c i < 0, c i * f (v i) = 0 := by simpa [\u2190 hc, hx\u2080] using hy.symm\n  replace hx (i : \u03b9) (hi : i \u2208 s) : c i \u2264 0 := by\n    rw [Finset.sum_eq_zero_iff_of_nonneg (by grind [mul_nonneg])] at hx\n    by_contra! hi'\n    grind [mul_pos hi' (hp i)]\n  replace hy (i : \u03b9) (hi : i \u2208 s) : 0 \u2264 c i := by\n    rw [Finset.sum_eq_zero_iff_of_nonpos (by grind [mul_nonpos_of_nonpos_of_nonneg])] at hy\n    by_contra! hi'\n    grind [mul_neg_of_neg_of_pos hi' (hp i)]\n",
      "body": "```suggestion\n  apply_fun f at hx hy\n  replace hx : \u2211 i \u2208 s with 0 \u2264 c i, c i * f (v i) = 0 := by simpa [hx\u2080] using hx.symm\n  replace hy : \u2211 i \u2208 s with c i < 0, c i * f (v i) = 0 := by simpa [\u2190 hc, hx\u2080] using hy.symm\n  replace hx (i : \u03b9) (hi : i \u2208 s) : c i \u2264 0 := by\n    rw [Finset.sum_eq_zero_iff_of_nonneg (by grind [mul_nonneg])] at hx\n    by_contra! hi'\n    grind [mul_pos hi' (hp i)]\n  replace hy (i : \u03b9) (hi : i \u2208 s) : 0 \u2264 c i := by\n    rw [Finset.sum_eq_zero_iff_of_nonpos (by grind [mul_nonpo",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 2780,
      "before_code": "variable {G}",
      "suggestion": "\r\n    have : f.NeBot := hf.1\r\n    obtain \u27e8K, K_compact, K_mem\u27e9 := WeaklyLocallyCompactSpace.exists_compact_mem_nhds (1 : G)\r\n    obtain \u27e8x, hx\u27e9 : \u2203 x, \u2200\u1da0 y in f, y / x \u2208 K := by\r\n      rw [cauchy_iff_le, uniformity_eq_comap_nhds_one', \u2190 tendsto_iff_comap] at hf\r\n      exact hf.eventually_mem K_mem |>.curry.exists\r\n    simp_rw [div_eq_mul_inv, \u2190 op_smul_eq_mul, op_inv, \u2190 mem_smul_set_iff_inv_smul_mem] at hx\r\n    have Kx_complete : IsComplete (K <\u2022 x) := K_compact.smul _ |>.isComplete\r\n    obtain \u27e8l, -, hl\u27e9 := Kx_complete f hf (by simpa using hx)\r\n    exact \u27e8l, hl\u27e9\r\n ",
      "body": "Thanks a lot for starting on this! This proof can be cleaned a bit using our filter library, which prevents having to manipulate sets explicitly. I would suggest the following (which needs an `open MulOpposite`) for example:\r\n```suggestion\r\n    have : f.NeBot := hf.1\r\n    obtain \u27e8K, K_compact, K_mem\u27e9 := WeaklyLocallyCompactSpace.exists_compact_mem_nhds (1 : G)\r\n    obtain \u27e8x, hx\u27e9 : \u2203 x, \u2200\u1da0 y in f, y / x \u2208 K := by\r\n      rw [cauchy_iff_le, uniformity_eq_comap_nhds_one', \u2190 tendsto_iff_comap] at hf",
      "path": "Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "rw",
          "exact",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "line_break"
        ],
        "keywords": [
          "variable"
        ]
      }
    },
    {
      "id": 2784,
      "before_code": "end MeasureTheory.Measure",
      "suggestion": "/-- Define a tempered distribution from a L^p function. -/\ndef toTemperedDistribution {p : \u211d\u22650\u221e}\n    [hp : Fact (1 \u2264 p)] (f : Lp F p \u03bc) : \ud835\udce2'(E, F) :=\n  haveI := ENNReal.HolderConjugate.inv_one_sub_inv' hp.out\n  haveI : Fact (1 \u2264 (1 - p\u207b\u00b9)\u207b\u00b9) := by simp [fact_iff]\n  toPointwiseConvergenceCLM _ _ _ _ <|\n    (lsmul \u2102 \u2102).flip.lpPairing \u03bc p (1 - p\u207b\u00b9)\u207b\u00b9 f \u2218L toLpCLM \u2102 \u2102 (1 - p\u207b\u00b9)\u207b\u00b9 \u03bc\n",
      "body": "I suggest instead:\n```suggestion\n/-- Define a tempered distribution from a L^p function. -/\ndef toTemperedDistribution {p : \u211d\u22650\u221e}\n    [hp : Fact (1 \u2264 p)] (f : Lp F p \u03bc) : \ud835\udce2'(E, F) :=\n  haveI := ENNReal.HolderConjugate.inv_one_sub_inv' hp.out\n  haveI : Fact (1 \u2264 (1 - p\u207b\u00b9)\u207b\u00b9) := by simp [fact_iff]\n  toPointwiseConvergenceCLM _ _ _ _ <|\n    (lsmul \u2102 \u2102).flip.lpPairing \u03bc p (1 - p\u207b\u00b9)\u207b\u00b9 f \u2218L toLpCLM \u2102 \u2102 (1 - p\u207b\u00b9)\u207b\u00b9 \u03bc\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "MeasureTheory",
          "Measure"
        ]
      }
    },
    {
      "id": 2785,
      "before_code": "end MeasureTheory.Measure",
      "suggestion": "  \u00b7 exact (Lp.memLp f).locallyIntegrable hp.elim\n  \u00b7 intro g g_smooth g_cpt\n    have hg\u2081 : HasCompactSupport (Complex.ofRealCLM \u2218 g) := g_cpt.comp_left rfl\n",
      "body": "dot notation\n\n```suggestion\n  \u00b7 exact (Lp.memLp f).locallyIntegrable hp.elim\n  \u00b7 intro g g_smooth g_cpt\n    have hg\u2081 : HasCompactSupport (Complex.ofRealCLM \u2218 g) := g_cpt.comp_left rfl\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "have",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "have",
          "intro"
        ],
        "new_tactics": [
          "exact",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "MeasureTheory",
          "Measure"
        ]
      }
    },
    {
      "id": 2834,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  simp [\u2190 degree_preimage_nsmul, hn]\r\n",
      "body": "You are missing the following lemmas\r\n```lean\r\nopen scoped Pointwise in\r\nlemma exists_le_degree_eq {\u03c3 : Type*} (f : \u03c3 \u2192\u2080 \u2115) (n : \u2115) (hn : n \u2264 f.degree) :\r\n    \u2203 g \u2264 f, g.degree = n := by\r\n  induction n with\r\n  | zero => simp [degree_eq_zero_iff]\r\n  | succ n IH =>\r\n    obtain \u27e8g, hgf, rfl\u27e9 := IH (by lia)\r\n    obtain \u27e8f, rfl\u27e9 := le_iff_exists_add.mp hgf\r\n    obtain \u27e8i, hi\u27e9 : f.support.Nonempty := by aesop\r\n    exact \u27e8g + .single i 1, add_le_add_right (by simp; grind) _, by simp\u27e9\r\n\r\nopen scoped Poi",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "exact",
          "grind",
          "obtain",
          "induction",
          "simp_all",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 2835,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  \u00b7 simp [hn]\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [hn]\r\n```\r\nIf you add this as a simp lemma\r\n```lean\r\n@[simp]\r\nlemma Set.Ici_zero {\u03b1 : Type*} [AddZeroClass \u03b1] [Preorder \u03b1] [CanonicallyOrderedAdd \u03b1] :\r\n    Set.Ici (0 : \u03b1) = Set.univ := by aesop\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 2838,
      "before_code": "hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\nend Dense",
      "suggestion": "  \u27e8fun h \u21a6 by simpa using congr($h\u15ee), fun h \u21a6 congr($h\u15ee)\u27e9\n",
      "body": "```suggestion\n  \u27e8fun h \u21a6 by simpa using congr($h\u15ee), fun h \u21a6 congr($h\u15ee)\u27e9\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "congr"
        ],
        "new_tactics": [
          "simpa",
          "congr"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "inner_zero_right",
          "end",
          "Dense",
          "eq_of_inner_right"
        ]
      }
    },
    {
      "id": 2839,
      "before_code": "hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\nend Dense",
      "suggestion": "theorem orthogonal_injective [CompleteSpace E] :\n    Function.Injective (fun K : ClosedSubmodule \ud835\udd5c E \u21a6 K\u15ee) :=\n  (orthogonal_eq_orthogonal_iff \u00b7 \u00b7 |>.mp)\n\n/-- The sup of two orthogonal subspaces equals the subspace orthogonal\nto the inf. -/\ntheorem sup_orthogonal [CompleteSpace E] (K\u2081 K\u2082 : ClosedSubmodule \ud835\udd5c E) :\n    K\u2081\u15ee \u2294 K\u2082\u15ee = (K\u2081 \u2293 K\u2082)\u15ee := by\n  simpa using congr($(inf_orthogonal K\u2081\u15ee K\u2082\u15ee)\u15ee).symm\n",
      "body": "Here's a another `simpa` proof, and let's have this `orthogonal_injective` lemma too.\n```suggestion\ntheorem orthogonal_injective [CompleteSpace E] :\n    Function.Injective (fun K : ClosedSubmodule \ud835\udd5c E \u21a6 K\u15ee) :=\n  (orthogonal_eq_orthogonal_iff \u00b7 \u00b7 |>.mp)\n\n/-- The sup of two orthogonal subspaces equals the subspace orthogonal\nto the inf. -/\ntheorem sup_orthogonal [CompleteSpace E] (K\u2081 K\u2082 : ClosedSubmodule \ud835\udd5c E) :\n    K\u2081\u15ee \u2294 K\u2082\u15ee = (K\u2081 \u2293 K\u2082)\u15ee := by\n  simpa using congr($(inf_orthogonal K\u2081\u15ee K\u2082\u15ee)\u15ee).symm\n`",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "congr",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "congr"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "inner_zero_right",
          "end",
          "Dense",
          "eq_of_inner_right"
        ]
      }
    },
    {
      "id": 2840,
      "before_code": "theorem continuous_closure : Continuous (Closeds.closure (\u03b1 := \u03b1)) :=\n  uniformContinuous_closure.continuous",
      "suggestion": "instance [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) where\n  isCompact_univ := by simpa [gi.l_surjective.range_eq]\n    using isCompact_univ.image continuous_closure\n",
      "body": "```suggestion\ninstance [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) where\n  isCompact_univ := by simpa [gi.l_surjective.range_eq]\n    using isCompact_univ.image continuous_closure\n```",
      "path": "Mathlib/Topology/UniformSpace/Closeds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "theorem",
          "closure",
          "continuous_closure",
          "continuous",
          "Closeds",
          "Continuous",
          "uniformContinuous_closure"
        ]
      }
    },
    {
      "id": 2843,
      "before_code": "instance isRegularEpi_of_extremalEpi (f : X \u27f6 Y) [ExtremalEpi f] : IsRegularEpi f :=\n  \u27e8\u27e8regularEpiOfExtremalEpi f\u27e9\u27e9",
      "suggestion": "noncomputable def frobeniusMorphism :\n  underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n  (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip.lift\n    ((ofLE _ _ (inf_le_right A' ((Subobject.pullback f).obj B'))) \u226b (pullback\u03c0 _ _))\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))) \u226b (imageFactorisation f A').F.e)\n    (by simp [\u2190 imageFactorisation_F_m, (isPullback _ _).w])\n\nlemma frobeniusMorphism_isPullback :\n  IsPullback (frobeniusMorphism f A' B')\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))))\n    ((ofLE _ _ (inf_le_left ((\u00abexists\u00bb f).obj A') B')))\n    (imageFactorisation _ _).F.e := by\n  apply IsPullback.of_right (t := (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip)\n    (p := by simp [frobeniusMorphism])\n  simpa [frobeniusMorphism, IsPullback.lift_fst, \u2190 imageFactorisation_F_m,\n    (isPullback f B').paste_horiz_iff ] using\n    (inf_isPullback A' ((Subobject.pullback f).obj B')).flip\n\ninstance : IsRegula",
      "body": "```suggestion\nnoncomputable def frobeniusMorphism :\n  underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n  (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip.lift\n    ((ofLE _ _ (inf_le_right A' ((Subobject.pullback f).obj B'))) \u226b (pullback\u03c0 _ _))\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))) \u226b (imageFactorisation f A').F.e)\n    (by simp [\u2190 imageFactorisation_F_m, (isPullback _ _).w])\n\nlemma frobeniusMorphism_isPullback :\n  IsPullbac",
      "path": "Mathlib/CategoryTheory/RegularCategory/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "rw",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "IsRegularEpi",
          "regularEpiOfExtremalEpi",
          "isRegularEpi_of_extremalEpi",
          "instance",
          "ExtremalEpi"
        ]
      }
    },
    {
      "id": 2845,
      "before_code": "p.darts[i].snd = p.support.tail[i]'(by grind) := by\n  grind [map_snd_darts]",
      "suggestion": "lemma support_getElem_zero (p : G.Walk u v) : p.support[0] = u := by cases p <;> simp\n",
      "body": "```suggestion\nlemma support_getElem_zero (p : G.Walk u v) : p.support[0] = u := by cases p <;> simp\n```\nThis seems to work for me",
      "path": "Mathlib/Combinatorics/SimpleGraph/Walks/Basic.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "grind"
        ],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support",
          "map_snd_darts",
          "grind",
          "tail",
          "snd",
          "darts"
        ]
      }
    },
    {
      "id": 2853,
      "before_code": "\u03c9ScottContinuous.of_monotone_map_\u03c9Sup\n    \u27e8fun _ _ h \u21a6 hf.monotone h a, fun c \u21a6 congr_fun (hf.map_\u03c9Sup c) a\u27e9",
      "suggestion": "\r\nlemma \u03c9ScottContinuous.apply (x : \u03b1) : \u03c9ScottContinuous (fun f : \u2200 x, \u03b2 x \u21a6 f x) :=\r\n",
      "body": "```suggestion\r\nlemma \u03c9ScottContinuous.apply (x : \u03b1) : \u03c9ScottContinuous (fun f : \u2200 x, \u03b2 x \u21a6 f x) :=\r\n```",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "monotone",
          "congr_fun"
        ]
      }
    },
    {
      "id": 2854,
      "before_code": "simpa [map_coe, OrderHom.coe_mk, Set.range_comp]\n    using hf (by simp) (Set.range_nonempty _) (isChain_range c).directedOn (isLUB_range_\u03c9Sup c)",
      "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```\r\nThis way, the `fun_id` lemma is also tagged with fun_prop.",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "OrderHom",
          "range_comp",
          "map_coe",
          "coe_mk",
          "Set",
          "directedOn",
          "simpa",
          "simp",
          "range_nonempty",
          "isChain_range",
          "using"
        ]
      }
    },
    {
      "id": 2855,
      "before_code": "inter_eq_self_of_subset_right (Ici_subset_Ici.2 hab)]\n  exact isLeast_Ici\n\n@[simp] lemma ScottContinuousOn.id : ScottContinuousOn D (id : \u03b1 \u2192 \u03b1) := by simp [ScottContinuousOn]\n\nvariable {g : \u03b1 \u2192 \u03b2}\n\nlemma ScottContinuousOn.prodMk (hD : \u2200 a b : \u03b1, a \u2264 b \u2192 {a, b} \u2208 D)",
      "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```",
      "path": "Mathlib/Order/ScottContinuity.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "continuity",
          "set_theory"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "Ici_subset_Ici",
          "inter_eq_self_of_subset_right",
          "lemma",
          "variable",
          "exact",
          "ScottContinuousOn",
          "hab",
          "isLeast_Ici",
          "simp",
          "prodMk"
        ]
      }
    },
    {
      "id": 2856,
      "before_code": "theorem \u03c9Sup_zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : \u03c9Sup (c\u2080.zip c\u2081) = (\u03c9Sup c\u2080, \u03c9Sup c\u2081) := rfl",
      "suggestion": "    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n",
      "body": "Something like\n```suggestion\n    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n```\nshould work, and then you can remove the `by exact` and (probably) format everything on one line.",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "rfl",
          "Chain",
          "zip",
          "theorem"
        ]
      }
    },
    {
      "id": 2860,
      "before_code": "obtain \u27e8s, rfl\u27e9 := hN\n    induction s using Finset.induction with\n    | empty =>\n      rw [Finset.coe_empty, Submodule.span_empty, \u2190 Submodule.span_zero_singleton]\n      exact h\u2081 _\n    | insert _ _ _ ih =>\n      rw [Finset.coe_insert, Submodule.span_insert]\n      exact h\u2082 _ _ (h\u2081 _) ih\n\ntheorem fg_restrictScalars {R S M : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommMonoid M] [Module S M] [Module R M] [IsScalarTower R S M] (N : Submodule S M)\n    (hfin : N.FG) (h : Function.Surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).FG := by\n  obtain \u27e8X, rfl\u27e9 := hfin\n  use X\n  exact (Submodule.restrictScalars_span R S h (X : Set M)).symm\n\nlemma FG.of_restrictScalars (R) {A M} [Semiring R] [Semiring A] [AddCommMonoid M]\n    [SMul R A] [Module R M] [Module A M] [IsScalarTower R A M] (S : Submodule A M)\n    (hS : (S.restrictScalars R).FG) : S.FG := by\n  obtain \u27e8s, e\u27e9 := hS\n  refine \u27e8s, Submodule.restrictScalars_injective R _ _ (le_antisymm ?_ ?_)\u27e9\n  \u00b7 change Submodule.span A s \u2264 S\n    have := Submodule.span_le.mp e.le\n    rwa [Submodule.span_le]\n  \u00b7 rw [\u2190 e]\n    exact Submodule.span_le_restrictScalars _ _ _\n\ntheorem FG.stabilizes_of_iSup_eq {M' : Submodule R M} (hM' : M'.FG) (N : \u2115 \u2192o Submodule R M)\n    (H : iSup N = M') : \u2203 n, M' = N n := by\n  obtain \u27e8S, hS\u27e9 := hM'\n  have : \u2200 s : S, \u2203 n, (s : M) \u2208 N n := fun s =>\n    (Submodule.mem_iSup_of_chain N s).mp\n      (by\n        rw [H, \u2190 hS]\n        exact Submodule.subset_span s.2)",
      "suggestion": "\r\n  have (s : S) : \u2203 n, (s : M) \u2208 N n :=\r\n    (mem_iSup_of_chain N s).mp (by simpa [H, \u2190 hS] using subset_span s.prop)\r\n",
      "body": "```suggestion\r\n  have (s : S) : \u2203 n, (s : M) \u2208 N n :=\r\n    (mem_iSup_of_chain N s).mp (by simpa [H, \u2190 hS] using subset_span s.prop)\r\n```",
      "path": "Mathlib/RingTheory/Finiteness/Basic.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "induction"
        ],
        "suggestion_tactics": [
          "simpa",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "have"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "refine",
          "exact",
          "obtain",
          "induction",
          "rw"
        ],
        "topics": [
          "function",
          "nat",
          "algebra",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Module",
          "lemma",
          "rwa",
          "fg_restrictScalars",
          "le_antisymm",
          "Type",
          "change",
          "obtain",
          "of_restrictScalars",
          "Function",
          "span_zero_singleton",
          "coe_empty",
          "empty",
          "insert",
          "restrictScalars",
          "symm",
          "refine",
          "span_insert",
          "Finset",
          "have",
          "Submodule",
          "span_empty",
          "mem_iSup_of_chain",
          "span_le_restrictScalars",
          "CommSemiring",
          "restrictScalars_injective",
          "hfin",
          "span",
          "stabilizes_of_iSup_eq",
          "Semiring",
          "induction",
          "rfl",
          "use",
          "subset_span",
          "AddCommMonoid",
          "theorem",
          "IsScalarTower",
          "exact",
          "Set",
          "iSup",
          "coe_insert",
          "restrictScalars_span",
          "SMul",
          "algebraMap",
          "Algebra",
          "Surjective",
          "span_le",
          "using"
        ]
      }
    },
    {
      "id": 2863,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n        rw [\u2190 (DiffContOnCl.circleIntegral_one_div_sub_center_pow_smul hR n hf)]\r\n",
      "body": "Please keep indentation consistent inside `calc` blocks, it aids readability. \r\n\r\nIf you're using `congr` followed by `exact`, it's worth trying whether `rw` (or `simp_rw`, `simp only` etc) can do it in one line:\r\n```suggestion\r\n        rw [\u2190 (DiffContOnCl.circleIntegral_one_div_sub_center_pow_smul hR n hf)]\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 2864,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n      rw [RCLike.norm_nsmul (K := \u2102), nsmul_eq_mul, mul_le_mul_iff_right\u2080 (by positivity)]\r\n      exact circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const hR.le hp\r\n",
      "body": "```suggestion\r\n      rw [RCLike.norm_nsmul (K := \u2102), nsmul_eq_mul, mul_le_mul_iff_right\u2080 (by positivity)]\r\n      exact circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const hR.le hp\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 2865,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n      \u222e z in C(c, R), (z - c)\u207b\u00b9 ^ (n + 1) \u2022 f z\u2016 := by rw [hq]\r\n",
      "body": "Alternative (not saying it's better, matter of taste):\r\n```suggestion\r\n      \u222e z in C(c, R), (z - c)\u207b\u00b9 ^ (n + 1) \u2022 f z\u2016 := by rw [hq]\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 2870,
      "before_code": "simp only [mem_adjoin_iff_div, Algebra.adjoin_singleton_eq_range_aeval,\n    AlgHom.mem_range, exists_exists_eq_and]",
      "suggestion": "\r\ntheorem forall_mem_adjoin_smul_eq_self_iff {M : Type*} [Group M] [MulSemiringAction M E]\r\n    [SMulCommClass M F E] (m : M) :\r\n    (\u2200 x \u2208 adjoin F S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) := by\r\n  refine \u27e8fun h x hx \u21a6 h _ <| mem_adjoin_of_mem F hx, fun h x hx \u21a6 ?_\u27e9\r\n  induction hx using adjoin_induction F <;> simp_all [smul_inv\u2080']\r\n",
      "body": "Here is an almost working suggestion:\r\n```suggestion\r\ntheorem forall_mem_adjoin_smul_eq_self_iff {M : Type*} [Group M] [MulSemiringAction M E]\r\n    [SMulCommClass M F E] (m : M) :\r\n    (\u2200 x \u2208 adjoin F S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) := by\r\n  refine \u27e8fun h x hx \u21a6 h _ <| mem_adjoin_of_mem F hx, fun h x hx \u21a6 ?_\u27e9\r\n  induction hx using adjoin_induction F <;> simp_all [smul_inv\u2080']\r\n```\r\nThe problem is that this requires `M` to be a group because [smul_inv\u2080'](https://leanprover-community.github.io",
      "path": "Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "induction",
          "simp_all"
        ],
        "body_tactics": [
          "refine",
          "induction",
          "simp_all"
        ],
        "new_tactics": [
          "simp_all",
          "induction",
          "refine"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "mem_adjoin_iff_div",
          "mem_range",
          "exists_exists_eq_and",
          "simp",
          "AlgHom",
          "adjoin_singleton_eq_range_aeval",
          "Algebra",
          "only"
        ]
      }
    },
    {
      "id": 2880,
      "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
      "suggestion": "  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n",
      "body": "```suggestion\n  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n```",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "nullMeasurable",
          "g_mble",
          "Set",
          "Countable",
          "Measurable"
        ]
      }
    },
    {
      "id": 2881,
      "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
      "suggestion": "  apply ae_sum_iff.2 (fun n \u21a6 (hD n s hs).trans ?_)\n",
      "body": "```suggestion\n  apply ae_sum_iff.2 (fun n \u21a6 (hD n s hs).trans ?_)\n```",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "nullMeasurable",
          "g_mble",
          "Set",
          "Countable",
          "Measurable"
        ]
      }
    },
    {
      "id": 2887,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  rw [\u2190 isCoatom_stabilizer_iff_preprimitive _ s, stabilizer_coe]\r\n  apply alternatingGroup.isCoatom_stabilizer\r\n  \u00b7 rw [Combination.coe_nonempty_iff]\r\n    exact le_trans (by norm_num) h_three_le\r\n  \u00b7 simp [Set.nonempty_compl, Set.eq_univ_iff_ncard, ncard_eq, hn.ne]\r\n  \u00b7 simpa [ncard_eq]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 isCoatom_stabilizer_iff_preprimitive _ s, stabilizer_coe]\r\n  apply alternatingGroup.isCoatom_stabilizer\r\n  \u00b7 rw [Combination.coe_nonempty_iff]\r\n    exact le_trans (by norm_num) h_three_le\r\n  \u00b7 simp [Set.nonempty_compl, Set.eq_univ_iff_ncard, ncard_eq, hn.ne]\r\n  \u00b7 simpa [ncard_eq]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "norm_num",
          "apply",
          "exact",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "norm_num",
          "apply",
          "exact",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "norm_num",
          "apply",
          "simpa",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 2889,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j :=\n  \u27e8fun hsum i j \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mp (by simpa using hsum) i j,\n    fun heq \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mpr (by simpa using heq)\u27e9\n",
      "body": "```suggestion\n    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j :=\n  \u27e8fun hsum i j \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mp (by simpa using hsum) i j,\n    fun heq \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mpr (by simpa using heq)\u27e9\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 2890,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pred_eq_of_pos hprime.pos\n    -- Derive a vanishing relation with coefficients `\u03b1\u1d62 - \u03b1_{p-1}` and exponents `< n`.\n    have : \u2211 i \u2208 Finset.range (n + 1), \u03b1Nat i * \u03b6 ^ i = 0 := by\n      simpa [show n + 1 = p by omega, \u2190 Fin.sum_univ_eq_sum_range, h\u03b1Nat_val]\n    have : \u2211 i \u2208 Finset.range n, \u03b1Nat i * \u03b6 ^ i - \u03b1Nat n * \u2211 i \u2208 Finset.range n, \u03b6 ^ i = 0 := by\n      rw [Finset.sum_range_succ] at this\n      -- Use the standard relation for primitive roots: `\u03b6^{p-1} = -\u2211_{i<p-1} \u03b6^i`.\n      grind [h\u03b6.pow_sub_one_eq hprime.one_lt]\n    have h",
      "body": "Attempted golfing\n\n```suggestion\n  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pr",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "body_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "new_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_omega",
          "cleanup_simp",
          "use_simpa",
          "use_grind",
          "use_ring"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 2892,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "  refine ext fun x => \u27e8?_, fun \u27e8t, \u27e8i, hi\u27e9, ht\u27e9 \u21a6 ?_\u27e9\n",
      "body": "I suggest you start with this to avoid `;`:\n```suggestion\n  refine ext fun x => \u27e8?_, fun \u27e8t, \u27e8i, hi\u27e9, ht\u27e9 \u21a6 ?_\u27e9\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "ext"
        ],
        "body_tactics": [
          "refine",
          "ext"
        ],
        "new_tactics": [
          "refine",
          "ext"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 2893,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    \u00b7 exact .biUnion (to_countable _) fun _ _ \u21a6 hm _\n",
      "body": "`measurability` tends to be a bit slow so I suggest you replace it with this.\n```suggestion\n    \u00b7 exact .biUnion (to_countable _) fun _ _ \u21a6 hm _\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "measurability"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 2894,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "  \u00b7 refine \u27e8fun n => SimpleFunc.indexedPartitionPiecewise hs hm (fun i => (hf i).approx n),\n      fun x => ?_\u27e9\n    simp [SimpleFunc.indexedPartitionPiecewise, IndexedPartition.piecewise_apply,\n      StronglyMeasurable.tendsto_approx]\n  simp only [not_finite_iff_infinite] at Fi\n",
      "body": "When you have small subgoals followed a main one, it's ok to not put a dot before the last one, so as to avoid too much indentation.\n```suggestion\n  \u00b7 refine \u27e8fun n => SimpleFunc.indexedPartitionPiecewise hs hm (fun i => (hf i).approx n),\n      fun x => ?_\u27e9\n    simp [SimpleFunc.indexedPartitionPiecewise, IndexedPartition.piecewise_apply,\n      StronglyMeasurable.tendsto_approx]\n  simp only [not_finite_iff_infinite] at Fi\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 2895,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "        have : y = (\u27e8y, by lia\u27e9 : Fin (b + 1)).1 := rfl\n",
      "body": "`linarith` should also be replaced by `lia`, can you do so in the rest of the proof as well?\n```suggestion\n        have : y = (\u27e8y, by lia\u27e9 : Fin (b + 1)).1 := rfl\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have",
          "linarith"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 2896,
      "before_code": "@SeparatesPoints _ m' := @SeparatesPoints.mk _ m' fun _ _ hxy \u21a6\n    @SeparatesPoints.separates _ m hsep _ _ fun _ hs \u21a6 hxy _ (h _ hs)",
      "suggestion": "    \u00b7 absurd hx\n      simp [\u2190 mem_preimage, h']\n    \u00b7 absurd hy\n      simp [\u2190 mem_preimage, h']\n  obtain h' | h' := isEmpty_or_nonempty \u03b1\n  \u00b7 use (Classical.ofNonempty : \u03b2), funext (by simp)\n  \u00b7 use f (Classical.ofNonempty : \u03b1), funext (fun x \u21a6 h _ _)\n",
      "body": "I think it's better not to use semicolons here. Also you can avoid `swap` by doing the following (or doing ` by_cases! h' : IsEmpty \u03b1` instead, or just not using `swap` because both proofs are one-liners):\n```suggestion\n    \u00b7 absurd hx\n      simp [\u2190 mem_preimage, h']\n    \u00b7 absurd hy\n      simp [\u2190 mem_preimage, h']\n  obtain h' | h' := isEmpty_or_nonempty \u03b1\n  \u00b7 use (Classical.ofNonempty : \u03b2), funext (by simp)\n  \u00b7 use f (Classical.ofNonempty : \u03b1), funext (fun x \u21a6 h _ _)\n```",
      "path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "SeparatesPoints",
          "hxy",
          "separates",
          "hsep"
        ]
      }
    },
    {
      "id": 2926,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "\r\n  have ha : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\r\n",
      "body": "I'd be inclined to inline this\r\n```suggestion\r\n  have ha : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 2927,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n",
      "body": "```suggestion\n  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n```\na little golf",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "refine",
          "simp",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 2928,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    \u00b7 exact hJ'disj.mono fun _ \u21a6 by simp\n",
      "body": "```suggestion\n    \u00b7 exact hJ'disj.mono fun _ \u21a6 by simp\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 2929,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    \u00b7 exact hJdisj.mono fun _ \u21a6 by simp\n",
      "body": "```suggestion\n    \u00b7 exact hJdisj.mono fun _ \u21a6 by simp\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 2931,
      "before_code": "module\n\npublic import Mathlib.Analysis.SpecialFunctions.Log.Basic",
      "suggestion": "\r\n",
      "body": "This import is redundant, let's not annoy Sebastian by making him do even more `shake` work :)\r\n```suggestion\r\n```",
      "path": "Mathlib/NumberTheory/Height/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "Basic",
          "import",
          "Mathlib",
          "public",
          "module",
          "Log",
          "Analysis",
          "SpecialFunctions"
        ]
      }
    },
    {
      "id": 2933,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n\n/-- An antitone, bounded below sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddBelow_antitone {f : \u2115 \u2192 \u211d} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9\n\n/-- An antitone sequence `f : \u2115 \u2192 \u211d\u22650` has a finite limit. -/\ntheorem tendsto_of_antitone {f : \u2115 \u2192 \u211d\u22650} (h_ant : Antitone f) :\n    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := by\n  have h_bdd_0 : (0 : \u211d) \u2208 lowerBounds (Set.range fun n : \u2115 => (f n : \u211d)) := by\n    rintro r \u27e8n, hn\u27e9\n    simp_rw [\u2190 hn]\n    exact NNReal.coe_nonneg _\n  obtain \u27e8L, hL\u27e9 := Real.tendsto_of_bddBelow_antitone \u27e80, h_bdd_0\u27e9 h_ant\n  have hL0 : 0 \u2264 L :=\n    haveI h_glb : IsGLB (Set.range fun n => (f n : \u211d)) L := isGLB_of_tendsto_atTop h_ant hL\n    (le_isGLB_iff h_glb).mpr h_bdd_0\n  exact \u27e8\u27e8L, hL0\u27e9, NNReal.tendsto_coe.mp hL\u27e9",
      "suggestion": "    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := \u27e8iInf f, tendsto_atTop_ciInf h_ant (by simp)\u27e9\n",
      "body": "```suggestion\n    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := \u27e8iInf f, tendsto_atTop_ciInf h_ant (by simp)\u27e9\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "lowerBounds",
          "mpr",
          "antitone",
          "rintro",
          "obtain",
          "hL0",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "have",
          "isGLB_of_tendsto_atTop",
          "exists_isLUB",
          "Antitone",
          "simp_rw",
          "h_mon",
          "range",
          "Real",
          "exists_isGLB",
          "Tendsto",
          "sequence",
          "IsGLB",
          "tendsto_of_bddAbove_monotone",
          "le_isGLB_iff",
          "tendsto_atTop_isLUB",
          "BddBelow",
          "tendsto_coe",
          "above",
          "bounded",
          "NNReal",
          "h_bdd",
          "below",
          "tendsto_atTop_isGLB",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set",
          "coe_nonneg",
          "h_bdd_0",
          "tendsto_of_bddBelow_antitone",
          "h_glb",
          "tendsto_of_antitone",
          "h_ant",
          "haveI"
        ]
      }
    },
    {
      "id": 2937,
      "before_code": "section Monotone",
      "suggestion": "  obtain rfl : iSup f = B := h_lub.csSup_eq (range_nonempty f)\n",
      "body": "This is a fun trick:\n```suggestion\n  obtain rfl : iSup f = B := h_lub.csSup_eq (range_nonempty f)\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Monotone",
          "section"
        ]
      }
    },
    {
      "id": 2942,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "/-- Composition of intertwining maps. -/\ndef llcomp : IntertwiningMap \u03c3 \u03c4 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c3 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c4 where\n  toFun f :=\n    { toFun g :=\n      { toLinearMap := f.toLinearMap.comp g.toLinearMap\n        isIntertwining' := by simp [f.isIntertwining, g.isIntertwining] }\n      map_add' _ _ := by ext; simp [map_add]\n      map_smul' _ _ := by ext; simp }\n  map_add' _ _ := by ext; simp\n  map_smul' _ _ := by ext; simp\n\nvariable {\u03c1 \u03c3 \u03c4} in\n/-- Composition of intertwining maps.\n\nA convenience variant of `IntertwiningMap.llcomp` for use in dot notation. -/\ndef comp (f : IntertwiningMap \u03c3 \u03c4) (g : IntertwiningMap \u03c1 \u03c3) : IntertwiningMap \u03c1 \u03c4 :=\n  llcomp _ _ _ f g\n",
      "body": "How about we also capture the fact that this operation is bilinear as follows:\n```suggestion\n/-- Composition of intertwining maps. -/\ndef llcomp : IntertwiningMap \u03c3 \u03c4 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c3 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c4 where\n  toFun f :=\n    { toFun g :=\n      { toLinearMap := f.toLinearMap.comp g.toLinearMap\n        isIntertwining' := by simp [f.isIntertwining, g.isIntertwining] }\n      map_add' _ _ := by ext; simp [map_add]\n      map_smul' _ _ := by ext; simp }\n  map_add' _ _ := by ext; simp\n ",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 2943,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "  Algebra.ofModule (fun a f g => rfl) (fun a f g => by ext; simp)\n",
      "body": "If we add `mul_apply` above, this can be just:\n```suggestion\n  Algebra.ofModule (fun a f g => rfl) (fun a f g => by ext; simp)\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 2950,
      "before_code": "rw [\u2190 sub_pos] at hR\n    rcases eq_or_ne x 0 with rfl | hx\n    \u00b7 have A : ContinuousAt (fun p : \u211d \u00d7 E \u21a6 (p.1 - \u2016p.2\u2016) / (p.1 - 1)) (R, 0) :=\n        (continuousAt_fst.sub continuousAt_snd.norm).div\n          (continuousAt_fst.sub continuousAt_const) hR.ne'",
      "suggestion": "\r\n        by fun_prop (disch := grind)\r\n",
      "body": "Can't this be\r\n```suggestion\r\n        by fun_prop (disch := grind)\r\n```\r\nor similar with a weaker discharger?",
      "path": "Mathlib/Analysis/Calculus/BumpFunction/InnerProduct.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "grind",
          "fun_prop"
        ],
        "body_tactics": [
          "grind",
          "fun_prop"
        ],
        "new_tactics": [
          "grind",
          "fun_prop"
        ],
        "removed_tactics": [
          "cases",
          "rw",
          "have"
        ],
        "topics": [
          "continuity",
          "real",
          "list",
          "norm"
        ],
        "transforms": [
          "use_fun_prop",
          "use_grind"
        ],
        "keywords": [
          "sub",
          "ContinuousAt",
          "have",
          "sub_pos",
          "div",
          "continuousAt_fst",
          "rcases",
          "norm",
          "rfl",
          "eq_or_ne",
          "continuousAt_snd",
          "continuousAt_const"
        ]
      }
    },
    {
      "id": 2951,
      "before_code": "g_an.continuousAt.continuousWithinAt.tendsto.norm\n    have : Tendsto (fun z \u21a6 z - x) (\ud835\udcdd[\u2260] x) (\ud835\udcdd[\u2260] 0) := by\n      refine tendsto_nhdsWithin_iff.2 \u27e8?_, ?_\u27e9\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) ({x}\u1d9c) x :=\n          ContinuousAt.continuousWithinAt (by fun_prop)",
      "suggestion": "\r\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) {x}\u1d9c x := by fun_prop\r\n",
      "body": "```suggestion\r\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) {x}\u1d9c x := by fun_prop\r\n```\r\nWhy the brackets?",
      "path": "Mathlib/Analysis/Meromorphic/Order.lean",
      "tags": {
        "before_tactics": [
          "fun_prop",
          "refine",
          "have"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "have"
        ],
        "body_tactics": [
          "fun_prop",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "continuity",
          "norm"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "ContinuousWithinAt",
          "tendsto",
          "refine",
          "tendsto_nhdsWithin_iff",
          "continuousAt",
          "ContinuousAt",
          "have",
          "Tendsto",
          "norm",
          "continuousWithinAt",
          "g_an",
          "fun_prop"
        ]
      }
    },
    {
      "id": 2952,
      "before_code": "congr 1\n      exact (norm_of_nonneg (posf _ _ x hx)).symm\n    \u00b7 refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi\n      refine (Continuous.continuousOn ?_).mul (continuousOn_of_forall_continuousAt fun x hx => ?_)\n      \u00b7 exact continuous_exp.comp (continuous_const.mul continuous_id')\n      \u00b7 exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')",
      "suggestion": "\r\n      refine .mul (by fun_prop)\r\n",
      "body": "```suggestion\r\n      refine .mul (by fun_prop)\r\n```\r\nmaybe?",
      "path": "Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "congr",
          "refine"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "refine"
        ],
        "body_tactics": [
          "fun_prop",
          "refine"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "exact",
          "congr"
        ],
        "topics": [
          "continuity",
          "list",
          "norm",
          "set_theory",
          "measurability"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "mem_Ioi",
          "posf",
          "ContinuousOn",
          "inl",
          "mul",
          "aestronglyMeasurable",
          "symm",
          "continuous_exp",
          "norm_of_nonneg",
          "refine",
          "continuousAt_rpow_const",
          "Continuous",
          "continuous_id",
          "continuousOn_of_forall_continuousAt",
          "continuous_const",
          "comp",
          "measurableSet_Ioi",
          "congr",
          "exact",
          "continuousOn"
        ]
      }
    },
    {
      "id": 2953,
      "before_code": "have : x = (fun \u03b5 : \u211d => mulExpNegMulSq \u03b5 x) 0 := by\n    simp only [mulExpNegMulSq, zero_mul, neg_zero, exp_zero, mul_one]\n  nth_rw 2 [this]\n  apply Continuous.tendsto (Continuous.mul continuous_const (by fun_prop))",
      "suggestion": "\r\n  apply Continuous.tendsto (by fun_prop)\r\n",
      "body": "Unnecessary diff? or maybe\r\n```suggestion\r\n  apply Continuous.tendsto (by fun_prop)\r\n```\r\nworks?",
      "path": "Mathlib/Analysis/SpecialFunctions/MulExpNegMulSq.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "have",
          "simp",
          "fun_prop"
        ],
        "suggestion_tactics": [
          "apply",
          "fun_prop"
        ],
        "body_tactics": [
          "apply",
          "fun_prop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "have"
        ],
        "topics": [
          "continuity",
          "real",
          "list"
        ],
        "transforms": [
          "remove_redundant",
          "use_fun_prop"
        ],
        "keywords": [
          "apply",
          "nth_rw",
          "tendsto",
          "have",
          "this",
          "exp_zero",
          "mulExpNegMulSq",
          "continuous_const",
          "mul_one",
          "neg_zero",
          "simp",
          "Continuous",
          "fun_prop",
          "zero_mul",
          "mul",
          "only"
        ]
      }
    },
    {
      "id": 2977,
      "before_code": "set f' := fun i => (f i : M\u2081 i \u2192\u2097[R] M\u2081' i)\n  rw [\u2190 zero_compLinearMap f', compLinearMap_inj f' fun i => (f i).surjective]",
      "suggestion": "\r\ndef compMultilinearMap (g : MultilinearMap R M\u2081 M\u2082) (f : (i : \u03b9) \u2192 MultilinearMap R (N i) (M\u2081 i)) :\r\n    MultilinearMap R (fun j : \u03a3 i, \u03b2 i \u21a6 N j.fst j.snd) M\u2082 where\r\n  toFun m := g fun i \u21a6 f i (Sigma.curry m i)\r\n  map_update_add' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n  map_update_smul' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n",
      "body": "A few changes and we can do it in a single `intro; classical; simp`:\r\n\r\n* `DecidableEq` is not needed to define `toFun`, so we should add this assumption (with `classical`) only for the proofs.\r\n* We only need to introduce `hDecEqSigma`, the rest is handled by `simp`. Might as well put the hypothesis before the colon (but I would also accept `intro` here).\r\n* `simp only` can do all the rewriting if we hint it what to exactly rewrite. In particular, breaking `[Sigma.apply_curry_update .., Sigma.c",
      "path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "function"
        ],
        "transforms": [
          "cleanup_simp",
          "line_break",
          "remove_redundant"
        ],
        "keywords": [
          "compLinearMap_inj",
          "zero_compLinearMap",
          "surjective",
          "set"
        ]
      }
    },
    {
      "id": 2992,
      "before_code": "\u03bcH[d] (K.orthogonalProjection '' s) \u2264 \u03bcH[d] s := by\n  simpa using K.lipschitzWith_orthogonalProjection.hausdorffMeasure_image_le hs s",
      "suggestion": "\r\n    apply iInf_le_of_le fun _ => {x}\r\n    simpa using hs\r\n",
      "body": "```suggestion\r\n    apply iInf_le_of_le fun _ => {x}\r\n    simpa using hs\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply"
        ],
        "body_tactics": [
          "simpa",
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "orthogonalProjection",
          "simpa",
          "hausdorffMeasure_image_le",
          "lipschitzWith_orthogonalProjection",
          "using"
        ]
      }
    },
    {
      "id": 2993,
      "before_code": "\u03bcH[d] (K.orthogonalProjection '' s) \u2264 \u03bcH[d] s := by\n  simpa using K.lipschitzWith_orthogonalProjection.hausdorffMeasure_image_le hs s",
      "suggestion": "\r\n    refine discreteTopology_iff_isOpen_singleton.mpr fun x => ?_\r\n",
      "body": "```suggestion\r\n    refine discreteTopology_iff_isOpen_singleton.mpr fun x => ?_\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "orthogonalProjection",
          "simpa",
          "hausdorffMeasure_image_le",
          "lipschitzWith_orthogonalProjection",
          "using"
        ]
      }
    },
    {
      "id": 2996,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term\n\n/--\n`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying `apply` operation.",
      "suggestion": "\r\n  * `-synthAssignedInstances` will not synthesize instance implicit arguments if they have been\r\n",
      "body": "The `ApplyConfig` docstring for `synthAssignedInstances` is a bit confusing: it explains what `synthAssignedInstances := true` does, but this is in fact already the case by default. So `-synthAssignedInstances` does the opposite: it does not resynthesize and therefore there is nothing to check.\r\n\r\nBut we can get rid of the \"even\" in this sentence, because that would be confusing.\r\n\r\n```suggestion\r\n  * `-synthAssignedInstances` will not synthesize instance implicit arguments if they have been\r\n``",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "operation",
          "but",
          "open",
          "section",
          "apply",
          "Mathlib",
          "Lean",
          "pass",
          "configuration",
          "ApplyConfig",
          "like",
          "Elab",
          "public",
          "underlying",
          "allows",
          "Term",
          "provide",
          "you",
          "namespace",
          "config",
          "cfg",
          "Meta",
          "meta",
          "Tactic"
        ]
      }
    },
    {
      "id": 3002,
      "before_code": "Indep m\u2081 m\u2083 \u03ba \u03bc :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)",
      "suggestion": "  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n",
      "body": "I suggest this proof instead:\n```suggestion\n  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n```\nIt's exactly the same but I reworked the variables (and removed unnecessary parentheses). We often use `s`, `t` for sets. Here `s` and `t` are not of the same kind (`s` is a finset of the index type while `t` is a family of sets) so it's better to use `s` and `t` rather than `t1` and `t2` which suggests they are of the same kind. As `i` is an element of the index type `\u03b9`, `i` is the usual",
      "path": "Mathlib/Probability/Independence/Kernel/Indep.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "ht1",
          "ht2",
          "h_indep",
          "h32",
          "Indep"
        ]
      }
    },
    {
      "id": 3004,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n",
      "body": "```suggestion\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "have",
          "refine"
        ],
        "removed_tactics": [
          "omega",
          "intro"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3005,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "theorem abundant_945 : Abundant 945 := by decide +kernel\n",
      "body": "```suggestion\ntheorem abundant_945 : Abundant 945 := by decide +kernel\n```\nIf you add `deriving Decidable` after the def of `Abundant`.\n\nBut why 945? And why can't this proof be inline?",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "decide"
        ],
        "body_tactics": [
          "decide"
        ],
        "new_tactics": [
          "decide"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3007,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family_span_fixedDegree_aux\r\n    {I : Type*} [LinearOrder I] (v : I \u2192 M) (\u03b1 : Fin n \u2192 I) :\r\n    ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) \u2208 span R (range (ExteriorAlgebra.\u03b9Multi_family R n v)) := by\r\n  by_cases \u03b1_inj : Injective \u03b1; swap\r\n  \u00b7 suffices ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) = 0 by simp [this]\r\n    exact AlternatingMap.map_eq_zero_of_not_injective _ _ <| fun h \u21a6 \u03b1_inj (Injective.of_comp h)\r\n",
      "body": "Looking at this one last time, even though it is a private \"auxiliary\" lemma, I think we should fold in the case analysis on whether `\u03b1` is injective so that we don't have a redundant hypothesis:\r\n```suggestion\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 3009,
      "before_code": "/-- We say that a type has `MeasurableSup` if `(c \u2294 \u00b7)` and `(\u00b7 \u2294 c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (\u00b7 \u2294 \u00b7)` see `MeasurableSup\u2082`. -/\nclass MeasurableSup (M : Type*) [MeasurableSpace M] [Max M] : Prop where\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7)\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c)",
      "suggestion": "\r\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7) := by intro c; measurability\r\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c) := by intro c; measurability\r\n",
      "body": "Do we have a good understanding of when to use `fun_prop` vs `measurability`? I thought the latter was now based on the former and therefore as fast but also slightly stronger. Therefore I was expecting\r\n```suggestion\r\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7) := by intro c; measurability\r\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c) := by intro c; measurability\r\n```",
      "path": "Mathlib/MeasureTheory/Order/Lattice.lean",
      "tags": {
        "before_tactics": [
          "measurability"
        ],
        "suggestion_tactics": [
          "measurability",
          "intro"
        ],
        "body_tactics": [
          "fun_prop",
          "measurability",
          "have",
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "measurability",
          "order"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "Type",
          "typeclass",
          "class",
          "type",
          "has",
          "Max",
          "For",
          "MeasurableSup",
          "Prop",
          "are",
          "see",
          "say",
          "assuming",
          "measurable_sup_const",
          "that",
          "measurability",
          "MeasurableSpace",
          "measurable_const_sup",
          "uncurry",
          "functions",
          "measurable",
          "Measurable"
        ]
      }
    },
    {
      "id": 3015,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    by simpa using im_pnat_div_pos 1 z\u27e9)\r\n",
      "body": "```suggestion\r\n    by simpa using im_pnat_div_pos 1 z\u27e9)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3016,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n      (by simpa using norm_exp_two_pi_I_lt_one \u27e8-N / z, im_pnat_div_pos N z\u27e9)]\r\n",
      "body": "```suggestion\r\n      (by simpa using norm_exp_two_pi_I_lt_one \u27e8-N / z, im_pnat_div_pos N z\u27e9)]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3017,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n",
      "body": "```suggestion\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n```\r\n(re-labelling variables for consistency with previous lemma)",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "grind",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "grind",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "grind",
          "congr",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3018,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simp_rw [inv_neg, mul_neg, mul_sum]\r\n  rw [Summable.tsum_finsetSum (fun i hi \u21a6 by apply linear_left_summable (ne_zero z) i le_rfl)]\r\n",
      "body": "```suggestion\r\n  simp_rw [inv_neg, mul_neg, mul_sum]\r\n  rw [Summable.tsum_finsetSum (fun i hi \u21a6 by apply linear_left_summable (ne_zero z) i le_rfl)]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "rw"
        ],
        "body_tactics": [
          "apply",
          "rw"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3019,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact fun i hi \u21a6 by simpa using linear_left_summable (ne_zero z) i le_rfl\r\n",
      "body": "```suggestion\r\n  exact fun i hi \u21a6 by simpa using linear_left_summable (ne_zero z) i le_rfl\r\n```\r\nI don't think we need `omega` to tell us that `2 \u2264 2`; and doing it this way avoids having to specify `k`.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "simpa",
          "exact",
          "omega"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_omega"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3020,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (m * z + n + 1)) =\r\n    1 / (m * z - b) - 1 / (m * z + b) := by\r\n  convert telescope_aux' b (fun n \u21a6 1 / ((m : \u2102) * z + n)) using 2 <;>\r\n  simp [add_assoc, sub_eq_add_neg]\r\n",
      "body": "I'd suggest splitting this up:\r\n```suggestion\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "aesop",
          "grind",
          "induction",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "grind",
          "induction",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "aesop",
          "induction",
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp",
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3021,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n",
      "body": "```suggestion\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n```\r\nAlso the capitalization is inconsistent: `Summable_cotTerm` is a proof of summability, not a statement of summability, so it should be lowercase \u2013 please change it wherever it's defined and here to match.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "aesop",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "aesop",
          "have"
        ],
        "new_tactics": [
          "aesop",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3022,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact this.congr <| by grind\r\n",
      "body": "```suggestion\r\n  exact this.congr <| by grind\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3023,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 exact tendsto_comp_val_Ioi_atTop.mpr <| \r\n      by simpa using (tendsto_inv_atTop_nhds_zero_nat (\ud835\udd5c := \u2102)).const_mul (-2)\r\n",
      "body": "```suggestion\r\n  \u00b7 exact tendsto_comp_val_Ioi_atTop.mpr <| \r\n      by simpa using (tendsto_inv_atTop_nhds_zero_nat (\ud835\udd5c := \u2102)).const_mul (-2)\r\n```\r\nSome of the proofs here are a bit awkward (here and elsewhere in this file) because you are using `tendsto_comp_val_Ioi_atTop` with `\u2115+` arguments, relying on the defeq that `\u2115+ = \u2191(Set.Ioi 0)` (which `rw` and `simp` cannot see through). I wonder if it would be better to have a version of `tendsto_comp_val_Ioi_atTop` stated for the `\u2115+` case (maybe `PN",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3031,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n",
      "body": "```suggestion\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 3032,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n",
      "body": "```suggestion\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 3034,
      "before_code": "/-- The Laplacian matrix is positive semidefinite -/\ntheorem posSemidef_lapMatrix [Field R] [LinearOrder R] [IsStrictOrderedRing R] [StarRing R]\n    [TrivialStar R] : PosSemidef (G.lapMatrix R) := by\n  constructor",
      "suggestion": "\r\n  refine .of_dotProduct_mulVec_nonneg ?_ fun x => ?_\r\n",
      "body": "```suggestion\r\n  refine .of_dotProduct_mulVec_nonneg ?_ fun x => ?_\r\n```\r\neven",
      "path": "Mathlib/Combinatorics/SimpleGraph/LapMatrix.lean",
      "tags": {
        "before_tactics": [
          "constructor"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "constructor"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "lapMatrix",
          "TrivialStar",
          "IsStrictOrderedRing",
          "Field",
          "posSemidef_lapMatrix",
          "constructor",
          "positive",
          "LinearOrder",
          "matrix",
          "semidefinite",
          "PosSemidef",
          "Laplacian",
          "StarRing"
        ]
      }
    },
    {
      "id": 3035,
      "before_code": "M\u1d34.PosSemidef \u2194 M.PosSemidef :=\n  \u27e8(by simpa using \u00b7.conjTranspose), .conjTranspose\u27e9\n\nprotected lemma zero : PosSemidef (0 : Matrix n n R) :=\n  \u27e8isHermitian_zero, by simp\u27e9",
      "suggestion": "\r\n  refine \u27e8.smul (.of_nonneg ha) hx.1, fun y => ?_\u27e9\r\n",
      "body": "```suggestion\r\n  refine \u27e8.smul (.of_nonneg ha) hx.1, fun y => ?_\u27e9\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/PosDef.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "simp"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "simpa",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "lemma",
          "protected",
          "isHermitian_zero",
          "simpa",
          "conjTranspose",
          "simp",
          "zero",
          "Matrix",
          "PosSemidef",
          "using"
        ]
      }
    },
    {
      "id": 3040,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero",
      "suggestion": "theorem one_lt_div' [LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1) {b : \u03b1} (hb : 0 < b) :\n    1 < a / b \u2194 b < a := by\n  rw [\u2190 mul_lt_mul_right (zero_lt_iff.mpr hb), one_mul, div_eq_mul_inv, inv_mul_cancel_right\u2080 hb]\n",
      "body": "Can you generalise that to `GroupWithZero` + `LinearOrder` + compatibility typeclasses by assuming \n```suggestion\ntheorem one_lt_div' [LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1) {b : \u03b1} (hb : 0 < b) :\n    1 < a / b \u2194 b < a := by\n  rw [\u2190 mul_lt_mul_right (zero_lt_iff.mpr hb), one_mul, div_eq_mul_inv, inv_mul_cancel_right\u2080 hb]\n```\nThis way it will also apply to eg linearly ordered fields. Same for the three lemmas below",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "apply",
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "WithZero",
          "end",
          "commGroupWithZero",
          "instLinearOrderedCommMonoidWithZero"
        ]
      }
    },
    {
      "id": 3044,
      "before_code": "theorem inf_orthogonal_eq_bot : K \u2293 K\u15ee = \u22a5 := by\n  rw [eq_bot_iff]\n  intro x\n  simp only [toSubmodule_inf, orthogonal_toSubmodule_eq, Submodule.mem_inf, toSubmodule_bot,\n    Submodule.mem_bot, and_imp]\n  exact fun hx ho => inner_self_eq_zero.1 (ho x hx)",
      "suggestion": "\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n",
      "body": "```suggestion\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n```\r\nDoes this work?",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "theorem",
          "toSubmodule_inf",
          "exact",
          "eq_bot_iff",
          "mem_inf",
          "toSubmodule_bot",
          "mem_bot",
          "Submodule",
          "and_imp",
          "simp",
          "intro",
          "orthogonal_toSubmodule_eq",
          "inner_self_eq_zero",
          "inf_orthogonal_eq_bot"
        ]
      }
    },
    {
      "id": 3045,
      "before_code": ".of_isCoveringMap_subtype (by simp) _ isCoveringMap_exp\n\nend Complex",
      "suggestion": "\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n",
      "body": "```suggestion\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n```",
      "path": "Mathlib/Analysis/Complex/CoveringMap.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "aesop",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "aesop",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "aesop",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "of_isCoveringMap_subtype",
          "end",
          "Complex",
          "simp",
          "isCoveringMap_exp"
        ]
      }
    },
    {
      "id": 3050,
      "before_code": "rw [isLittleO_iff_forall_isBigOWith, isLittleO_iff_forall_isBigOWith]\n  simp [isBigOWith_mul_iff_isBigOWith_div hf]",
      "suggestion": "\r\n      _ \u2264 C\u2081 * \u2016g m\u2016 := by\r\n        gcongr\r\n        exact Finset.le_sup' (fun x => \u2016f x\u2016 / \u2016g x\u2016) (Finset.mem_def.mpr hm)\r\n",
      "body": "```suggestion\r\n      _ \u2264 C\u2081 * \u2016g m\u2016 := by\r\n        gcongr\r\n        exact Finset.le_sup' (fun x => \u2016f x\u2016 / \u2016g x\u2016) (Finset.mem_def.mpr hm)\r\n```",
      "path": "Mathlib/Analysis/Asymptotics/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "gcongr"
        ],
        "body_tactics": [
          "exact",
          "gcongr"
        ],
        "new_tactics": [
          "exact",
          "gcongr"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isBigOWith_mul_iff_isBigOWith_div",
          "simp",
          "isLittleO_iff_forall_isBigOWith"
        ]
      }
    },
    {
      "id": 3051,
      "before_code": "\u21d1f.toHomeomorphOfFiniteDimensional.symm = f.symm :=\n  rfl",
      "suggestion": "\r\n  refine \u27e8\u27e8\u2016fL\u2016\u208a, LipschitzWith.of_dist_le_mul fun x y \u21a6 ?_\u27e9\r\n",
      "body": "```suggestion\r\n  refine \u27e8\u27e8\u2016fL\u2016\u208a, LipschitzWith.of_dist_le_mul fun x y \u21a6 ?_\u27e9\r\n```\r\nThis ought to work",
      "path": "Mathlib/Analysis/Normed/Module/FiniteDimension.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "symm",
          "toHomeomorphOfFiniteDimensional"
        ]
      }
    },
    {
      "id": 3052,
      "before_code": "map n (g \u2218\u2097 f) = map n g \u2218\u2097 map n f := by\n  aesop",
      "suggestion": "\r\n/-- If a linear map has a retraction, then the map it induces on exterior powers is injective. -/\r\nlemma map_injective {f : M \u2192\u2097[R] N} (g : N \u2192\u2097[R] M) (hg : g \u2218\u2097 f = .id) :\r\n    Injective (map n f) :=\r\n  RightInverse.injective (g := map n g)\r\n    (fun _ \u21a6 by rw [\u2190 LinearMap.comp_apply, \u2190 map_comp, hg, map_id, LinearMap.id_coe, id_eq])\r\n\r\n/-- If the base ring is a field, then any injective linear map induces an injective map on\r\nexterior powers. -/\r\nlemma map_injective_field {K : Type*} [Field K] [Module K M] [Module K N]\r\n    {f : M \u2192\u2097[K] N} (hf : Injective f) :\r\n    Injective (map n f) :=\r\n  map_injective _ (f.exists_leftInverse_of_injective (LinearMap.ker_eq_bot.mpr hf)).choose_spec\r\n",
      "body": "It is almost always more convenient to destruct an existential hypothesis and I think we should do so here. Given that and some other very minor style tweaks I suggest:\r\n```suggestion\r\n/-- If a linear map has a retraction, then the map it induces on exterior powers is injective. -/\r\nlemma map_injective {f : M \u2192\u2097[R] N} (g : N \u2192\u2097[R] M) (hg : g \u2218\u2097 f = .id) :\r\n    Injective (map n f) :=\r\n  RightInverse.injective (g := map n g)\r\n    (fun _ \u21a6 by rw [\u2190 LinearMap.comp_apply, \u2190 map_comp, hg, map_id, Line",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "ring",
          "rw"
        ],
        "body_tactics": [
          "ring",
          "rw"
        ],
        "new_tactics": [
          "ring",
          "rw"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "map",
          "aesop"
        ]
      }
    },
    {
      "id": 3053,
      "before_code": "have B : \u2200\u1da0 x in atTop, x + 1 \u2264 exp x := eventually_atTop.2 \u27e80, fun x _ => add_one_le_exp x\u27e9\n  exact tendsto_atTop_mono' atTop B A",
      "suggestion": "  have h_le : y \u2264 exp (y - 1) := by simpa using add_one_le_exp (y - 1)\n  have h_mul_le : y * rexp (-y) \u2264 rexp (y - 1) * rexp (-y) := by gcongr\n  simpa [\u2190 exp_add, sub_add_eq_add_sub] using h_mul_le\n",
      "body": "```suggestion\n  have h_le : y \u2264 exp (y - 1) := by simpa using add_one_le_exp (y - 1)\n  have h_mul_le : y * rexp (-y) \u2264 rexp (y - 1) * rexp (-y) := by gcongr\n  simpa [\u2190 exp_add, sub_add_eq_add_sub] using h_mul_le\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Exp.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "simpa",
          "gcongr",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "gcongr",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "gcongr"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exp",
          "eventually_atTop",
          "exact",
          "have",
          "tendsto_atTop_mono",
          "add_one_le_exp",
          "atTop"
        ]
      }
    },
    {
      "id": 3056,
      "before_code": "(hx : \u2200 r : R, r \u2022 x \u2208 Submodule.span R s \u2192 r = 0) : LinearIndepOn R id (insert x s) :=\n  hs.insert' <| by simpa",
      "suggestion": "/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?_\n  have aux (j : \u03b9) (hjs : j \u2208 s) (hji : j \u2260 i) : g j * (f i) (v j) = 0 := by simp [h1 hji.symm]\n  simpa [s.sum_eq_single i aux (by aesop), h2 i] using congr_arg (f i) hrel\n",
      "body": "Just a few minor style tweaks:\n```suggestion\n/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?",
      "path": "Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "have",
          "aesop",
          "simp",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "insert",
          "LinearIndepOn",
          "span",
          "simpa",
          "Submodule"
        ]
      }
    },
    {
      "id": 3065,
      "before_code": "end IsSetSemiring",
      "suggestion": "      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n",
      "body": "```suggestion\n      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "rw",
          "simp",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 3066,
      "before_code": "end IsSetSemiring",
      "suggestion": "      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n",
      "body": "```suggestion\n      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 3067,
      "before_code": "end IsSetSemiring",
      "suggestion": "      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n",
      "body": "```suggestion\n      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 3068,
      "before_code": "ext\n  simp +contextual [imp_false]",
      "suggestion": "\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n",
      "body": "I know you're not a fan but `diagSet` seems to fit the hypothesis pretty well:\r\n```suggestion\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n```\r\nThe current proof (just without the underscore) will also work after your #32679 is merged",
      "path": "Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simpa",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "contextual",
          "imp_false",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 3077,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3078,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3079,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3080,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3081,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3082,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3083,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3084,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3089,
      "before_code": "(p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (\u2a05 i, p i) = \u2a05 i, comap f (p i) :=\n  (gc_map_comap f).u_iInf",
      "suggestion": "\r\n    (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (s.inf p) = s.inf fun i \u21a6 comap f (p i) := by\r\n  simp [Finset.inf_eq_iInf]\r\n",
      "body": "```suggestion\r\n    (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (s.inf p) = s.inf fun i \u21a6 comap f (p i) := by\r\n  simp [Finset.inf_eq_iInf]\r\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Map.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "gc_map_comap",
          "Submodule",
          "comap",
          "u_iInf"
        ]
      }
    },
    {
      "id": 3090,
      "before_code": "theorem comap_iInf (K : \u03b9 \u2192 Ideal S) : (iInf K).comap f = \u2a05 i, (K i).comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_iInf",
      "suggestion": "\r\n    (s.inf K).comap f = s.inf fun i \u21a6 (K i).comap f := by\r\n  simp [Finset.inf_eq_iInf, comap_iInf]\r\n",
      "body": "```suggestion\r\n    (s.inf K).comap f = s.inf fun i \u21a6 (K i).comap f := by\r\n  simp [Finset.inf_eq_iInf, comap_iInf]\r\n```",
      "path": "Mathlib/RingTheory/Ideal/Maps.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Ideal",
          "GaloisConnection",
          "theorem",
          "comap_iInf",
          "gc_map_comap",
          "iInf",
          "map",
          "u_iInf",
          "comap"
        ]
      }
    },
    {
      "id": 3095,
      "before_code": "simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b\u2081, h, \u2190 mul_assoc, mul_comm _ (f a)]",
      "suggestion": "    exact (hki.2 (hs hi hj hij k (by grind))).elim\n",
      "body": "```suggestion\n    exact (hki.2 (hs hi hj hij k (by grind))).elim\n```",
      "path": "Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mul_assoc",
          "not_true_eq_false",
          "false_and",
          "mem_erase",
          "ne_eq",
          "not_false_eq_true",
          "simp",
          "mul_comm",
          "only",
          "prod_insert"
        ]
      }
    },
    {
      "id": 3098,
      "before_code": "theorem preCantorSet_antitone : Antitone preCantorSet := by\n  apply antitone_nat_of_succ_le\n  intro m",
      "suggestion": "\r\n  refine antitone_nat_of_succ_le fun m \u21a6 ?_\r\n",
      "body": "Since we're already golfing:\r\n```suggestion\r\n  refine antitone_nat_of_succ_le fun m \u21a6 ?_\r\n```",
      "path": "Mathlib/Topology/Instances/CantorSet.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "intro"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "apply",
          "intro"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "antitone_nat_of_succ_le",
          "theorem",
          "preCantorSet",
          "preCantorSet_antitone",
          "Antitone",
          "intro"
        ]
      }
    },
    {
      "id": 3101,
      "before_code": "theorem symm_comp : e.symm.toLinearMap \u2218\u209b\u2097 e.toLinearMap = LinearMap.id :=\n  LinearMap.ext e.symm_apply_apply",
      "suggestion": "\r\n    e\u2081\u2082.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n\r\n@[simp]\r\nlemma symm_comp_assoc (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) [RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082] :\r\n    e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n",
      "body": "```suggestion\r\n    e\u2081\u2082.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n\r\n@[simp]\r\nlemma symm_comp_assoc (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) [RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082] :\r\n    e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n```",
      "path": "Mathlib/Algebra/Module/Equiv/Defs.lean",
      "tags": {
        "before_tactics": [
          "ext"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "LinearMap",
          "theorem",
          "symm_apply_apply",
          "symm_comp",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 3111,
      "before_code": "theorem irreducible_of_factor {a : \u03b1} : \u2200 x : \u03b1, x \u2208 factors a \u2192 Irreducible x := fun x h =>\n  (prime_of_factor x h).irreducible",
      "suggestion": "  have hf : factors a \u2260 0 := by\n    intro hf\n    simpa [hf, Associated.comm, ha.not_isUnit] using factors_prod ha.ne_zero\n",
      "body": "I think this is clearer as:\n```suggestion\n  have hf : factors a \u2260 0 := by\n    intro hf\n    simpa [hf, Associated.comm, ha.not_isUnit] using factors_prod ha.ne_zero\n```\nand then deindent the rest of the proof",
      "path": "Mathlib/RingTheory/UniqueFactorizationDomain/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "irreducible",
          "theorem",
          "Irreducible",
          "factors",
          "irreducible_of_factor",
          "prime_of_factor"
        ]
      }
    },
    {
      "id": 3115,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
      "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 3116,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
      "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 3117,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
      "body": "```suggestion\n  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 3118,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
      "body": "```suggestion\n  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 3120,
      "before_code": "instance [Nontrivial M] : Nontrivial P.invtRootSubmodule where\n  exists_pair_ne := \u27e8\u22a5, \u22a4, by rw [ne_eq, Subtype.ext_iff]; exact bot_ne_top\u27e9",
      "suggestion": "    q = \u22a4 \u2194 range P.root \u2286 q :=\n  \u27e8fun h \u21a6 by simp [h], fun h \u21a6 by simpa using Submodule.span_mono h (R := K)\u27e9\n",
      "body": "How about:\n```suggestion\n    q = \u22a4 \u2194 range P.root \u2286 q :=\n  \u27e8fun h \u21a6 by simp [h], fun h \u21a6 by simpa using Submodule.span_mono h (R := K)\u27e9\n```\n(I confess I'm slightly amazed I could golf this so much: it suggests our `simp` sets are in pretty good shape)",
      "path": "Mathlib/LinearAlgebra/RootSystem/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Subtype",
          "ext_iff",
          "Nontrivial",
          "exact",
          "invtRootSubmodule",
          "ne_eq",
          "exists_pair_ne",
          "instance",
          "bot_ne_top"
        ]
      }
    },
    {
      "id": 3134,
      "before_code": "have h\u2082 := cos_pi_div_three;\n    have h\u2082 := cos_zero] <;>\n  simp [injOn_cos h_bnd \u27e8by positivity, by linarith [pi_nonneg]\u27e9 (h\u2082 \u25b8 h)]",
      "suggestion": "  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n",
      "body": "```suggestion\n  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n```",
      "path": "Mathlib/NumberTheory/Niven.lean",
      "tags": {
        "before_tactics": [
          "positivity",
          "have",
          "simp",
          "linarith"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "grind",
          "have",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "grind",
          "have",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "grind",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "removed_tactics": [
          "positivity",
          "simp",
          "linarith"
        ],
        "topics": [],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "injOn_cos",
          "cos_pi_div_three",
          "positivity",
          "pi_nonneg",
          "have",
          "h_bnd",
          "simp",
          "linarith",
          "cos_zero"
        ]
      }
    },
    {
      "id": 3136,
      "before_code": "obtain \u27e8b', hb', d_ab\u27e9 := exists_lt_mul_right_of_nonneg ha'.1 hd d_ab\n  exact d_ab.le.trans (h a' ha'.1 ha'.2 b' hb'.1 hb'.2)\n\ntheorem mul_self_inj_of_nonneg (a0 : 0 \u2264 a) (b0 : 0 \u2264 b) : a * a = b * b \u2194 a = b :=\n  mul_self_eq_mul_self_iff.trans <|\n    or_iff_left_of_imp fun h => by grind",
      "suggestion": "\r\n  have := fun h \u21a6 le_antisymm (neg_nonneg.mp h) b0\r\n  grind [sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg]\r\n",
      "body": "this is the same proof, but just using grind:\r\n```suggestion\r\n  have := fun h \u21a6 le_antisymm (neg_nonneg.mp h) b0\r\n  grind [sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg]\r\n```\r\nnot sure what file this could go to though\r\n\r\nalso, we have this [sq_eq_sq\u2080](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#sq_eq_sq%E2%82%80) which is essentially the same (but uses `LinearOrder`)",
      "path": "Mathlib/Algebra/Order/Field/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "grind",
          "obtain"
        ],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mul_self_eq_mul_self_iff",
          "theorem",
          "exact",
          "mul_self_inj_of_nonneg",
          "grind",
          "d_ab",
          "obtain",
          "trans",
          "exists_lt_mul_right_of_nonneg",
          "or_iff_left_of_imp"
        ]
      }
    },
    {
      "id": 3138,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "    derivative^[k] (\u220f vj \u2208 (s.erase i).image v, (X - C vj)) := by rw [Finset.prod_image hvs']\n",
      "body": "```suggestion\n    derivative^[k] (\u220f vj \u2208 (s.erase i).image v, (X - C vj)) := by rw [Finset.prod_image hvs']\n```\n(matter of taste, maybe)",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3139,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_injOn hvs').mono (by grind)\n        case i_surj => grind [card_image_of_injOn, hvs'.mono]\n        case h =>\n          rw [eq_comm]\n          exact prod_image <| by grind [hvs'.mono]\n",
      "body": "```suggestion\n          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_in",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "rw",
          "intro",
          "omega"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_omega",
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3140,
      "before_code": "minTensorProduct C\u2081 C\u2082 \u2264 maxTensorProduct C\u2081 C\u2082 := by\n  exact Submodule.span_le.mpr (tmul_subset_maxTensorProduct C\u2081 C\u2082)",
      "suggestion": "  refine \u27e8?_, fun hz \u21a6\n    \u27e8(TensorProduct.comm R H G) z, ?_, (TensorProduct.comm R H G).symm_apply_apply z\u27e9\u27e9\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9 \u03c8 h\u03c8 \u03c6 h\u03c6\n    simpa [dualDistrib_apply_comm] using hw \u03c6 h\u03c6 \u03c8 h\u03c8\n  \u00b7 intro \u03c6 h\u03c6 \u03c8 h\u03c8\n    simpa [dualDistrib_apply_comm] using hz \u03c8 h\u03c8 \u03c6 h\u03c6\n",
      "body": "```suggestion\n  refine \u27e8?_, fun hz \u21a6\n    \u27e8(TensorProduct.comm R H G) z, ?_, (TensorProduct.comm R H G).symm_apply_apply z\u27e9\u27e9\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9 \u03c8 h\u03c8 \u03c6 h\u03c6\n    simpa [dualDistrib_apply_comm] using hw \u03c6 h\u03c6 \u03c8 h\u03c8\n  \u00b7 intro \u03c6 h\u03c6 \u03c8 h\u03c8\n    simpa [dualDistrib_apply_comm] using hz \u03c8 h\u03c8 \u03c6 h\u03c6\n```\ngolf; unsqueeze terminal simps",
      "path": "Mathlib/Geometry/Convex/Cone/TensorProduct.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "tmul_subset_maxTensorProduct",
          "mpr",
          "exact",
          "maxTensorProduct",
          "Submodule",
          "minTensorProduct",
          "span_le"
        ]
      }
    },
    {
      "id": 3143,
      "before_code": "simp_rw [measurable_iff_comap_le, MeasurableSpace.pi, MeasurableSpace.comap_iSup,\n    MeasurableSpace.comap_comp, Function.comp_def, iSup_le_iff]",
      "suggestion": "theorem MeasurableSpace.comap_le_comap_pi {g : (a : \u03b4) \u2192 \u03b2 \u2192 X a} (a : \u03b4) :\n    .comap (g a) inferInstance \u2264 pi.comap (fun b c \u21a6 g c b) := by\n  simpa only [pi, comap_iSup] using le_iSup_of_le a <| by measurability\n",
      "body": "```suggestion\ntheorem MeasurableSpace.comap_le_comap_pi {g : (a : \u03b4) \u2192 \u03b2 \u2192 X a} (a : \u03b4) :\n    .comap (g a) inferInstance \u2264 pi.comap (fun b c \u21a6 g c b) := by\n  simpa only [pi, comap_iSup] using le_iSup_of_le a <| by measurability\n```",
      "path": "Mathlib/MeasureTheory/MeasurableSpace/Constructions.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "measurability"
        ],
        "body_tactics": [
          "simpa",
          "measurability"
        ],
        "new_tactics": [
          "simpa",
          "measurability"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "order",
          "function"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "comp_def",
          "iSup_le_iff",
          "comap_iSup",
          "comap_comp",
          "simp_rw",
          "MeasurableSpace",
          "Function",
          "measurable_iff_comap_le"
        ]
      }
    },
    {
      "id": 3160,
      "before_code": "end QuasiFinite",
      "suggestion": "  have : IsLocalizedModule (.powers r) (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8fun x \u21a6 IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n      \u27e8x, hrp' x.2\u27e9, fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simp [Submonoid.mem_powers_iff]\u27e9\n",
      "body": "```suggestion\n  have : IsLocalizedModule (.powers r) (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8fun x \u21a6 IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n      \u27e8x, hrp' x.2\u27e9, fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simp [Submonoid.mem_powers_iff]\u27e9\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 3162,
      "before_code": "end QuasiFinite",
      "suggestion": "  have : IsLocalizedModule p.primeCompl (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p)),\n      fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simpa using \u27e81, p.primeCompl.one_mem\u27e9\u27e9\n",
      "body": "```suggestion\n  have : IsLocalizedModule p.primeCompl (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p)),\n      fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simpa using \u27e81, p.primeCompl.one_mem\u27e9\u27e9\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 3179,
      "before_code": "end Real",
      "suggestion": "\r\n  rw [eq_div_iff (Nat.cast_ne_zero.mpr (by positivity)), mul_comm, iterate_derivative_T_eval_one]\r\n",
      "body": "```suggestion\r\n  rw [eq_div_iff (Nat.cast_ne_zero.mpr (by positivity)), mul_comm, iterate_derivative_T_eval_one]\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "rw"
        ],
        "body_tactics": [
          "positivity",
          "rw"
        ],
        "new_tactics": [
          "positivity",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Real",
          "end"
        ]
      }
    },
    {
      "id": 3180,
      "before_code": "end Real",
      "suggestion": "\r\n  rw [eq_div_iff (Nat.cast_ne_zero.mpr (by positivity)), mul_comm, iterate_derivative_U_eval_one]\r\n",
      "body": "```suggestion\r\n  rw [eq_div_iff (Nat.cast_ne_zero.mpr (by positivity)), mul_comm, iterate_derivative_U_eval_one]\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "rw"
        ],
        "body_tactics": [
          "positivity",
          "rw"
        ],
        "new_tactics": [
          "positivity",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Real",
          "end"
        ]
      }
    },
    {
      "id": 3190,
      "before_code": "@[simp] theorem logCounting_const_zero {e : WithTop E} :\n    logCounting (0 : \ud835\udd5c \u2192 E) e = 0 := logCounting_const",
      "suggestion": "\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n",
      "body": "```suggestion\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n```",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CountingFunction.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "positivity"
        ],
        "body_tactics": [
          "simpa",
          "positivity"
        ],
        "new_tactics": [
          "simpa",
          "positivity"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "logCounting",
          "WithTop",
          "theorem",
          "logCounting_const_zero",
          "logCounting_const",
          "simp"
        ]
      }
    },
    {
      "id": 3192,
      "before_code": "theorem Ici_top [PartialOrder \u03b1] [OrderTop \u03b1] : Ici (\u22a4 : \u03b1) = {\u22a4} :=\n  isMax_top.Ici_eq",
      "suggestion": "\r\n  Set.ext fun _ => lt_top_iff_ne_top\r\n",
      "body": "```suggestion\r\n  Set.ext fun _ => lt_top_iff_ne_top\r\n```\r\n`grind` feels like overkill here.",
      "path": "Mathlib/Order/Interval/Set/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "grind",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "theorem",
          "Ici_top",
          "OrderTop",
          "PartialOrder",
          "isMax_top",
          "Ici",
          "Ici_eq"
        ]
      }
    },
    {
      "id": 3193,
      "before_code": "isLocalizedModule_iff_isLocalization.mp inferInstance\n  inferInstance",
      "suggestion": "\r\n  rw [show s \u2297\u209c[R] 1 = algebraMap S (S \u2297[R] A) s by rfl,\r\n    show (algebraMap A (S \u2297[R] A)) a = 1 \u2297\u209c[R] a by rfl,\r\n    algebraMap_smul, \u2190 Derivation.map_smul, smul_tmul', smul_eq_mul, mul_one]\r\n",
      "body": "```suggestion\r\n  rw [show s \u2297\u209c[R] 1 = algebraMap S (S \u2297[R] A) s by rfl,\r\n    show (algebraMap A (S \u2297[R] A)) a = 1 \u2297\u209c[R] a by rfl,\r\n    algebraMap_smul, \u2190 Derivation.map_smul, smul_tmul', smul_eq_mul, mul_one]\r\n```\r\nI think this is slightly better: this way it\u2019s clear what defeq are being used.",
      "path": "Mathlib/RingTheory/Kaehler/TensorProduct.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "isLocalizedModule_iff_isLocalization",
          "inferInstance"
        ]
      }
    },
    {
      "id": 3194,
      "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
      "suggestion": "\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n",
      "body": "Untested, but something like this should work?\r\n```suggestion\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "new_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "_ha",
          "mem_top",
          "le_top",
          "theorem"
        ]
      }
    },
    {
      "id": 3195,
      "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
      "suggestion": "\r\n  refine fun h \u21a6 \u27e8\u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9, ?_\u27e9\r\n",
      "body": "You could merge these two lines as well (though you might argue the original is cleaner)\r\n```suggestion\r\n  refine fun h \u21a6 \u27e8\u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9, ?_\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "_ha",
          "mem_top",
          "le_top",
          "theorem"
        ]
      }
    },
    {
      "id": 3198,
      "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
      "suggestion": "\r\n  simp only [Submodule.ext_iff, mem_map, mem_orthogonal, forall_exists_index, and_imp,\r\n    forall_apply_eq_imp_iff\u2082, LinearIsometryEquiv.inner_map_eq_flip]\r\n  exact fun x \u21a6 \u27e8fun \u27e8y, hy\u27e9 z hz \u21a6 by simp [\u2190 hy.2, hy.1 _ hz], fun h \u21a6 \u27e8_, h, by simp\u27e9\u27e9\r\n",
      "body": "```suggestion\r\n  simp only [Submodule.ext_iff, mem_map, mem_orthogonal, forall_exists_index, and_imp,\r\n    forall_apply_eq_imp_iff\u2082, LinearIsometryEquiv.inner_map_eq_flip]\r\n  exact fun x \u21a6 \u27e8fun \u27e8y, hy\u27e9 z hz \u21a6 by simp [\u2190 hy.2, hy.1 _ hz], fun h \u21a6 \u27e8_, h, by simp\u27e9\u27e9\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "CompleteSpace",
          "instOrthogonalCompleteSpace",
          "isClosed_orthogonal",
          "instance",
          "completeSpace_coe"
        ]
      }
    },
    {
      "id": 3199,
      "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
      "suggestion": "\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n",
      "body": "(I don't know if this is recommended, but you _can_ technically do this in one line:\r\n```suggestion\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n```\r\n)\r\nProbably over-golfed though... so less of a suggestion, and more of an observation I guess",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "cleanup_simp",
          "use_aesop"
        ],
        "keywords": [
          "CompleteSpace",
          "instOrthogonalCompleteSpace",
          "isClosed_orthogonal",
          "instance",
          "completeSpace_coe"
        ]
      }
    },
    {
      "id": 3201,
      "before_code": "convert ((open_iff i subset_rfl).mp open_V).inter open_W using 1\n    refine Set.ext fun e \u21a6 and_right_comm.trans (and_congr_right fun \u27e8hV, hU\u27e9 \u21a6 ?_)\n    rw [Set.mem_preimage, dif_pos hV, inj i (inv_U i _) hU (f_inv i _)]",
      "suggestion": "\r\n  /- for each preimage e of x, choose a homeomorphism \u03c6\u2091\r\n    from a neighborhood of e to its image -/\r\n  choose \u03c6 h\u03c6 using fun e : f \u207b\u00b9' {x} \u21a6 h e e.2\r\n  -- separately, choose pairwise disjoint neighborhoods V\u2091 by Hausdorff-ness\r\n  have \u27e8V, hV, disj\u27e9 := fin.t2_separation\r\n  -- let V\u2091' be the intersection V\u2091 \u2229 dom(\u03c6\u2091)\r\n  let V' (e : f \u207b\u00b9' {x}) := V e \u2229 (\u03c6 e).source\r\n  have hV' e : IsOpen (V' e) := (hV e).2.inter (\u03c6 e).open_source\r\n  have : \u22c3 e, V' e \u2208 nhdsSet (f \u207b\u00b9' {x}) :=\r\n    (isOpen_iUnion hV').mem_nhdsSet.2 fun e he \u21a6 mem_iUnion_of_mem \u27e8e, he\u27e9 \u27e8(hV e).1, (h\u03c6 _).1\u27e9\r\n  -- since f is a closed map, the union of the V\u2091' contains the preimage of a neighborhood U \u220b x\r\n  have \u27e8W, hWx, hWV\u27e9 := isClosedMap_iff_comap_nhds_le.mp hf this\r\n  cases isEmpty_or_nonempty (f \u207b\u00b9' {x})\r\n  \u00b7 exact .of_preimage_eq_empty _ hWx (by simpa using hWV)\r\n  have \u27e8U, hUW, hU, hxU\u27e9 := mem_nhds_iff.mp hWx\r\n  -- show that the intersection of U with the images of V\u2091' is evenly covered\r\n  let U' := U \u2229 \u22c2 e : f \u207b\u00b9' ",
      "body": "```suggestion\r\n  /- for each preimage e of x, choose a homeomorphism \u03c6\u2091\r\n    from a neighborhood of e to its image -/\r\n  choose \u03c6 h\u03c6 using fun e : f \u207b\u00b9' {x} \u21a6 h e e.2\r\n  -- separately, choose pairwise disjoint neighborhoods V\u2091 by Hausdorff-ness\r\n  have \u27e8V, hV, disj\u27e9 := fin.t2_separation\r\n  -- let V\u2091' be the intersection V\u2091 \u2229 dom(\u03c6\u2091)\r\n  let V' (e : f \u207b\u00b9' {x}) := V e \u2229 (\u03c6 e).source\r\n  have hV' e : IsOpen (V' e) := (hV e).2.inter (\u03c6 e).open_source\r\n  have : \u22c3 e, V' e \u2208 nhdsSet (f \u207b\u00b9' {x}) :=\r\n    (",
      "path": "Mathlib/Topology/Covering/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "removed_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "and_right_comm",
          "refine",
          "ext",
          "convert",
          "f_inv",
          "open_iff",
          "dif_pos",
          "inter",
          "and_congr_right",
          "subset_rfl",
          "open_W",
          "inv_U",
          "Set",
          "trans",
          "mem_preimage",
          "using",
          "open_V",
          "inj"
        ]
      }
    },
    {
      "id": 3203,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    exact (one_ne_zero heq).elim\r\n",
      "body": "Here's a slight golf.\r\n```suggestion\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at he",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 3204,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n",
      "body": "```suggestion\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n```\r\nThis is slightly shorter.",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "simp_all",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 3205,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n",
      "body": "```suggestion\n  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "grind",
          "simp_all",
          "have",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp_all",
          "have",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "have",
          "simp",
          "simp_all"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 3219,
      "before_code": "ContinuousLinearMap.fst \ud835\udd5c E E + ContinuousLinearMap.snd \ud835\udd5c E E |>.isBigOTVS_comp\n    |>.trans <| h\u2081.prodMk h\u2082",
      "suggestion": "\r\n\r\ntheorem isLittleOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isLittleOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =o[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =o[\ud835\udd5c; l] g :=\r\n  isLittleOTVS_comm\r\n\r\n@[to_fun]\r\nprotected theorem IsBigOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n\r\ntheorem isBigOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isBigOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =O[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =O[\ud835\udd5c; l] g :=\r\n  isBigOTVS_comm\r\n\r\n",
      "body": "Why no also add the following?\r\n```suggestion\r\n\r\ntheorem isLittleOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isLittleOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =o[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =o[\ud835\udd5c; l] g :=\r\n  isLittleOTVS_comm\r\n\r\n@[to_fun]\r\nprotected theorem IsBigOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n\r\ntheorem isBigOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 ",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigOTVS_comp",
          "ContinuousLinearMap",
          "fst",
          "trans",
          "prodMk",
          "snd"
        ]
      }
    },
    {
      "id": 3225,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "        mem_le_prod_of_one_le _ (fun a \u21a6 le_max_left 1 \u2016a\u2016) _ z hz\n",
      "body": "```suggestion\n        mem_le_prod_of_one_le _ (fun a \u21a6 le_max_left 1 \u2016a\u2016) _ z hz\n```\n(this is where you'll have some simplification from making the arguments implicit)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3227,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  suffices \u2203 (n : \u2115) (_ : 0 < n), y ^ n = 1 by\n    obtain \u27e8n, hn\u2080, hn\u2081\u27e9 := this\n    exact \u27e8n, hn\u2080, congrArg (algebraMap K \u2102) hn\u2081\u27e9\n  refine NumberField.Embeddings.pow_eq_one_of_norm_le_one (x := y) K \u2102 (Subtype.coe_ne_coe.mp hz\u2080)\n    (coe_isIntegral_iff.mp <| isIntegral_of_mahlerMeasure_eq_one h hz)\n    fun \u03c6 \u21a6 norm_root_le_one_of_mahlerMeasure_eq_one h ?_\n  -- the conjugates of `y` are inside the closed unit disk\n",
      "body": "```suggestion\n  suffices \u2203 (n : \u2115) (_ : 0 < n), y ^ n = 1 by\n    obtain \u27e8n, hn\u2080, hn\u2081\u27e9 := this\n    exact \u27e8n, hn\u2080, congrArg (algebraMap K \u2102) hn\u2081\u27e9\n  refine NumberField.Embeddings.pow_eq_one_of_norm_le_one (x := y) K \u2102 (Subtype.coe_ne_coe.mp hz\u2080)\n    (coe_isIntegral_iff.mp <| isIntegral_of_mahlerMeasure_eq_one h hz)\n    fun \u03c6 \u21a6 norm_root_le_one_of_mahlerMeasure_eq_one h ?_\n  -- the conjugates of `y` are inside the closed unit disk\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "new_tactics": [
          "obtain",
          "refine"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3228,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  rw [mem_aroots] at hz \u22a2\n  refine \u27e8hz.1, ?_\u27e9\n  have H (\u03c8 : K \u2192+* \u2102) : \u03c8 ((aeval y) p) = (aeval (\u03c8 y)) p := by\n    conv_rhs => rw [\u2190 map_id (p := p)]\n    exact p.map_aeval_eq_aeval_map (by ext; simp) y\n  rw [\u2190 H, map_eq_zero_iff _ \u03c6.injective,\n    \u2190 map_eq_zero_iff _ (FaithfulSMul.algebraMap_injective \u21a5K \u2102), H]\n  exact hz.2\n",
      "body": "```suggestion\n  rw [mem_aroots] at hz \u22a2\n  refine \u27e8hz.1, ?_\u27e9\n  have H (\u03c8 : K \u2192+* \u2102) : \u03c8 ((aeval y) p) = (aeval (\u03c8 y)) p := by\n    conv_rhs => rw [\u2190 map_id (p := p)]\n    exact p.map_aeval_eq_aeval_map (by ext; simp) y\n  rw [\u2190 H, map_eq_zero_iff _ \u03c6.injective,\n    \u2190 map_eq_zero_iff _ (FaithfulSMul.algebraMap_injective \u21a5K \u2102), H]\n  exact hz.2\n```\n* The `convert`s resulting in an `Iff` are a bit ugly.\n* The way I have arranged it is closer to the usual Mathlib style (arguing \"backwards\").\n* Also, one ",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "ext",
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3231,
      "before_code": "rintro rfl\n      exact \u27e81, rfl\u27e9 }",
      "suggestion": "\r\n  have : Away (algebraMap R S z) T := by rwa [iff_of_associated h]\r\n",
      "body": "```suggestion\r\n  have : Away (algebraMap R S z) T := by rwa [iff_of_associated h]\r\n```",
      "path": "Mathlib/RingTheory/Localization/Away/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "exact",
          "rintro"
        ]
      }
    },
    {
      "id": 3236,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  exact \u27e8algebraMap S _ (a i), by simp +zetaDelta [IsLocalizedModule.map_linearCombination]\u27e9\r\n",
      "body": "```suggestion\r\n  exact \u27e8algebraMap S _ (a i), by simp +zetaDelta [IsLocalizedModule.map_linearCombination]\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 3241,
      "before_code": "finsum (fun d \u21a6 coeff d f \u2022 (constantCoeff (d.prod fun s e => (a s) ^ e))) := by\n  simp only [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_subst ha f 0]",
      "suggestion": "\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n",
      "body": "```suggestion\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Substitution.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "coeff",
          "prod",
          "coeff_zero_eq_constantCoeff_apply",
          "coeff_subst",
          "simp",
          "finsum",
          "constantCoeff",
          "only"
        ]
      }
    },
    {
      "id": 3243,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n",
      "body": "```suggestion\n    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n```\nMost of the time, `by exact` is useless.",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 3249,
      "before_code": "F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]",
      "suggestion": "\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n",
      "body": "```suggestion\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n```\r\nvery minor, but this way you don\u2019t have to guess what the `rwa` is proving from the source.",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isoAdd",
          "inv",
          "shiftFunctorAdd",
          "app",
          "_eq_shiftFunctorAdd",
          "map",
          "simp",
          "_inv_app",
          "only"
        ]
      }
    },
    {
      "id": 3275,
      "before_code": "namespace RCLike",
      "suggestion": "\r\n@[simp] theorem map_apply_real (x : \u211d) : map \u211d K x = x := by simp [im, re]\r\n",
      "body": "```suggestion\r\n@[simp] theorem map_apply_real (x : \u211d) : map \u211d K x = x := by simp [im, re]\r\n```",
      "path": "Mathlib/Analysis/RCLike/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "RCLike",
          "namespace"
        ]
      }
    },
    {
      "id": 3284,
      "before_code": "lemma Odd.ne_two_of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : m \u2260 2 := by\n  rintro rfl\n  exact absurd (hn.of_dvd_nat hm) (by decide)",
      "suggestion": "lemma Int.le_abs_of_dvd {a b : \u2124} (h\u2081 : b \u2260 0) (h\u2082 : a \u2223 b) : a \u2264 |b| :=\n  le_of_dvd (by simpa) (by simpa)\n",
      "body": "```suggestion\nlemma Int.le_abs_of_dvd {a b : \u2124} (h\u2081 : b \u2260 0) (h\u2082 : a \u2223 b) : a \u2264 |b| :=\n  le_of_dvd (by simpa) (by simpa)\n```",
      "path": "Mathlib/Algebra/Order/Ring/Abs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "decide"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "decide"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "lemma",
          "Odd",
          "exact",
          "rintro",
          "decide",
          "absurd",
          "rfl",
          "of_dvd_nat",
          "ne_two_of_dvd_nat"
        ]
      }
    },
    {
      "id": 3289,
      "before_code": "instance [Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] : IsSemireal R where\n  one_add_ne_zero hs amo := zero_ne_one' R (le_antisymm zero_le_one\n                              (le_of_le_of_eq (le_add_of_nonneg_right hs.nonneg) amo))",
      "suggestion": "\r\n      rw [add_comm] at hn\r\n      push_cast at hn\r\n      simpa using IsSemireal.one_add_ne_zero (by simp) hn\r\n",
      "body": "```suggestion\r\n      rw [add_comm] at hn\r\n      push_cast at hn\r\n      simpa using IsSemireal.one_add_ne_zero (by simp) hn\r\n```",
      "path": "Mathlib/Algebra/Ring/Semireal/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "body_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "ExistsAddOfLE",
          "le_antisymm",
          "zero_ne_one",
          "Semiring",
          "amo",
          "le_of_le_of_eq",
          "one_add_ne_zero",
          "LinearOrder",
          "IsSemireal",
          "instance",
          "le_add_of_nonneg_right",
          "IsStrictOrderedRing",
          "zero_le_one",
          "nonneg"
        ]
      }
    },
    {
      "id": 3291,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\n/-- The support of a graph is empty if there at most one vertex. -/\r\n@[simp]\r\ntheorem support_of_subsingleton [Subsingleton V] (G : SimpleGraph V) : G.support = \u2205 :=\r\n  Set.eq_empty_of_forall_notMem fun v \u27e8w, h\u27e9 => G.irrefl <| Subsingleton.elim v w \u25b8 h\r\n",
      "body": "```suggestion\r\n/-- The support of a graph is empty if there at most one vertex. -/\r\n@[simp]\r\ntheorem support_of_subsingleton [Subsingleton V] (G : SimpleGraph V) : G.support = \u2205 :=\r\n  Set.eq_empty_of_forall_notMem fun v \u27e8w, h\u27e9 => G.irrefl <| Subsingleton.elim v w \u25b8 h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3297,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "/--\nDetermines if the pretty-printed version of the given name would parse as an `ident` with an underlying name (via `getId`) equal to the original name. The pretty-printer usually escapes unparseable components of a name with `\u00ab\u00bb`, but makes exceptions for various names with special meaning, meaning that the result does not round trip. We therefore re-check those conditions here.\n\nThis function is intended to be \"safe\" in that it if it returns `true`, the name will definitely round trip. Any deviation from this behavior is a bug which should be fixed.\n-/\n-- See also [Zulip](https://leanprover.zulipchat.com/#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Check.20if.20a.20.60Lean.2EName.60.20is.20roundtrippable/with/565735560)\ndef Lean.Name.willRoundTrip (n : Name) : Bool :=\n  !n.isAnonymous -- anonymous names do not roundtrip\n    && !n.hasMacroScopes -- names with macroscopes do not roundtrip\n    && !maybePseudoSyntax -- names which might be \"pseudo-syntax\" do not roundtrip\n ",
      "body": "Oh, hey, this seems so familiar... :)\n\nIf we keep this, we should document the living daylights out of this function. Without doing so, it would be totally mysterious to a future maintainer of this file who is trying to figure out e.g. what core change made roundtripping break.\n\nHere's a first pass at documentation. (Sorry, adding newlines is necessary.)\n\n```suggestion\n/--\nDetermines if the pretty-printed version of the given name would parse as an `ident` with an underlying name (via `getId`) e",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 3310,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  have := hs (i := 1) (j := 2) (by decide)\r\n",
      "body": "```suggestion\r\n  have := hs (i := 1) (j := 2) (by decide)\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "decide",
          "have"
        ],
        "body_tactics": [
          "decide",
          "have"
        ],
        "new_tactics": [
          "decide",
          "have"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 3311,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  have := hs (i := 0) (j := 1) (by decide)\r\n",
      "body": "```suggestion\r\n  have := hs (i := 0) (j := 1) (by decide)\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "decide",
          "have"
        ],
        "body_tactics": [
          "decide",
          "have"
        ],
        "new_tactics": [
          "decide",
          "have"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 3317,
      "before_code": "set at this point. -/\n@[fun_prop]",
      "suggestion": "\r\n@[to_fun (attr := fun_prop)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop)]\r\n```",
      "path": "Mathlib/Analysis/Calculus/ContDiff/Operations.lean",
      "tags": {
        "before_tactics": [
          "fun_prop"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "fun_prop",
          "point",
          "this",
          "set"
        ]
      }
    },
    {
      "id": 3319,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n    obtain \u27e8U, hU, H\u27e9 := ((hf.eventually (by simp)).and (hg.eventually (by simp))).exists_mem\r\n",
      "body": ":golf:\r\n```suggestion\r\n    obtain \u27e8U, hU, H\u27e9 := ((hf.eventually (by simp)).and (hg.eventually (by simp))).exists_mem\r\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 3320,
      "before_code": "rw [weierstrassPExceptSeries, FormalMultilinearSeries.ofScalars_apply_eq,\n      FormalMultilinearSeries.coeff_ofScalars, smul_eq_mul]\n\nlemma analyticOnNhd_weierstrassPExcept (l\u2080 : \u2102) : AnalyticOnNhd \u2102 \u2118[L - l\u2080] (L.lattice \\ {l\u2080})\u1d9c :=\n  (L.differentiableOn_weierstrassPExcept l\u2080).analyticOnNhd L.isOpen_compl_lattice_diff",
      "suggestion": "\r\n    \u00b7 simp [Nat.factorial_succ (n + 1)]\r\n      field [(n + 1).factorial_pos.ne']\r\n",
      "body": "```suggestion\r\n    \u00b7 simp [Nat.factorial_succ (n + 1)]\r\n      field [(n + 1).factorial_pos.ne']\r\n```\r\nIt's a pity that `field_simp` isn't able to spot automatically that factorials are non-zero, given how often one needs to divide by `n!`. Perhaps one could do the following:\r\n- add an instance `NeZero n.factorial` for all `n : Nat` (a bundled version of `Nat.factorial_ne_zero`)\r\n- add `NeZero.ne` to the list of lemmas used by `field_simp` in line 85-6 of `Mathlib.Tactic.FieldSimp.Discharger`.\r\nB",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "field_simp",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "complex",
          "differentiability",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "analyticOnNhd_weierstrassPExcept",
          "FormalMultilinearSeries",
          "weierstrassPExceptSeries",
          "AnalyticOnNhd",
          "coeff_ofScalars",
          "isOpen_compl_lattice_diff",
          "ofScalars_apply_eq",
          "differentiableOn_weierstrassPExcept",
          "smul_eq_mul",
          "analyticOnNhd",
          "lattice"
        ]
      }
    },
    {
      "id": 3327,
      "before_code": "instance ULift.instT5Space [T5Space X] : T5Space (ULift X) :=\n  IsEmbedding.uliftDown.t5Space",
      "suggestion": "    T5Space X \u2194 \u2200 s : Set X, IsOpen s \u2192 T4Space s where\n  mp := fun _ _ _ => inferInstance\n  mpr h := \n  \t{ toCompletelyNormalSpace :=\n        completelyNormalSpace_iff_forall_isOpen_normalSpace.2 fun s hs => (h s hs).toNormalSpace\n      toT1Space :=\n        have := h univ isOpen_univ\n        t1Space_of_injective_of_continuous\n          (fun _ _ => congrArg Subtype.val) (continuous_id.subtype_mk mem_univ) }\n",
      "body": "I prefer to use `where` or `:= by` when the proof of an `\u2194` where one of the proofs is more than a line or two.\n```suggestion\n    T5Space X \u2194 \u2200 s : Set X, IsOpen s \u2192 T4Space s where\n  mp := fun _ _ _ => inferInstance\n  mpr h := \n  \t{ toCompletelyNormalSpace :=\n        completelyNormalSpace_iff_forall_isOpen_normalSpace.2 fun s hs => (h s hs).toNormalSpace\n      toT1Space :=\n        have := h univ isOpen_univ\n        t1Space_of_injective_of_continuous\n          (fun _ _ => congrArg Subtype.val) (",
      "path": "Mathlib/Topology/Separation/Regular.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsEmbedding",
          "T5Space",
          "ULift",
          "uliftDown",
          "t5Space",
          "instT5Space",
          "instance"
        ]
      }
    },
    {
      "id": 3336,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\n  have : p.IsPrime := by rw [P.over_def p]; infer_instance\r\n",
      "body": "```suggestion\r\n  have : p.IsPrime := by rw [P.over_def p]; infer_instance\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw",
          "have"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 3337,
      "before_code": "end single",
      "suggestion": "\r\ntheorem trace_surjective [AddCommMonoid R] [Nonempty n] :\r\n    Function.Surjective (trace : Matrix n n R \u2192 R) := fun r \u21a6 by\r\n  classical\r\n  let i := Classical.arbitrary n\r\n  exact \u27e8single i i r, trace_single_eq_same i r\u27e9\r\n",
      "body": "No need to section things off. And better to just use the variables above. And also instead of repeating `Classical.arbitrary` just define it once:\r\n\r\n```suggestion\r\ntheorem trace_surjective [AddCommMonoid R] [Nonempty n] :\r\n    Function.Surjective (trace : Matrix n n R \u2192 R) := fun r \u21a6 by\r\n  classical\r\n  let i := Classical.arbitrary n\r\n  exact \u27e8single i i r, trace_single_eq_same i r\u27e9\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/Trace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "single",
          "end"
        ]
      }
    },
    {
      "id": 3339,
      "before_code": "(rootSpaceProduct R L H \u03b1 (-\u03b1) 0 (add_neg_cancel \u03b1) (\u27e8y, hy\u27e9 \u2297\u209c[R] \u27e8z, hz\u27e9)).property using 0\n  simp [hyz]",
      "suggestion": "lemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n",
      "body": "```suggestion\nlemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n```",
      "path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "exact",
          "simpa",
          "rw",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "rootSpaceProduct",
          "property",
          "simp",
          "add_neg_cancel",
          "using",
          "hyz"
        ]
      }
    },
    {
      "id": 3340,
      "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
      "suggestion": "    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n",
      "body": "There are two _independent_ changes here:\n\n1. Fix the `by exact` issue by adding `.toLinearMap` to help elaboration\n2. Add `.toSubmodule` rather than a coercion to avoid an indirect coercion (`LieIdeal` to `LieSubalgebra` to `Submodule`)\n```suggestion\n    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n```",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "add_lie",
          "mem_coe",
          "SetLike",
          "exact",
          "Submodule",
          "add_mem",
          "simp",
          "carrier_eq_coe",
          "only"
        ]
      }
    },
    {
      "id": 3341,
      "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
      "suggestion": "\r\n-- This should probably be somewhere in the file `Algebra.Lie.Weights.RootSystem`\r\nopen LieSubmodule in\r\n@[simp]\r\nlemma biSup_corootSpace_eq_top :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 := by\r\n  simp only [\u2190 toSubmodule_inj, top_toSubmodule, iSup_toSubmodule,\r\n    \u2190 RootPairing.IsRootSystem.span_coroot_eq_top (P := rootSystem H),\r\n    coe_corootSpace_eq_span_singleton, Submodule.iSup_span]\r\n  congr\r\n  ext \u03b1\r\n  simp [eq_comm]\r\n\r\n-- This should probably be below `bisup_corootSpace_eq_top`\r\n@[simp]\r\nlemma biSup_corootSubmodule_eq_cartan :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSubmodule \u03b1 = H.toLieSubmodule := by\r\n  suffices \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 from\r\n    le_antisymm (by simp) (by simp [\u2190 LieSubmodule.map_iSup, this])\r\n  simp\r\n\r\nopen LieSubmodule in\r\n@[simp] lemma invtSubmoduleToLieIdeal_top :\r\n    invtSubmoduleToLieIdeal (\u22a4 : Submodule K (Module.Dual K H)) (by simp) = \u22a4 := by\r\n  simp_rw [\u2190 toSubmodule_inj, coe_",
      "body": "I think the right way to break this result down is as follows:\r\n```suggestion\r\n-- This should probably be somewhere in the file `Algebra.Lie.Weights.RootSystem`\r\nopen LieSubmodule in\r\n@[simp]\r\nlemma biSup_corootSpace_eq_top :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 := by\r\n  simp only [\u2190 toSubmodule_inj, top_toSubmodule, iSup_toSubmodule,\r\n    \u2190 RootPairing.IsRootSystem.span_coroot_eq_top (P := rootSystem H),\r\n    coe_corootSpace_eq_span_singleton, Submodule.iSup_span]\r\n  ",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "congr",
          "refine",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "congr",
          "refine",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "congr",
          "refine",
          "ext"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "line_break"
        ],
        "keywords": [
          "add_lie",
          "mem_coe",
          "SetLike",
          "exact",
          "Submodule",
          "add_mem",
          "simp",
          "carrier_eq_coe",
          "only"
        ]
      }
    },
    {
      "id": 3350,
      "before_code": "contrapose! hs\n  simpa [hs] using IsMeagre.empty",
      "suggestion": "  suffices IsMeagre (\u22c3 i : I, A i) by simpa\n",
      "body": "```suggestion\n  suffices IsMeagre (\u22c3 i : I, A i) by simpa\n```",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "contrapose",
          "empty",
          "IsMeagre",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 3351,
      "before_code": "applyReplacementFun t e #[]\n\n/-- Unfold auxlemmas in the type and value. -/",
      "suggestion": "\r\n/-- Unfold auxlemmas (generated by `simp`) in the type and value. -/\r\n",
      "body": "```suggestion\r\n/-- Unfold auxlemmas (generated by `simp`) in the type and value. -/\r\n```",
      "path": "Mathlib/Tactic/Translate/Core.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "auxlemmas",
          "Unfold",
          "value",
          "type",
          "applyReplacementFun"
        ]
      }
    },
    {
      "id": 3356,
      "before_code": "\u00b7 rw [h1]\n  \u00b7 rfl",
      "suggestion": "theorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitFunction xy.1 = xy.2 := by\n  refine h.implicitFunctionData.hasStrictFDerivAt.eventually_left_inverse.mono fun xy h\u2081 h\u2082 \u21a6 ?_\n  change (h.implicitFunctionData.implicitFunction xy.1 (f a)).2 = xy.2\n  change h.implicitFunctionData.implicitFunction xy.1 (f xy) = xy at h\u2081\n  aesop\n",
      "body": "I strongly encourage you to embrace the existing API for `ImplicitFunctionData`. You're currently fighting it quite a bit in this proof. I prefer the following golf not so much because it is shorter but because it makes it clear that this is really just a wrapper around `ImplicitFunctionData.hasStrictFDerivAt` and `HasStrictFDerivAt.eventually_left_inverse`:\n```suggestion\ntheorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitF",
      "path": "Mathlib/Analysis/Calculus/ImplicitContDiff.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "rfl"
        ]
      }
    },
    {
      "id": 3368,
      "before_code": "rw [and_congr_right IsClosed.isNowhereDense_iff,\n    isOpen_compl_iff, interior_eq_empty_iff_dense_compl]",
      "suggestion": "\r\n/-- To check that `s` is nowhere dense, it suffices to check that no point of `s`\r\nis in the interior of `closure s`. -/\r\nlemma isNowhereDense_iff_disjoint {s : Set X} :\r\n    IsNowhereDense s \u2194 Disjoint s (interior (closure s)) :=\r\n  \u27e8fun H \u21a6 H \u25b8 disjoint_empty _, fun H \u21a6\r\n    H.closure_left isOpen_interior |>.mono_left interior_subset |>.eq_bot_of_self\u27e9\r\n\r\n/-- To check that `s` is nowhere dense, it suffices to check that `closure s` is not a\r\nneighborhood of any point of `s`. -/\r\nlemma isNowhereDense_iff_forall_notMem_nhds {s : Set X} :\r\n    IsNowhereDense s \u2194 \u2200 x \u2208 s, closure s \u2209 \ud835\udcdd x := by\r\n  simp [isNowhereDense_iff_disjoint, disjoint_iff_inter_eq_empty, eq_empty_iff_forall_notMem,\r\n    mem_interior_iff_mem_nhds]\r\n\r\n/-- The image of a nowhere dense set through an inducing map is nowhere dense. -/\r\nlemma Topology.IsInducing.isNowhereDense_image {f : X \u2192 Y} [TopologicalSpace Y]\r\n    (hf : Topology.IsInducing f) {s : Set X} (h : IsNowhereDense s) : IsNowhereDense (f '' s) := by\r\n  rw",
      "body": "I was intrigued by this proof: it is slightly mathematically annoying, because you have to change the original `y` if it's not in `f '' s`. This led me to the following, which you should feel free to accept or not (i.e I have no preference):\r\n```suggestion\r\n/-- To check that `s` is nowhere dense, it suffices to check that no point of `s`\r\nis in the interior of `closure s`. -/\r\nlemma isNowhereDense_iff_disjoint {s : Set X} :\r\n    IsNowhereDense s \u2194 Disjoint s (interior (closure s)) :=\r\n  \u27e8fun H \u21a6",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "interior_eq_empty_iff_dense_compl",
          "and_congr_right",
          "isOpen_compl_iff",
          "IsClosed",
          "isNowhereDense_iff"
        ]
      }
    },
    {
      "id": 3369,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081_iff_termDefinable (f : M \u2192 M) : A.TermDefinable\u2081 L f \u2194\r\n    A.TermDefinable L (fun v \u21a6 f (v ())) := by\r\n  refine exists_congr fun \u03c6 \u21a6 ?_\r\n  rw [funext_iff, funext_iff, (Equiv.funUnique Unit M).forall_congr']\r\n  simp only [Equiv.funUnique_symm_apply, uniqueElim_const, Function.comp_apply]\r\n  congr!\r\n",
      "body": "This would be shorter (just an suggestion, feel free to ignore it)\r\n\r\n```suggestion\r\ntheorem TermDefinable\u2081_iff_termDefinable (f : M \u2192 M) : A.TermDefinable\u2081 L f \u2194\r\n    A.TermDefinable L (fun v \u21a6 f (v ())) := by\r\n  refine exists_congr fun \u03c6 \u21a6 ?_\r\n  rw [funext_iff, funext_iff, (Equiv.funUnique Unit M).forall_congr']\r\n  simp only [Equiv.funUnique_symm_apply, uniqueElim_const, Function.comp_apply]\r\n  congr!\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3370,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.const M C) :=\r\n  (TermDefinable.const C).termDefinable\u2081\r\n",
      "body": "Generalize\r\n\r\n```suggestion\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.c",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_fun_prop"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3371,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp {f g : M \u2192 M} (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable\u2081 L g) :\r\n    A.TermDefinable\u2081 L (f \u2218 g) :=\r\n  (hf.termDefinable.comp fun _ \u21a6 hg.termDefinable).termDefinable\u2081\r\n\r\n/-- A `TermDefinable` function postcomposed with `TermDefinable\u2081` is `TermDefinable`. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp_termDefinable {f : M \u2192 M} {g : (\u03b1 \u2192 M) \u2192 M}\r\n    (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable L g) : A.TermDefinable L (f \u2218 g) :=\r\n  hf.termDefinable.comp fun _ \u21a6 hg\r\n",
      "body": "```suggestion\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "new_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_fun_prop"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3372,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081.graph_definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n    A.Definable\u2082 L f.graph := by\r\n  obtain \u27e8t, h\u27e9 := h.termDefinable.tupleGraph_definable A L\r\n  use t.relabel (Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  ext v\r\n  convert Set.ext_iff.1 h (Sum.elim (fun _ \u21a6 v 0) (fun _ \u21a6 v 1))\r\n  rw [mem_setOf, mem_setOf, Formula.realize_relabel, Sum.comp_elim]\r\n  rfl\r\n",
      "body": "```suggestion\r\ntheorem TermDefinable\u2081.graph_definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n    A.Definable\u2082 L f.graph := by\r\n  obtain \u27e8t, h\u27e9 := h.termDefinable.tupleGraph_definable A L\r\n  use t.relabel (Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  ext v\r\n  convert Set.ext_iff.1 h (Sum.elim (fun _ \u21a6 v 0) (fun _ \u21a6 v 1))\r\n  rw [mem_setOf, mem_setOf, Formula.realize_relabel, Sum.comp_elim]\r\n  rfl\r\n```\r\n\r\n`rw [setOf]` is a defeq abuse (see docstring of `Set.setOf_app_iff`)",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3375,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  convert Set.ext_iff.1 h (v \u2218 Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  simp\r\n",
      "body": "golf\r\n```suggestion\r\n  convert Set.ext_iff.1 h (v \u2218 Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  simp\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3383,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n",
      "body": "```suggestion\n  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n```\n\n`by exact` is (almost always) a no-op.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 3384,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "      (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset]))\n",
      "body": "```suggestion\n      (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset]))\n```",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 3385,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "    (fun n => (hg1 n).inter (hV.1 n))\n    (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset])) (hg1 n))\n",
      "body": "```suggestion\n    (fun n => (hg1 n).inter (hV.1 n))\n    (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset])) (hg1 n))\n```\nI think this slightly improves readability.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 3386,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n",
      "body": "I would like to reformat this to make it easier to distinguish the different arguments. I originally thought this was one argument to `mkCLM`.\n```suggestion\n  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n```\nThen indent the remainder of the proof, and remove the final `)`.",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "simpa",
          "simp",
          "intro",
          "fun_prop"
        ],
        "body_tactics": [
          "ext",
          "simpa",
          "simp",
          "intro",
          "fun_prop"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "ext",
          "intro",
          "fun_prop"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa",
          "use_fun_prop"
        ],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 3387,
      "before_code": "convert hf.add hg.neg using 1\n  grind",
      "suggestion": "\r\n  classical\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert a s has ih => \r\n    obtain \u27e8hf, h\u27e9 := by simpa using hf\r\n    simpa [has] using hf.add (ih h)\r\n",
      "body": "When I saw this, I thought \"do we really not have `HasTemperateGrowth.add`?\" and then I realized we do. This is much easier than you're making it. You need to use an induction principle. In this case:\r\n```suggestion\r\n  classical\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert a s has ih => \r\n    obtain \u27e8hf, h\u27e9 := by simpa using hf\r\n    simpa [has] using hf.add (ih h)\r\n```",
      "path": "Mathlib/Analysis/Distribution/TemperateGrowth.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "removed_tactics": [
          "grind"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "add",
          "neg",
          "convert",
          "grind",
          "using"
        ]
      }
    },
    {
      "id": 3388,
      "before_code": "filter_upwards [Tendsto.eventually_const_lt (zero_lt_one) h\u03c6, hu\u03c6v] with x h\u03c6_pos huv'\n  simp [\u2190 Real.mul_rpow (le_of_lt h\u03c6_pos) (hv x), huv']",
      "suggestion": "\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <| Real.tendsto_log_atTop.comp g_tendsto\r\n",
      "body": "slightly cleaner\r\n```suggestion\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <",
      "path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "body_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "new_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "eventually_const_lt",
          "zero_lt_one",
          "Real",
          "Tendsto",
          "filter_upwards",
          "mul_rpow",
          "simp",
          "huv"
        ]
      }
    },
    {
      "id": 3393,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "\r\ntheorem iterate_derivative_derivative_mul_X_pow {n m l : \u2115} (p : R[X]) (hl : m \u2264 l) :\r\n    derivative^[n] (derivative^[l] p * X ^ m) =\r\n      \u2211 k \u2208 range (min m n).succ,\r\n        ((n.choose k * m.descFactorial k) \u2022 (derivative^[n + (l - k)] p * X ^ (m - k))) := by\r\n  have {k : \u2115} (hk : k \u2208 range (min m n).succ) : n - k + l = n + (l - k) := by\r\n    replace hk : k \u2264 m \u2227 k \u2264 n := by simpa using hk\r\n    grind\r\n  simp_rw [iterate_derivative_mul_X_pow, \u2190 Function.iterate_add_apply]\r\n  exact Finset.sum_congr rfl fun k hk \u21a6 by simp [this hk]\r\n",
      "body": "I'm also dubious about this lemma since it's really just an extension of `iterate_derivative_mul_X_pow` which inlines a proof that `n + (m - k) = n - k + m` for `k` in the right range.\r\n\r\nOf course convenience lemmas can be justified if they come up enough. If you do have compelling evidence in favour then I think we should generalise since the repeated `m` is not relevant, and also avoid using low-level lemmas like `Nat.add_sub_assoc` as follows:\r\n```suggestion\r\ntheorem iterate_derivative_deriv",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 3395,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n    simp_rw [iterate_derivative_mul, iterate_derivative_X_pow_eq_smul, mul_smul]\n    congr! 2 with k hk\n    norm_cast\n    ring\n  rw [hsum]\n  refine sum_congr_of_eq_on_inter (fun k hk hk' \u21a6 ?_) (by aesop) (by simp)\n  rcases le_or_gt k m with hkm | hkm\n  \u00b7 replace hk' : n < k := by simpa [hkm] using hk'\n    simp [Nat.choose_eq_zero_of_lt hk']\n  \u00b7 simp [Nat.descFactorial_eq_zero_iff_lt.mpr hkm]\n",
      "body": "Here's a slight golf. It's happens to be shorter but my main aim was to make the formal proof match how I think about this argument a bit more closely:\n```suggestion\ntheorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivati",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "ring",
          "norm_cast"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "ring",
          "norm_cast"
        ],
        "new_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_ring",
          "use_aesop"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 3396,
      "before_code": "map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\ndef toModuleCatObj : Submodule R M :=\r\n  LinearMap.range (\u03c4\u2081\u2082 := .id _) <|\r\n    { __ := DistribMulAction.toAddMonoidHom M (single default default 1 : Matrix \u03b9 \u03b9 R)\r\n      map_smul' r x := by\r\n        dsimp\r\n        rw [\u2190 smul_assoc r, Matrix.smul_eq_diagonal_mul, show (diagonal fun x : \u03b9 \u21a6 r) *\r\n          single _ _ 1 = single default default 1 * diagonal (fun _ \u21a6 r) by ext; simp [Matrix.single],\r\n          SemigroupAction.mul_smul, \u2190 Matrix.smul_one_eq_diagonal]\r\n        nth_rw 1 [\u2190 one_smul (Matrix \u03b9 \u03b9 R) x]\r\n        rw [smul_assoc] }\r\n",
      "body": "Perhaps nicer to build the map first:\r\n```suggestion\r\ndef toModuleCatObj : Submodule R M :=\r\n  LinearMap.range (\u03c4\u2081\u2082 := .id _) <|\r\n    { __ := DistribMulAction.toAddMonoidHom M (single default default 1 : Matrix \u03b9 \u03b9 R)\r\n      map_smul' r x := by\r\n        dsimp\r\n        rw [\u2190 smul_assoc r, Matrix.smul_eq_diagonal_mul, show (diagonal fun x : \u03b9 \u21a6 r) *\r\n          single _ _ 1 = single default default 1 * diagonal (fun _ \u21a6 r) by ext; simp [Matrix.single],\r\n          SemigroupAction.mul_smul, \u2190 Matrix.",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "LinearMap",
          "map_comp",
          "mapMatrixModule",
          "mapMatrixModule_id",
          "map",
          "ModuleCat",
          "hom_ext",
          "ofHom",
          "mapMatrixModule_comp",
          "map_id"
        ]
      }
    },
    {
      "id": 3401,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n",
      "body": "For this sort of argument (where `fun_prop` can't quite close the goal alone), I find it works well to put auxiliary facts into the context and then run `fun_prop` with a custom discharger:\r\n ```suggestion\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "use_fun_prop"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 3402,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n",
      "body": "We can use more automation here too:\r\n```suggestion\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "funext",
          "exact",
          "have",
          "simp",
          "fun_prop"
        ],
        "body_tactics": [
          "funext",
          "exact",
          "have",
          "simp",
          "fun_prop"
        ],
        "new_tactics": [
          "funext",
          "simp",
          "exact",
          "fun_prop",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 3405,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194 Nonempty (G.CompleteBipartiteSubgraph (card \u03b1) (card \u03b2)) where\r\n  mp := fun \u27e8f\u27e9 \u21a6 \u27e8CompleteBipartiteSubgraph.ofCopy f\u27e9\r\n  mpr := fun \u27e8B\u27e9 \u21a6 \u27e8B.toCopy.comp <| Iso.toCopy \u27e8(equivFin \u03b1).sumCongr (equivFin \u03b2), by simp\u27e9\u27e9\r\n",
      "body": "nit:\r\n```suggestion\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194 Nonempty (G.CompleteBipartiteSubgraph (card \u03b1) (card \u03b2)) where\r\n  mp := fun \u27e8f\u27e9 \u21a6 \u27e8CompleteBipartiteSubgraph.ofCopy f\u27e9\r\n  mpr := fun \u27e8B\u27e9 \u21a6 \u27e8B.toCopy.comp <| Iso.toCopy \u27e8(equivFin \u03b1).sumCongr (equivFin \u03b2), by simp\u27e9\u27e9\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 3413,
      "before_code": "lemma reciprocalFactors_odd {n : \u2115} (h1 : n \u2260 1) (h2 : Odd n) :\n    reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1) := by\n  have h0 : n \u2260 0 := by\n    rintro rfl\n    norm_num [\u2190 Nat.not_even_iff_odd] at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.not_even_iff_odd.2 h2)]",
      "suggestion": "\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n",
      "body": "this is 10x slower than the previous proof. What about changing it to something like this?\r\n```suggestion\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n```\r\nso same as before, but the `n \u2260 0` is by `grind`.",
      "path": "Mathlib/GroupTheory/CommutingProbability.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "grind"
        ],
        "removed_tactics": [
          "norm_num",
          "have"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "norm_num",
          "reciprocalFactors_odd",
          "lemma",
          "reciprocalFactors",
          "not_even_iff_odd",
          "Odd",
          "Nat",
          "dif_neg",
          "have",
          "rintro",
          "if_neg",
          "rfl"
        ]
      }
    },
    {
      "id": 3418,
      "before_code": "(fun _ _ _ _ he => AffineIndependent.injective s\u2081.independent he)\n      (fun _ _ _ _ he => AffineIndependent.injective s\u2082.independent he) h",
      "suggestion": "  exact affineSpan_mono _ (by simp) (s.faceOppositeCentroid_mem_affineSpan_face i)\n",
      "body": "```suggestion\n  exact affineSpan_mono _ (by simp) (s.faceOppositeCentroid_mem_affineSpan_face i)\n```\nDoes this work? If so, I wonder if this one-line should be an extra lemma. It seems to me that it can just be inlined when needed.",
      "path": "Mathlib/LinearAlgebra/AffineSpace/Simplex/Centroid.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "independent",
          "AffineIndependent",
          "injective"
        ]
      }
    },
    {
      "id": 3422,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_one' := by simp\r\n        mul_le' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_mul_le_add p.1 x y) <| add_le_add _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 _\r\n            \u00b7 use q y\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 _\r\n          \u00b7 simp_all\r\n        inv' x := by simp }\r\n",
      "body": "same proofs, just significantly shorter and easier to read\r\n\r\n```suggestion\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_one' := by simp\r\n        mul_le' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_mul_le_add p.1 x y) <| add_le_add _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "refine",
          "simp_all",
          "simp",
          "exact",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "com",
          "https",
          "add_apply",
          "theorem",
          "too",
          "pull",
          "skeleton",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "rfl",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 3423,
      "before_code": "instance : Inhabited (NonarchAddGroupSeminorm E) :=\n  \u27e80\u27e9\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_zero' := by simp\r\n        add_le_max' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_add_le_max p.1 x y) <| max_le_max _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 x\r\n            \u00b7 use q y\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 y\r\n          \u00b7 simp_all\r\n        neg' x := congr(\u2a06 _, $(map_neg_eq_map _ x)) }\r\n",
      "body": "```suggestion\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_zero' := by simp\r\n        add_le_max' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_add_le_max p.1 x y) <| max_le_max _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exa",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "com",
          "https",
          "Inhabited",
          "too",
          "pull",
          "skeleton",
          "NonarchAddGroupSeminorm",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "instance",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 3424,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "noncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n            all_goals\n              apply le_ciSup (f := (DFunLike.coe \u00b7 _) \u2218 Subtype.val) ?_ p\n              simpa [Set.range_comp] using Monotone.map_bddAbove (fun _ _ h' \u21a6 by exact h' _) h\n        inv' x := by simp }\n    else 0\n",
      "body": "I think `where` syntax is nicer here, and I provided a small golf to avoid the case split.\n```suggestion\nnoncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n     ",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa",
          "term_mode"
        ],
        "keywords": [
          "community",
          "com",
          "https",
          "add_apply",
          "theorem",
          "too",
          "pull",
          "skeleton",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "rfl",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 3425,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345\n@[to_additive]\ninstance : Max (GroupSeminorm E) :=",
      "suggestion": "\nlemma sSup_of_not_bddAbove {s : Set (GroupSeminorm E)} (hs : \u00acBddAbove s) :\n    sSup s = 0 := by\n  simp [SupSet.sSup, hs]\n\nlemma coe_sSup_apply {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = \u2a06 p : s, (p : GroupSeminorm E) x := by\n  simp [SupSet.sSup, hs]\n  rfl\n\nlemma coe_sSup_apply' {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = sSup ((\u00b7 x) '' s) := by\n  rw [coe_sSup_apply hs, \u2190 sSup_range]\n  congr\n  ext\n  simp\n\nlemma coe_iSup_apply {\u03b9 : Type*} (f : \u03b9 \u2192 GroupSeminorm E) (h : BddAbove (range f)) {x : E} :\n    \u21d1(\u2a06 i, f i) x = \u2a06 i, (f i : GroupSeminorm E) x := by\n  rw [\u2190 sSup_range, coe_sSup_apply h]\n  exact (Set.rangeFactorization_surjective.iSup_congr _ (by simp)) |>.symm\n\n@[to_additive]\ninstance : Max (GroupSeminorm E) :=\n",
      "body": "you should have these lemmas available for rewriting\n```suggestion\n\nlemma sSup_of_not_bddAbove {s : Set (GroupSeminorm E)} (hs : \u00acBddAbove s) :\n    sSup s = 0 := by\n  simp [SupSet.sSup, hs]\n\nlemma coe_sSup_apply {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = \u2a06 p : s, (p : GroupSeminorm E) x := by\n  simp [SupSet.sSup, hs]\n  rfl\n\nlemma coe_sSup_apply' {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = sSup ((\u00b7 x) '' s) := by\n  rw [coe_sSup_apply hs",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "exact",
          "rw",
          "simp",
          "congr"
        ],
        "body_tactics": [
          "ext",
          "exact",
          "have",
          "rw",
          "simp",
          "congr"
        ],
        "new_tactics": [
          "rw",
          "simp",
          "ext",
          "exact",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "skeleton",
          "GroupSeminorm",
          "github",
          "Max",
          "TODO",
          "SupSet",
          "to_additive",
          "add_apply",
          "leanprover",
          "com",
          "issuecomment",
          "rfl",
          "https",
          "theorem",
          "too",
          "pull",
          "mathlib",
          "from",
          "instance",
          "define"
        ]
      }
    },
    {
      "id": 3426,
      "before_code": "natDegree (\u2211 i \u2208 s, f i) \u2264 n :=\n  le_trans (natDegree_sum_le s f) <| (Finset.fold_max_le n).mpr <| by simpa",
      "suggestion": "  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n",
      "body": "```suggestion\n  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n```",
      "path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "body_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "natDegree_sum_le",
          "natDegree",
          "mpr",
          "fold_max_le",
          "Finset",
          "simpa",
          "le_trans"
        ]
      }
    },
    {
      "id": 3436,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n",
      "body": "```suggestion\n  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n```\n`by exact` should be dropped most of the time.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 3437,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "  have h : a \u2260 b := by intro hab; simp [hab] at h\u03bc0\n",
      "body": "```suggestion\n  have h : a \u2260 b := by intro hab; simp [hab] at h\u03bc0\n```\nNo need to `subst`, it's something `simp` can do.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simp",
          "have",
          "intro"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 3438,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]\n\n/-- The mean value theorem for integrals:\nThere exists a point in an interval such that the mean of a continuous function over the interval\nequals the value of the function at the point. -/\ntheorem exists_eq_interval_average\n    {f : \u211d \u2192 \u211d} {a b : \u211d} (hab : a \u2260 b) (hf : ContinuousOn f (uIcc a b)) :\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d (x : \u211d) in a..b, f x := by\n  wlog h : a < b generalizing a b\n  \u00b7 rw [uIcc_comm] at hf\n    have := this hab.symm hf (lt_of_le_of_ne (le_of_not_gt h) (Ne.symm hab))\n    rwa [uIoo_comm, interval_average_symm] at this\n  let ave := \u2a0d (x : \u211d) in a..b, f x\n  have h_vol_fin1 : volume (uIoc a b) \u2260 0 := by simpa [h.le] using h\n  have h_vol_fin2 : volume (uIoc a b) \u2260 \u22a4 := by simp [h.le]\n  have h_intble : IntegrableOn f (uIoc a b) := by\n    have : IntegrableOn f (uIcc a b) := hf.integrableOn_uIcc\n    rwa [uIcc_of_lt h,integrableOn_Icc_iff_integrableOn_Ioc, \u2190uIoc_of_le (le_of_lt h)] at this\n  let S1 := {x | x \u2208 uIoc a b \u2227 f x \u2264 ave}\n  let S2 := {x | x \u2208 uIoc a b \u2227 ave \u2264 f x}\n  have h_meas1 : volume (S1 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_le_setAverage_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  have h_meas2 : volume (S2 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_setAverage_le_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  obtain \u27e8c1, \u27e8hc1_mem, hc1_le\u27e9, hc1'\u27e9 := nonempty_of_measure_ne_zero h_meas1\n  have hc1' : c1 \u2208 Ioo a b := by\n    rw [Set.uIoc_of_le (le_of_lt h)] at hc1_mem\n    rw [notMem_singleton_iff] at hc1'\n    exact \u27e8hc1_mem.1, lt_of_le_of_ne hc1_mem.2 hc1'\u27e9\n  obtain \u27e8c2, \u27e8hc2_mem, hc2_ge\u27e9, hc2'\u27e9 := nonempty_of_measure_ne_zero h_meas2\n  have hc2' : c2 \u2208 Ioo a b := by\n    rw [Se",
      "suggestion": "    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n",
      "body": "```suggestion\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n```\nsimp lemmas that you register elsewhere in the PR make the proof very direct!",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "cases",
          "have",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "continuity",
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "rwa",
          "codiscreteWithin",
          "interval_average_symm",
          "intervalIntegral",
          "le_of_lt",
          "Ioo_subset_Icc_self",
          "have",
          "mem_Ioo",
          "Filter",
          "notMem_singleton_iff",
          "integrableOn_uIcc",
          "intro",
          "hc2_mem",
          "such",
          "uIoc_of_le",
          "hab",
          "that",
          "simp",
          "h_ave",
          "volume",
          "theorem",
          "h_vol_fin2",
          "h_meas1",
          "h_meas2",
          "value",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "lt_of_lt_of_le",
          "There",
          "point",
          "imp",
          "uIcc",
          "intermediate_value_uIcc",
          "h_intble",
          "uIoo",
          "IntegrableOn",
          "hc1_mem",
          "continuous",
          "hc1_le",
          "hc1",
          "generalizing",
          "lt_of_le_of_ne",
          "interval",
          "Icc",
          "ave",
          "hc2",
          "measure_diff_null",
          "Ioo",
          "hc2_ge",
          "integrals"
        ]
      }
    },
    {
      "id": 3446,
      "before_code": "(isMulCocycle\u2081_of_mem_cocycles\u2081 _ x.2) with \u27e8\u03b2, h\u03b2\u27e9\n    use \u03b2",
      "suggestion": "  have := FiniteCyclicGroup.groupCohomology\u03c0Odd_eq_zero_iff (ofAlgebraAutOnUnits K L) g hg\n",
      "body": "There are two consecutive spaces between `groupCohomology\u03c0Odd_eq_zero_iff` and `(ofAlgebraAutOnUnits K L)`. This should be a single space for consistent formatting.\n```suggestion\n  have := FiniteCyclicGroup.groupCohomology\u03c0Odd_eq_zero_iff (ofAlgebraAutOnUnits K L) g hg\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/Hilbert90.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "use"
        ]
      }
    },
    {
      "id": 3448,
      "before_code": "(isMulCocycle\u2081_of_mem_cocycles\u2081 _ x.2) with \u27e8\u03b2, h\u03b2\u27e9\n    use \u03b2",
      "suggestion": "    have hxinv : Algebra.norm K x\u207b\u00b9 = 1 := by simp [Algebra.norm_inv, hx]\n    obtain \u27e8y, hy\u27e9 := H _ hxinv\n    use y\n    rw [IsUnit.div_eq_iff y.isUnit] at hy\n    rw [hy]\n    field_simp\n",
      "body": "```suggestion\n    have hxinv : Algebra.norm K x\u207b\u00b9 = 1 := by simp [Algebra.norm_inv, hx]\n    obtain \u27e8y, hy\u27e9 := H _ hxinv\n    use y\n    rw [IsUnit.div_eq_iff y.isUnit] at hy\n    rw [hy]\n    field_simp\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/Hilbert90.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "field_simp",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "field_simp",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "field_simp",
          "rw",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "use"
        ]
      }
    },
    {
      "id": 3451,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9",
      "suggestion": "lemma tendsto_nhds_top_iff {\u03b1 : Type*} {f : Filter \u03b1} (x : \u03b1 \u2192 WithTop \u03b9) :\n    Tendsto x f (\ud835\udcdd \u22a4) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (a : \u03b1) in f, i < x a := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using .of_forall fun _ \u21a6 Subsingleton.elim ..\n  refine nhds_top_basis.tendsto_right_iff.trans ?_\n  rw [\u2190 Set.forall_mem_range (p := (\u2200\u1da0 a in f, \u00b7 < x a)), WithTop.range_coe]\n  simp\n",
      "body": "You can avoid the `Nonempty` hypothesis and simplify the proof like so:\n```suggestion\nlemma tendsto_nhds_top_iff {\u03b1 : Type*} {f : Filter \u03b1} (x : \u03b1 \u2192 WithTop \u03b9) :\n    Tendsto x f (\ud835\udcdd \u22a4) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (a : \u03b1) in f, i < x a := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using .of_forall fun _ \u21a6 Subsingleton.elim ..\n  refine nhds_top_basis.tendsto_right_iff.trans ?_\n  rw [\u2190 Set.forall_mem_range (p := (\u2200\u1da0 a in f, \u00b7 < x a)), WithTop.range_coe]\n  simp\n```",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 3453,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9\n\nend WithTop",
      "suggestion": "",
      "body": "If you add this lemma (in the `WithTop` namespace):\n```lean\nlemma tendsto_coe_atTop [NoMaxOrder \u03b9] :\n    Tendsto ((\u2191) : \u03b9 \u2192 WithTop \u03b9) atTop (\ud835\udcdd \u22a4) := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using Subsingleton.elim ..\n  rw [tendsto_nhds_top_iff]\n  intro i\n  filter_upwards [atTop_basis_Ioi.mem_of_mem (i := i) trivial]\n  simp\n```\nThen you can prove the highlighted lemma as simply as:\n```lean\ntheorem Tendsto.tendsto_withTop_atTop_nhds_top {\u03b9 : Type*}\n    [Nonempty \u03b9] [LinearOrder \u03b9] [",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "WithTop",
          "end",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 3458,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, n = p \u2022 m :=\n      \u27e8Finsupp.equivFunOnFinite.symm fun i => n i / p, by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, n = p \u2022 m :=\n      \u27e8Finsupp.equivFunOnFinite.symm fun i => n i / p, by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 3459,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, d = p \u2022 m := \u27e8Finsupp.equivFunOnFinite.symm fun i => d i / p,\n      by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, d = p \u2022 m := \u27e8Finsupp.equivFunOnFinite.symm fun i => d i / p,\n      by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n```\nAre there more examples of this pattern?",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 3461,
      "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
      "suggestion": "/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced := by\n  rw [IsSimplyLaced, IsSimplyLaced, Pairwise, Pairwise, forall_comm]\n  aesop\n\ntheorem isSimplyLaced_A (n : \u2115) : IsSimplyLaced (A n) := by\n  intro i j h\n  simp only [A, of_apply]\n  grind\n\ntheorem isSimplyLaced_D (n : \u2115) : IsSimplyLaced (D n) := by\n  intro i j h\n  simp only [D, of_apply]\n  grind\n\ntheorem isSimplyLaced_E\u2086 : IsSimplyLaced E\u2086 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2086] at h \u22a2\n\ntheorem isSimplyLaced_E\u2087 : IsSimplyLaced E\u2087 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2087] at h \u22a2\n\ntheorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2\n",
      "body": "I've never seen being symmetric as a definition of begin simply laced before. Where does this come from?\n\nI would have expected something like:\n```suggestion\n/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced :",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "decide",
          "simp"
        ],
        "suggestion_tactics": [
          "aesop",
          "grind",
          "fin_cases",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "aesop",
          "grind",
          "have",
          "fin_cases",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "aesop",
          "grind",
          "fin_cases",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "decide"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "decide",
          "transpose",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 3463,
      "before_code": "(\u22a4 : NonUnitalSubalgebra R A).toNonUnitalSubring = \u22a4 :=\n  rfl\n\n@[simp]\ntheorem toSubmodule_eq_top {S : NonUnitalSubalgebra R A} : S.toSubmodule = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toSubmodule'.injective.eq_iff' top_toSubmodule\n\n@[simp]\ntheorem toNonUnitalSubsemiring_eq_top {S : NonUnitalSubalgebra R A} :\n    S.toNonUnitalSubsemiring = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toNonUnitalSubsemiring_injective.eq_iff' top_toNonUnitalSubsemiring",
      "suggestion": "\r\n-- This lemma isn't simp because `NonUnitalSubalgebra.toSubmodule` is a \"fake\" projection,\r\n-- which is syntactically a constructor application.\r\n",
      "body": "Then it is proved by `simp only [Submodule.mk_eq_top, NonUnitalSubsemiring.toAddSubmonoid_eq_top, toNonUnitalSubsemiring_eq_top]`. I guess I should have said\r\n```suggestion\r\n-- This lemma isn't simp because `NonUnitalSubalgebra.toSubmodule` is a \"fake\" projection,\r\n-- which is syntactically a constructor application.\r\n```\r\ninstead",
      "path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "constructor",
          "simp"
        ],
        "body_tactics": [
          "have",
          "constructor",
          "simp"
        ],
        "new_tactics": [
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "use_simp"
        ],
        "keywords": [
          "toNonUnitalSubsemiring",
          "toSubmodule",
          "theorem",
          "top_toSubmodule",
          "NonUnitalSubalgebra",
          "toNonUnitalSubring",
          "eq_iff",
          "toNonUnitalSubsemiring_injective",
          "toSubmodule_eq_top",
          "simp",
          "rfl",
          "injective",
          "toNonUnitalSubsemiring_eq_top",
          "top_toNonUnitalSubsemiring"
        ]
      }
    },
    {
      "id": 3465,
      "before_code": "theorem mul_natCast_floor_div_cancel {n : \u2115} (hn : n \u2260 0) (a : R) : \u230aa * n\u230b / n = \u230aa\u230b := by\n  simpa using mul_cast_floor_div_cancel_of_pos (n := n) (by positivity) a",
      "suggestion": "\r\ntheorem mul_fract_eq_one_iff_exists_int {x : R} {k : R} (hk : 1 < k) :\r\n    k * fract x = 1 \u2194 \u2203 n : \u2124, k * x = k * n + 1 := by\r\n  rw [fract, mul_sub, sub_eq_iff_eq_add']\r\n  refine \u27e8fun hx \u21a6 \u27e8\u230ax\u230b, hx\u27e9, ?_\u27e9\r\n  rintro \u27e8n, hn\u27e9\r\n  convert hn\r\n  have hk0 : 0 < (k : R) := zero_le_one.trans_lt hk\r\n  rw [floor_eq_iff, \u2190 mul_le_mul_iff_right\u2080 hk0, \u2190 mul_lt_mul_iff_right\u2080 hk0, hn]\r\n  simp [mul_add, hk]\r\n",
      "body": "Better I think as\r\n```suggestion\r\ntheorem mul_fract_eq_one_iff_exists_int {x : R} {k : R} (hk : 1 < k) :\r\n    k * fract x = 1 \u2194 \u2203 n : \u2124, k * x = k * n + 1 := by\r\n  rw [fract, mul_sub, sub_eq_iff_eq_add']\r\n  refine \u27e8fun hx \u21a6 \u27e8\u230ax\u230b, hx\u27e9, ?_\u27e9\r\n  rintro \u27e8n, hn\u27e9\r\n  convert hn\r\n  have hk0 : 0 < (k : R) := zero_le_one.trans_lt hk\r\n  rw [floor_eq_iff, \u2190 mul_le_mul_iff_right\u2080 hk0, \u2190 mul_lt_mul_iff_right\u2080 hk0, hn]\r\n  simp [mul_add, hk]\r\n```",
      "path": "Mathlib/Algebra/Order/Floor/Ring.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "positivity"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have",
          "rw",
          "refine"
        ],
        "removed_tactics": [
          "simpa",
          "positivity"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mul_cast_floor_div_cancel_of_pos",
          "positivity",
          "theorem",
          "simpa",
          "mul_natCast_floor_div_cancel",
          "using"
        ]
      }
    },
    {
      "id": 3468,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\n  intro u c hc\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\n    have eneq : e \u2260 s(x,y) := fun h => h_bridge.2 c hc (h \u25b8 he)\n    simpa [eneq] using Walk.edges_subset_edgeSet c he)\n",
      "body": "Just style nits. The only one worth highlighting is that the pattern `apply my_lemma.mp` is almost always a synonym for `rw [my_lemma]`:\n```suggestion\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\n  intro u c hc\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\n    have eneq : e \u2260 s(x,y) := fun h => h_bridge.2 c hc (h \u25b8 he)\n    simpa [eneq] using Walk.edges_subset_edgeSet c he)\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "have",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "have",
          "intro"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3469,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "/-- A subgraph is maximal acyclic iff its reachability relation agrees with the larger graph. -/\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G \u2227 F.IsAcyclic) :\n    Maximal (fun H => H \u2264 G \u2227 H.IsAcyclic) F \u2194 F.Reachable = G.Reachable := by\n  refine \u27e8reachable_eq_of_maximal_isAcyclic F, fun h \u21a6 ?_\u27e9\n",
      "body": "We don't need to have both `maximal_isAcyclic_of_reachable_eq` and `maximal_isAcyclic_iff_reachable_eq` since the latter dominates the former so let's just collapse them together like this:\n```suggestion\n/-- A subgraph is maximal acyclic iff its reachability relation agrees with the larger graph. -/\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G \u2227 F.IsAcyclic) :\n    Maximal (fun H => H \u2264 G \u2227 H.IsAcyclic) F \u2194 F.Reachable = G.Reachable := by\n  refine \u27e8reachable_eq_of_ma",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine",
          "have"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3470,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  have : Nonempty V := hG.nonempty\n  refine \u27e8fun h \u21a6 \u27e8\u27e8fun u v \u21a6 ?_\u27e9, h.1.2\u27e9, fun hT' \u21a6 ?_\u27e9\n  \u00b7 rw [G.reachable_eq_of_maximal_isAcyclic T h]\n    exact hG.preconnected u v\n  \u00b7 rw [maximal_isAcyclic_iff_reachable_eq \u27e8hT, hT'.IsAcyclic\u27e9]\n    replace hT' : T.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hT'.isConnected.preconnected\n    replace hG : G.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hG.preconnected\n    rw [hT', hG]\n",
      "body": "What you have is probably fine but I worry that the call to `grind` is maybe a bit brittle so let's try:\n```suggestion\n  have : Nonempty V := hG.nonempty\n  refine \u27e8fun h \u21a6 \u27e8\u27e8fun u v \u21a6 ?_\u27e9, h.1.2\u27e9, fun hT' \u21a6 ?_\u27e9\n  \u00b7 rw [G.reachable_eq_of_maximal_isAcyclic T h]\n    exact hG.preconnected u v\n  \u00b7 rw [maximal_isAcyclic_iff_reachable_eq \u27e8hT, hT'.IsAcyclic\u27e9]\n    replace hT' : T.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hT'.isConnected.preconnected\n    replace hG : G",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "exact",
          "refine",
          "rw",
          "have"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "rw"
        ],
        "new_tactics": [
          "have",
          "rw",
          "refine"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3471,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  obtain \u27e8\u27e8hF : F \u2264 G, hF' : F.IsAcyclic\u27e9, h\u27e9 := by simpa [Maximal] using h\n  ext u v\n  refine \u27e8fun h \u21a6 h.mono hF, ?_\u27e9\n  contrapose! h\n  obtain \u27e8\u27e8p : G.Walk u v\u27e9, h : \u00ac F.Reachable u v\u27e9 := h\n  let s : Set V := F.connectedComponentMk u\n  have hus : u \u2208 s := ConnectedComponent.connectedComponentMk_mem\n  have hvs : v \u2209 s := h \u2218 (F.connectedComponentMk u).reachable_of_mem_supp hus\n  obtain \u27e8\u27e8\u27e8u', v'\u27e9, huv : G.Adj u' v'\u27e9, -, hu : u' \u2208 s, hv : v' \u2209 s\u27e9 :=\n    p.exists_boundary_dart s hus hvs\n  suffices (F \u2294 fromEdgeSet {s(u', v')}).IsAcyclic by\n    refine \u27e8F \u2294 fromEdgeSet {s(u', v')}, ?_, this, le_sup_left, ?_\u27e9\n    \u00b7 have : G.Adj v' u' := G.symm huv\n      simp only [sup_le_iff, le_iff_adj, fromEdgeSet_adj, Set.mem_singleton_iff, Sym2.eq,\n        Sym2.rel_iff'] at hF \u22a2\n      grind\n    \u00b7 rw [le_iff_adj]\n      push_neg\n      refine \u27e8u', v', ?_, fun hc \u21a6 ?_\u27e9\n      \u00b7 simpa using Or.inr huv.ne\n      \u00b7 have := (F.connectedComponentMk u).mem_supp_congr_adj hc\n        grind\n  suffices \u00ac F.Reachable u'",
      "body": "The following is a slight golf. I was not trying to make it shorter though: I was trying to make it slightly more idiomatic and readable. I think what I've got is still not great but is acceptable (as was yours already). Two minor points I highlight are:\n\n- I've added various redundant type ascriptions (e.g., to the `obtain`s). These aid readability for a human.\n- I've use the `ext` tactic rather than directly calling the underlying very low-level `funext`, `propext`\n\nI also note that [Maximal](",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "funext",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "remove_redundant",
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3472,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "\r\n    (G \u2294 fromEdgeSet {s(x, y)}).IsAcyclic \u2194 IsAcyclic G := by\r\n  refine \u27e8fun h \u21a6 h.anti le_sup_left, fun hG \u21a6 ?_\u27e9\r\n  have x_neq_y : x \u2260 y := fun c => (c \u25b8 hxy) (Reachable.refl y)\r\n  have h_add_remove : (G \u2294 fromEdgeSet {s(x, y)}) \\ fromEdgeSet {s(x, y)} = G := by\r\n    simpa using fun h => hxy h.reachable\r\n  have h_bridge : (G \u2294 fromEdgeSet {s(x, y)}).IsBridge s(x, y) := by\r\n    simpa [isBridge_iff, x_neq_y, h_add_remove]\r\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\r\n  intro u c hc\r\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\r\n    have eneq : e \u2260 s(x, y) := fun h => h_bridge.2 c hc (h \u25b8 he)\r\n",
      "body": "```suggestion\r\n    (G \u2294 fromEdgeSet {s(x, y)}).IsAcyclic \u2194 IsAcyclic G := by\r\n  refine \u27e8fun h \u21a6 h.anti le_sup_left, fun hG \u21a6 ?_\u27e9\r\n  have x_neq_y : x \u2260 y := fun c => (c \u25b8 hxy) (Reachable.refl y)\r\n  have h_add_remove : (G \u2294 fromEdgeSet {s(x, y)}) \\ fromEdgeSet {s(x, y)} = G := by\r\n    simpa using fun h => hxy h.reachable\r\n  have h_bridge : (G \u2294 fromEdgeSet {s(x, y)}).IsBridge s(x, y) := by\r\n    simpa [isBridge_iff, x_neq_y, h_add_remove]\r\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3481,
      "before_code": "rcases h\u03be with \u27e8i, hin, hi, H\u27e9\n    exact \u27e8i, \u27e8hin, hi.symm\u27e9, H\u27e9",
      "suggestion": "\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n",
      "body": "```suggestion\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n```\r\nI think it\u2019s better practice to inline the \"haves\" when in term mode with a non-prop goal like this.\r\n\r\nalso, added the `@[simps! apply_coe]` adds the lemma saying that you\u2019re i",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact",
          "cases"
        ],
        "topics": [],
        "transforms": [
          "term_mode",
          "use_grind"
        ],
        "keywords": [
          "exact",
          "rcases",
          "symm",
          "hin"
        ]
      }
    },
    {
      "id": 3490,
      "before_code": "section BaireTheorem\n\nvariable [TopologicalSpace X] [BaireSpace X]",
      "suggestion": "theorem baire_of_finite [Finite X] : BaireSpace X where\n  baire_property f _ _ := sInter_range f \u25b8 (toFinite (range f)).dense_sInter (by grind) (by grind)\n",
      "body": "```suggestion\ntheorem baire_of_finite [Finite X] : BaireSpace X where\n  baire_property f _ _ := sInter_range f \u25b8 (toFinite (range f)).dense_sInter (by grind) (by grind)\n```",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "TopologicalSpace",
          "variable",
          "BaireSpace",
          "BaireTheorem",
          "section"
        ]
      }
    },
    {
      "id": 3509,
      "before_code": "section shift_invariance\n\nvariable {\ud835\udd5c F} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\n\n/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (s + z)) = fun t \u21a6 iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (z + s)) = fun t \u21a6 iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s",
      "suggestion": "  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n",
      "body": "```suggestion\n  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "funext",
          "induction",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "funext",
          "induction",
          "simp"
        ],
        "topics": [
          "norm",
          "list",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "funext",
          "lemma",
          "deriv_comp_add_const",
          "succ",
          "iterated",
          "iteratedDeriv_succ",
          "commutes",
          "section",
          "right",
          "iteratedDeriv_comp_const_add",
          "NormedAddCommGroup",
          "constant",
          "variable",
          "derivative",
          "shift_invariance",
          "induction",
          "simp",
          "iteratedDeriv_comp_add_const",
          "zero",
          "only",
          "iteratedDeriv",
          "NontriviallyNormedField",
          "deriv_comp_const_add",
          "function",
          "left",
          "NormedSpace",
          "simpa",
          "iteratedDeriv_zero",
          "shifting",
          "using"
        ]
      }
    },
    {
      "id": 3514,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "theorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\n  Int.floor_eq_iff.mpr (by grind [pi_gt_three, pi_lt_four])\n",
      "body": "Possible alternative:\n\n```suggestion\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\n  Int.floor_eq_iff.mpr (by grind [pi_gt_three, pi_lt_four])\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 3515,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "theorem ceil_pi_eq_four : \u2308\u03c0\u2309 = 4 :=\n  Int.ceil_eq_iff.mpr (by grind [pi_gt_three, pi_lt_four])\n",
      "body": "Possible alternative:\n\n```suggestion\ntheorem ceil_pi_eq_four : \u2308\u03c0\u2309 = 4 :=\n  Int.ceil_eq_iff.mpr (by grind [pi_gt_three, pi_lt_four])\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 3516,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "theorem round_pi_eq_three : round \u03c0 = 3 :=\n  round_eq _ |>.trans <| Int.floor_eq_iff.mpr \u27e8by grind [pi_gt_three], by grind [pi_lt_d2]\u27e9\n",
      "body": "Possible alternative:\n\n```suggestion\ntheorem round_pi_eq_three : round \u03c0 = 3 :=\n  round_eq _ |>.trans <| Int.floor_eq_iff.mpr \u27e8by grind [pi_gt_three], by grind [pi_lt_d2]\u27e9\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 3517,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n",
      "body": "We can also\r\n```suggestion\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": []
      }
    },
    {
      "id": 3529,
      "before_code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  \u00b7 exact absurd hf <| h _ _ hxy\n  \u00b7 rfl\n  \u00b7 exact absurd hf.symm <| h _ _ hxy",
      "suggestion": "\r\n  exact injective_of_eq_imp_le f fun {x y} \u21a6\r\n    not_lt (\u03b1 := \u03b1) |>.eq \u25b8 imp_not_comm.mp (eq_comm.eq \u25b8 h y x)\r\n",
      "body": "if you move the new lemma before this one, you could do\r\n```suggestion\r\n  exact injective_of_eq_imp_le f fun {x y} \u21a6\r\n    not_lt (\u03b1 := \u03b1) |>.eq \u25b8 imp_not_comm.mp (eq_comm.eq \u25b8 h y x)\r\n```\r\nor\r\n```suggestion\r\n  grind [injective_of_eq_imp_le]\r\n```",
      "path": "Mathlib/Order/Monotone/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lt_trichotomy",
          "Injective",
          "symm",
          "theorem",
          "exact",
          "rcases",
          "absurd",
          "injective_of_lt_imp_ne",
          "LinearOrder",
          "intro",
          "hxy",
          "rfl"
        ]
      }
    },
    {
      "id": 3530,
      "before_code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  \u00b7 exact absurd hf <| h _ _ hxy\n  \u00b7 rfl\n  \u00b7 exact absurd hf.symm <| h _ _ hxy",
      "suggestion": "\r\n  exact Function.Injective.of_eq_imp_le _ (le_of_not_gt <| Imp.swap.mp (h _ _) \u00b7.symm)\r\n",
      "body": "I know, I had this before:\r\n```suggestion\r\n  exact Function.Injective.of_eq_imp_le _ (le_of_not_gt <| Imp.swap.mp (h _ _) \u00b7.symm)\r\n```\r\nthen I realized I can\r\n```suggestion\r\n  exact Function.Injective.of_eq_imp_le _ <| by grind\r\n```\r\nand then\r\n```suggestion\r\n  grind [Function.Injective.of_eq_imp_le]\r\n```\r\nand finally the current version, which doesn't need the new theorem.\r\nI don't think that going back to the explicit term is better.",
      "path": "Mathlib/Order/Monotone/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lt_trichotomy",
          "Injective",
          "symm",
          "theorem",
          "exact",
          "rcases",
          "absurd",
          "injective_of_lt_imp_ne",
          "LinearOrder",
          "intro",
          "hxy",
          "rfl"
        ]
      }
    },
    {
      "id": 3531,
      "before_code": "(SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n@[to_additive]\nlemma closure_pow_le : \u2200 {n}, n \u2260 0 \u2192 closure (s ^ n) \u2264 closure s\n  | 1, _ => by simp\n  | n + 2, _ =>",
      "suggestion": "\r\n  | 0 => by simp_all\r\n",
      "body": "```suggestion\r\n  | 0 => by simp_all\r\n```",
      "path": "Mathlib/Algebra/Group/Subgroup/Pointwise.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "lemma",
          "SetLike",
          "le_def",
          "subset_closure",
          "closure_pow_le",
          "closure",
          "le_sup_right",
          "simp"
        ]
      }
    },
    {
      "id": 3533,
      "before_code": "le_antisymm ((packingNumber_le_encard_self {x}).trans_eq (by simp)) <|\n    le_iSup_of_le {x} <| le_iSup_of_le (by simp) <| le_iSup_of_le (by simp) (by simp)",
      "suggestion": "lemma maximalSeparatedSet_subset : maximalSeparatedSet \u03b5 A \u2286 A := by\n  by grind [maximalSeparatedSet]\n",
      "body": "This and the next two lemmas can be proven with this, although for it to work on `isSeparated_maximalSeparatedSet`, you have to add\n```lean\nattribute [grind .] IsSeparated.empty\n```\nbut I think we should do that anyway.\n\n```suggestion\nlemma maximalSeparatedSet_subset : maximalSeparatedSet \u03b5 A \u2286 A := by\n  by grind [maximalSeparatedSet]\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "le_iSup_of_le",
          "trans_eq",
          "le_antisymm",
          "simp",
          "packingNumber_le_encard_self"
        ]
      }
    },
    {
      "id": 3536,
      "before_code": "{g} (hg : g \u2208 \u0393) : |g.det.val| = 1 := by\n  rcases HasDetPlusMinusOne.det_eq hg with h | h <;> simp [h]",
      "suggestion": "\r\n  refine \u27e8fun h {g} hg \u21a6 h.abs_det hg, fun h \u21a6 \u27e8?_\u27e9\u27e9\r\n",
      "body": "```suggestion\r\n  refine \u27e8fun h {g} hg \u21a6 h.abs_det hg, fun h \u21a6 \u27e8?_\u27e9\u27e9\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/ArithmeticSubgroups.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "simp"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "HasDetPlusMinusOne",
          "det",
          "det_eq",
          "rcases",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 3539,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by simpa [inverse, H] using hf\n  simp_all [Subsingleton.elim f 0]\n",
      "body": "```suggestion\n  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by simpa [inverse, H] using hf\n  simp_all [Subsingleton.elim f 0]\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "body_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 3540,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M\u2082 \u2227 Subsingleton M := by simpa [inverse, H] using hf\r\n",
      "body": "It's the other way around for some reason, or you can add `and_comm` to the `simpa` I guess:\r\n```suggestion\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M\u2082 \u2227 Subsingleton M := by simpa [inverse, H] using hf\r\n```\r\nor\r\n```suggestion\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by aesop\r\n```\r\nor even better (or change the `M` to `M\u2082`):\r\n```suggestion\r\n  have : Subsingleton M := by aesop\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain"
        ],
        "body_tactics": [
          "simpa",
          "obtain",
          "aesop",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "obtain"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 3549,
      "before_code": "-/\ndef liftOn\u2082 {\u03b1 : Type*} (x y : LocalizedModule S M) (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') : \u03b1 :=\n  Quotient.liftOn\u2082 x y f wd\n\ntheorem liftOn\u2082_mk {\u03b1 : Type*} (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') (m m' : M)\n    (s s' : S) : liftOn\u2082 (mk m s) (mk m' s') f wd = f \u27e8m, s\u27e9 \u27e8m', s'\u27e9 := by\n  convert Quotient.liftOn\u2082_mk f wd _ _\n\ninstance : Zero (LocalizedModule S M) :=\n  \u27e8mk 0 1\u27e9\n\n/-- If `S` contains `0` then the localization at `S` is trivial. -/\ntheorem subsingleton (h : 0 \u2208 S) : Subsingleton (LocalizedModule S M) := by\n  refine \u27e8fun a b \u21a6 ?_\u27e9\n  induction a,b using LocalizedModule.induction_on\u2082\n  exact mk_eq.mpr \u27e8\u27e80, h\u27e9, by simp only [Submonoid.mk_smul, zero_smul]\u27e9\n\n@[simp]\ntheorem zero_mk (s : S) : mk (0 : M) s = 0 :=\n  mk_eq.mpr \u27e81, by rw [one_smul, smul_zero, smul_zero, one_smul]\u27e9\n\ninstance : Add (LocalizedModule S M) where\n  add p1 p2 :=\n    liftOn\u2082 p1 p2 (fun x y => mk (y.2 \u2022 x.1 + x.2 \u2022 y.1) (x.2 * y.2)) <|\n      fun \u27e8m1, s1\u27e9 \u27e8m2, s2\u27e9 \u27e8m1', s1'\u27e9 \u27e8m2', s2'\u27e9 \u27e8u1, hu1\u27e9 \u27e8u2, hu2\u27e9 =>\n          mk_eq.mpr\n            \u27e8u1 * u2, by\n              -- Put everything in the same shape, sorting the terms using `simp`\n              have hu1' := congr_arg ((u2 * s2 * s2') \u2022 \u00b7) hu1\n              have hu2' := congr_arg ((u1 * s1 * s1') \u2022 \u00b7) hu2\n              simp only [smul_add, \u2190 mul_smul, mul_comm,\n                mul_left_comm] at hu1' hu2' \u22a2\n              rw [hu1', hu2']\u27e9\n\ntheorem mk_add_mk {m1 m2 : M} {s1 s2 : S} :\n    mk m1 s1 + mk m2 s2 = mk (s2 \u2022 m1 + s1 \u2022 m2) (s1 * s2) :=\n  mk_eq.mpr <| \u27e81, rfl\u27e9\n\nprivate theorem add_assoc' (x y z : LocalizedModule S M) : x + y + z = x + (y + z) := by\n  induction x with | _ mx sx\n  induction y with | _ my sy\n  induction z with | _ mz sz\n  simp only [mk_add_mk, smul_add]\n  refine mk_eq.mpr \u27e81, ?_\u27e9\n  rw [one_smul, one_smul]\n  congr 1\n  \u00b7 rw [mul_assoc]\n  \u00b7 rw [eq_comm, mul_comm, add_assoc, mul_smul, mul_smul, \u2190 mul_smul sx sz, mul_comm,",
      "suggestion": "instance (priority := 900) {A : Type*} [Semiring A] [Algebra R A] {S : Submonoid R} :\n    Monoid (LocalizedModule S A) :=\n  fast_instance%\n  { __ := inferInstanceAs (One (LocalizedModule S A))\n    mul := LocalizedModule.mul\n    one_mul := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [one_mul, mul_one, one_smul]\u27e9\n    mul_one := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [mul_one, one_smul, one_mul]\u27e9\n    mul_assoc := by with_unfolding_all\n      rintro \u27e8a\u2081, s\u2081\u27e9 \u27e8a\u2082, s\u2082\u27e9 \u27e8a\u2083, s\u2083\u27e9\n      apply mk_eq.mpr _\n      use 1\n      simp only [one_mul, smul_smul, \u2190 mul_assoc, mul_right_comm] }\n",
      "body": "```suggestion\ninstance (priority := 900) {A : Type*} [Semiring A] [Algebra R A] {S : Submonoid R} :\n    Monoid (LocalizedModule S A) :=\n  fast_instance%\n  { __ := inferInstanceAs (One (LocalizedModule S A))\n    mul := LocalizedModule.mul\n    one_mul := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [one_mul, mul_one, one_smul]\u27e9\n    mul_one := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [mul_one, one_smul, one_mul]\u27e9\n    mul_as",
      "path": "Mathlib/Algebra/Module/LocalizedModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "simpa",
          "rw",
          "simp",
          "induction",
          "congr",
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "induction",
          "congr",
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Module",
          "mpr",
          "Monoid",
          "neg",
          "zero_add",
          "hasNatSMul",
          "Type",
          "succ",
          "mul_smul_comm",
          "terms",
          "mul",
          "add",
          "eq_comm",
          "mul_right_comm",
          "Neg",
          "Quotient",
          "private",
          "liftOn",
          "zero_mk",
          "neg_add_cancel",
          "hu1",
          "have",
          "smul_smul",
          "hu2",
          "CommSemiring",
          "fix",
          "CommRing",
          "trivial",
          "def",
          "mul_comm",
          "mul_one",
          "simp",
          "rfl",
          "Add",
          "theorem",
          "add_assoc",
          "trans",
          "localization",
          "smul_smul_smul_comm",
          "SMul",
          "mul_smul",
          "sorting",
          "Zero",
          "smul",
          "show",
          "mk_eq",
          "induction_on",
          "TODO",
          "mk_add_mk",
          "apply"
        ]
      }
    },
    {
      "id": 3551,
      "before_code": "simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_iff_left_iff_imp]\n  exact fun hz \u21a6 UpperHalfPlane.coe_mem_integerComplement \u27e8z, hz\u27e9",
      "suggestion": "\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n",
      "body": "If you put this in `UpperHalfPlane` then you can dot-notate. Also `n` can be implicit since you have `hm`. \r\n```suggestion\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n```",
      "path": "Mathlib/Analysis/Complex/IntegerCompl.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mem_setOf_eq",
          "exact",
          "Set",
          "mem_inter_iff",
          "UpperHalfPlane",
          "coe_mem_integerComplement",
          "simp",
          "and_iff_left_iff_imp",
          "only"
        ]
      }
    },
    {
      "id": 3552,
      "before_code": "@[simp, norm_cast]\nlemma coe_I : I = Complex.I := rfl",
      "suggestion": "\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffices 0 < n * z.im / Complex.normSq z by simpa [Complex.div_im, neg_div]\r\n  positivity [NeZero.ne n, z.normSq_pos]\r\n",
      "body": "This is in the `UpperHalfPlane` namespace so you don't really need `UpperHalfPlane` in the statment. My instinct would be to formulate using `Nat` with a `[NeZero]` typeclass assumption, rather than `PNat`, but I haven't checked how that plays together with the usage of this lemma later. \r\n\r\nIf you move this to a few lines later in the file (maybe after `ne_int`) then you can do the following:\r\n```suggestion\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffi",
      "path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa",
          "positivity"
        ],
        "body_tactics": [
          "simpa",
          "positivity"
        ],
        "new_tactics": [
          "simpa",
          "positivity"
        ],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "complex",
          "norm"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "coe_I",
          "lemma",
          "Complex",
          "simp",
          "rfl",
          "norm_cast"
        ]
      }
    },
    {
      "id": 3553,
      "before_code": "exact Real.rpow_le_rpow_of_nonpos (r_pos _) (r_lower_bound_on_verticalStrip z hB hz)\n    (neg_nonpos.mpr hk)\n\nlemma linear_isTheta_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\n  refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real)\n  rw [isLittleO_const_left]\n  exact Or.inr\n    (tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real)",
      "suggestion": "\r\nlemma linear_isTheta_right_add (c e : \u2124) (z : \u2102) :\r\n    (fun d : \u2124 \u21a6 c * z + d + e) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\r\n  apply IsTheta.add_isLittleO <;>\r\n  [refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real); skip] <;>\r\n  simpa [-Int.cofinite_eq] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real\r\n",
      "body": "optional golf (might be a bit convoluted):\r\n```suggestion\r\nlemma linear_isTheta_right_add (c e : \u2124) (z : \u2102) :\r\n    (fun d : \u2124 \u21a6 c * z + d + e) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\r\n  apply IsTheta.add_isLittleO <;>\r\n  [refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real); skip] <;>\r\n  simpa [-Int.cofinite_eq] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real\r\n```\r\n(This makes me wonder if `Int.cofinite_eq` should not",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "apply"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "lemma",
          "neg_nonpos",
          "cofinite",
          "isLittleO_const_left",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "refine",
          "rpow_le_rpow_of_nonpos",
          "isClosedEmbedding_coe_real",
          "add_isTheta",
          "linear_isTheta_right",
          "Int",
          "IsLittleO",
          "Real",
          "r_pos",
          "r_lower_bound_on_verticalStrip",
          "Asymptotics",
          "exact",
          "cast_complex_isTheta_cast_real",
          "inr"
        ]
      }
    },
    {
      "id": 3554,
      "before_code": "\u00b7 simp only [isLittleO_const_left, Int.cast_eq_zero,\n      tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real, or_true]\n\nlemma linear_inv_isBigO_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_right c z).inv.isBigO\n\nlemma linear_inv_isBigO_left (d : \u2124) {z : \u2102} (hz : z \u2260 0) :\n    (fun (c : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_left d hz).inv.isBigO",
      "suggestion": "\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n",
      "body": "`Asymptotics` is already open, and `simpa` uses `this` by default:\r\n```suggestion\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigO",
          "cast_eq_zero",
          "lemma",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "linear_isTheta_right",
          "Int",
          "linear_inv_isBigO_left",
          "or_true",
          "inv",
          "linear_isTheta_left",
          "simp",
          "cofinite",
          "isClosedEmbedding_coe_real",
          "isLittleO_const_left",
          "only",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3557,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _)]\r\n  aesop\r\n",
      "body": "I'm not a fan of `simp only [massive list of stuff] at *`, it seems a bit of a \"scattergun\" approach. Here's a shorter and cleaner version:\r\n```suggestion\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "aesop",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp",
          "use_aesop"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3558,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n",
      "body": "```suggestion\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n```\r\nThe statement can be made far more general, you could do e.g.\r\n```\r\nlemma isLittleO_const_left_of_properSpace_of_discreteTopology\r\n    {\u03b1 : Type*} (a : \u03b1) [NormedAddCommGroup \u03b1] [DiscreteTopology \u03b1]\r\n    [ProperSpace \u03b1] : (fun _ : \u03b1 \u21a6 a) =",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3559,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n",
      "body": "```suggestion\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3561,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "simpa",
          "exact"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 3563,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  have := tendsto_tsum_of_dominated_convergence (\ud835\udcd5 := atTop) (g := fun _ \u21a6 0)\r\n    (f := fun d n : \u2115+ \u21a6 r ^ (n * d : \u2115)) (bound := fun n \u21a6 (\u2016r ^ (n : \u2115)\u2016))\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  have := tendsto_tsum_of_dominated_convergence (\ud835\udcd5 := atTop) (g := fun _ \u21a6 0)\r\n    (f := fun d n : \u2115+ \u21a6 r ^ (n * d : \u2115)) (bound := fun n \u21a6 (\u2016r ^ (n : \u2115)\u2016))\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 3564,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n```\r\n(It's a pity that none of the auto-tactics seem to work on the last line.)",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 3566,
      "before_code": "f 0 * \u220f' n : \u2115+, f \u2191n = \u220f' n, f n := by\n  simpa [hf.tprod_eq_zero_mul] using tprod_pnat_eq_tprod_succ\n\n@[to_additive tsum_int_eq_zero_add_two_mul_tsum_pnat]\ntheorem tprod_int_eq_zero_mul_tprod_pnat_sq [UniformSpace G] [IsUniformGroup G] [CompleteSpace G]\n    [T2Space G] {f : \u2124 \u2192 G} (hf : \u2200 n : \u2124, f (-n) = f n) (hf2 : Multipliable f) :\n    \u220f' n, f n = f 0 * (\u220f' n : \u2115+, f n) ^ 2 := by\n  have hf3 : Multipliable fun n : \u2115 \u21a6 f n :=\n    (multipliable_int_iff_multipliable_nat_and_neg.mp hf2).1\n  have hf4 : Multipliable fun n : \u2115+ \u21a6 f n := by\n    rwa [multipliable_pnat_iff_multipliable_succ (f := (f \u00b7)),\n      multipliable_nat_add_iff 1 (f := (f \u00b7))]\n  have := tprod_nat_mul_neg hf2\n  rw [\u2190 tprod_zero_pnat_eq_tprod_nat (by simpa [hf] using hf3.mul hf3), mul_comm _ (f 0)] at this\n  simp only [hf, Nat.cast_zero, mul_assoc, mul_right_inj] at this\n  rw [\u2190 this, mul_right_inj, hf4.tprod_mul hf4, sq]",
      "suggestion": "\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n",
      "body": "Indentation is off here. But the proof can also be hugely shortened:\r\n```suggestion\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n```\r\nYou could also use `Function.Even` as the hypothesis, at the cost of an extra import; note that if you do `(hf : Function.Even f)` then you need `hf _` in the simp call, not just `hf`.",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "topics": [
          "int",
          "finset",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "CompleteSpace",
          "rwa",
          "Multipliable",
          "multipliable_nat_add_iff",
          "tsum_int_eq_zero_add_two_mul_tsum_pnat",
          "mul",
          "to_additive",
          "IsUniformGroup",
          "multipliable_int_iff_multipliable_nat_and_neg",
          "hf4",
          "Nat",
          "cast_zero",
          "have",
          "tprod_zero_pnat_eq_tprod_nat",
          "hf3",
          "mul_right_inj",
          "multipliable_pnat_iff_multipliable_succ",
          "tprod_pnat_eq_tprod_succ",
          "T2Space",
          "mul_comm",
          "simp",
          "tprod_eq_zero_mul",
          "only",
          "mul_assoc",
          "theorem",
          "UniformSpace",
          "hf2",
          "tprod_nat_mul_neg",
          "tprod_mul",
          "this",
          "simpa",
          "tprod_int_eq_zero_mul_tprod_pnat_sq",
          "using"
        ]
      }
    },
    {
      "id": 3572,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  \u00b7 have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -(y * log y ^ 2)\u207b\u00b9 := by\n",
      "body": "```suggestion\n  \u00b7 have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -(y * log y ^ 2)\u207b\u00b9 := by\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3574,
      "before_code": "convert sum_mul_eq_sub_integral_mul\u2080 c hc m hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]",
      "suggestion": "    have H\u2081 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, c n = 0 := by grind [(Nat.floor_lt' two_ne_zero).mpr hb]\n    have H\u2082 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, f n * c n = 0 := by grind\n    simp [sum_eq_zero H\u2081, sum_eq_zero H\u2082, Set.Ioc_eq_empty_of_le hb.le]\n  --Split off the first two terms of the sum\n  have : 2 \u2264 \u230ab\u230b\u208a := Nat.le_floor hb\n  have H : \u2211 k \u2208 Icc 0 \u230ab\u230b\u208a, f \u2191k * c k = f (2 :) * c 2 + \u2211 k \u2208 Ioc 2 \u230ab\u230b\u208a, f \u2191k * c k := by\n    rw [add_sum_Ioc_eq_sum_Icc (f := fun (k : \u2115) \u21a6 f k * c k) this,\n      show Icc 0 \u230ab\u230b\u208a = {0, 1} \u222a Icc 2 \u230ab\u230b\u208a by grind]\n    exact sum_union_eq_right fun k hk hk' \u21a6 by grind\n  rw [H]\n  --Apply Abel summation to the remainder\n  nth_rewrite 3 [show 2 = \u230a(2 : \u211d)\u230b\u208a by simp]\n  rw [sum_mul_eq_sub_sub_integral_mul c zero_le_two hb hf_diff hf_int]\n  simp [show Icc 0 2 = {0, 1, 2} by rfl, hc, hc1]\n  grind\n",
      "body": "```suggestion\n    have H\u2081 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, c n = 0 := by grind [(Nat.floor_lt' two_ne_zero).mpr hb]\n    have H\u2082 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, f n * c n = 0 := by grind\n    simp [sum_eq_zero H\u2081, sum_eq_zero H\u2082, Set.Ioc_eq_empty_of_le hb.le]\n  --Split off the first two terms of the sum\n  have : 2 \u2264 \u230ab\u230b\u208a := Nat.le_floor hb\n  have H : \u2211 k \u2208 Icc 0 \u230ab\u230b\u208a, f \u2191k * c k = f (2 :) * c 2 + \u2211 k \u2208 Ioc 2 \u230ab\u230b\u208a, f \u2191k * c k := by\n    rw [add_sum_Ioc_eq_sum_Icc (f := fun (k : \u2115) \u21a6 f k * c k) this,\n      show Icc 0 \u230ab\u230b\u208a = ",
      "path": "Mathlib/NumberTheory/AbelSummation.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "all_goals",
          "convert",
          "Nat",
          "floor_natCast",
          "hf_int",
          "hf_diff"
        ]
      }
    },
    {
      "id": 3575,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have : x * log x ^ 2 \u2260 0 := mul_ne_zero this <| by simp; grind\n",
      "body": "```suggestion\n  have : x * log x ^ 2 \u2260 0 := mul_ne_zero this <| by simp; grind\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "have",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "have",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3577,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  \u00b7 refine sum_congr rfl fun n hn \u21a6 ?_\n    split_ifs with h\n    \u00b7 have : log n \u2260 0 := log_ne_zero_of_pos_of_ne_one (mod_cast h.pos) (mod_cast h.ne_one)\n      simp [a, h, field]\n    \u00b7 simp [a, h]\n",
      "body": "```suggestion\n  \u00b7 refine sum_congr rfl fun n hn \u21a6 ?_\n    split_ifs with h\n    \u00b7 have : log n \u2260 0 := log_ne_zero_of_pos_of_ne_one (mod_cast h.pos) (mod_cast h.ne_one)\n      simp [a, h, field]\n    \u00b7 simp [a, h]\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "new_tactics": [
          "have",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3578,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "      replace hu : 2 \u2264 u := ((Set.uIcc_of_le hx) \u25b8 hu).1\n      simp [deriv_log_inv (by linarith) (by linarith) (by linarith), field]\n",
      "body": "```suggestion\n      replace hu : 2 \u2264 u := ((Set.uIcc_of_le hx) \u25b8 hu).1\n      simp [deriv_log_inv (by linarith) (by linarith) (by linarith), field]\n```\nNote that this is one of the places where `deric_log_inv` without side conditions would simplify things.",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "linarith"
        ],
        "body_tactics": [
          "simp",
          "linarith"
        ],
        "new_tactics": [
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3579,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
      "body": "```suggestion\n    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "exact",
          "have",
          "fun_prop",
          "linarith",
          "congr"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "have",
          "fun_prop",
          "linarith",
          "congr"
        ],
        "new_tactics": [
          "refine",
          "exact",
          "congr",
          "have",
          "linarith",
          "fun_prop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_linarith",
          "use_fun_prop"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3580,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  calc\n  _ \u2264 \u222b x in a..b, 1 / log a ^ 2 := by\n      refine intervalIntegral.integral_mono_on hab ?_ (by simp) fun x \u27e8hx, _\u27e9 \u21a6 by gcongr <;> bound\n      apply intervalIntegrable_one_div_log_sq <;> linarith\n  _ \u2264 _ := by simp [field]\n",
      "body": "```suggestion\n  calc\n  _ \u2264 \u222b x in a..b, 1 / log a ^ 2 := by\n      refine intervalIntegral.integral_mono_on hab ?_ (by simp) fun x \u27e8hx, _\u27e9 \u21a6 by gcongr <;> bound\n      apply intervalIntegrable_one_div_log_sq <;> linarith\n  _ \u2264 _ := by simp [field]\n```\n* `calc` proofs are usually easier to read than proofs using `trans`\n* `refine` allows to fold `intro` (or `use`, ...)",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "simp",
          "linarith"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "simp",
          "intro",
          "linarith"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3582,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have two_le_sqrt : 2 \u2264 x.sqrt := Real.le_sqrt_of_sq_le <| by norm_num [hx]\n",
      "body": "```suggestion\n  have two_le_sqrt : 2 \u2264 x.sqrt := Real.le_sqrt_of_sq_le <| by norm_num [hx]\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "norm_num",
          "have"
        ],
        "body_tactics": [
          "norm_num",
          "have"
        ],
        "new_tactics": [
          "norm_num",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3583,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have sqrt_le_x : x.sqrt \u2264 x := sqrt_le_left (by linarith) |>.mpr (by bound)\n",
      "body": "```suggestion\n  have sqrt_le_x : x.sqrt \u2264 x := sqrt_le_left (by linarith) |>.mpr (by bound)\n```\n(Same proofs, only a bit more condensed.)",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have",
          "linarith"
        ],
        "body_tactics": [
          "have",
          "linarith"
        ],
        "new_tactics": [
          "have",
          "linarith"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3585,
      "before_code": "hW := .sup D\u2081.hW D\u2082.hW (Cardinal.IsRegular.aleph0_le Fact.out)\n  hP := .sup D\u2081.hP D\u2082.hP (Cardinal.IsRegular.aleph0_le Fact.out)",
      "suggestion": "@[simps!]\ndef D\u2080 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) :\n    Diagram J \u03ba :=\n  Diagram.iSup (fun i \u21a6 (D i).toDiagram) h\u03b9\n\n@[simps!]\ndef D\u2081 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) (m : J) :\n    Diagram J \u03ba :=\n  (D\u2080 J \u03ba D h\u03b9).sup (.single m)\n\n@[simps!]\ndef D\u2082 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba)\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) (m : J) (u : (i : \u03b9) \u2192 (D i).top \u27f6 m) :\n    Diagram J \u03ba where\n  W := (D\u2081 J \u03ba D h\u03b9 m).W \u2294 MorphismProperty.ofHoms\n    fun (x : (\u03a3 (i : \u03b9), (Subtype (D i).P))) \u21a6 (D x.1).isTerminal.lift x.2.2 \u226b u x.1\n  P := (D\u2081 J \u03ba D h\u03b9 m).P\n  src := by\n    simp only [D\u2081_W, D\u2081_P]\n    rintro _ _ _ ((hf | \u27e8\u27e8\u27e9\u27e9) | \u27e8i, j, hj\u27e9)\n    \u00b7 simp only [MorphismProperty.iSup_iff] at hf\n      obtain \u27e8i, hf\u27e9 := hf\n      exact Or.inl \u27e8i, (D i).src hf\u27e9\n    \u00b7 exact Or.inr rfl\n    \u00b7 exact Or.inl \u27e8i, hj\u27e9\n  tgt := by\n    simp only [D\u2081_W, D\u2081_P]\n    rintro _ _ _ ((hf | \u27e8\u27e8\u27e9\u27e9) | \u27e8i, j, hj\u27e9)\n   ",
      "body": "```suggestion\n@[simps!]\ndef D\u2080 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) :\n    Diagram J \u03ba :=\n  Diagram.iSup (fun i \u21a6 (D i).toDiagram) h\u03b9\n\n@[simps!]\ndef D\u2081 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) (m : J) :\n    Diagram J \u03ba :=\n  (D\u2080 J \u03ba D h\u03b9).sup (.single m)\n\n@[simps!]\ndef D\u2082 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba)\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) (m : J) (u : (i : \u03b9) \u2192 (D i).top \u27f6 m) :\n  ",
      "path": "Mathlib/CategoryTheory/Presentable/Directed.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "out",
          "aleph0_le",
          "Fact",
          "sup",
          "IsRegular",
          "Cardinal"
        ]
      }
    },
    {
      "id": 3601,
      "before_code": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]",
      "suggestion": "\r\n  simp [e.forall_congr_left]\r\n",
      "body": "yeah it's having trouble unifying because `e.symm.symm` looks different to `e`\r\n\r\nI found a fix though; `exact` followed by an iff statement is generally a sign that `simp` or `rw` will work\r\n\r\n````suggestion\r\n  simp [e.forall_congr_left]\r\n````",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "Basis",
          "fundamentalDomain_reindex",
          "ext",
          "theorem",
          "fundamentalDomain",
          "forall_congr",
          "Type",
          "reindex",
          "implies_true",
          "Equiv",
          "mem_fundamentalDomain",
          "simp_rw",
          "repr_reindex_apply"
        ]
      }
    },
    {
      "id": 3607,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n",
      "body": "It's easier if you case split on whether the range of the function from the subtype is bounded above or not.\n```suggestion\n  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "exact",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "exact",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "aesop",
          "refine",
          "simp",
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 3608,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    toEuclidean '' Euclidean.closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [Euclidean.closedBall, Euclidean.dist]\r\n",
      "body": "```suggestion\r\n    toEuclidean '' Euclidean.closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [Euclidean.closedBall, Euclidean.dist]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "new_tactics": [
          "simpa",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 3610,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 ((by simp_all [x\u2081, x\u2082])) (by simp)]\r\n    simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n  \u00b7 simp [x\u2081, abs_of_nonneg, hr]\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n",
      "body": "More compact this way:\r\n```suggestion\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 ((by simp_all [x\u2081, x\u2082])) (by simp)]\r\n    simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n  \u00b7 simp [x\u2081, abs_of_nonneg, hr]\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine",
          "rw",
          "simp_all"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 3611,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  let x\u2081 := toEuclidean x + EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  let x\u2082 := toEuclidean x - EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 (by simp_all [x\u2081, x\u2082]) (by simp)]\r\n",
      "body": "```suggestion\r\n  let x\u2081 := toEuclidean x + EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  let x\u2082 := toEuclidean x - EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 (by simp_all [x\u2081, x\u2082]) (by simp)]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine",
          "rw",
          "simp_all"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 3612,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    toEuclidean '' closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [closedBall, dist]\r\n",
      "body": "```suggestion\r\n    toEuclidean '' closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [closedBall, dist]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "new_tactics": [
          "simpa",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 3629,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "  rw [Nat.le_div_iff_mul_le (by positivity), Nat.mul_comm,\n    \u2190 Nat.add_mul_div_right _ _ (by positivity),\n    Nat.le_div_iff_mul_le (by positivity)]\n  have := (Commute.all (b : \u2124) (a - b)).pow_add_mul_le_add_pow_of_sq_nonneg\n    (by positivity) (sq_nonneg _) (sq_nonneg _) (by grind) (n + 1)\n  -- `grind` should solve this, but:  https://github.com/leanprover/lean4/issues/11539\n  simp [mul_sub, \u2190 add_sub_assoc] at this\n  norm_cast at this\n  grind \n",
      "body": "This worked last week\n```suggestion\n  rw [Nat.le_div_iff_mul_le (by positivity), Nat.mul_comm,\n    \u2190 Nat.add_mul_div_right _ _ (by positivity),\n    Nat.le_div_iff_mul_le (by positivity)]\n  have := (Commute.all (b : \u2124) (a - b)).pow_add_mul_le_add_pow_of_sq_nonneg\n    (by positivity) (sq_nonneg _) (sq_nonneg _) (by grind) (n + 1)\n  -- `grind` should solve this, but:  https://github.com/[user]r/lean4/issues/11539\n  simp [mul_sub, \u2190 add_sub_assoc] at this\n  norm_cast at this\n  grind \n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "grind",
          "have",
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "positivity",
          "grind",
          "have",
          "rw",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "positivity",
          "rw",
          "simp",
          "grind",
          "have",
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 3630,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "  have H : \u2203 c, a < (c + 1) ^ (n + 1) := \u27e8a, Nat.le_self_pow (by positivity) (a + 1)\u27e9\n  let +nondep (eq := hc) c := Nat.find H\n  refine \u27e8c, ?_, hc \u25b8 Nat.find_spec H\u27e9\n  cases c with\n  | zero => simp\n  | succ k => simpa using Nat.find_min H hc.le\n",
      "body": "Here's a nice little trick for you. This introduces a new name `c` which is equal (propositionally) to `Nat.find H`, but it doesn't reduce to that. This allows us to perform a nice case split on `c` which simplifies the argument.\n```suggestion\n  have H : \u2203 c, a < (c + 1) ^ (n + 1) := \u27e8a, Nat.le_self_pow (by positivity) (a + 1)\u27e9\n  let +nondep (eq := hc) c := Nat.find H\n  refine \u27e8c, ?_, hc \u25b8 Nat.find_spec H\u27e9\n  cases c with\n  | zero => simp\n  | succ k => simpa using Nat.find_min H hc.le\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "refine",
          "cases",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "positivity",
          "refine",
          "cases",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "positivity",
          "refine",
          "simp",
          "cases",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 3632,
      "before_code": "IsClosed { f : \u03b1 \u2192 \u03b2 | LipschitzWith K f } := by\n  simp only [\u2190 lipschitzOnWith_univ, isClosed_setOf_lipschitzOnWith]",
      "suggestion": "protected lemma LipschitzOnWith.closure_iff [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {K : \u211d\u22650}\n    (hcont : ContinuousOn f (closure s)) :\n    LipschitzOnWith K f (closure s) \u2194 LipschitzOnWith K f s := by\n  refine \u27e8fun hf \u21a6 hf.mono subset_closure, fun hf \u21a6 ?_\u27e9\n",
      "body": "How about we upgrade this to an `iff` and use `variable`s a bit more:\n```suggestion\nprotected lemma LipschitzOnWith.closure_iff [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {K : \u211d\u22650}\n    (hcont : ContinuousOn f (closure s)) :\n    LipschitzOnWith K f (closure s) \u2194 LipschitzOnWith K f s := by\n  refine \u27e8fun hf \u21a6 hf.mono subset_closure, fun hf \u21a6 ?_\u27e9\n```",
      "path": "Mathlib/Topology/Instances/ENNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "IsClosed",
          "LipschitzWith",
          "lipschitzOnWith_univ",
          "simp",
          "only",
          "isClosed_setOf_lipschitzOnWith"
        ]
      }
    },
    {
      "id": 3634,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n  have {x} (hx : x \u2208 s) : \u2203 K' : \u211d\u22650, \u2200 y \u2208 s.diff (ball x (\u03b5 x hx)),\r\n",
      "body": "Should this be stated as\r\n```suggestion\r\n  have {x} (hx : x \u2208 s) : \u2203 K' : \u211d\u22650, \u2200 y \u2208 s.diff (ball x (\u03b5 x hx)),\r\n```\r\nso you can avoid the `fun x hx` at the beginning of hte proof?",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 3636,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n      gcongr\r\n      exact (add_le_add_left (mul_le_mul_of_nonneg_left h (by positivity)) _).trans (by linarith)\r\n",
      "body": "```suggestion\r\n      gcongr\r\n      exact (add_le_add_left (mul_le_mul_of_nonneg_left h (by positivity)) _).trans (by linarith)\r\n```",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "body_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "new_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 3637,
      "before_code": "(by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n\nend MeromorphicOn",
      "suggestion": "@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3)) :\n    Meromorphic (\u2211 n \u2208 s, G n) := fun x \u21a6 MeromorphicAt.sum (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma sub (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f - g) := fun x \u21a6 (hf x).sub (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma mul {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f * g) := fun x \u21a6 (hf x).mul (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem prod (h : \u2200 \u03c3, Meromorphic (F \u03c3)) :\n    Meromorphic (\u220f n \u2208 s, F n) := fun x \u21a6 MeromorphicAt.prod (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma div {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f / g) := fun x \u21a6 (hf x).div (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma pow",
      "body": "There is some new metaprogramming that can help here: the `to_fun` attribute.\nTo get access, you need to add `import Mathlib.Tactic.ToFun` to the imports (doesn't need `public`).\n\n```suggestion\n@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "restrict",
          "measurable_of_countable",
          "end",
          "mem_compl_iff",
          "simp",
          "MeromorphicOn",
          "measurable"
        ]
      }
    },
    {
      "id": 3643,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "  rcases (by lia : finrank R V = 0 \u2228 finrank R V = 1) with h0 | h1\n  \u00b7 have : Subsingleton V := (finrank_eq_zero_iff_of_free R V).mp h0\n    simp [Subsingleton.eq_zero v]\n",
      "body": "```suggestion\n  rcases (by lia : finrank R V = 0 \u2228 finrank R V = 1) with h0 | h1\n  \u00b7 have : Subsingleton V := (finrank_eq_zero_iff_of_free R V).mp h0\n    simp [Subsingleton.eq_zero v]\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "have"
        ],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 3644,
      "before_code": "namespace LinearMap\n\nvariable {R V : Type*} [CommSemiring R] [AddCommMonoid V] [Module R V]\n\n/-- The transvection associated with a linear form `f` and a vector `v`.\n\nNB. It is only a transvection when `f v = 0`. See also `Module.preReflection`. -/\ndef transvection (f : Module.Dual R V) (v : V) : V \u2192\u2097[R] V where\n  toFun x := x + f x \u2022 v\n  map_add' x y := by simp only [map_add]; module\n  map_smul' r x := by simp only [map_smul, RingHom.id_apply, smul_eq_mul]; module\n\nnamespace transvection\n\ntheorem apply (f : Module.Dual R V) (v x : V) :\n    transvection f v x = x + f x \u2022 v :=\n  rfl\n\ntheorem comp_of_left_eq_apply {f : Module.Dual R V} {v w : V} {x : V} (hw : f w = 0) :\n    transvection f v (transvection f w x) = transvection f (v + w) x := by\n  simp only [transvection, coe_mk, AddHom.coe_mk, map_add, map_smul, hw, smul_add]\n  module\n\ntheorem comp_of_left_eq {f : Module.Dual R V} {v w : V} (hw : f w = 0) :\n    (transvection f v) \u2218\u2097 (transvection f w) = transvection f (v + w) := by\n  ext; simp [comp_of_left_eq_apply hw]\n\ntheorem comp_of_right_eq_apply {f g : Module.Dual R V} {v : V} {x : V} (hf : f v = 0) :\n    (transvection f v) (transvection g v x) = transvection (f + g) v x := by\n  simp only [transvection, coe_mk, AddHom.coe_mk, map_add, map_smul, hf, add_apply]\n  module\n\ntheorem comp_of_right_eq {f g : Module.Dual R V} {v : V} (hf : f v = 0) :\n    (transvection f v) \u2218\u2097 (transvection g v) = transvection (f + g) v := by\n  ext; simp [comp_of_right_eq_apply hf]\n\n@[simp]\ntheorem of_left_eq_zero (v : V) :\n    transvection (0 : Module.Dual R V) v = LinearMap.id := by\n  ext\n  simp [transvection]\n\n@[simp]\ntheorem of_right_eq_zero (f : Module.Dual R V) :\n    transvection f 0 = LinearMap.id := by\n  ext\n  simp [transvection]",
      "suggestion": "    rwa [Finset.sum_eq_single_of_mem i (Finset.mem_univ i) (by grind)] at this\n",
      "body": "```suggestion\n    rwa [Finset.sum_eq_single_of_mem i (Finset.mem_univ i) (by grind)] at this\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "simp",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Module",
          "map_smul",
          "preReflection",
          "Type",
          "when",
          "form",
          "apply",
          "add_apply",
          "LinearMap",
          "ext",
          "associated",
          "coe_mk",
          "comp_of_right_eq_apply",
          "transvection",
          "RingHom",
          "smul_eq_mul",
          "CommSemiring",
          "also",
          "linear",
          "of_left_eq_zero",
          "variable",
          "def",
          "comp_of_right_eq",
          "comp_of_left_eq",
          "See",
          "toFun",
          "module",
          "AddHom",
          "map_add",
          "simp",
          "rfl",
          "only",
          "namespace",
          "comp_of_left_eq_apply",
          "of_right_eq_zero",
          "AddCommMonoid",
          "id_apply",
          "theorem",
          "smul_add",
          "vector",
          "Dual"
        ]
      }
    },
    {
      "id": 3655,
      "before_code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible",
      "suggestion": "    have hd := congr(degree $h)\n    have aux : (a \u2022 (X : R[X]) + C b).degree = 1 := by compute_degree!\n    rw [degree_mul, aux, eq_comm, Nat.WithBot.add_eq_one_iff] at hd\n    obtain \u27e8hf, -\u27e9 : f.degree = 0 \u2227 g.degree = 1 := by\n      apply hd.resolve_right\n      rintro \u27e8hf0, hfg\u27e9\n      simp_all [(zero_lt_one' (WithBot \u2115)).not_ge]\n    left\n    replace hf := f.eq_C_of_degree_eq_zero hf\n    suffices IsUnit (f.coeff 0) by\n      rw [isUnit_iff]\n      exact \u27e8f.coeff 0, this, hf.symm\u27e9\n    rw [hf, \u2190 smul_eq_C_mul] at h\n    apply hab\n    \u00b7 use g.coeff 1\n      simpa using congr(coeff $h 1)\n    \u00b7 use g.coeff 0\n      simpa using congr(coeff $h 0)\n",
      "body": "```suggestion\n    have hd := congr(degree $h)\n    have aux : (a \u2022 (X : R[X]) + C b).degree = 1 := by compute_degree!\n    rw [degree_mul, aux, eq_comm, Nat.WithBot.add_eq_one_iff] at hd\n    obtain \u27e8hf, -\u27e9 : f.degree = 0 \u2227 g.degree = 1 := by\n      apply hd.resolve_right\n      rintro \u27e8hf0, hfg\u27e9\n      simp_all [(zero_lt_one' (WithBot \u2115)).not_ge]\n    left\n    replace hf := f.eq_C_of_degree_eq_zero hf\n    suffices IsUnit (f.coeff 0) by\n      rw [isUnit_iff]\n      exact \u27e8f.coeff 0, this, hf.symm\u27e9\n    r",
      "path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Monic",
          "irreducible",
          "theorem",
          "Irreducible",
          "hp1",
          "prime_of_degree_eq_one",
          "irreducible_of_degree_eq_one",
          "degree"
        ]
      }
    },
    {
      "id": 3665,
      "before_code": "simpa using angle_le_angle_add_angle_of_norm_eq_one (norm_normalize_eq_one_iff.mpr hx)\n    (norm_normalize_eq_one_iff.mpr hy) (norm_normalize_eq_one_iff.mpr hz)",
      "suggestion": "\r\n      obtain \u27e8_, \u27e8r2, \u27e8H5, rfl\u27e9\u27e9\u27e9 := H2\r\n      lift r2 to \u211d\u22650 using H5.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n    have H2 : Real.sin (angle x z) \u2260 0 := by\r\n      grind [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi]\r\n    obtain hx | hx := eq_or_ne x 0\r\n    \u00b7 subst x; simp only [angle_zero_left, left_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H3, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H3.le\r\n      rw [\u2190 NNReal.smul_def, Submodule.span_insert_zero, Submodule.span_singleton_smul_eq]\r\n      \u00b7 simp\r\n      norm_cast at H3\r\n      grind [isUnit_iff_ne_zero]\r\n    obtain hz | hz := eq_or_ne z 0\r\n    \u00b7 subst z; simp only [angle_zero_right, right_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H1, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H1.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n",
      "body": "```suggestion\r\n      obtain \u27e8_, \u27e8r2, \u27e8H5, rfl\u27e9\u27e9\u27e9 := H2\r\n      lift r2 to \u211d\u22650 using H5.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n    have H2 : Real.sin (angle x z) \u2260 0 := by\r\n      grind [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi]\r\n    obtain hx | hx := eq_or_ne x 0\r\n    \u00b7 subst x; simp only [angle_zero_left, left_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H3, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H3.le\r\n      rw [\u2190 NNReal.smul_d",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp_all",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp",
          "norm_cast"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "simpa",
          "angle_le_angle_add_angle_of_norm_eq_one",
          "using",
          "norm_normalize_eq_one_iff"
        ]
      }
    },
    {
      "id": 3669,
      "before_code": "(H \u2294 K).Connected :=\n  Subgraph.connected_sup hH.preconnected hK.preconnected hn",
      "suggestion": "\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degree_pos_of_nontrivial v\r\n",
      "body": "Even though you know the graph is nonempty I think it's better to assume the weaker `Preconnected` instead of `Connected`.\r\nAlso, the `by_contra` is redundant here.\r\n```suggestion\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degre",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa",
          "remove_redundant"
        ],
        "keywords": [
          "Connected",
          "connected_sup",
          "Subgraph",
          "preconnected"
        ]
      }
    },
    {
      "id": 3671,
      "before_code": "have h2 : 0 \u2264 r := nonneg_of_mul_nonneg_left h1 (dist_pos.mpr hab\u2081)\n    exact (sq_eq_sq\u2080 dist_nonneg (mul_nonneg h2 dist_nonneg)).mp h'",
      "suggestion": "\r\ntheorem exterior_angle_eq_angle_add_angle {p\u2081 p\u2082 p\u2083 : P} (p : P) (h : Sbtw \u211d p p\u2081 p\u2082) :\r\n    \u2220 p\u2083 p\u2081 p = \u2220 p\u2081 p\u2083 p\u2082 + \u2220 p\u2083 p\u2082 p\u2081 := by\r\n  have H := (EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n  rw [show \u2220 p\u2083 p\u2081 p\u2082 = \u2220 p\u2082 p\u2081 p\u2083 by simp only [angle_comm],\r\n      add_comm,\r\n      \u2190 angle_add_angle_add_angle_eq_pi p\u2083 ((Sbtw.right_ne h).symm),\r\n      add_assoc] at H\r\n  simp only [add_right_inj] at H\r\n  rw [H]\r\n",
      "body": "Thanks for the PR! I think we can shorten this proof. Here is a suggestion: \r\n```suggestion\r\ntheorem exterior_angle_eq_angle_add_angle {p\u2081 p\u2082 p\u2083 : P} (p : P) (h : Sbtw \u211d p p\u2081 p\u2082) :\r\n    \u2220 p\u2083 p\u2081 p = \u2220 p\u2081 p\u2083 p\u2082 + \u2220 p\u2083 p\u2082 p\u2081 := by\r\n  have H := (EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n  rw [show \u2220 p\u2083 p\u2081 p\u2082 = \u2220 p\u2082 p\u2081 p\u2083 by simp only [angle_comm],\r\n      add_comm,\r\n      \u2190 angle_add_angle_add_angle_eq_pi p\u2083 ((Sbtw.right_ne h).symm),\r\n      add_assoc] at",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "mpr",
          "nonneg_of_mul_nonneg_left",
          "exact",
          "have",
          "dist_pos",
          "dist_nonneg",
          "mul_nonneg"
        ]
      }
    },
    {
      "id": 3676,
      "before_code": "rw [Set.top_eq_univ, Set.finite_univ_iff, \u2190 @Finset.coe_sort_coe]\n    exact Finite.of_fintype p.support\n  apply Set.Finite.bddAbove <| Set.Finite.subset h_fin _\n  intro x hx\n  obtain \u27e8i, hi\u27e9 := hx\n  rw [\u2190 hi]\n  by_cases hi : i \u2208 p.support\n  \u00b7 left\n    use \u27e8i, hi\u27e9\n    simp [f]\n  \u00b7 right\n    simp [Polynomial.notMem_support_iff.mp hi]",
      "suggestion": "refine Set.Finite.bddAbove <| Set.Finite.subset h_fin _ fun _ \u21a6 ?_\n",
      "body": "````suggestion\nrefine Set.Finite.bddAbove <| Set.Finite.subset h_fin _ fun _ \u21a6 ?_\n````\nPerhaps?",
      "path": "Mathlib/RingTheory/Polynomial/GaussNorm.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "exact",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "apply",
          "exact",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "bddAbove",
          "obtain",
          "Polynomial",
          "coe_sort_coe",
          "apply",
          "right",
          "by_cases",
          "Finset",
          "intro",
          "notMem_support_iff",
          "top_eq_univ",
          "h_fin",
          "of_fintype",
          "simp",
          "use",
          "subset",
          "Finite",
          "finite_univ_iff",
          "support",
          "exact",
          "left",
          "Set"
        ]
      }
    },
    {
      "id": 3682,
      "before_code": "end Northcott",
      "suggestion": "  have : NeZero n := \u27e8hn\u27e9\n  suffices \u220f x \u2208 primitiveRoots n \u2102, max 1 \u2016x\u2016 = 1 by\n    simpa [mahlerMeasure_eq_leadingCoeff_mul_prod_roots, cyclotomic.monic n \u2102,\n      Polynomial.cyclotomic.roots_eq_primitiveRoots_val]\n  suffices \u2200 a \u2208 primitiveRoots n \u2102, \u2016a\u2016 \u2264 1 from Multiset.prod_eq_one (by simpa)\n  intro z hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le\n",
      "body": "```suggestion\n  have : NeZero n := \u27e8hn\u27e9\n  suffices \u220f x \u2208 primitiveRoots n \u2102, max 1 \u2016x\u2016 = 1 by\n    simpa [mahlerMeasure_eq_leadingCoeff_mul_prod_roots, cyclotomic.monic n \u2102,\n      Polynomial.cyclotomic.roots_eq_primitiveRoots_val]\n  suffices \u2200 a \u2208 primitiveRoots n \u2102, \u2016a\u2016 \u2264 1 from Multiset.prod_eq_one (by simpa)\n  intro z hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Northcott",
          "end"
        ]
      }
    },
    {
      "id": 3684,
      "before_code": "rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h",
      "suggestion": "\r\n  refine \u27e8fun h hn' \u21a6 ?_, fun h => separable_X_pow_sub_C_unit (Units.mk0 x hx) (IsUnit.mk0 _ h)\u27e9\r\n  exact not_isUnit_of_natDegree_pos (X ^ n - C x) (by simp [hn]) <| by\r\n    simpa [separable_def, derivative_X_pow, hn', isCoprime_zero_right] using h\r\n",
      "body": "````suggestion\r\n  refine \u27e8fun h hn' \u21a6 ?_, fun h => separable_X_pow_sub_C_unit (Units.mk0 x hx) (IsUnit.mk0 _ h)\u27e9\r\n  exact not_isUnit_of_natDegree_pos (X ^ n - C x) (by simp [hn]) <| by\r\n    simpa [separable_def, derivative_X_pow, hn', isCoprime_zero_right] using h\r\n````\r\nI know you copied the proof from the previous lemma, but that old proof is honestly pretty bizzare. Here's a shorter version doing exactly the same steps.",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "exact",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "exact",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "C_0",
          "isCoprime_zero_right",
          "not_isUnit_X_pow_sub_one",
          "zero_mul"
        ]
      }
    },
    {
      "id": 3685,
      "before_code": "rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h",
      "suggestion": "  refine \u27e8?_, fun h => separable_X_pow_sub_C x h hx\u27e9\n",
      "body": "````suggestion\n  refine \u27e8?_, fun h => separable_X_pow_sub_C x h hx\u27e9\n````",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "C_0",
          "isCoprime_zero_right",
          "not_isUnit_X_pow_sub_one",
          "zero_mul"
        ]
      }
    },
    {
      "id": 3689,
      "before_code": "simp [LinearMap.comp_assoc]\n\nend Finsupp",
      "suggestion": "    coassoc := by ext; simp [coalgebraStruct] }\n",
      "body": "```suggestion\n    coassoc := by ext; simp [coalgebraStruct] }\n```",
      "path": "Mathlib/RingTheory/Coalgebra/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "end",
          "LinearMap",
          "comp_assoc",
          "simp"
        ]
      }
    },
    {
      "id": 3699,
      "before_code": "rw [this, \u2190 Measure.map_map (by fun_prop) (by fun_prop), gaussianReal_map_neg,\n    gaussianReal_map_const_add, add_comm]\n\nvariable {\u03a9 : Type} [MeasureSpace \u03a9]\n\n/-- If `X` is a real random variable with Gaussian law with mean `\u03bc` and variance `v`, then `X + y`\nhas Gaussian law with mean `\u03bc + y` and variance `v`. -/\nlemma gaussianReal_add_const {X : \u03a9 \u2192 \u211d} (hX : Measure.map X \u2119 = gaussianReal \u03bc v) (y : \u211d) :\n    Measure.map (fun \u03c9 \u21a6 X \u03c9 + y) \u2119 = gaussianReal (\u03bc + y) v := by\n  have hXm : AEMeasurable X := aemeasurable_of_map_neZero (by rw [hX]; infer_instance)\n  change Measure.map ((fun \u03c9 \u21a6 \u03c9 + y) \u2218 X) \u2119 = gaussianReal (\u03bc + y) v\n  rw [\u2190 AEMeasurable.map_map_of_aemeasurable (measurable_id'.add_const _).aemeasurable hXm, hX,\n    gaussianReal_map_add_const y]",
      "suggestion": "    HasLaw (fun \u03c9 \u21a6 X \u03c9 + y) (gaussianReal (\u03bc + y) v) P :=\n  HasLaw.comp \u27e8by fun_prop, gaussianReal_map_add_const y\u27e9 hX\n",
      "body": "Like you did for the mul:\n```suggestion\n    HasLaw (fun \u03c9 \u21a6 X \u03c9 + y) (gaussianReal (\u03bc + y) v) P :=\n  HasLaw.comp \u27e8by fun_prop, gaussianReal_map_add_const y\u27e9 hX\n```\nIn fact you can do the same for all the lemmas.",
      "path": "Mathlib/Probability/Distributions/Gaussian/Real.lean",
      "tags": {
        "before_tactics": [
          "fun_prop",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "have"
        ],
        "topics": [
          "list",
          "real",
          "measurability"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "lemma",
          "add_comm",
          "real",
          "Type",
          "law",
          "hXm",
          "change",
          "gaussianReal",
          "has",
          "fun_prop",
          "variance",
          "infer_instance",
          "have",
          "Measure",
          "map",
          "Gaussian",
          "gaussianReal_map_const_add",
          "gaussianReal_map_add_const",
          "MeasureSpace",
          "variable",
          "then",
          "aemeasurable_of_map_neZero",
          "map_map",
          "gaussianReal_map_neg",
          "aemeasurable",
          "add_const",
          "measurable_id",
          "AEMeasurable",
          "random",
          "mean",
          "this",
          "map_map_of_aemeasurable",
          "gaussianReal_add_const"
        ]
      }
    },
    {
      "id": 3700,
      "before_code": "(h : \u2200 F : Set \u03a9, IsClosed F \u2192\n      limsup (fun i \u21a6 (\u03bcs i : Measure \u03a9).real F) L \u2264 (\u03bc : Measure \u03a9).real F) :\n    Tendsto \u03bcs L (\ud835\udcdd \u03bc) := by\n  refine tendsto_of_forall_isClosed_limsup_le' fun F hF \u21a6 ?_\n  rcases L.eq_or_neBot with rfl | hne\n  \u00b7 simp\n  specialize h F hF\n  simp only [Measure.real_def] at h\n  rwa [ENNReal.limsup_toReal_eq (b := 1) (by simp) (.of_forall fun i \u21a6 prob_le_one),\n    ENNReal.toReal_le_toReal _ (by finiteness)] at h\n  refine ne_top_of_le_ne_top (b := 1) (by simp) ?_\n  refine limsup_le_of_le ?_ (.of_forall fun i \u21a6 prob_le_one)\n  exact isCoboundedUnder_le_of_le L (x := 0) (by simp)",
      "suggestion": "Tendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n",
      "body": "````suggestion\nTendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n````",
      "path": "Mathlib/MeasureTheory/Measure/Portmanteau.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "simp",
          "refine"
        ],
        "topics": [
          "measurability",
          "order",
          "topology"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "of_forall",
          "rwa",
          "real",
          "rcases",
          "limsup_le_of_le",
          "finiteness",
          "refine",
          "specialize",
          "real_def",
          "Measure",
          "isCoboundedUnder_le_of_le",
          "limsup",
          "eq_or_neBot",
          "hne",
          "Tendsto",
          "simp",
          "prob_le_one",
          "rfl",
          "IsClosed",
          "only",
          "ne_top_of_le_ne_top",
          "ENNReal",
          "exact",
          "Set",
          "tendsto_of_forall_isClosed_limsup_le",
          "limsup_toReal_eq",
          "toReal_le_toReal"
        ]
      }
    },
    {
      "id": 3701,
      "before_code": "refine (e.forall_congr ?_).symm\n    intro i\n    rw [MeasurableEquiv.piCongrLeft_apply_apply e x i]\n  rw [this, pi_pi, Finset.prod_equiv e.symm]\n  \u00b7 simp only [Finset.mem_univ, implies_true]\n  intro i _\n  simp only [s']\n  congr\n  all_goals rw [e.apply_symm_apply]",
      "suggestion": "\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n",
      "body": "````suggestion\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n````",
      "path": "Mathlib/MeasureTheory/Constructions/Pi.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "topics": [
          "measurability",
          "set_theory",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply_symm_apply",
          "symm",
          "refine",
          "all_goals",
          "mem_univ",
          "forall_congr",
          "piCongrLeft_apply_apply",
          "Finset",
          "implies_true",
          "pi_pi",
          "congr",
          "this",
          "simp",
          "intro",
          "MeasurableEquiv",
          "prod_equiv",
          "only"
        ]
      }
    },
    {
      "id": 3704,
      "before_code": "end IsTightMeasureSet",
      "suggestion": "  refine ENNReal.tsum_le_tsum fun m \u21a6 tsub_le_iff_tsub_le.mp ?_\n",
      "body": "You can put `intro`s inside `refine`. Please do so at the other places where this appears in the file. You can also combine the lines below:\n```suggestion\n  refine ENNReal.tsum_le_tsum fun m \u21a6 tsub_le_iff_tsub_le.mp ?_\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine",
          "intro"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsTightMeasureSet",
          "end"
        ]
      }
    },
    {
      "id": 3705,
      "before_code": "end IsTightMeasureSet",
      "suggestion": "  rw [\u2190 coe_ofNat, \u2190 ENNReal.coe_zpow (by simp), \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n",
      "body": "Please mind the spacing. You can put the `simp` inside the `rw`. Also you don't need the `ENNReal` namespace.\n```suggestion\n  rw [\u2190 coe_ofNat, \u2190 ENNReal.coe_zpow (by simp), \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsTightMeasureSet",
          "end"
        ]
      }
    },
    {
      "id": 3706,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "private lemma lt_geom_series {D : \u2115 \u2192 \ud835\udce7} {\u03b5 : \u211d\u22650\u221e} {\u03bc : ProbabilityMeasure \ud835\udce7} {km : \u2115 \u2192 \u2115}\n    {u : \u2115 \u2192 \u211d} (hu_anti : Antitone u)\n    (hbound : \u2200 k : \u2115, 1 - \u03b5 * 2 ^ (-k : \u2124) < \u03bc (\u22c3 i \u2264 km k, ball (D i) (u k))) :\n    \u2211' (m : \u2115), (1 - \u03bc.toMeasure (\u22c3 i \u2264 km (m + 1), closure (ball (D i) (u m)))) \u2264\n    \u2211' (m : \u2115), (\u03b5 : \u211d\u22650\u221e) * 2 ^ (-((m : \u2124) + 1)) := by\n  refine ENNReal.tsum_le_tsum fun m \u21a6 tsub_le_iff_tsub_le.mp ?_\n  specialize hbound (m+1)\n  apply le_of_lt at hbound\n  simp_all only [neg_add_rev, Int.reduceNeg, tsub_le_iff_right, Nat.cast_add, Nat.cast_one,\n      \u2190 coe_ofNat, \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n  grw [hbound]\n  gcongr\n  \u00b7 refine apply_mono \u03bc <| iUnion\u2082_mono <| fun i hi \u21a6 ?_\n    grw [\u2190 subset_closure (s := ball (D i) (u m)), ball_subset_ball]\n    exact hu_anti (by grind)\n",
      "body": "Changes:\n- use a generic antitone sequence `u` instead of `1/(m+1)`\n- spacing of the statement\n- some spaces added (after `\u2190`, before `:=`)\n```suggestion\nprivate lemma lt_geom_series {D : \u2115 \u2192 \ud835\udce7} {\u03b5 : \u211d\u22650\u221e} {\u03bc : ProbabilityMeasure \ud835\udce7} {km : \u2115 \u2192 \u2115}\n    {u : \u2115 \u2192 \u211d} (hu_anti : Antitone u)\n    (hbound : \u2200 k : \u2115, 1 - \u03b5 * 2 ^ (-k : \u2124) < \u03bc (\u22c3 i \u2264 km k, ball (D i) (u k))) :\n    \u2211' (m : \u2115), (1 - \u03bc.toMeasure (\u22c3 i \u2264 km (m + 1), closure (ball (D i) (u m)))) \u2264\n    \u2211' (m : \u2115), (\u03b5 : \u211d\u22650\u221e) * 2 ^ (-((m : \u2124) + 1)) ",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "grind",
          "simp_all"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "grind",
          "simp_all"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "grind",
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3707,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "theorem isTightMeasureSet_of_isCompact_closure (hcomp : IsCompact (closure S)) :\n    IsTightMeasureSet {((\u03bc : ProbabilityMeasure \ud835\udce7) : Measure \ud835\udce7) | \u03bc \u2208 S} := by\n  rw [IsTightMeasureSet_iff_exists_isCompact_measure_compl_le]\n  rcases isEmpty_or_nonempty \ud835\udce7 with hempty | hempty\n  \u00b7 intro \u03b5 \u03b5pos\n    use \u2205\n    constructor\n    \u00b7 exact isCompact_empty\n    rw [\u2190 univ_eq_empty_iff] at hempty\n    simp only [mem_setOf_eq, compl_empty, hempty, measure_empty, zero_le, implies_true]\n  obtain \u27e8D, hD\u27e9 := exists_dense_seq \ud835\udce7\n  obtain \u27e8u, hu_anti, hu_pos, hu\u27e9 : \u2203 u, StrictAnti u \u2227 (\u2200 n, 0 < u n) \u2227 Tendsto u atTop (\ud835\udcdd 0) :=\n    exists_seq_strictAnti_tendsto (0 : \u211d)\n  have hcov (m : \u2115) : \u22c3 i, ball (D i) (u m) = univ := by\n    rw [denseRange_iff] at hD\n    ext p\n    exact \u27e8fun a \u21a6 trivial, fun _ \u21a6 mem_iUnion.mpr <| hD p (u m) (hu_pos m)\u27e9\n  intro \u03b5 \u03b5pos\n  by_cases h\u03b5bound : 1 < \u03b5\n  \u00b7 use \u2205\n    constructor\n    \u00b7 exact isCompact_empty\n    intro \u03bc h\u03bc\n    simp only [mem_setOf_eq] at h\u03bc\n    obtain \u27e8\u03bc', h\u03bc', rfl\u27e9 :=",
      "body": "Changes:\n- use a generic sequence `u` with `StrictAnti u \u2227 (\u2200 n, 0 < u n) \u2227 Tendsto u atTop (\ud835\udcdd 0)` instead of `1/(m+1)`. It leads to shorter expressions and makes it easier to see what are the properties used. Also replace the inverse of delta by `have \u27e8\u03b4_inv, h\u03b4_inv\u27e9 : \u2203 x, u x < \u03b4`.\n- use `simpa` more\n- fix spaces here and there\n- replace instances of `use x; constructor; intro y`... on multiple lines by a one-line `refine`\n```suggestion\ntheorem isTightMeasureSet_of_isCompact_closure (hcomp : ",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "ext",
          "exact",
          "cases",
          "linarith",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "constructor",
          "intro",
          "congr",
          "measurability",
          "ring_nf"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "ext",
          "exact",
          "cases",
          "linarith",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "constructor",
          "intro",
          "congr",
          "measurability",
          "ring_nf"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "simp",
          "congr",
          "measurability",
          "ring_nf",
          "apply",
          "gcongr",
          "refine",
          "ext",
          "cases",
          "have",
          "simpa",
          "constructor",
          "intro",
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_simpa",
          "use_linarith",
          "cleanup_simp"
        ],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3708,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  have \u03b5fin : \u03b5 \u2260 \u221e := ne_top_of_le_ne_top (by simp) h\u03b5bound\n",
      "body": "- use `\u221e` for top in ENNReal\n- shorter proof\n```suggestion\n  have \u03b5fin : \u03b5 \u2260 \u221e := ne_top_of_le_ne_top (by simp) h\u03b5bound\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3709,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "            fun _ d hyp \u21a6 (hyp d (by simp)).trans (by simp)\n",
      "body": "```suggestion\n            fun _ d hyp \u21a6 (hyp d (by simp)).trans (by simp)\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3710,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "      Tendsto.eventually_const_le (v := 1) (by simp; positivity) accumulation\n",
      "body": "```suggestion\n      Tendsto.eventually_const_le (v := 1) (by simp; positivity) accumulation\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "positivity",
          "simp"
        ],
        "body_tactics": [
          "positivity",
          "simp"
        ],
        "new_tactics": [
          "positivity",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3711,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  \u00b7 rw [\u2190 univ_eq_empty_iff] at hempty\n    exact fun \u03b5 \u03b5pos \u21a6 \u27e8\u2205, isCompact_empty, by simp [hempty]\u27e9\n",
      "body": "```suggestion\n  \u00b7 rw [\u2190 univ_eq_empty_iff] at hempty\n    exact fun \u03b5 \u03b5pos \u21a6 \u27e8\u2205, isCompact_empty, by simp [hempty]\u27e9\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3717,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "theorem continuousOn_arcosh : ContinuousOn arcosh (Ici 1) :=\n  have {x : \u211d} (hx : x \u2208 Ici 1) : 0 < x + \u221a(x ^ 2 - 1) :=\n    add_pos_of_pos_of_nonneg (show 0 < x by grind) (sqrt_nonneg _)\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (fun _ _ => by grind)\n",
      "body": "It's very minor, but why not?\n\n```suggestion\ntheorem continuousOn_arcosh : ContinuousOn arcosh (Ici 1) :=\n  have {x : \u211d} (hx : x \u2208 Ici 1) : 0 < x + \u221a(x ^ 2 - 1) :=\n    add_pos_of_pos_of_nonneg (show 0 < x by grind) (sqrt_nonneg _)\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (fun _ _ => by grind)\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "body_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "new_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 3718,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "\r\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (by grind [MapsTo])\r\n",
      "body": "```suggestion\r\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (by grind [MapsTo])\r\n```\r\nThis lets `grind` unfold the definition, instead of invoking it only after the `intro` (or `fun`) unfolds it",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "continuity",
          "grind"
        ],
        "body_tactics": [
          "continuity",
          "grind",
          "intro"
        ],
        "new_tactics": [
          "continuity",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 3721,
      "before_code": "end",
      "suggestion": "\r\n  letI gen : M.GeneratingSections :=\r\n    { I := \u03c3\r\n      s := M.freeHomEquiv g\r\n      epi := by simpa using epi_of_isColimit_cofork H'}\r\n  haveI eq_aux : gen.\u03c0 = g := Equiv.symm_apply_apply M.freeHomEquiv g\r\n  haveI comp_zero : f \u226b gen.\u03c0 = 0 := eq_aux \u25b8 H\r\n  { generators := gen\r\n    relations :=\r\n      { I := \u03b9\r\n        s := (kernel gen.\u03c0).freeHomEquiv <| kernel.lift gen.\u03c0 f comp_zero\r\n        epi := by\r\n          let h : cokernel f \u2245 M := (H'.coconePointUniqueUpToIso (colimit.isColimit _)).symm\r\n          let h' : Abelian.image f \u2245 kernel gen.\u03c0 :=\r\n            kernel.mapIso (cokernel.\u03c0 f) gen.\u03c0 (Iso.refl _) h (by simp [h, eq_aux])\r\n          have comp_aux : Abelian.factorThruImage f \u226b h'.hom =\r\n            (kernel.lift gen.\u03c0 f comp_zero) := equalizer.hom_ext <| by simp [h']\r\n          rw [\u2190 comp_aux, Equiv.symm_apply_apply]\r\n          infer_instance }}\r\n",
      "body": "```suggestion\r\n  letI gen : M.GeneratingSections :=\r\n    { I := \u03c3\r\n      s := M.freeHomEquiv g\r\n      epi := by simpa using epi_of_isColimit_cofork H'}\r\n  haveI eq_aux : gen.\u03c0 = g := Equiv.symm_apply_apply M.freeHomEquiv g\r\n  haveI comp_zero : f \u226b gen.\u03c0 = 0 := eq_aux \u25b8 H\r\n  { generators := gen\r\n    relations :=\r\n      { I := \u03b9\r\n        s := (kernel gen.\u03c0).freeHomEquiv <| kernel.lift gen.\u03c0 f comp_zero\r\n        epi := by\r\n          let h : cokernel f \u2245 M := (H'.coconePointUniqueUpToIso (colimit.is",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3722,
      "before_code": "end",
      "suggestion": "\r\ndef Presentation.isColimit {M : SheafOfModules.{u} R} (P : Presentation M) :\r\n    IsColimit (CokernelCofork.of\u03c0\r\n      (f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))\r\n      P.generators.\u03c0 (by simp)) :=\r\n  isCokernelEpiComp (c := CokernelCofork.of\u03c0 _ (kernel.condition P.generators.\u03c0))\r\n      (Abelian.epiIsCokernelOfKernel _ <| limit.isLimit _) _ rfl\r\n",
      "body": "I find it a bit akward to state things using this Sigma-type given that here all the data are explicit and already known:\r\n\r\n```suggestion\r\ndef Presentation.isColimit {M : SheafOfModules.{u} R} (P : Presentation M) :\r\n    IsColimit (CokernelCofork.of\u03c0\r\n      (f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))\r\n      P.generators.\u03c0 (by simp)) :=\r\n  isCokernelEpiComp (c := CokernelCofork.of\u03c0 _ (kernel.condition P.generators.\u03c0))\r\n      (Abelian.epiIsCokernelOfKernel _ <| limit.isLimit _) _ rf",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3723,
      "before_code": "end",
      "suggestion": "\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map f \u226b\r\n    (PreservesCoproduct.iso F _).hom \u226b (Sigma.mapIso fun b \u21a6 hf').hom\r\n  letI g_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map g\r\n  haveI H' : f_new \u226b g_new = 0 := by\r\n    simp_rw [f_new, g_new, Category.assoc, Iso.hom_inv_id_assoc,\r\n      Preadditive.IsIso.comp_left_eq_zero, IsHomLift.eq_of_isHomLift F (F.map f \u226b F.map g) (f \u226b g),\r\n      H, Functor.map_zero]\r\n  letI h' : IsColimit (CokernelCofork.of\u03c0 g_new H') := by\r\n    refine IsColimit.ofIsoColimit ((IsColimit.precomposeHom",
      "body": "This suggestion uses the modification suggested above for `Presentation.isColimit`\r\n\r\n```suggestion\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_ne",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3724,
      "before_code": "end",
      "suggestion": "  letI f := (map_free F hf' P.relations.I).inv \u226b F.map ((freeHomEquiv _).symm P.relations.s) \u226b\n    F.map (kernel.\u03b9 _) \u226b (map_free F hf' P.generators.I).hom\n  letI g := (map_free F hf' P.generators.I).inv \u226b F.map (P.generators.\u03c0)\n  presentationOfIsCokernelFree f g (by simp [f, g, \u2190 Functor.map_comp]) <|\n    cokernel.cokernelIso f g ((((cokernel.mapIso (F.map\n      ((freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))) f\n        (map_free F hf' P.relations.I) (map_free F hf' P.generators.I) (by simp [f])).symm) \u226a\u226b\n          (Limits.PreservesCokernel.iso F ((freeHomEquiv _).symm P.relations.s \u226b\n            (kernel.\u03b9 _))).symm) \u226a\u226b F.mapIso (Limits.IsColimit.coconePointUniqueUpToIso\n              (colimit.isColimit _) P.isColimit)) (by simp [\u2190 Functor.map_comp, g])\n",
      "body": "```suggestion\n  letI f := (map_free F hf' P.relations.I).inv \u226b F.map ((freeHomEquiv _).symm P.relations.s) \u226b\n    F.map (kernel.\u03b9 _) \u226b (map_free F hf' P.generators.I).hom\n  letI g := (map_free F hf' P.generators.I).inv \u226b F.map (P.generators.\u03c0)\n  presentationOfIsCokernelFree f g (by simp [f, g, \u2190 Functor.map_comp]) <|\n    cokernel.cokernelIso f g ((((cokernel.mapIso (F.map\n      ((freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))) f\n        (map_free F hf' P.relations.I) (map_free F hf' P.generat",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3733,
      "before_code": "nonrec theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=\n  ofReal_inj.1 <| by simp [tanh_eq_sinh_div_cosh]",
      "suggestion": "  rw [tanh_eq_sinh_div_cosh, sinh_eq, cosh_eq, div_div_div_cancel_right\u2080 two_ne_zero]\n",
      "body": "```suggestion\n  rw [tanh_eq_sinh_div_cosh, sinh_eq, cosh_eq, div_div_div_cancel_right\u2080 two_ne_zero]\n```\nor if you want to do it without knowing the lemma name:\n```lean\n  rw [tanh_eq_sinh_div_cosh, sinh_eq, cosh_eq, div_div_div_cancel_right\u2080 (by norm_num)]\n```",
      "path": "Mathlib/Analysis/Complex/Trigonometric.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "norm_num",
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "nonrec",
          "sinh",
          "theorem",
          "tanh",
          "cosh",
          "simp",
          "tanh_eq_sinh_div_cosh",
          "ofReal_inj"
        ]
      }
    },
    {
      "id": 3736,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n",
      "body": "```suggestion\n    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind",
          "simp_all",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp_all",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "simp_all",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3737,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n",
      "body": "```suggestion\n  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind",
          "have",
          "simp_all"
        ],
        "body_tactics": [
          "grind",
          "have",
          "simp_all"
        ],
        "new_tactics": [
          "grind",
          "simp_all",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3743,
      "before_code": "intro x hx\n  simp [hx]",
      "suggestion": "  have h\u2081' := h\u2081.to_subtype\n  have h\u2082 : IsOpen s := isOpen_analyticAt \ud835\udd5c f\n  have h\u2083 : ContinuousOn f s := fun z hz \u21a6 hz.continuousAt.continuousWithinAt\n  exact .of_union_range_cover (.subtype_coe h\u2082.measurableSet) (.subtype_coe h\u2081.measurableSet)\n    (by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n",
      "body": "I think this is easier. If `s` is a measurable set, and `f` is measurable on both `s` and `s\u1d9c` (the former because it's continuous there, the latter because `s\u1d9c` is countable), then `f` is measurable.\n```suggestion\n  have h\u2081' := h\u2081.to_subtype\n  have h\u2082 : IsOpen s := isOpen_analyticAt \ud835\udd5c f\n  have h\u2083 : ContinuousOn f s := fun z hz \u21a6 hz.continuousAt.continuousWithinAt\n  exact .of_union_range_cover (.subtype_coe h\u2082.measurableSet) (.subtype_coe h\u2081.measurableSet)\n    (by simp [- mem_compl_iff]) h\u2083.rest",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "have"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "intro"
        ]
      }
    },
    {
      "id": 3757,
      "before_code": "rw [norm_pow, norm_norm, one_mul, add_pow_two]\n    exact le_add_of_nonneg_left (by positivity)",
      "suggestion": "    rintro - \u27e8y, rfl\u27e9\n    simp only [Set.mem_setOf_eq, t]\n    exact lt_add_of_lt_add_left (c := 0) (by norm_num) (by positivity)\n  have hdiff : ContDiffOn \u211d \u221e (fun x \u21a6 x ^ r) t :=\n    contDiffOn_id.rpow_const_of_ne fun x hx \u21a6 (lt_trans (by norm_num) hx).ne'\n",
      "body": "```suggestion\n    rintro - \u27e8y, rfl\u27e9\n    simp only [Set.mem_setOf_eq, t]\n    exact lt_add_of_lt_add_left (c := 0) (by norm_num) (by positivity)\n  have hdiff : ContDiffOn \u211d \u221e (fun x \u21a6 x ^ r) t :=\n    contDiffOn_id.rpow_const_of_ne fun x hx \u21a6 (lt_trans (by norm_num) hx).ne'\n```",
      "path": "Mathlib/Analysis/Distribution/TemperateGrowth.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "suggestion_tactics": [
          "norm_num",
          "positivity",
          "exact",
          "have",
          "simp"
        ],
        "body_tactics": [
          "norm_num",
          "positivity",
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "norm_num",
          "simp",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "norm_pow",
          "positivity",
          "le_add_of_nonneg_left",
          "add_pow_two",
          "exact",
          "norm_norm",
          "one_mul"
        ]
      }
    },
    {
      "id": 3769,
      "before_code": "theorem isCompact_generateFrom' [T : TopologicalSpace X]\n    {S : Set (Set X)} (hTS : T = generateFrom S) {s : Set X}\n    (h : \u2200 (\u03b9 : Type u) (U : \u03b9 \u2192 S), s \u2286 \u22c3 i, U i \u2192 \u2203 J : Set \u03b9, J.Finite \u2227 s \u2286 \u22c3 i \u2208 J, U i) :\n    IsCompact s := by\n  apply isCompact_generateFrom hTS\n  intro P hP hs\n  rw [Set.sUnion_eq_iUnion] at hs\n  obtain \u27e8J, hJ, cover\u27e9 := h P (fun a \u21a6 \u27e8a.1, hP a.2\u27e9) hs\n  refine \u27e8(fun x \u21a6 x.1) '' J, \u27e8by simp, Set.Finite.image _ hJ, ?_\u27e9\u27e9\n  simpa only [Set.sUnion_eq_iUnion, Set.iUnion_coe_set, Set.mem_image, Subtype.exists,\n    exists_and_right, exists_eq_right, Set.iUnion_exists] using cover",
      "suggestion": "\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n",
      "body": "```suggestion\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "simpa",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "Subtype",
          "exists_eq_right",
          "Type",
          "obtain",
          "exists",
          "apply",
          "refine",
          "intro",
          "sUnion_eq_iUnion",
          "IsCompact",
          "hTS",
          "TopologicalSpace",
          "exists_and_right",
          "simp",
          "generateFrom",
          "only",
          "isCompact_generateFrom",
          "Finite",
          "cover",
          "mem_image",
          "theorem",
          "Set",
          "iUnion_coe_set",
          "simpa",
          "image",
          "iUnion_exists",
          "using"
        ]
      }
    },
    {
      "id": 3770,
      "before_code": "\u2203 x, ClusterPt x f := by\n  simpa using isCompact_univ (show f \u2264 \ud835\udcdf univ by simp)\n\nnonrec theorem Ultrafilter.le_nhds_lim [CompactSpace X] (F : Ultrafilter X) : \u2191F \u2264 \ud835\udcdd F.lim := by\n  rcases isCompact_univ.ultrafilter_le_nhds F (by simp) with \u27e8x, -, h\u27e9\n  exact le_nhds_lim \u27e8x, h\u27e9\n\ntheorem CompactSpace.elim_nhds_subcover [CompactSpace X] (U : X \u2192 Set X) (hU : \u2200 x, U x \u2208 \ud835\udcdd x) :\n    \u2203 t : Finset X, \u22c3 x \u2208 t, U x = \u22a4 := by\n  obtain \u27e8t, -, s\u27e9 := IsCompact.elim_nhds_subcover isCompact_univ U fun x _ => hU x\n  exact \u27e8t, top_unique s\u27e9",
      "suggestion": "\r\n  have \u27e8t, _, s\u27e9 := isCompact_univ.elim_nhds_subcover U fun x _ \u21a6 hU x\r\n",
      "body": "```suggestion\r\n  have \u27e8t, _, s\u27e9 := isCompact_univ.elim_nhds_subcover U fun x _ \u21a6 hU x\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "topics": [
          "order",
          "finset",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "show",
          "le_nhds_lim",
          "top_unique",
          "rcases",
          "obtain",
          "nonrec",
          "isCompact_univ",
          "Finset",
          "CompactSpace",
          "ClusterPt",
          "elim_nhds_subcover",
          "IsCompact",
          "univ",
          "ultrafilter_le_nhds",
          "simp",
          "lim",
          "theorem",
          "exact",
          "Set",
          "Ultrafilter",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 3772,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "/-- Let `\u03b1` be a non-zero algebraic integer. Then `\u03b1` has a conjugate `\u03c3 \u03b1` with `\u2016\u03c3 \u03b1\u2016 \u2265 1`. -/\nlemma exists_conjugate_one_le_norm {\u03b1 : \ud835\udcde K} (h\u03b10 : \u03b1 \u2260 0) :\n    \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016 := by\n  obtain \u27e8w, hw\u27e9 : \u2203 w : InfinitePlace K, 1 \u2264 w \u03b1 := by\n    by_contra! h_neg\n    let w\u2080 := Classical.arbitrary (InfinitePlace K)\n    have h_ge_one : 1 \u2264 w\u2080 \u03b1 := InfinitePlace.one_le_of_lt_one h\u03b10 (fun z _ \u21a6 h_neg z)\n    exact (h_neg w\u2080).not_ge h_ge_one\n  use w.embedding\n  rwa [InfinitePlace.norm_embedding_eq]\n",
      "body": "```suggestion\n/-- Let `\u03b1` be a non-zero algebraic integer. Then `\u03b1` has a conjugate `\u03c3 \u03b1` with `\u2016\u03c3 \u03b1\u2016 \u2265 1`. -/\nlemma exists_conjugate_one_le_norm {\u03b1 : \ud835\udcde K} (h\u03b10 : \u03b1 \u2260 0) :\n    \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016 := by\n  obtain \u27e8w, hw\u27e9 : \u2203 w : InfinitePlace K, 1 \u2264 w \u03b1 := by\n    by_contra! h_neg\n    let w\u2080 := Classical.arbitrary (InfinitePlace K)\n    have h_ge_one : 1 \u2264 w\u2080 \u03b1 := InfinitePlace.one_le_of_lt_one h\u03b10 (fun z _ \u21a6 h_neg z)\n    exact (h_neg w\u2080).not_ge h_ge_one\n  use w.embedding\n  rwa [InfinitePlace.n",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 3773,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n",
      "body": "```suggestion\nlemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "rw",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "rw",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 3774,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma norm_norm_le_norm_mul_house_pow (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) :\n    \u2016Algebra.norm \u211a \u03b1\u2016 \u2264 \u2016\u03c3 \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by\n  classical\n  set \u03c3' := \u03c3.toRatAlgHom\n  calc _ = \u2016\u220f \u03c4 : K \u2192\u2090[\u211a] \u2102, \u03c4 \u03b1\u2016 := ?_\n       _ = \u2016(\u03c3' \u03b1) * \u220f \u03c4 \u2208 univ.erase \u03c3', \u03c4 \u03b1\u2016 := by rw [mul_prod_erase univ (\u00b7 \u03b1) (mem_univ \u03c3')]\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', \u2016\u03c4 \u03b1\u2016 := ?_\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', house \u03b1 := by gcongr; apply norm_embedding_le_house\n       _ = \u2016\u03c3' \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by simp\n  \u00b7 rw [\u2190 Algebra.norm_eq_prod_embeddings, \u2190 Rat.norm_cast_real,\n      Real.norm_eq_abs, eq_ratCast, Complex.norm_ratCast]\n  \u00b7 rw [Complex.norm_mul]\n    gcongr\n    exact norm_prod_le (univ.erase \u03c3') (\u00b7 \u03b1)\n",
      "body": "```suggestion\nlemma norm_norm_le_norm_mul_house_pow (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) :\n    \u2016Algebra.norm \u211a \u03b1\u2016 \u2264 \u2016\u03c3 \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by\n  classical\n  set \u03c3' := \u03c3.toRatAlgHom\n  calc _ = \u2016\u220f \u03c4 : K \u2192\u2090[\u211a] \u2102, \u03c4 \u03b1\u2016 := ?_\n       _ = \u2016(\u03c3' \u03b1) * \u220f \u03c4 \u2208 univ.erase \u03c3', \u03c4 \u03b1\u2016 := by rw [mul_prod_erase univ (\u00b7 \u03b1) (mem_univ \u03c3')]\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', \u2016\u03c4 \u03b1\u2016 := ?_\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', house \u03b1 := by gcongr; apply norm_embedding_le_house\n       _ = \u2016\u03c3' \u03b1\u2016 * house \u03b1 ",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "gcongr",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 3775,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "    suffices B x y \u2264 0 by simpa [hc, \u2190 hB.le_zero_iff, B.toQuadraticMap_apply]\n    suffices 0 \u2264 \u2211 x \u2208 s with c x < 0, \u2211 i \u2208 s with 0 \u2264 c i, c x * (c i * (B (v i)) (v x)) by\n      simpa [hx, hy, map_neg, Finset.mul_sum]\n",
      "body": "```suggestion\n    suffices B x y \u2264 0 by simpa [hc, \u2190 hB.le_zero_iff, B.toQuadraticMap_apply]\n    suffices 0 \u2264 \u2211 x \u2208 s with c x < 0, \u2211 i \u2208 s with 0 \u2264 c i, c x * (c i * (B (v i)) (v x)) by\n      simpa [hx, hy, map_neg, Finset.mul_sum]\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 3776,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "  rw [\u2190 s.sum_filter_add_sum_filter_not (p := fun i \u21a6 0 \u2264 c i), add_eq_zero_iff_eq_neg] at hc\n  set x := \u2211 i \u2208 s with 0 \u2264 c i, c i \u2022 v i with hx\n  set y := \u2211 i \u2208 s with c i < 0, (-c i) \u2022 v i with hy\n  replace hc : x = y := by simpa [hy] using hc\n",
      "body": "Extreme nitpicking\n```suggestion\n  rw [\u2190 s.sum_filter_add_sum_filter_not (p := fun i \u21a6 0 \u2264 c i), add_eq_zero_iff_eq_neg] at hc\n  set x := \u2211 i \u2208 s with 0 \u2264 c i, c i \u2022 v i with hx\n  set y := \u2211 i \u2208 s with c i < 0, (-c i) \u2022 v i with hy\n  replace hc : x = y := by simpa [hy] using hc\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 3777,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "  apply_fun f at hx hy\n  replace hx : \u2211 i \u2208 s with 0 \u2264 c i, c i * f (v i) = 0 := by simpa [hx\u2080] using hx.symm\n  replace hy : \u2211 i \u2208 s with c i < 0, c i * f (v i) = 0 := by simpa [\u2190 hc, hx\u2080] using hy.symm\n  replace hx (i : \u03b9) (hi : i \u2208 s) : c i \u2264 0 := by\n    rw [Finset.sum_eq_zero_iff_of_nonneg (by grind [mul_nonneg])] at hx\n    by_contra! hi'\n    grind [mul_pos hi' (hp i)]\n  replace hy (i : \u03b9) (hi : i \u2208 s) : 0 \u2264 c i := by\n    rw [Finset.sum_eq_zero_iff_of_nonpos (by grind [mul_nonpos_of_nonpos_of_nonneg])] at hy\n    by_contra! hi'\n    grind [mul_neg_of_neg_of_pos hi' (hp i)]\n",
      "body": "```suggestion\n  apply_fun f at hx hy\n  replace hx : \u2211 i \u2208 s with 0 \u2264 c i, c i * f (v i) = 0 := by simpa [hx\u2080] using hx.symm\n  replace hy : \u2211 i \u2208 s with c i < 0, c i * f (v i) = 0 := by simpa [\u2190 hc, hx\u2080] using hy.symm\n  replace hx (i : \u03b9) (hi : i \u2208 s) : c i \u2264 0 := by\n    rw [Finset.sum_eq_zero_iff_of_nonneg (by grind [mul_nonneg])] at hx\n    by_contra! hi'\n    grind [mul_pos hi' (hp i)]\n  replace hy (i : \u03b9) (hi : i \u2208 s) : 0 \u2264 c i := by\n    rw [Finset.sum_eq_zero_iff_of_nonpos (by grind [mul_nonpo",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 3778,
      "before_code": "variable {G}",
      "suggestion": "\r\n    have : f.NeBot := hf.1\r\n    obtain \u27e8K, K_compact, K_mem\u27e9 := WeaklyLocallyCompactSpace.exists_compact_mem_nhds (1 : G)\r\n    obtain \u27e8x, hx\u27e9 : \u2203 x, \u2200\u1da0 y in f, y / x \u2208 K := by\r\n      rw [cauchy_iff_le, uniformity_eq_comap_nhds_one', \u2190 tendsto_iff_comap] at hf\r\n      exact hf.eventually_mem K_mem |>.curry.exists\r\n    simp_rw [div_eq_mul_inv, \u2190 op_smul_eq_mul, op_inv, \u2190 mem_smul_set_iff_inv_smul_mem] at hx\r\n    have Kx_complete : IsComplete (K <\u2022 x) := K_compact.smul _ |>.isComplete\r\n    obtain \u27e8l, -, hl\u27e9 := Kx_complete f hf (by simpa using hx)\r\n    exact \u27e8l, hl\u27e9\r\n ",
      "body": "Thanks a lot for starting on this! This proof can be cleaned a bit using our filter library, which prevents having to manipulate sets explicitly. I would suggest the following (which needs an `open MulOpposite`) for example:\r\n```suggestion\r\n    have : f.NeBot := hf.1\r\n    obtain \u27e8K, K_compact, K_mem\u27e9 := WeaklyLocallyCompactSpace.exists_compact_mem_nhds (1 : G)\r\n    obtain \u27e8x, hx\u27e9 : \u2203 x, \u2200\u1da0 y in f, y / x \u2208 K := by\r\n      rw [cauchy_iff_le, uniformity_eq_comap_nhds_one', \u2190 tendsto_iff_comap] at hf",
      "path": "Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "rw",
          "exact",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "line_break"
        ],
        "keywords": [
          "variable"
        ]
      }
    },
    {
      "id": 3780,
      "before_code": "end MeasureTheory.Measure",
      "suggestion": "/-- Define a tempered distribution from a L^p function. -/\ndef toTemperedDistribution {p : \u211d\u22650\u221e}\n    [hp : Fact (1 \u2264 p)] (f : Lp F p \u03bc) : \ud835\udce2'(E, F) :=\n  haveI := ENNReal.HolderConjugate.inv_one_sub_inv' hp.out\n  haveI : Fact (1 \u2264 (1 - p\u207b\u00b9)\u207b\u00b9) := by simp [fact_iff]\n  toPointwiseConvergenceCLM _ _ _ _ <|\n    (lsmul \u2102 \u2102).flip.lpPairing \u03bc p (1 - p\u207b\u00b9)\u207b\u00b9 f \u2218L toLpCLM \u2102 \u2102 (1 - p\u207b\u00b9)\u207b\u00b9 \u03bc\n",
      "body": "I suggest instead:\n```suggestion\n/-- Define a tempered distribution from a L^p function. -/\ndef toTemperedDistribution {p : \u211d\u22650\u221e}\n    [hp : Fact (1 \u2264 p)] (f : Lp F p \u03bc) : \ud835\udce2'(E, F) :=\n  haveI := ENNReal.HolderConjugate.inv_one_sub_inv' hp.out\n  haveI : Fact (1 \u2264 (1 - p\u207b\u00b9)\u207b\u00b9) := by simp [fact_iff]\n  toPointwiseConvergenceCLM _ _ _ _ <|\n    (lsmul \u2102 \u2102).flip.lpPairing \u03bc p (1 - p\u207b\u00b9)\u207b\u00b9 f \u2218L toLpCLM \u2102 \u2102 (1 - p\u207b\u00b9)\u207b\u00b9 \u03bc\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "MeasureTheory",
          "Measure"
        ]
      }
    },
    {
      "id": 3781,
      "before_code": "}",
      "suggestion": "\r\n      -- Create `id t` application - this ensures grind sees it as a term, not an e-match candidate\r\n      mkNode ``Lean.Parser.Term.app #[mkIdent `id, mkNullNode #[t]]\r\n    else t\r\n",
      "body": "```suggestion\r\n      -- Create `id t` application - this ensures grind sees it as a term, not an e-match candidate\r\n      mkNode ``Lean.Parser.Term.app #[mkIdent `id, mkNullNode #[t]]\r\n    else t\r\n```\r\njust an indentation fix.",
      "path": "Mathlib/Tactic/TacticAnalysis/Declarations.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 3826,
      "before_code": "have a_mem := hp.mem_support a\n    have b_mem := hp.mem_support b\n    exact ((p.takeUntil a a_mem).reverse.append <| p.takeUntil b b_mem).reachable\n  nonempty := not_isEmpty_iff.1 fun _ \u21a6 by simpa using hG <| by simp [@Fintype.card_eq_zero]\n\nlemma IsHamiltonian.of_card_eq_one (h : Fintype.card \u03b1 = 1) : G.IsHamiltonian :=\n  (\u00b7 h |>.elim)",
      "suggestion": "  grind [hp.three_le_length, hp.length_eq]\n",
      "body": "```suggestion\n  grind [hp.three_le_length, hp.length_eq]\n```\nimo this makes it clearer what the proof is doing (rather than `trans_eq`) since it says \"it's obvious from these two facts\"",
      "path": "Mathlib/Combinatorics/SimpleGraph/Hamiltonian.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "have",
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "simp",
          "exact",
          "have"
        ],
        "topics": [
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lemma",
          "b_mem",
          "mem_support",
          "nonempty",
          "takeUntil",
          "have",
          "card_eq_zero",
          "reachable",
          "elim",
          "reverse",
          "a_mem",
          "simp",
          "IsHamiltonian",
          "card",
          "exact",
          "append",
          "of_card_eq_one",
          "simpa",
          "Fintype",
          "not_isEmpty_iff",
          "using"
        ]
      }
    },
    {
      "id": 3839,
      "before_code": "g.ker.comap f = (g.comp f).ker :=\n  rfl",
      "suggestion": "  rw [\u2190 comap_ker, comap_equiv_eq_map_symm]\n",
      "body": "```suggestion\n  rw [\u2190 comap_ker, comap_equiv_eq_map_symm]\n```",
      "path": "Mathlib/Algebra/Group/Subgroup/Ker.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "comap",
          "ker"
        ]
      }
    },
    {
      "id": 3854,
      "before_code": "theorem mem_coe_iff {s : Nat.Combination \u03b1 n} {a : \u03b1} : a \u2208 (s : Finset \u03b1) \u2194 a \u2208 s := .rfl",
      "suggestion": "\r\n  rw [\u2190 coe_coe, Finset.nontrivial_coe, \u2190 one_lt_card_iff_nontrivial, card_eq]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 coe_coe, Finset.nontrivial_coe, \u2190 one_lt_card_iff_nontrivial, card_eq]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "set_theory",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Nat",
          "Finset",
          "Combination",
          "rfl",
          "mem_coe_iff"
        ]
      }
    },
    {
      "id": 3857,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n      grind\r\n",
      "body": "```suggestion\r\n      grind\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 3924,
      "before_code": "refine Continuous.if_le ?_ ?_ (continuous_subtype_val.comp continuous_snd) continuous_const ?_\n  \u00b7 change\n      Continuous ((fun p : \u03b9 \u00d7 \u211d => (\u03b3\u2081 p.1).extend p.2) \u2218 Prod.map id (fun x => 2 * x : I \u2192 \u211d))\n    exact h\u2081'.comp (continuous_id.prodMap <| continuous_const.mul continuous_subtype_val)",
      "suggestion": "\r\n    fun_prop\r\n",
      "body": "What's wrong with\r\n```suggestion\r\n    fun_prop\r\n```\r\n?",
      "path": "Mathlib/Topology/Path.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "refine"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "exact",
          "refine"
        ],
        "topics": [
          "continuity",
          "real",
          "list"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "continuous_snd",
          "prodMap",
          "refine",
          "continuous_subtype_val",
          "Prod",
          "extend",
          "continuous_id",
          "exact",
          "change",
          "continuous_const",
          "map",
          "if_le",
          "comp",
          "Continuous",
          "mul"
        ]
      }
    },
    {
      "id": 3933,
      "before_code": "obtain \u27e8y, rfl, hcodisjoint\u27e9 := exists_inf_eq_and_codisjoint hx\n    exact \u27e8\u27e8y, inf_le_right\u27e9, rfl, hcodisjoint\u27e9",
      "suggestion": "\r\n  rw [\u2190 disjoint_toDual_iff] at hab\r\n",
      "body": "```suggestion\r\n  rw [\u2190 disjoint_toDual_iff] at hab\r\n```",
      "path": "Mathlib/Order/ModularLattice.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hcodisjoint",
          "exact",
          "inf_le_right",
          "exists_inf_eq_and_codisjoint",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 3978,
      "before_code": "def Weird (n : \u2115) : Prop := Abundant n \u2227 \u00ac Pseudoperfect n\n\ntheorem not_pseudoperfect_iff_forall :\n    \u00ac Pseudoperfect n \u2194 n = 0 \u2228 \u2200 s \u2286 properDivisors n, \u2211 i \u2208 s, i \u2260 n := by\n  rw [Pseudoperfect, not_and_or]\n  simp only [not_lt, nonpos_iff_eq_zero, not_exists, not_and, ne_eq]",
      "suggestion": "\r\n    \u00ac Pseudoperfect n \u2194 n = 0 \u2228 \u2200 s \u2286 properDivisors n, \u2211 i \u2208 s, i \u2260 n := by\r\n  grind [Pseudoperfect]\r\n",
      "body": "```suggestion\r\n    \u00ac Pseudoperfect n \u2194 n = 0 \u2228 \u2200 s \u2286 properDivisors n, \u2211 i \u2208 s, i \u2260 n := by\r\n  grind [Pseudoperfect]\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "not_lt",
          "not_pseudoperfect_iff_forall",
          "nonpos_iff_eq_zero",
          "Pseudoperfect",
          "not_and_or",
          "def",
          "theorem",
          "properDivisors",
          "Abundant",
          "Prop",
          "Weird",
          "not_exists",
          "ne_eq",
          "simp",
          "not_and",
          "only"
        ]
      }
    },
    {
      "id": 3990,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  refine aux_tendsto_tsum_cexp_pnat z |>.const_mul _ |>.const_sub _ |>.add (.const_mul _ ?_)\r\n",
      "body": "```suggestion\r\n  refine aux_tendsto_tsum_cexp_pnat z |>.const_mul _ |>.const_sub _ |>.add (.const_mul _ ?_)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3991,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    grind\r\n",
      "body": "```suggestion\r\n    grind\r\n```\r\n(could inline into prev line)",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3994,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n  \u00b7 rw [Subgroup.closure_le]\r\n",
      "body": "```suggestion\r\n  \u00b7 rw [Subgroup.closure_le]\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 3995,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n  \u00b7 rw [\u2190 Equiv.Perm.closure_three_cycles_eq_alternating, Subgroup.closure_le]\r\n",
      "body": "```suggestion\r\n  \u00b7 rw [\u2190 Equiv.Perm.closure_three_cycles_eq_alternating, Subgroup.closure_le]\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 4008,
      "before_code": "lemma stdSimplexHomeomorphUnitInterval_one :\n    stdSimplexHomeomorphUnitInterval \u27e8_, single_mem_stdSimplex _ 1\u27e9 = 1 := rfl",
      "suggestion": "\r\n  grind [Real.dist_eq]\r\n",
      "body": "```suggestion\r\n  grind [Real.dist_eq]\r\n```",
      "path": "Mathlib/Analysis/Convex/StdSimplex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lemma",
          "rfl",
          "single_mem_stdSimplex",
          "stdSimplexHomeomorphUnitInterval",
          "stdSimplexHomeomorphUnitInterval_one"
        ]
      }
    },
    {
      "id": 4044,
      "before_code": "simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b\u2081, h, \u2190 mul_assoc, mul_comm _ (f a)]",
      "suggestion": "  rw [\u2190 prod_filter_ne_one, \u2190 this, prod_biUnion]\n  swap\n  \u00b7 intro i hi j hj hij a hai haj k hk\n",
      "body": "I think I'd prefer\n```suggestion\n  rw [\u2190 prod_filter_ne_one, \u2190 this, prod_biUnion]\n  swap\n  \u00b7 intro i hi j hj hij a hai haj k hk\n```",
      "path": "Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "intro"
        ],
        "body_tactics": [
          "rw",
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mul_assoc",
          "not_true_eq_false",
          "false_and",
          "mem_erase",
          "ne_eq",
          "not_false_eq_true",
          "simp",
          "mul_comm",
          "only",
          "prod_insert"
        ]
      }
    },
    {
      "id": 4067,
      "before_code": "simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]",
      "suggestion": "    \u00ac IsPrimePow n \u2194 n.primeFactors.Nontrivial := by\n  rw [isPrimePow_iff_card_primeFactors_eq_one, \u2190 Finset.one_lt_card_iff_nontrivial]\n  grind [primeFactors_eq_empty]\n",
      "body": "```suggestion\n    \u00ac IsPrimePow n \u2194 n.primeFactors.Nontrivial := by\n  rw [isPrimePow_iff_card_primeFactors_eq_one, \u2190 Finset.one_lt_card_iff_nontrivial]\n  grind [primeFactors_eq_empty]\n```",
      "path": "Mathlib/Data/Nat/Factorization/PrimePow.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "rw"
        ],
        "body_tactics": [
          "grind",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Finsupp",
          "support_factorization",
          "Nat",
          "pos_iff_ne_zero",
          "card_support_eq_one",
          "simp_rw",
          "isPrimePow_iff_factorization_eq_single"
        ]
      }
    },
    {
      "id": 4071,
      "before_code": "instance [Nontrivial M] : Nontrivial P.invtRootSubmodule where\n  exists_pair_ne := \u27e8\u22a5, \u22a4, by rw [ne_eq, Subtype.ext_iff]; exact bot_ne_top\u27e9",
      "suggestion": "",
      "body": "Not needed here:\n```suggestion\n```",
      "path": "Mathlib/LinearAlgebra/RootSystem/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "Subtype",
          "ext_iff",
          "Nontrivial",
          "exact",
          "invtRootSubmodule",
          "ne_eq",
          "exists_pair_ne",
          "instance",
          "bot_ne_top"
        ]
      }
    },
    {
      "id": 4074,
      "before_code": "theorem lid_symm_apply (m : M) : (TensorProduct.lid R M).symm m = 1 \u2297\u209c m :=\n  rfl",
      "suggestion": "\r\n    (1 : S) \u2297\u209c[R] (TensorProduct.lid R M) m =\r\n      (LinearMap.rTensor M (Algebra.algHom R R S).toLinearMap) m := by\r\n",
      "body": "The line break should be after the infix operator:\r\n```suggestion\r\n    (1 : S) \u2297\u209c[R] (TensorProduct.lid R M) m =\r\n      (LinearMap.rTensor M (Algebra.algHom R R S).toLinearMap) m := by\r\n```",
      "path": "Mathlib/LinearAlgebra/TensorProduct/Associator.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "symm",
          "theorem",
          "lid_symm_apply",
          "TensorProduct",
          "lid",
          "rfl"
        ]
      }
    },
    {
      "id": 4102,
      "before_code": "theorem X_ne_zero : (X : RatFunc K) \u2260 0 :=\n  RatFunc.algebraMap_ne_zero Polynomial.X_ne_zero",
      "suggestion": "  rw [\u2190 num_div_denom f, \u2190 ha, \u2190 hb, algebraMap_C, algebraMap_C, map_div\u2080]\n",
      "body": "```suggestion\n  rw [\u2190 num_div_denom f, \u2190 ha, \u2190 hb, algebraMap_C, algebraMap_C, map_div\u2080]\n```",
      "path": "Mathlib/FieldTheory/RatFunc/AsPolynomial.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "algebraMap_ne_zero",
          "RatFunc",
          "X_ne_zero",
          "Polynomial"
        ]
      }
    },
    {
      "id": 4107,
      "before_code": "defined as `{0}` and `\u2293` defined as intersection of the underlying carrier.\nIf `p` and `q` are submodules of a module, `p \u2264 q` means that `p \u2286 q`.\n\nMany results about operations on this lattice structure are defined in `LinearAlgebra/Basic.lean`,\nmost notably those which use `span`.",
      "suggestion": "",
      "body": "I don't think this comment is really helping anyone and is in danger of breaking again, let's just excise it.\n```suggestion\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Lattice.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "those",
          "results",
          "which",
          "lean",
          "intersection",
          "lattice",
          "operations",
          "most",
          "submodules",
          "Basic",
          "structure",
          "are",
          "notably",
          "LinearAlgebra",
          "underlying",
          "module",
          "span",
          "that",
          "defined",
          "use",
          "about",
          "this",
          "means",
          "carrier",
          "Many"
        ]
      }
    },
    {
      "id": 4109,
      "before_code": "/-- A line contains a space before a semicolon -/\n  | semicolon\n  /-- A line contains a non-breaking space character -/\n  | nonbreakingSpace",
      "suggestion": "\r\n  | nonbreakingSpace\r\n",
      "body": "```suggestion\r\n  | nonbreakingSpace\r\n```",
      "path": "Mathlib/Tactic/Linter/TextBased.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "breaking",
          "space",
          "contains",
          "character",
          "semicolon",
          "non",
          "nonbreakingSpace",
          "line",
          "before"
        ]
      }
    },
    {
      "id": 4118,
      "before_code": "\u00b7 rw [Finset.sum_comp_equiv]\n    simp",
      "suggestion": "\r\n  ext i : 1\r\n",
      "body": "fwiw, this can also be spelt as\r\n```suggestion\r\n  ext i : 1\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Incenter.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "sum_comp_equiv",
          "Finset",
          "simp"
        ]
      }
    },
    {
      "id": 4145,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  rw [cyclotomic_eq_minpoly h_prim h_m_pos]\n",
      "body": "```suggestion\n  rw [cyclotomic_eq_minpoly h_prim h_m_pos]\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 4149,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  \u00b7 grind\r\n",
      "body": "```suggestion\r\n  \u00b7 grind\r\n```\r\nOr just merge it into the refine.",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "refine"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 4161,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "",
      "body": "```suggestion\n```\nNot needed",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 4165,
      "before_code": "apply HomologicalComplex.isZero_single_obj_X\n      simp",
      "suggestion": "\r\nvariable {I I'}\r\n\r\n",
      "body": "```suggestion\r\nvariable {I I'}\r\n\r\n```\r\nI guess there should be a line break if it\u2019s not a `variable \u2026 in`.",
      "path": "Mathlib/CategoryTheory/Preadditive/Injective/Resolution.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "apply",
          "HomologicalComplex",
          "simp",
          "isZero_single_obj_X"
        ]
      }
    },
    {
      "id": 4229,
      "before_code": "theorem measure_smul (c : G) (s : Set \u03b1) : \u03bc (c \u2022 s) = \u03bc s := by\n  simpa only [preimage_smul_inv] using measure_preimage_smul \u03bc c\u207b\u00b9 s",
      "suggestion": "\r\n  rw [\u2190 measure_smul _ c (s \u2229 c\u207b\u00b9 \u2022 t), smul_set_inter, smul_smul, mul_inv_cancel, one_smul]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 measure_smul _ c (s \u2229 c\u207b\u00b9 \u2022 t), smul_set_inter, smul_smul, mul_inv_cancel, one_smul]\r\n```\r\nSame below",
      "path": "Mathlib/MeasureTheory/Group/Action.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "measure_preimage_smul",
          "measure_smul",
          "theorem",
          "Set",
          "preimage_smul_inv",
          "simpa",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 4238,
      "before_code": "section",
      "suggestion": "\r\n  congr($(hfg.iteratedFDerivWithin_eq hfg' n) _)\r\n",
      "body": "```suggestion\r\n  congr($(hfg.iteratedFDerivWithin_eq hfg' n) _)\r\n```\r\nseems to work",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr"
        ],
        "body_tactics": [
          "congr"
        ],
        "new_tactics": [
          "congr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "section"
        ]
      }
    },
    {
      "id": 4255,
      "before_code": "that of a functor `T : X \u2964 A`, a functor `L : X \u2964 C`, and a `CatCommSqOver T L F G`.\nNote that this is *exactly* what an object of\n`((whiskeringRight X A B).obj F) \u22a1 ((whiskeringRight X C B).obj G)` is,\nso `CatCommSqOver F G X` is in fact an abbreviation for\n`((whiskeringRight X A B).obj F) \u22a1 ((whiskeringRight X C B).obj G)`. -/\nabbrev CatCommSqOver :=\n  (whiskeringRight X A B |>.obj F) \u22a1 (whiskeringRight X C B |>.obj G)\n\nnamespace CatCommSqOver",
      "suggestion": "    (h\u2081 : f.fst = g.fst) (h\u2082 : f.snd = g.snd) : f = g :=\n  Hom.ext h\u2081 h\u2082\n",
      "body": "```suggestion\n    (h\u2081 : f.fst = g.fst) (h\u2082 : f.snd = g.snd) : f = g :=\n  Hom.ext h\u2081 h\u2082\n```",
      "path": "Mathlib/CategoryTheory/Limits/Shapes/Pullback/Categorical/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "object",
          "whiskeringRight",
          "abbrev",
          "functor",
          "exactly",
          "what",
          "Note",
          "this",
          "that",
          "CatCommSqOver",
          "abbreviation",
          "obj",
          "fact",
          "for",
          "namespace"
        ]
      }
    },
    {
      "id": 4267,
      "before_code": "\u2200\u1d50 (x : \u211d), x \u2208 uIcc a b \u2192 DifferentiableAt \u211d f x :=\n  hf.boundedVariationOn.ae_differentiableAt_of_mem_uIcc",
      "suggestion": "",
      "body": "```suggestion\n```\nNot needed since you've given the type.",
      "path": "Mathlib/MeasureTheory/Function/AbsolutelyContinuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "set_theory",
          "differentiability"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "uIcc",
          "ae_differentiableAt_of_mem_uIcc",
          "boundedVariationOn",
          "DifferentiableAt"
        ]
      }
    },
    {
      "id": 4270,
      "before_code": "Tendsto (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm (f \u00d7\u02e2 (g \u00d7\u02e2 h)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) :=\n  (prod_assoc_symm f g h).le",
      "suggestion": "  rw [eventually_assoc_iff]\n",
      "body": "```suggestion\n  rw [eventually_assoc_iff]\n```",
      "path": "Mathlib/Order/Filter/Prod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "prod_assoc_symm",
          "prodAssoc",
          "Tendsto",
          "Equiv"
        ]
      }
    },
    {
      "id": 4329,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n  grind [L.weierstrassPExcept_add \u27e8_, hl\u2080\u27e9]\r\n",
      "body": "And here:\r\n```suggestion\r\n  grind [L.weierstrassPExcept_add \u27e8_, hl\u2080\u27e9]\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 4330,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n  grind [weierstrassPSummand, weierstrassPExceptSummand]\r\n",
      "body": "```suggestion\r\n  grind [weierstrassPSummand, weierstrassPExceptSummand]\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 4363,
      "before_code": "theorem castSucc_ne_zero_of_lt {p i : Fin n} (h : p < i) : castSucc i \u2260 0 := by\n  cases n\n  \u00b7 exact i.elim0\n  \u00b7 rw [castSucc_ne_zero_iff, Ne, Fin.ext_iff]\n    exact ((zero_le _).trans_lt h).ne'",
      "suggestion": "  \u00b7 grind [castSucc_ne_zero_iff]\n",
      "body": "```suggestion\n  \u00b7 grind [castSucc_ne_zero_iff]\n```\nDoes this work?",
      "path": "Mathlib/Data/Fin/SuccPred.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "rw"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "trans_lt",
          "theorem",
          "castSucc_ne_zero_of_lt",
          "ext_iff",
          "zero_le",
          "cases",
          "exact",
          "castSucc_ne_zero_iff",
          "Fin",
          "elim0",
          "castSucc"
        ]
      }
    },
    {
      "id": 4417,
      "before_code": "have : NeZero n := \u27e8hn\u27e9\n  exact nthRoots_one_eq_biUnion_primitiveRoots'",
      "suggestion": "\r\n    rw [hgcd, zpow_sub, zpow_mul]\r\n",
      "body": "```suggestion\r\n    rw [hgcd, zpow_sub, zpow_mul]\r\n```",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "have"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "NeZero",
          "have",
          "nthRoots_one_eq_biUnion_primitiveRoots"
        ]
      }
    },
    {
      "id": 4418,
      "before_code": "have : NeZero n := \u27e8hn\u27e9\n  exact nthRoots_one_eq_biUnion_primitiveRoots'",
      "suggestion": "\r\n    \u00b7 rw [\u2190 Nat.isCoprime_iff_coprime, Int.isCoprime_iff_gcd_eq_one, Int.gcd_natCast_natCast] at h\r\n",
      "body": "```suggestion\r\n    \u00b7 rw [\u2190 Nat.isCoprime_iff_coprime, Int.isCoprime_iff_gcd_eq_one, Int.gcd_natCast_natCast] at h\r\n```",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "have"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "NeZero",
          "have",
          "nthRoots_one_eq_biUnion_primitiveRoots"
        ]
      }
    },
    {
      "id": 4429,
      "before_code": "(x y : R\u27e6\u0393\u27e7) : (x * y).cardSupp \u2264 x.cardSupp * y.cardSupp :=\n  (mk_le_mk_of_subset (support_mul_subset ..)).trans mk_add_le",
      "suggestion": "  grw [\u2190 lift_uzero (cardSupp _), \u2190 sum_pow_le_max_aleph0, cardSupp_hsum_le, sum_le_sum]\n  intro i\n",
      "body": "An alternative way to write this, if you like it\n\n```suggestion\n  grw [\u2190 lift_uzero (cardSupp _), \u2190 sum_pow_le_max_aleph0, cardSupp_hsum_le, sum_le_sum]\n  intro i\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Cardinal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "intro"
        ],
        "body_tactics": [
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support_mul_subset",
          "mk_le_mk_of_subset",
          "trans",
          "cardSupp",
          "mk_add_le"
        ]
      }
    },
    {
      "id": 4461,
      "before_code": "rw [ShortComplex.ab_exact_iff] at this\n  exact this x\u2083 hx\u2083",
      "suggestion": "    Mono (AddCommGrpCat.ofHom <| (Ext.mk\u2080 f).postcomp L (add_zero 0)) :=\n",
      "body": "```suggestion\n    Mono (AddCommGrpCat.ofHom <| (Ext.mk\u2080 f).postcomp L (add_zero 0)) :=\n```",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ShortComplex",
          "exact",
          "this",
          "ab_exact_iff"
        ]
      }
    },
    {
      "id": 4462,
      "before_code": "rw [ShortComplex.ab_exact_iff] at this\n  exact this x\u2083 hx\u2083",
      "suggestion": "    Mono (AddCommGrpCat.ofHom <| (Ext.mk\u2080 g).precomp L (zero_add 0)) :=\n",
      "body": "```suggestion\n    Mono (AddCommGrpCat.ofHom <| (Ext.mk\u2080 g).precomp L (zero_add 0)) :=\n```",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ShortComplex",
          "exact",
          "this",
          "ab_exact_iff"
        ]
      }
    },
    {
      "id": 4463,
      "before_code": "\u00b7 simp only [isLittleO_const_left, Int.cast_eq_zero,\n      tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real, or_true]\n\nlemma linear_inv_isBigO_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_right c z).inv.isBigO\n\nlemma linear_inv_isBigO_left (d : \u2124) {z : \u2102} (hz : z \u2260 0) :\n    (fun (c : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_left d hz).inv.isBigO",
      "suggestion": "\r\n  grind [neg_zero, (tendsto_zero_inv_linear z (-b)).neg]\r\n",
      "body": "```suggestion\r\n  grind [neg_zero, (tendsto_zero_inv_linear z (-b)).neg]\r\n```\r\n(\"grind\" seems to be good when there are several distinct kinds of automation that need to be used together)",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isBigO",
          "cast_eq_zero",
          "lemma",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "linear_isTheta_right",
          "Int",
          "linear_inv_isBigO_left",
          "or_true",
          "inv",
          "linear_isTheta_left",
          "simp",
          "cofinite",
          "isClosedEmbedding_coe_real",
          "isLittleO_const_left",
          "only",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 4546,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "    grind\n",
      "body": "```suggestion\n    grind\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 4561,
      "before_code": "grw [\u2190 H2]\n  ring_nf; rfl",
      "suggestion": "\r\n  \u00b7 grind [Real.sin_zero, zero_smul, eq_of_norm_eq_of_angle_eq_zero]\r\n",
      "body": "```suggestion\r\n  \u00b7 grind [Real.sin_zero, zero_smul, eq_of_norm_eq_of_angle_eq_zero]\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "ring_nf"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "ring_nf"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rfl",
          "grw",
          "ring_nf"
        ]
      }
    },
    {
      "id": 4566,
      "before_code": "iff_of_false ((Sentence.realize_not M).1 (h\u03c6n.realize_sentence M))\n        ((h.models_not_iff \u03c6).1 h\u03c6n)",
      "suggestion": "\r\n  rw [ElementarilyEquivalent, \u2190 h.eq_complete_theory, \u2190 h.eq_complete_theory]\r\n",
      "body": "```suggestion\r\n  rw [ElementarilyEquivalent, \u2190 h.eq_complete_theory, \u2190 h.eq_complete_theory]\r\n```\r\nThis finishes the proof. You can also use this result to prove one direction of `isComplete_iff_models_elementarily_equivalent`.",
      "path": "Mathlib/ModelTheory/Satisfiability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "realize_not",
          "iff_of_false",
          "realize_sentence",
          "models_not_iff",
          "Sentence"
        ]
      }
    },
    {
      "id": 4603,
      "before_code": "theorem degree_add (a b : \u03c3 \u2192\u2080 R) : (a + b).degree = a.degree + b.degree :=\n  sum_add_index' (h := fun _ \u21a6 id) (congrFun rfl) fun _ _ \u21a6 congrFun rfl",
      "suggestion": "  intro a s hs hs'\n  rw [Finset.sum_insert hs, Finset.sum_insert hs, degree_add, hs']\n",
      "body": "```suggestion\n  intro a s hs hs'\n  rw [Finset.sum_insert hs, Finset.sum_insert hs, degree_add, hs']\n```",
      "path": "Mathlib/Data/Finsupp/Weight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "intro"
        ],
        "body_tactics": [
          "rw",
          "intro"
        ],
        "new_tactics": [
          "rw",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "degree_add",
          "theorem",
          "sum_add_index",
          "congrFun",
          "rfl",
          "degree"
        ]
      }
    },
    {
      "id": 4654,
      "before_code": "| single h => exact TransGen.single h\n  | tail _ hbc ih => exact ih.head hbc",
      "suggestion": "\r\n@[grind =]\r\n",
      "body": "This one is surprising to me, it'll fire any time it sees `TransGen r a b`, which I think is too general. I think this is much more reasonable:\r\n```suggestion\r\n@[grind =]\r\n```",
      "path": "Mathlib/Logic/Relation.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "exact",
          "head",
          "TransGen",
          "single",
          "tail",
          "hbc"
        ]
      }
    },
    {
      "id": 4660,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "    \u00b7 specialize hn hij.symm\n      grind [mul_nonneg_iff, mul_nonpos_iff]\n",
      "body": "```suggestion\n    \u00b7 specialize hn hij.symm\n      grind [mul_nonneg_iff, mul_nonpos_iff]\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 4661,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "    rw [\u2190 hc, hx\u2080] at hy\n",
      "body": "```suggestion\n    rw [\u2190 hc, hx\u2080] at hy\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    }
  ],
  "by_pattern": {
    "simp_to_simpa": [
      {
        "id": 434,
        "before_code": "/-! ### Cliques -/\n\n\ntheorem IsClique.card_le_of_coloring {s : Finset V} (h : G.IsClique s) [Fintype \u03b1]\n    (C : G.Coloring \u03b1) : s.card \u2264 Fintype.card \u03b1 := by\n  rw [isClique_iff_induce_eq] at h\n  have f : G.induce \u2191s \u21aag G := Embedding.comap (Function.Embedding.subtype fun x => x \u2208 \u2191s) G\n  rw [h] at f\n  convert Fintype.card_le_of_injective _ (C.comp f.toHom).injective_of_top_hom using 1\n  simp\n\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) {n : \u2115}\n    (hc : G.Colorable n) : s.card \u2264 n := by\n  convert h.card_le_of_coloring hc.some\n  simp\n\ntheorem IsClique.card_le_chromaticNumber {s : Finset V} (h : G.IsClique s) :\n    s.card \u2264 G.chromaticNumber := by\n  obtain (hc | hc) := eq_or_ne G.chromaticNumber \u22a4\n  \u00b7 rw [hc]\n    exact le_top\n  \u00b7 have hc' := hc\n    rw [chromaticNumber_ne_top_iff_exists] at hc'\n    obtain \u27e8n, c\u27e9 := hc'\n    rw [\u2190 ENat.coe_toNat_eq_self] at hc\n    rw [\u2190 hc, Nat.cast_le]\n    exact h.card_le_of_colorable (colorable_chromaticNumber c)",
        "suggestion": "\r\n    s.card \u2264 G.chromaticNumber := by\r\n  simpa using card_le_chromaticNumber_of_pairwise_adj _ <|\r\n    s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n",
        "body": "```suggestion\r\n    s.card \u2264 G.chromaticNumber := by\r\n  simpa using card_le_chromaticNumber_of_pairwise_adj _ <|\r\n    s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n```",
        "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "have",
            "obtain",
            "rw",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "have",
            "obtain",
            "rw",
            "simp"
          ],
          "topics": [
            "nat",
            "order",
            "function",
            "finset"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "convert",
            "Cliques",
            "chromaticNumber_ne_top_iff_exists",
            "cast_le",
            "chromaticNumber",
            "obtain",
            "Function",
            "Colorable",
            "toHom",
            "injective_of_top_hom",
            "using",
            "Nat",
            "Finset",
            "Coloring",
            "card_le_of_colorable",
            "have",
            "le_top",
            "card_le_of_coloring",
            "subtype",
            "card_le_chromaticNumber",
            "Embedding",
            "IsClique",
            "ENat",
            "comap",
            "comp",
            "colorable_chromaticNumber",
            "simp",
            "induce",
            "card_le_of_injective",
            "card",
            "theorem",
            "exact",
            "isClique_iff_induce_eq",
            "Fintype",
            "eq_or_ne",
            "coe_toNat_eq_self",
            "some"
          ]
        }
      },
      {
        "id": 643,
        "before_code": "theorem inf_orthogonal_eq_bot : K \u2293 K\u15ee = \u22a5 := by\n  rw [eq_bot_iff]\n  intro x\n  simp only [toSubmodule_inf, orthogonal_toSubmodule_eq, Submodule.mem_inf, toSubmodule_bot,\n    Submodule.mem_bot, and_imp]\n  exact fun hx ho => inner_self_eq_zero.1 (ho x hx)",
        "suggestion": "\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n",
        "body": "```suggestion\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n```\r\nDoes this work?",
        "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "rw",
            "simp",
            "intro"
          ],
          "topics": [
            "set_theory",
            "order",
            "algebra"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "only",
            "theorem",
            "toSubmodule_inf",
            "exact",
            "eq_bot_iff",
            "mem_inf",
            "toSubmodule_bot",
            "mem_bot",
            "Submodule",
            "and_imp",
            "simp",
            "intro",
            "orthogonal_toSubmodule_eq",
            "inner_self_eq_zero",
            "inf_orthogonal_eq_bot"
          ]
        }
      },
      {
        "id": 698,
        "before_code": "ext\n  simp +contextual [imp_false]",
        "suggestion": "\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n",
        "body": "I know you're not a fan but `diagSet` seems to fit the hypothesis pretty well:\r\n```suggestion\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n```\r\nThe current proof (just without the underscore) will also work after your #32679 is merged",
        "path": "Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean",
        "tags": {
          "before_tactics": [
            "simp",
            "ext"
          ],
          "suggestion_tactics": [
            "simpa",
            "simp",
            "ext"
          ],
          "body_tactics": [
            "simpa",
            "simp",
            "ext"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "contextual",
            "imp_false",
            "simp",
            "ext"
          ]
        }
      },
      {
        "id": 830,
        "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
        "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
        "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
        "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "add",
            "aesop",
            "upperBounds",
            "Succ",
            "exact",
            "suffices",
            "simp",
            "rec",
            "from"
          ]
        }
      },
      {
        "id": 831,
        "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
        "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
        "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
        "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "add",
            "aesop",
            "upperBounds",
            "Succ",
            "exact",
            "suffices",
            "simp",
            "rec",
            "from"
          ]
        }
      },
      {
        "id": 832,
        "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
        "suggestion": "  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
        "body": "```suggestion\n  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
        "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "add",
            "aesop",
            "upperBounds",
            "Succ",
            "exact",
            "suffices",
            "simp",
            "rec",
            "from"
          ]
        }
      },
      {
        "id": 833,
        "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
        "suggestion": "  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
        "body": "```suggestion\n  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
        "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "add",
            "aesop",
            "upperBounds",
            "Succ",
            "exact",
            "suffices",
            "simp",
            "rec",
            "from"
          ]
        }
      },
      {
        "id": 871,
        "before_code": "have h\u2082 := cos_pi_div_three;\n    have h\u2082 := cos_zero] <;>\n  simp [injOn_cos h_bnd \u27e8by positivity, by linarith [pi_nonneg]\u27e9 (h\u2082 \u25b8 h)]",
        "suggestion": "  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n",
        "body": "```suggestion\n  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n```",
        "path": "Mathlib/NumberTheory/Niven.lean",
        "tags": {
          "before_tactics": [
            "positivity",
            "have",
            "simp",
            "linarith"
          ],
          "suggestion_tactics": [
            "apply",
            "gcongr",
            "grind",
            "have",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "body_tactics": [
            "apply",
            "gcongr",
            "grind",
            "have",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "new_tactics": [
            "apply",
            "gcongr",
            "grind",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "removed_tactics": [
            "positivity",
            "simp",
            "linarith"
          ],
          "topics": [],
          "transforms": [
            "use_simpa",
            "use_grind"
          ],
          "keywords": [
            "injOn_cos",
            "cos_pi_div_three",
            "positivity",
            "pi_nonneg",
            "have",
            "h_bnd",
            "simp",
            "linarith",
            "cos_zero"
          ]
        }
      },
      {
        "id": 1065,
        "before_code": "@[simp] theorem logCounting_const_zero {e : WithTop E} :\n    logCounting (0 : \ud835\udd5c \u2192 E) e = 0 := logCounting_const",
        "suggestion": "\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n",
        "body": "```suggestion\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n```",
        "path": "Mathlib/Analysis/Complex/ValueDistribution/CountingFunction.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "simpa",
            "positivity"
          ],
          "body_tactics": [
            "simpa",
            "positivity"
          ],
          "new_tactics": [
            "simpa",
            "positivity"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "list"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "logCounting",
            "WithTop",
            "theorem",
            "logCounting_const_zero",
            "logCounting_const",
            "simp"
          ]
        }
      },
      {
        "id": 1224,
        "before_code": "finsum (fun d \u21a6 coeff d f \u2022 (constantCoeff (d.prod fun s e => (a s) ^ e))) := by\n  simp only [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_subst ha f 0]",
        "suggestion": "\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n",
        "body": "```suggestion\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n```",
        "path": "Mathlib/RingTheory/MvPowerSeries/Substitution.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "simpa",
            "simp"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [],
          "topics": [
            "list"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "coeff",
            "prod",
            "coeff_zero_eq_constantCoeff_apply",
            "coeff_subst",
            "simp",
            "finsum",
            "constantCoeff",
            "only"
          ]
        }
      },
      {
        "id": 1513,
        "before_code": "(rootSpaceProduct R L H \u03b1 (-\u03b1) 0 (add_neg_cancel \u03b1) (\u27e8y, hy\u27e9 \u2297\u209c[R] \u27e8z, hz\u27e9)).property using 0\n  simp [hyz]",
        "suggestion": "lemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n",
        "body": "```suggestion\nlemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n```",
        "path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "exact",
            "simpa",
            "rw",
            "simp",
            "intro"
          ],
          "body_tactics": [
            "exact",
            "simpa",
            "rw",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "exact",
            "simpa",
            "rw",
            "intro"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "rootSpaceProduct",
            "property",
            "simp",
            "add_neg_cancel",
            "using",
            "hyz"
          ]
        }
      },
      {
        "id": 1649,
        "before_code": "filter_upwards [Tendsto.eventually_const_lt (zero_lt_one) h\u03c6, hu\u03c6v] with x h\u03c6_pos huv'\n  simp [\u2190 Real.mul_rpow (le_of_lt h\u03c6_pos) (hv x), huv']",
        "suggestion": "\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <| Real.tendsto_log_atTop.comp g_tendsto\r\n",
        "body": "slightly cleaner\r\n```suggestion\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <",
        "path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "norm_num",
            "exact",
            "have",
            "simpa",
            "rw",
            "congr"
          ],
          "body_tactics": [
            "norm_num",
            "exact",
            "have",
            "simpa",
            "rw",
            "congr"
          ],
          "new_tactics": [
            "norm_num",
            "exact",
            "have",
            "simpa",
            "rw",
            "congr"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "list",
            "real",
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "eventually_const_lt",
            "zero_lt_one",
            "Real",
            "Tendsto",
            "filter_upwards",
            "mul_rpow",
            "simp",
            "huv"
          ]
        }
      },
      {
        "id": 1728,
        "before_code": "{k\u2081 : Function.LeftInverse \u03c6' \u03c6} {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    (inverse' f g k\u2082 h\u2081 h\u2082).comp f (\u03ba := CompTriple.comp_inv k\u2081) = MulActionHom.id M := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2081 x",
        "suggestion": "  simpa using h\u2081.eq _\n",
        "body": "```suggestion\n  simpa using h\u2081.eq _\n```",
        "path": "Mathlib/GroupTheory/GroupAction/Hom.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "rw",
            "simp",
            "intro"
          ],
          "topics": [
            "function"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "RightInverse",
            "id_apply",
            "ext_iff",
            "exact",
            "comp_apply",
            "MulActionHom",
            "comp",
            "CompTriple",
            "simp",
            "intro",
            "LeftInverse",
            "Function",
            "comp_inv",
            "only",
            "inverse"
          ]
        }
      },
      {
        "id": 1729,
        "before_code": "{k\u2081 : Function.LeftInverse \u03c6' \u03c6} {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    (inverse' f g k\u2082 h\u2081 h\u2082).comp f (\u03ba := CompTriple.comp_inv k\u2081) = MulActionHom.id M := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2081 x\n\n@[to_additive]\ntheorem inverse'_comp {f : X \u2192\u2091[\u03c6] Y} {g : Y \u2192 X}\n    {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    f.comp (inverse' f g k\u2082 h\u2081 h\u2082) (\u03ba := CompTriple.comp_inv k\u2082) = MulActionHom.id N := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2082 x",
        "suggestion": "  simpa using h\u2082.eq _\n",
        "body": "```suggestion\n  simpa using h\u2082.eq _\n```",
        "path": "Mathlib/GroupTheory/GroupAction/Hom.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "rw",
            "simp",
            "intro"
          ],
          "topics": [
            "function"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "to_additive",
            "RightInverse",
            "id_apply",
            "ext_iff",
            "theorem",
            "exact",
            "comp_apply",
            "MulActionHom",
            "comp",
            "CompTriple",
            "simp",
            "intro",
            "LeftInverse",
            "Function",
            "_comp",
            "comp_inv",
            "only",
            "inverse"
          ]
        }
      },
      {
        "id": 1797,
        "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
        "suggestion": "  simpa only [angle_comm] using h.angle_eq_right p\u2083\n",
        "body": "```suggestion\n  simpa only [angle_comm] using h.angle_eq_right p\u2083\n```",
        "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [],
          "transforms": [
            "use_simpa",
            "cleanup_simp"
          ],
          "keywords": [
            "by_cases",
            "Sbtw",
            "symm",
            "simp"
          ]
        }
      },
      {
        "id": 1799,
        "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
        "suggestion": "  simpa only [angle_comm] using h.angle_eq_right p\u2083 hp\u2081p\u2082\n",
        "body": "```suggestion\n  simpa only [angle_comm] using h.angle_eq_right p\u2083 hp\u2081p\u2082\n```",
        "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [],
          "transforms": [
            "use_simpa",
            "cleanup_simp"
          ],
          "keywords": [
            "by_cases",
            "Sbtw",
            "symm",
            "simp"
          ]
        }
      },
      {
        "id": 1814,
        "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]\n\n/-- The mean value theorem for integrals:\nThere exists a point in an interval such that the mean of a continuous function over the interval\nequals the value of the function at the point. -/\ntheorem exists_eq_interval_average\n    {f : \u211d \u2192 \u211d} {a b : \u211d} (hab : a \u2260 b) (hf : ContinuousOn f (uIcc a b)) :\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d (x : \u211d) in a..b, f x := by\n  wlog h : a < b generalizing a b\n  \u00b7 rw [uIcc_comm] at hf\n    have := this hab.symm hf (lt_of_le_of_ne (le_of_not_gt h) (Ne.symm hab))\n    rwa [uIoo_comm, interval_average_symm] at this\n  let ave := \u2a0d (x : \u211d) in a..b, f x\n  have h_vol_fin1 : volume (uIoc a b) \u2260 0 := by simpa [h.le] using h\n  have h_vol_fin2 : volume (uIoc a b) \u2260 \u22a4 := by simp [h.le]\n  have h_intble : IntegrableOn f (uIoc a b) := by\n    have : IntegrableOn f (uIcc a b) := hf.integrableOn_uIcc\n    rwa [uIcc_of_lt h,integrableOn_Icc_iff_integrableOn_Ioc, \u2190uIoc_of_le (le_of_lt h)] at this\n  let S1 := {x | x \u2208 uIoc a b \u2227 f x \u2264 ave}\n  let S2 := {x | x \u2208 uIoc a b \u2227 ave \u2264 f x}\n  have h_meas1 : volume (S1 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_le_setAverage_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  have h_meas2 : volume (S2 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_setAverage_le_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  obtain \u27e8c1, \u27e8hc1_mem, hc1_le\u27e9, hc1'\u27e9 := nonempty_of_measure_ne_zero h_meas1\n  have hc1' : c1 \u2208 Ioo a b := by\n    rw [Set.uIoc_of_le (le_of_lt h)] at hc1_mem\n    rw [notMem_singleton_iff] at hc1'\n    exact \u27e8hc1_mem.1, lt_of_le_of_ne hc1_mem.2 hc1'\u27e9\n  obtain \u27e8c2, \u27e8hc2_mem, hc2_ge\u27e9, hc2'\u27e9 := nonempty_of_measure_ne_zero h_meas2\n  have hc2' : c2 \u2208 Ioo a b := by\n    rw [Se",
        "suggestion": "    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n",
        "body": "```suggestion\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n```\nsimp lemmas that you register elsewhere in the PR make the proof very direct!",
        "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "cases",
            "have",
            "simpa",
            "obtain",
            "rw",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "simpa",
            "simp"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "exact",
            "cases",
            "have",
            "obtain",
            "rw",
            "intro"
          ],
          "topics": [
            "continuity",
            "set_theory",
            "real",
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "rwa",
            "codiscreteWithin",
            "interval_average_symm",
            "intervalIntegral",
            "le_of_lt",
            "Ioo_subset_Icc_self",
            "have",
            "mem_Ioo",
            "Filter",
            "notMem_singleton_iff",
            "integrableOn_uIcc",
            "intro",
            "hc2_mem",
            "such",
            "uIoc_of_le",
            "hab",
            "that",
            "simp",
            "h_ave",
            "volume",
            "theorem",
            "h_vol_fin2",
            "h_meas1",
            "h_meas2",
            "value",
            "integral_congr_codiscreteWithin",
            "interval_average_eq",
            "lt_of_lt_of_le",
            "There",
            "point",
            "imp",
            "uIcc",
            "intermediate_value_uIcc",
            "h_intble",
            "uIoo",
            "IntegrableOn",
            "hc1_mem",
            "continuous",
            "hc1_le",
            "hc1",
            "generalizing",
            "lt_of_le_of_ne",
            "interval",
            "Icc",
            "ave",
            "hc2",
            "measure_diff_null",
            "Ioo",
            "hc2_ge",
            "integrals"
          ]
        }
      },
      {
        "id": 2022,
        "before_code": "section shift_invariance\n\nvariable {\ud835\udd5c F} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\n\n/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (s + z)) = fun t \u21a6 iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (z + s)) = fun t \u21a6 iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s",
        "suggestion": "  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n",
        "body": "```suggestion\n  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n```",
        "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "funext",
            "induction",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "funext",
            "induction",
            "simp"
          ],
          "topics": [
            "norm",
            "list",
            "nat",
            "algebra"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "funext",
            "lemma",
            "deriv_comp_add_const",
            "succ",
            "iterated",
            "iteratedDeriv_succ",
            "commutes",
            "section",
            "right",
            "iteratedDeriv_comp_const_add",
            "NormedAddCommGroup",
            "constant",
            "variable",
            "derivative",
            "shift_invariance",
            "induction",
            "simp",
            "iteratedDeriv_comp_add_const",
            "zero",
            "only",
            "iteratedDeriv",
            "NontriviallyNormedField",
            "deriv_comp_const_add",
            "function",
            "left",
            "NormedSpace",
            "simpa",
            "iteratedDeriv_zero",
            "shifting",
            "using"
          ]
        }
      },
      {
        "id": 2141,
        "before_code": "simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_iff_left_iff_imp]\n  exact fun hz \u21a6 UpperHalfPlane.coe_mem_integerComplement \u27e8z, hz\u27e9",
        "suggestion": "\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n",
        "body": "If you put this in `UpperHalfPlane` then you can dot-notate. Also `n` can be implicit since you have `hm`. \r\n```suggestion\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n```",
        "path": "Mathlib/Analysis/Complex/IntegerCompl.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa",
            "have",
            "simp"
          ],
          "body_tactics": [
            "simpa",
            "have",
            "simp"
          ],
          "new_tactics": [
            "simpa",
            "have"
          ],
          "removed_tactics": [
            "exact"
          ],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "mem_setOf_eq",
            "exact",
            "Set",
            "mem_inter_iff",
            "UpperHalfPlane",
            "coe_mem_integerComplement",
            "simp",
            "and_iff_left_iff_imp",
            "only"
          ]
        }
      },
      {
        "id": 2142,
        "before_code": "@[simp, norm_cast]\nlemma coe_I : I = Complex.I := rfl",
        "suggestion": "\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffices 0 < n * z.im / Complex.normSq z by simpa [Complex.div_im, neg_div]\r\n  positivity [NeZero.ne n, z.normSq_pos]\r\n",
        "body": "This is in the `UpperHalfPlane` namespace so you don't really need `UpperHalfPlane` in the statment. My instinct would be to formulate using `Nat` with a `[NeZero]` typeclass assumption, rather than `PNat`, but I haven't checked how that plays together with the usage of this lemma later. \r\n\r\nIf you move this to a few lines later in the file (maybe after `ne_int`) then you can do the following:\r\n```suggestion\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffi",
        "path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
        "tags": {
          "before_tactics": [
            "simp",
            "norm_cast"
          ],
          "suggestion_tactics": [
            "simpa",
            "positivity"
          ],
          "body_tactics": [
            "simpa",
            "positivity"
          ],
          "new_tactics": [
            "simpa",
            "positivity"
          ],
          "removed_tactics": [
            "simp",
            "norm_cast"
          ],
          "topics": [
            "complex",
            "norm"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "coe_I",
            "lemma",
            "Complex",
            "simp",
            "rfl",
            "norm_cast"
          ]
        }
      },
      {
        "id": 2144,
        "before_code": "\u00b7 simp only [isLittleO_const_left, Int.cast_eq_zero,\n      tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real, or_true]\n\nlemma linear_inv_isBigO_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_right c z).inv.isBigO\n\nlemma linear_inv_isBigO_left (d : \u2124) {z : \u2102} (hz : z \u2260 0) :\n    (fun (c : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_left d hz).inv.isBigO",
        "suggestion": "\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n",
        "body": "`Asymptotics` is already open, and `simpa` uses `this` by default:\r\n```suggestion\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n```",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "simpa",
            "apply",
            "have"
          ],
          "body_tactics": [
            "simpa",
            "apply",
            "have"
          ],
          "new_tactics": [
            "simpa",
            "apply",
            "have"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "list",
            "real",
            "complex",
            "norm",
            "topology",
            "int"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "isBigO",
            "cast_eq_zero",
            "lemma",
            "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
            "linear_isTheta_right",
            "Int",
            "linear_inv_isBigO_left",
            "or_true",
            "inv",
            "linear_isTheta_left",
            "simp",
            "cofinite",
            "isClosedEmbedding_coe_real",
            "isLittleO_const_left",
            "only",
            "linear_inv_isBigO_right"
          ]
        }
      },
      {
        "id": 2146,
        "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]",
        "suggestion": "\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul\r\n      (linear_inv_isBigO_right_add c\u2081 0 z).comp_neg_int\r\n",
        "body": "```suggestion\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul\r\n      (linear_inv_isBigO_right_add c\u2081 0 z).comp_neg_int\r\n```",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "simp",
            "norm_cast"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "apply",
            "simp",
            "norm_cast"
          ],
          "topics": [
            "norm",
            "real",
            "int"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "apply",
            "pow_two",
            "Real",
            "abs_mul_abs_self",
            "Summable",
            "simp",
            "summable_inv_of_isBigO_rpow_inv",
            "only",
            "rpow_two",
            "norm_cast"
          ]
        }
      },
      {
        "id": 2147,
        "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
        "suggestion": "\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul \r\n    (linear_inv_isBigO_right_add c\u2081 1 z)\r\n",
        "body": "```suggestion\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul \r\n    (linear_inv_isBigO_right_add c\u2081 1 z)\r\n```\r\n(It's a pity we don't have an automatic way to \"anti-squeeze\" a simp, i.e. remove explicitly-listed lemmas where they aren't needed.) Ditto in the next lemma.",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "apply",
            "simp",
            "norm_cast"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa",
            "have",
            "simp"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "apply",
            "simp",
            "norm_cast"
          ],
          "topics": [
            "norm",
            "real",
            "int"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "only",
            "apply",
            "pow_two",
            "Real",
            "norm_cast",
            "abs_mul_abs_self",
            "simpa",
            "Summable",
            "simp",
            "summable_inv_of_isBigO_rpow_inv",
            "sub_eq_add_neg",
            "using",
            "mul",
            "comp_neg_int",
            "rpow_two",
            "linear_inv_isBigO_right"
          ]
        }
      },
      {
        "id": 2148,
        "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
        "suggestion": "\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _)]\r\n  aesop\r\n",
        "body": "I'm not a fan of `simp only [massive list of stuff] at *`, it seems a bit of a \"scattergun\" approach. Here's a shorter and cleaner version:\r\n```suggestion\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "apply",
            "simp",
            "norm_cast"
          ],
          "suggestion_tactics": [
            "apply",
            "aesop",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "apply",
            "aesop",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "aesop",
            "rw",
            "have"
          ],
          "removed_tactics": [
            "norm_cast"
          ],
          "topics": [
            "norm",
            "real",
            "int"
          ],
          "transforms": [
            "use_simpa",
            "cleanup_simp",
            "use_aesop"
          ],
          "keywords": [
            "only",
            "apply",
            "pow_two",
            "Real",
            "norm_cast",
            "abs_mul_abs_self",
            "simpa",
            "Summable",
            "simp",
            "summable_inv_of_isBigO_rpow_inv",
            "sub_eq_add_neg",
            "using",
            "mul",
            "comp_neg_int",
            "rpow_two",
            "linear_inv_isBigO_right"
          ]
        }
      },
      {
        "id": 2149,
        "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
        "suggestion": "\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n",
        "body": "```suggestion\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n```\r\nThe statement can be made far more general, you could do e.g.\r\n```\r\nlemma isLittleO_const_left_of_properSpace_of_discreteTopology\r\n    {\u03b1 : Type*} (a : \u03b1) [NormedAddCommGroup \u03b1] [DiscreteTopology \u03b1]\r\n    [ProperSpace \u03b1] : (fun _ : \u03b1 \u21a6 a) =",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "apply",
            "simp",
            "norm_cast"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "apply",
            "simp",
            "norm_cast"
          ],
          "topics": [
            "norm",
            "real",
            "int"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "only",
            "apply",
            "pow_two",
            "Real",
            "norm_cast",
            "abs_mul_abs_self",
            "simpa",
            "Summable",
            "simp",
            "summable_inv_of_isBigO_rpow_inv",
            "sub_eq_add_neg",
            "using",
            "mul",
            "comp_neg_int",
            "rpow_two",
            "linear_inv_isBigO_right"
          ]
        }
      },
      {
        "id": 2150,
        "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
        "suggestion": "\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n",
        "body": "```suggestion\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n```",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "apply",
            "simp",
            "norm_cast"
          ],
          "suggestion_tactics": [
            "simpa",
            "rw",
            "have"
          ],
          "body_tactics": [
            "simpa",
            "rw",
            "have"
          ],
          "new_tactics": [
            "rw",
            "have"
          ],
          "removed_tactics": [
            "apply",
            "simp",
            "norm_cast"
          ],
          "topics": [
            "norm",
            "real",
            "int"
          ],
          "transforms": [
            "use_simpa",
            "cleanup_simp"
          ],
          "keywords": [
            "only",
            "apply",
            "pow_two",
            "Real",
            "norm_cast",
            "abs_mul_abs_self",
            "simpa",
            "Summable",
            "simp",
            "summable_inv_of_isBigO_rpow_inv",
            "sub_eq_add_neg",
            "using",
            "mul",
            "comp_neg_int",
            "rpow_two",
            "linear_inv_isBigO_right"
          ]
        }
      },
      {
        "id": 2153,
        "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
        "suggestion": "\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n",
        "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n```",
        "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa",
            "exact"
          ],
          "body_tactics": [
            "simpa",
            "exact"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "rw",
            "simp"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "h00",
            "exact",
            "pow_mul",
            "mul_comm",
            "simp",
            "val"
          ]
        }
      },
      {
        "id": 2156,
        "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
        "suggestion": "\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n",
        "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n```\r\n(It's a pity that none of the auto-tactics seem to work on the last line.)",
        "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "rw",
            "simp"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "h00",
            "exact",
            "pow_mul",
            "mul_comm",
            "simp",
            "val"
          ]
        }
      },
      {
        "id": 2158,
        "before_code": "f 0 * \u220f' n : \u2115+, f \u2191n = \u220f' n, f n := by\n  simpa [hf.tprod_eq_zero_mul] using tprod_pnat_eq_tprod_succ\n\n@[to_additive tsum_int_eq_zero_add_two_mul_tsum_pnat]\ntheorem tprod_int_eq_zero_mul_tprod_pnat_sq [UniformSpace G] [IsUniformGroup G] [CompleteSpace G]\n    [T2Space G] {f : \u2124 \u2192 G} (hf : \u2200 n : \u2124, f (-n) = f n) (hf2 : Multipliable f) :\n    \u220f' n, f n = f 0 * (\u220f' n : \u2115+, f n) ^ 2 := by\n  have hf3 : Multipliable fun n : \u2115 \u21a6 f n :=\n    (multipliable_int_iff_multipliable_nat_and_neg.mp hf2).1\n  have hf4 : Multipliable fun n : \u2115+ \u21a6 f n := by\n    rwa [multipliable_pnat_iff_multipliable_succ (f := (f \u00b7)),\n      multipliable_nat_add_iff 1 (f := (f \u00b7))]\n  have := tprod_nat_mul_neg hf2\n  rw [\u2190 tprod_zero_pnat_eq_tprod_nat (by simpa [hf] using hf3.mul hf3), mul_comm _ (f 0)] at this\n  simp only [hf, Nat.cast_zero, mul_assoc, mul_right_inj] at this\n  rw [\u2190 this, mul_right_inj, hf4.tprod_mul hf4, sq]",
        "suggestion": "\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n",
        "body": "Indentation is off here. But the proof can also be hugely shortened:\r\n```suggestion\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n```\r\nYou could also use `Function.Even` as the hypothesis, at the cost of an extra import; note that if you do `(hf : Function.Even f)` then you need `hf _` in the simp call, not just `hf`.",
        "path": "Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "have",
            "rw",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa",
            "simp"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "simp",
            "rw",
            "have"
          ],
          "topics": [
            "int",
            "finset",
            "nat",
            "algebra"
          ],
          "transforms": [
            "use_simpa",
            "cleanup_simp"
          ],
          "keywords": [
            "CompleteSpace",
            "rwa",
            "Multipliable",
            "multipliable_nat_add_iff",
            "tsum_int_eq_zero_add_two_mul_tsum_pnat",
            "mul",
            "to_additive",
            "IsUniformGroup",
            "multipliable_int_iff_multipliable_nat_and_neg",
            "hf4",
            "Nat",
            "cast_zero",
            "have",
            "tprod_zero_pnat_eq_tprod_nat",
            "hf3",
            "mul_right_inj",
            "multipliable_pnat_iff_multipliable_succ",
            "tprod_pnat_eq_tprod_succ",
            "T2Space",
            "mul_comm",
            "simp",
            "tprod_eq_zero_mul",
            "only",
            "mul_assoc",
            "theorem",
            "UniformSpace",
            "hf2",
            "tprod_nat_mul_neg",
            "tprod_mul",
            "this",
            "simpa",
            "tprod_int_eq_zero_mul_tprod_pnat_sq",
            "using"
          ]
        }
      },
      {
        "id": 2358,
        "before_code": "intro B n\n  induction n with\n  | zero => simp only [zpow_zero, one_smul]\n  | succ n hn =>\n    simpa only [add_comm (n:\u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc, prop_red_T hS hT]",
        "suggestion": "\r\n  | succ n hn =>\r\n    simpa only [add_comm (n : \u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc,\r\n      prop_red_T hS hT]\r\n",
        "body": "```suggestion\r\n  | succ n hn =>\r\n    simpa only [add_comm (n : \u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc,\r\n      prop_red_T hS hT]\r\n```",
        "path": "Mathlib/LinearAlgebra/Matrix/FixedDetMatrices.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "induction",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "induction",
            "simp",
            "intro"
          ],
          "topics": [
            "int"
          ],
          "transforms": [
            "use_simpa",
            "cleanup_simp"
          ],
          "keywords": [
            "zpow_add",
            "add_comm",
            "one_smul",
            "prop_red_T",
            "succ",
            "zpow_zero",
            "simpa",
            "zpow_one",
            "induction",
            "simp",
            "intro",
            "zero",
            "smul_eq_mul",
            "only",
            "smul_assoc"
          ]
        }
      },
      {
        "id": 2529,
        "before_code": "(h : \u2200 F : Set \u03a9, IsClosed F \u2192\n      limsup (fun i \u21a6 (\u03bcs i : Measure \u03a9).real F) L \u2264 (\u03bc : Measure \u03a9).real F) :\n    Tendsto \u03bcs L (\ud835\udcdd \u03bc) := by\n  refine tendsto_of_forall_isClosed_limsup_le' fun F hF \u21a6 ?_\n  rcases L.eq_or_neBot with rfl | hne\n  \u00b7 simp\n  specialize h F hF\n  simp only [Measure.real_def] at h\n  rwa [ENNReal.limsup_toReal_eq (b := 1) (by simp) (.of_forall fun i \u21a6 prob_le_one),\n    ENNReal.toReal_le_toReal _ (by finiteness)] at h\n  refine ne_top_of_le_ne_top (b := 1) (by simp) ?_\n  refine limsup_le_of_le ?_ (.of_forall fun i \u21a6 prob_le_one)\n  exact isCoboundedUnder_le_of_le L (x := 0) (by simp)",
        "suggestion": "Tendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n",
        "body": "````suggestion\nTendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n````",
        "path": "Mathlib/MeasureTheory/Measure/Portmanteau.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "cases",
            "refine",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "cases",
            "simp",
            "refine"
          ],
          "topics": [
            "measurability",
            "order",
            "topology"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "of_forall",
            "rwa",
            "real",
            "rcases",
            "limsup_le_of_le",
            "finiteness",
            "refine",
            "specialize",
            "real_def",
            "Measure",
            "isCoboundedUnder_le_of_le",
            "limsup",
            "eq_or_neBot",
            "hne",
            "Tendsto",
            "simp",
            "prob_le_one",
            "rfl",
            "IsClosed",
            "only",
            "ne_top_of_le_ne_top",
            "ENNReal",
            "exact",
            "Set",
            "tendsto_of_forall_isClosed_limsup_le",
            "limsup_toReal_eq",
            "toReal_le_toReal"
          ]
        }
      },
      {
        "id": 2530,
        "before_code": "\u222b\u207b b in s, Kernel.condKernel \u03ba (a, b) t \u2202(Kernel.fst \u03ba a) = \u03ba a (s \u00d7\u02e2 t) := by\n  have : \u03ba a (s \u00d7\u02e2 t) = (Kernel.fst \u03ba \u2297\u2096 Kernel.condKernel \u03ba) a (s \u00d7\u02e2 t) := by\n    congr; exact (\u03ba.disintegrate _).symm\n  rw [this, Kernel.compProd_apply (hs.prod ht)]\n  classical\n  have : \u2200 b, Kernel.condKernel \u03ba (a, b) {c | (b, c) \u2208 s \u00d7\u02e2 t}\n      = s.indicator (fun b \u21a6 Kernel.condKernel \u03ba (a, b) t) b := by\n    intro b\n    by_cases hb : b \u2208 s <;> simp [hb]\n  simp_rw [Set.preimage, this]\n  rw [lintegral_indicator hs]",
        "suggestion": "simpa [this] using (Kernel.compProd_apply_prod hs ht).symm\n",
        "body": "````suggestion\nsimpa [this] using (Kernel.compProd_apply_prod hs ht).symm\n````",
        "path": "Mathlib/Probability/Kernel/Disintegration/Integral.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "have",
            "rw",
            "simp",
            "intro",
            "congr"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "have",
            "rw",
            "simp",
            "intro",
            "congr"
          ],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "compProd_apply",
            "classical",
            "condKernel",
            "symm",
            "by_cases",
            "fst",
            "have",
            "lintegral_indicator",
            "intro",
            "preimage",
            "simp_rw",
            "prod",
            "Kernel",
            "disintegrate",
            "simp",
            "congr",
            "indicator",
            "exact",
            "Set",
            "this"
          ]
        }
      },
      {
        "id": 2532,
        "before_code": "refine (e.forall_congr ?_).symm\n    intro i\n    rw [MeasurableEquiv.piCongrLeft_apply_apply e x i]\n  rw [this, pi_pi, Finset.prod_equiv e.symm]\n  \u00b7 simp only [Finset.mem_univ, implies_true]\n  intro i _\n  simp only [s']\n  congr\n  all_goals rw [e.apply_symm_apply]",
        "suggestion": "\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n",
        "body": "````suggestion\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n````",
        "path": "Mathlib/MeasureTheory/Constructions/Pi.lean",
        "tags": {
          "before_tactics": [
            "refine",
            "rw",
            "simp",
            "intro",
            "congr"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "refine",
            "rw",
            "simp",
            "intro",
            "congr"
          ],
          "topics": [
            "measurability",
            "set_theory",
            "finset"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "apply_symm_apply",
            "symm",
            "refine",
            "all_goals",
            "mem_univ",
            "forall_congr",
            "piCongrLeft_apply_apply",
            "Finset",
            "implies_true",
            "pi_pi",
            "congr",
            "this",
            "simp",
            "intro",
            "MeasurableEquiv",
            "prod_equiv",
            "only"
          ]
        }
      },
      {
        "id": 2767,
        "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
        "suggestion": "theorem house_pow_le (\u03b1 : K) (i : \u2115) : house (\u03b1^i) \u2264 house \u03b1 ^ i := by\n  simpa only [house, map_pow] using norm_pow_le ((canonicalEmbedding K) \u03b1) i\n",
        "body": "```suggestion\ntheorem house_pow_le (\u03b1 : K) (i : \u2115) : house (\u03b1^i) \u2264 house \u03b1 ^ i := by\n  simpa only [house, map_pow] using norm_pow_le ((canonicalEmbedding K) \u03b1) i\n```",
        "path": "Mathlib/NumberTheory/NumberField/House.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "apply",
            "simp"
          ],
          "topics": [
            "norm"
          ],
          "transforms": [
            "use_simpa",
            "cleanup_simp"
          ],
          "keywords": [
            "house",
            "apply",
            "theorem",
            "map_mul",
            "simp",
            "house_mul_le",
            "only",
            "norm_mul_le"
          ]
        }
      },
      {
        "id": 2769,
        "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
        "suggestion": "theorem house_num_mul_int (\u03b1 : K) (c' : \u2124) (hc : 0 \u2264 c') :\n    house ((c' : K) * \u03b1) = |(c' : \u211d)| * house (\u03b1) := by\n  lift c' to \u2115 using hc\n  simpa using house_nat_mul \u03b1 c'\n",
        "body": "You can use the `lift` tactic in a situation like this.\n```suggestion\ntheorem house_num_mul_int (\u03b1 : K) (c' : \u2124) (hc : 0 \u2264 c') :\n    house ((c' : K) * \u03b1) = |(c' : \u211d)| * house (\u03b1) := by\n  lift c' to \u2115 using hc\n  simpa using house_nat_mul \u03b1 c'\n```\nSo I think you can drop this lemma.\n\n```suggestion\n```",
        "path": "Mathlib/NumberTheory/NumberField/House.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "apply",
            "simp"
          ],
          "topics": [
            "norm"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "house",
            "apply",
            "theorem",
            "map_mul",
            "simp",
            "house_mul_le",
            "only",
            "norm_mul_le"
          ]
        }
      },
      {
        "id": 2771,
        "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
        "suggestion": "lemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n",
        "body": "```suggestion\nlemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n```",
        "path": "Mathlib/NumberTheory/NumberField/House.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa",
            "apply",
            "rw",
            "have"
          ],
          "body_tactics": [
            "simpa",
            "apply",
            "rw",
            "have"
          ],
          "new_tactics": [
            "simpa",
            "rw",
            "have"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "norm",
            "complex",
            "list",
            "int"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "house",
            "apply",
            "cast_abs",
            "theorem",
            "Complex",
            "intCast_def",
            "Int",
            "norm_intCast",
            "pi_norm_const",
            "house_intCast",
            "map_mul",
            "simp",
            "house_mul_le",
            "map_intCast",
            "only",
            "norm_mul_le"
          ]
        }
      },
      {
        "id": 2772,
        "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
        "suggestion": "lemma house_prod_le (s : Finset K) : house (\u220f x \u2208 s, x) \u2264 \u220f x \u2208 s, house x := by\n  simpa [house, map_prod] using Finset.norm_prod_le _ _\n",
        "body": "Please move this right after `house_mul_le`.\n```suggestion\nlemma house_prod_le (s : Finset K) : house (\u220f x \u2208 s, x) \u2264 \u220f x \u2208 s, house x := by\n  simpa [house, map_prod] using Finset.norm_prod_le _ _\n```",
        "path": "Mathlib/NumberTheory/NumberField/House.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "apply",
            "simp"
          ],
          "topics": [
            "norm",
            "complex",
            "list",
            "int"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "house",
            "apply",
            "cast_abs",
            "theorem",
            "Complex",
            "intCast_def",
            "Int",
            "norm_intCast",
            "pi_norm_const",
            "house_intCast",
            "map_mul",
            "simp",
            "house_mul_le",
            "map_intCast",
            "only",
            "norm_mul_le"
          ]
        }
      },
      {
        "id": 3044,
        "before_code": "theorem inf_orthogonal_eq_bot : K \u2293 K\u15ee = \u22a5 := by\n  rw [eq_bot_iff]\n  intro x\n  simp only [toSubmodule_inf, orthogonal_toSubmodule_eq, Submodule.mem_inf, toSubmodule_bot,\n    Submodule.mem_bot, and_imp]\n  exact fun hx ho => inner_self_eq_zero.1 (ho x hx)",
        "suggestion": "\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n",
        "body": "```suggestion\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n```\r\nDoes this work?",
        "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "rw",
            "simp",
            "intro"
          ],
          "topics": [
            "set_theory",
            "order",
            "algebra"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "only",
            "theorem",
            "toSubmodule_inf",
            "exact",
            "eq_bot_iff",
            "mem_inf",
            "toSubmodule_bot",
            "mem_bot",
            "Submodule",
            "and_imp",
            "simp",
            "intro",
            "orthogonal_toSubmodule_eq",
            "inner_self_eq_zero",
            "inf_orthogonal_eq_bot"
          ]
        }
      },
      {
        "id": 3068,
        "before_code": "ext\n  simp +contextual [imp_false]",
        "suggestion": "\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n",
        "body": "I know you're not a fan but `diagSet` seems to fit the hypothesis pretty well:\r\n```suggestion\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n```\r\nThe current proof (just without the underscore) will also work after your #32679 is merged",
        "path": "Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean",
        "tags": {
          "before_tactics": [
            "simp",
            "ext"
          ],
          "suggestion_tactics": [
            "simpa",
            "simp",
            "ext"
          ],
          "body_tactics": [
            "simpa",
            "simp",
            "ext"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "contextual",
            "imp_false",
            "simp",
            "ext"
          ]
        }
      },
      {
        "id": 3115,
        "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
        "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
        "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
        "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "add",
            "aesop",
            "upperBounds",
            "Succ",
            "exact",
            "suffices",
            "simp",
            "rec",
            "from"
          ]
        }
      },
      {
        "id": 3116,
        "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
        "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
        "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
        "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "add",
            "aesop",
            "upperBounds",
            "Succ",
            "exact",
            "suffices",
            "simp",
            "rec",
            "from"
          ]
        }
      },
      {
        "id": 3117,
        "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
        "suggestion": "  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
        "body": "```suggestion\n  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
        "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "add",
            "aesop",
            "upperBounds",
            "Succ",
            "exact",
            "suffices",
            "simp",
            "rec",
            "from"
          ]
        }
      },
      {
        "id": 3118,
        "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
        "suggestion": "  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
        "body": "```suggestion\n  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
        "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [
            "exact",
            "aesop",
            "simp"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "add",
            "aesop",
            "upperBounds",
            "Succ",
            "exact",
            "suffices",
            "simp",
            "rec",
            "from"
          ]
        }
      },
      {
        "id": 3134,
        "before_code": "have h\u2082 := cos_pi_div_three;\n    have h\u2082 := cos_zero] <;>\n  simp [injOn_cos h_bnd \u27e8by positivity, by linarith [pi_nonneg]\u27e9 (h\u2082 \u25b8 h)]",
        "suggestion": "  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n",
        "body": "```suggestion\n  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n```",
        "path": "Mathlib/NumberTheory/Niven.lean",
        "tags": {
          "before_tactics": [
            "positivity",
            "have",
            "simp",
            "linarith"
          ],
          "suggestion_tactics": [
            "apply",
            "gcongr",
            "grind",
            "have",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "body_tactics": [
            "apply",
            "gcongr",
            "grind",
            "have",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "new_tactics": [
            "apply",
            "gcongr",
            "grind",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "removed_tactics": [
            "positivity",
            "simp",
            "linarith"
          ],
          "topics": [],
          "transforms": [
            "use_simpa",
            "use_grind"
          ],
          "keywords": [
            "injOn_cos",
            "cos_pi_div_three",
            "positivity",
            "pi_nonneg",
            "have",
            "h_bnd",
            "simp",
            "linarith",
            "cos_zero"
          ]
        }
      },
      {
        "id": 3190,
        "before_code": "@[simp] theorem logCounting_const_zero {e : WithTop E} :\n    logCounting (0 : \ud835\udd5c \u2192 E) e = 0 := logCounting_const",
        "suggestion": "\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n",
        "body": "```suggestion\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n```",
        "path": "Mathlib/Analysis/Complex/ValueDistribution/CountingFunction.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "simpa",
            "positivity"
          ],
          "body_tactics": [
            "simpa",
            "positivity"
          ],
          "new_tactics": [
            "simpa",
            "positivity"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "list"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "logCounting",
            "WithTop",
            "theorem",
            "logCounting_const_zero",
            "logCounting_const",
            "simp"
          ]
        }
      },
      {
        "id": 3241,
        "before_code": "finsum (fun d \u21a6 coeff d f \u2022 (constantCoeff (d.prod fun s e => (a s) ^ e))) := by\n  simp only [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_subst ha f 0]",
        "suggestion": "\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n",
        "body": "```suggestion\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n```",
        "path": "Mathlib/RingTheory/MvPowerSeries/Substitution.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "simpa",
            "simp"
          ],
          "new_tactics": [
            "simpa"
          ],
          "removed_tactics": [],
          "topics": [
            "list"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "coeff",
            "prod",
            "coeff_zero_eq_constantCoeff_apply",
            "coeff_subst",
            "simp",
            "finsum",
            "constantCoeff",
            "only"
          ]
        }
      },
      {
        "id": 3339,
        "before_code": "(rootSpaceProduct R L H \u03b1 (-\u03b1) 0 (add_neg_cancel \u03b1) (\u27e8y, hy\u27e9 \u2297\u209c[R] \u27e8z, hz\u27e9)).property using 0\n  simp [hyz]",
        "suggestion": "lemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n",
        "body": "```suggestion\nlemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n```",
        "path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "exact",
            "simpa",
            "rw",
            "simp",
            "intro"
          ],
          "body_tactics": [
            "exact",
            "simpa",
            "rw",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "exact",
            "simpa",
            "rw",
            "intro"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "rootSpaceProduct",
            "property",
            "simp",
            "add_neg_cancel",
            "using",
            "hyz"
          ]
        }
      },
      {
        "id": 3388,
        "before_code": "filter_upwards [Tendsto.eventually_const_lt (zero_lt_one) h\u03c6, hu\u03c6v] with x h\u03c6_pos huv'\n  simp [\u2190 Real.mul_rpow (le_of_lt h\u03c6_pos) (hv x), huv']",
        "suggestion": "\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <| Real.tendsto_log_atTop.comp g_tendsto\r\n",
        "body": "slightly cleaner\r\n```suggestion\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <",
        "path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "norm_num",
            "exact",
            "have",
            "simpa",
            "rw",
            "congr"
          ],
          "body_tactics": [
            "norm_num",
            "exact",
            "have",
            "simpa",
            "rw",
            "congr"
          ],
          "new_tactics": [
            "norm_num",
            "exact",
            "have",
            "simpa",
            "rw",
            "congr"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "list",
            "real",
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "le_of_lt",
            "eventually_const_lt",
            "zero_lt_one",
            "Real",
            "Tendsto",
            "filter_upwards",
            "mul_rpow",
            "simp",
            "huv"
          ]
        }
      },
      {
        "id": 3438,
        "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]\n\n/-- The mean value theorem for integrals:\nThere exists a point in an interval such that the mean of a continuous function over the interval\nequals the value of the function at the point. -/\ntheorem exists_eq_interval_average\n    {f : \u211d \u2192 \u211d} {a b : \u211d} (hab : a \u2260 b) (hf : ContinuousOn f (uIcc a b)) :\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d (x : \u211d) in a..b, f x := by\n  wlog h : a < b generalizing a b\n  \u00b7 rw [uIcc_comm] at hf\n    have := this hab.symm hf (lt_of_le_of_ne (le_of_not_gt h) (Ne.symm hab))\n    rwa [uIoo_comm, interval_average_symm] at this\n  let ave := \u2a0d (x : \u211d) in a..b, f x\n  have h_vol_fin1 : volume (uIoc a b) \u2260 0 := by simpa [h.le] using h\n  have h_vol_fin2 : volume (uIoc a b) \u2260 \u22a4 := by simp [h.le]\n  have h_intble : IntegrableOn f (uIoc a b) := by\n    have : IntegrableOn f (uIcc a b) := hf.integrableOn_uIcc\n    rwa [uIcc_of_lt h,integrableOn_Icc_iff_integrableOn_Ioc, \u2190uIoc_of_le (le_of_lt h)] at this\n  let S1 := {x | x \u2208 uIoc a b \u2227 f x \u2264 ave}\n  let S2 := {x | x \u2208 uIoc a b \u2227 ave \u2264 f x}\n  have h_meas1 : volume (S1 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_le_setAverage_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  have h_meas2 : volume (S2 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_setAverage_le_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  obtain \u27e8c1, \u27e8hc1_mem, hc1_le\u27e9, hc1'\u27e9 := nonempty_of_measure_ne_zero h_meas1\n  have hc1' : c1 \u2208 Ioo a b := by\n    rw [Set.uIoc_of_le (le_of_lt h)] at hc1_mem\n    rw [notMem_singleton_iff] at hc1'\n    exact \u27e8hc1_mem.1, lt_of_le_of_ne hc1_mem.2 hc1'\u27e9\n  obtain \u27e8c2, \u27e8hc2_mem, hc2_ge\u27e9, hc2'\u27e9 := nonempty_of_measure_ne_zero h_meas2\n  have hc2' : c2 \u2208 Ioo a b := by\n    rw [Se",
        "suggestion": "    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n",
        "body": "```suggestion\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n```\nsimp lemmas that you register elsewhere in the PR make the proof very direct!",
        "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "cases",
            "have",
            "simpa",
            "obtain",
            "rw",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "simpa",
            "simp"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "exact",
            "cases",
            "have",
            "obtain",
            "rw",
            "intro"
          ],
          "topics": [
            "continuity",
            "set_theory",
            "real",
            "order"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "rwa",
            "codiscreteWithin",
            "interval_average_symm",
            "intervalIntegral",
            "le_of_lt",
            "Ioo_subset_Icc_self",
            "have",
            "mem_Ioo",
            "Filter",
            "notMem_singleton_iff",
            "integrableOn_uIcc",
            "intro",
            "hc2_mem",
            "such",
            "uIoc_of_le",
            "hab",
            "that",
            "simp",
            "h_ave",
            "volume",
            "theorem",
            "h_vol_fin2",
            "h_meas1",
            "h_meas2",
            "value",
            "integral_congr_codiscreteWithin",
            "interval_average_eq",
            "lt_of_lt_of_le",
            "There",
            "point",
            "imp",
            "uIcc",
            "intermediate_value_uIcc",
            "h_intble",
            "uIoo",
            "IntegrableOn",
            "hc1_mem",
            "continuous",
            "hc1_le",
            "hc1",
            "generalizing",
            "lt_of_le_of_ne",
            "interval",
            "Icc",
            "ave",
            "hc2",
            "measure_diff_null",
            "Ioo",
            "hc2_ge",
            "integrals"
          ]
        }
      },
      {
        "id": 3509,
        "before_code": "section shift_invariance\n\nvariable {\ud835\udd5c F} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\n\n/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (s + z)) = fun t \u21a6 iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (z + s)) = fun t \u21a6 iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s",
        "suggestion": "  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n",
        "body": "```suggestion\n  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n```",
        "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "funext",
            "induction",
            "simp"
          ],
          "suggestion_tactics": [
            "simpa"
          ],
          "body_tactics": [
            "simpa"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "funext",
            "induction",
            "simp"
          ],
          "topics": [
            "norm",
            "list",
            "nat",
            "algebra"
          ],
          "transforms": [
            "use_simpa"
          ],
          "keywords": [
            "funext",
            "lemma",
            "deriv_comp_add_const",
            "succ",
            "iterated",
            "iteratedDeriv_succ",
            "commutes",
            "section",
            "right",
            "iteratedDeriv_comp_const_add",
            "NormedAddCommGroup",
            "constant",
            "variable",
            "derivative",
            "shift_invariance",
            "induction",
            "simp",
            "iteratedDeriv_comp_add_const",
            "zero",
            "only",
            "iteratedDeriv",
            "NontriviallyNormedField",
            "deriv_comp_const_add",
            "function",
            "left",
            "NormedSpace",
            "simpa",
            "iteratedDeriv_zero",
            "shifting",
            "using"
          ]
        }
      }
    ],
    "use_grind": [
      {
        "id": 82,
        "before_code": "Sbtw R w x y :=\n  \u27e8h\u2081.wbtw.trans_right_left h\u2082.wbtw, h\u2081.ne_left, h\u2082.left_ne\u27e9",
        "suggestion": "\r\n    \u00b7 constructor\r\n      \u00b7 apply div_nonneg (mul_nonneg ht\u2081.1 ht\u2082.1)\r\n        nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n      \u00b7 apply div_le_one_of_le\u2080\r\n        \u00b7 grind\r\n        \u00b7 nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n",
        "body": "```suggestion\r\n    \u00b7 constructor\r\n      \u00b7 apply div_nonneg (mul_nonneg ht\u2081.1 ht\u2082.1)\r\n        nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n      \u00b7 apply div_le_one_of_le\u2080\r\n        \u00b7 grind\r\n        \u00b7 nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n```",
        "path": "Mathlib/Analysis/Convex/Between.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "nlinarith",
            "apply",
            "grind",
            "constructor"
          ],
          "body_tactics": [
            "nlinarith",
            "apply",
            "grind",
            "constructor"
          ],
          "new_tactics": [
            "nlinarith",
            "apply",
            "grind",
            "constructor"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "wbtw",
            "trans_right_left",
            "Sbtw",
            "ne_left",
            "left_ne"
          ]
        }
      },
      {
        "id": 137,
        "before_code": "case g2 => simp [Equiv.toPEquiv_apply]\n  case g3 => simp [Equiv.toPEquiv_apply, \u2190 Equiv.eq_symm_apply]",
        "suggestion": "\r\nlemma rowStochastic_inf_colStochastic :\r\n    rowStochastic R n \u2293 colStochastic R n = doublyStochastic R n := by\r\n  ext M\r\n  simp only [rowStochastic, colStochastic, Submonoid.mem_inf, Submonoid.mem_mk, Subsemigroup.mem_mk,\r\n    Set.mem_setOf_eq, doublyStochastic]\r\n  grind\r\n",
        "body": "I would phrase this as an equality of submonoids. Also, `grind` is a pretty nice tactic. I suggest that you try to play around with it and read about it to learn its power.\r\n\r\nCan you also move this much closer to the top of the file and use it to golf some of the other results in this file? (e.g., `convex_doublyStochastic` and `permMatrix_mem_doublyStochastic`)\r\n```suggestion\r\nlemma rowStochastic_inf_colStochastic :\r\n    rowStochastic R n \u2293 colStochastic R n = doublyStochastic R n := by\r\n  ext ",
        "path": "Mathlib/Data/Matrix/DoublyStochastic.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "grind",
            "simp",
            "ext"
          ],
          "body_tactics": [
            "grind",
            "simp",
            "ext"
          ],
          "new_tactics": [
            "grind",
            "ext"
          ],
          "removed_tactics": [],
          "topics": [
            "equiv"
          ],
          "transforms": [
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "eq_symm_apply",
            "Equiv",
            "case",
            "simp",
            "toPEquiv_apply"
          ]
        }
      },
      {
        "id": 161,
        "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
        "suggestion": "  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n",
        "body": "```suggestion\n  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n```",
        "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "exact",
            "grind"
          ],
          "body_tactics": [
            "exact",
            "grind"
          ],
          "new_tactics": [
            "exact",
            "grind"
          ],
          "removed_tactics": [],
          "topics": [
            "measurability",
            "set_theory"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "nullMeasurable",
            "g_mble",
            "Set",
            "Countable",
            "Measurable"
          ]
        }
      },
      {
        "id": 182,
        "before_code": "apply nontrivial h1\n  simp [ENat.card_eq_coe_natCard \u03b1, h2]",
        "suggestion": "\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Finite.one_lt_card_iff_nontrivial, Combination.card, Nat.one_lt_iff_ne_zero_and_ne_one,\r\n    ne_eq, Nat.choose_eq_zero_iff, ne_eq, Nat.choose_eq_one_iff]\r\n  grind\r\n",
        "body": "```suggestion\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Finite.one_lt_card_iff_nontrivial, Combination.card, Nat.one_lt_iff_ne_zero_and_ne_one,\r\n    ne_eq, Nat.choose_eq_zero_iff, ne_eq, Nat.choose_eq_one_iff]\r\n  grind\r\n```",
        "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "simp"
          ],
          "suggestion_tactics": [
            "grind",
            "rw",
            "have"
          ],
          "body_tactics": [
            "grind",
            "rw",
            "have"
          ],
          "new_tactics": [
            "grind",
            "rw",
            "have"
          ],
          "removed_tactics": [
            "apply",
            "simp"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "apply",
            "card_eq_coe_natCard",
            "simp",
            "nontrivial",
            "ENat"
          ]
        }
      },
      {
        "id": 187,
        "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
        "suggestion": "\r\n  apply isPretransitive_of_isMultiplyPretransitive\r\n  rcases eq_or_ne n 0 with rfl | hn0\r\n  \u00b7 infer_instance\r\n  rcases eq_or_ne n 1 with rfl | hn1\r\n  \u00b7 rw [is_one_pretransitive_iff]\r\n    exact alternatingGroup.isPretransitive_of_three_le_card \u03b1 h\u03b1\r\n  have := alternatingGroup.isMultiplyPretransitive \u03b1\r\n  apply isMultiplyPretransitive_of_le (n := Nat.card \u03b1 - 2) <;> grind\r\n",
        "body": "```suggestion\r\n  apply isPretransitive_of_isMultiplyPretransitive\r\n  rcases eq_or_ne n 0 with rfl | hn0\r\n  \u00b7 infer_instance\r\n  rcases eq_or_ne n 1 with rfl | hn1\r\n  \u00b7 rw [is_one_pretransitive_iff]\r\n    exact alternatingGroup.isPretransitive_of_three_le_card \u03b1 h\u03b1\r\n  have := alternatingGroup.isMultiplyPretransitive \u03b1\r\n  apply isMultiplyPretransitive_of_le (n := Nat.card \u03b1 - 2) <;> grind\r\n```",
        "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain"
          ],
          "suggestion_tactics": [
            "apply",
            "exact",
            "grind",
            "cases",
            "have",
            "rw"
          ],
          "body_tactics": [
            "apply",
            "exact",
            "grind",
            "cases",
            "have",
            "rw"
          ],
          "new_tactics": [
            "apply",
            "grind",
            "cases",
            "have",
            "rw"
          ],
          "removed_tactics": [
            "obtain"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "exact",
            "Finset",
            "card_eq_one",
            "obtain",
            "rfl"
          ]
        }
      },
      {
        "id": 198,
        "before_code": "end minpoly\n\nend Polynomial",
        "suggestion": "  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pred_eq_of_pos hprime.pos\n    -- Derive a vanishing relation with coefficients `\u03b1\u1d62 - \u03b1_{p-1}` and exponents `< n`.\n    have : \u2211 i \u2208 Finset.range (n + 1), \u03b1Nat i * \u03b6 ^ i = 0 := by\n      simpa [show n + 1 = p by omega, \u2190 Fin.sum_univ_eq_sum_range, h\u03b1Nat_val]\n    have : \u2211 i \u2208 Finset.range n, \u03b1Nat i * \u03b6 ^ i - \u03b1Nat n * \u2211 i \u2208 Finset.range n, \u03b6 ^ i = 0 := by\n      rw [Finset.sum_range_succ] at this\n      -- Use the standard relation for primitive roots: `\u03b6^{p-1} = -\u2211_{i<p-1} \u03b6^i`.\n      grind [h\u03b6.pow_sub_one_eq hprime.one_lt]\n    have h",
        "body": "Attempted golfing\n\n```suggestion\n  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pr",
        "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "body_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "new_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_omega",
            "cleanup_simp",
            "use_simpa",
            "use_grind",
            "use_ring"
          ],
          "keywords": [
            "Polynomial",
            "minpoly",
            "end"
          ]
        }
      },
      {
        "id": 313,
        "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
        "suggestion": "\r\n    \u00b7 simp only [K, coe_biUnion]\r\n      refine (h'I.mono_on ?_).biUnion hJdisj\r\n      simp\r\n      grind\r\n",
        "body": "```suggestion\r\n    \u00b7 simp only [K, coe_biUnion]\r\n      refine (h'I.mono_on ?_).biUnion hJdisj\r\n      simp\r\n      grind\r\n```",
        "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "grind",
            "refine",
            "simp"
          ],
          "body_tactics": [
            "grind",
            "refine",
            "simp"
          ],
          "new_tactics": [
            "grind",
            "simp",
            "refine"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "hst",
            "sUnion_insert_disjointOfDiff",
            "coe_insert",
            "rwa"
          ]
        }
      },
      {
        "id": 315,
        "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
        "suggestion": "  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n",
        "body": "```suggestion\n  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n```\na little golf",
        "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "refine",
            "grind",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "refine",
            "grind",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "simpa",
            "rw",
            "refine",
            "simp",
            "grind",
            "have"
          ],
          "removed_tactics": [],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_simpa",
            "use_grind"
          ],
          "keywords": [
            "h_dis",
            "h_ss",
            "sUnion",
            "h_mem"
          ]
        }
      },
      {
        "id": 523,
        "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
        "suggestion": "\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n",
        "body": "```suggestion\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n```",
        "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain",
            "rw",
            "intro",
            "omega"
          ],
          "suggestion_tactics": [
            "refine",
            "exact",
            "grind",
            "have",
            "obtain",
            "rw"
          ],
          "body_tactics": [
            "refine",
            "exact",
            "grind",
            "have",
            "obtain",
            "rw"
          ],
          "new_tactics": [
            "grind",
            "have",
            "refine"
          ],
          "removed_tactics": [
            "omega",
            "intro"
          ],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "mpr",
            "symm",
            "exact",
            "Set",
            "infinite_iff_exists_gt",
            "obtain",
            "mem_setOf",
            "exists_infinite_primes",
            "intro",
            "max",
            "odd_of_ne_two",
            "ne_of_lt",
            "Prime",
            "omega",
            "deficient"
          ]
        }
      },
      {
        "id": 524,
        "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
        "suggestion": "\r\n  have := abundancyIndex_le_ofDvd hd hn\r\n  have := ne_zero_of_dvd_ne_zero hn hd\r\n  grind [abundant_iff_two_lt_abundancyIndex]\r\n",
        "body": "```suggestion\r\n  have := abundancyIndex_le_ofDvd hd hn\r\n  have := ne_zero_of_dvd_ne_zero hn hd\r\n  grind [abundant_iff_two_lt_abundancyIndex]\r\n```",
        "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain",
            "rw",
            "intro",
            "omega"
          ],
          "suggestion_tactics": [
            "grind",
            "have"
          ],
          "body_tactics": [
            "grind",
            "have"
          ],
          "new_tactics": [
            "grind",
            "have"
          ],
          "removed_tactics": [
            "exact",
            "obtain",
            "rw",
            "intro",
            "omega"
          ],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "mpr",
            "symm",
            "exact",
            "Set",
            "infinite_iff_exists_gt",
            "obtain",
            "mem_setOf",
            "exists_infinite_primes",
            "intro",
            "max",
            "odd_of_ne_two",
            "ne_of_lt",
            "Prime",
            "omega",
            "deficient"
          ]
        }
      },
      {
        "id": 542,
        "before_code": "Submodule.span R (Set.range (ExteriorAlgebra.\u03b9Multi R n)) = \u22c0[R]^n M :=\n  ExteriorAlgebra.\u03b9Multi_span_fixedDegree R n",
        "suggestion": "open Set Submodule in\n/-- If a set `s` spans the module `M`, then the set of all elements of the form `x\u2081 \u2227 \u22ef \u2227 x\u2099`\nspans `\u22c0\u207f M`. -/\nlemma \u03b9Multi_span_fixedDegree_of_span_eq_top {s : Set M} (hs : span R s = \u22a4) :\n    span R (ExteriorAlgebra.\u03b9Multi R n '' {a | range a \u2286 s}) = \u22c0[R]^n M := by\n  apply le_antisymm\n  \u00b7 rw [span_le]\n    rintro - \u27e8y, \u27e8y_mem, rfl\u27e9\u27e9\n    apply ExteriorAlgebra.\u03b9Multi_range R n\n    simp\n  \u00b7 rw [ExteriorAlgebra.exteriorPower, LinearMap.range_eq_map, \u2190 hs, map_span, span_pow, span_le]\n    rintro x hx\n    obtain \u27e8f, rfl\u27e9 := Set.mem_pow.mp hx\n    refine mem_span_of_mem \u27e8ExteriorAlgebra.\u03b9Inv \u2218 Subtype.val \u2218 f, ?_, ?_\u27e9\n    \u00b7 rw [Set.mem_setOf_eq, Set.range_comp, Set.image_subset_iff]\n      apply Subset.trans ?_ (s.image_subset_preimage_of_inverse ExteriorAlgebra.\u03b9_leftInverse)\n      grind\n",
        "body": "This is mostly just vanity golfing. I think the main (minor) advantages are that the doc string and formal statement are slightly more human-friendly.\n```suggestion\nopen Set Submodule in\n/-- If a set `s` spans the module `M`, then the set of all elements of the form `x\u2081 \u2227 \u22ef \u2227 x\u2099`\nspans `\u22c0\u207f M`. -/\nlemma \u03b9Multi_span_fixedDegree_of_span_eq_top {s : Set M} (hs : span R s = \u22a4) :\n    span R (ExteriorAlgebra.\u03b9Multi R n '' {a | range a \u2286 s}) = \u22c0[R]^n M := by\n  apply le_antisymm\n  \u00b7 rw [span_le]\n    rint",
        "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "apply",
            "refine",
            "grind",
            "obtain",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "apply",
            "refine",
            "grind",
            "obtain",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "apply",
            "obtain",
            "rw",
            "refine",
            "simp",
            "grind"
          ],
          "removed_tactics": [],
          "topics": [
            "set_theory",
            "algebra"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "range",
            "Set",
            "span",
            "Submodule",
            "ExteriorAlgebra"
          ]
        }
      },
      {
        "id": 571,
        "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
        "suggestion": "\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n",
        "body": "```suggestion\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n```\r\n(re-labelling variables for consistency with previous lemma)",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "rw"
          ],
          "suggestion_tactics": [
            "apply",
            "grind",
            "have",
            "simpa",
            "rw",
            "congr"
          ],
          "body_tactics": [
            "apply",
            "grind",
            "have",
            "simpa",
            "rw",
            "congr"
          ],
          "new_tactics": [
            "apply",
            "grind",
            "congr",
            "have"
          ],
          "removed_tactics": [],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_simpa",
            "use_grind"
          ],
          "keywords": [
            "neg",
            "summable_e2Summand_symmetricIcc",
            "tsum_symmetricIcc_eq_tsum_symmetricIco",
            "simpa",
            "comp",
            "tendsto_e2Summand_atTop_nhds_zero",
            "tendsto_natCast_atTop_atTop",
            "using"
          ]
        }
      },
      {
        "id": 576,
        "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
        "suggestion": "\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (m * z + n + 1)) =\r\n    1 / (m * z - b) - 1 / (m * z + b) := by\r\n  convert telescope_aux' b (fun n \u21a6 1 / ((m : \u2102) * z + n)) using 2 <;>\r\n  simp [add_assoc, sub_eq_add_neg]\r\n",
        "body": "I'd suggest splitting this up:\r\n```suggestion\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "rw"
          ],
          "suggestion_tactics": [
            "aesop",
            "grind",
            "induction",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "grind",
            "induction",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "grind",
            "aesop",
            "induction",
            "simp"
          ],
          "removed_tactics": [
            "simpa"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "cleanup_simp",
            "use_aesop",
            "use_grind"
          ],
          "keywords": [
            "neg",
            "summable_e2Summand_symmetricIcc",
            "tsum_symmetricIcc_eq_tsum_symmetricIco",
            "simpa",
            "comp",
            "tendsto_e2Summand_atTop_nhds_zero",
            "tendsto_natCast_atTop_atTop",
            "using"
          ]
        }
      },
      {
        "id": 578,
        "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
        "suggestion": "\r\n      grind [Int.cast_natCast]\r\n",
        "body": "```suggestion\r\n      grind [Int.cast_natCast]\r\n```\r\nI'm not sure what lemmas `grind` knows; less than `simp`, but more than nothing. Similarly elsewhere in this proof.",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "rw"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind",
            "simp"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "simpa",
            "rw"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "neg",
            "summable_e2Summand_symmetricIcc",
            "tsum_symmetricIcc_eq_tsum_symmetricIco",
            "simpa",
            "comp",
            "tendsto_e2Summand_atTop_nhds_zero",
            "tendsto_natCast_atTop_atTop",
            "using"
          ]
        }
      },
      {
        "id": 585,
        "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
        "suggestion": "\r\n  exact this.congr <| by grind\r\n",
        "body": "```suggestion\r\n  exact this.congr <| by grind\r\n```",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "rw"
          ],
          "suggestion_tactics": [
            "exact",
            "congr",
            "grind"
          ],
          "body_tactics": [
            "exact",
            "congr",
            "grind"
          ],
          "new_tactics": [
            "exact",
            "congr",
            "grind"
          ],
          "removed_tactics": [
            "simpa",
            "rw"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "neg",
            "summable_e2Summand_symmetricIcc",
            "tsum_symmetricIcc_eq_tsum_symmetricIco",
            "simpa",
            "comp",
            "tendsto_e2Summand_atTop_nhds_zero",
            "tendsto_natCast_atTop_atTop",
            "using"
          ]
        }
      },
      {
        "id": 601,
        "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
        "suggestion": "\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n",
        "body": "```suggestion\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n```",
        "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "grind",
            "obtain",
            "have"
          ],
          "body_tactics": [
            "grind",
            "obtain",
            "have"
          ],
          "new_tactics": [
            "grind",
            "obtain",
            "have"
          ],
          "removed_tactics": [],
          "topics": [
            "list",
            "set_theory"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "mem_cons_self",
            "mem_cons_of_mem",
            "List"
          ]
        }
      },
      {
        "id": 602,
        "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
        "suggestion": "\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n",
        "body": "```suggestion\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n```",
        "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "exact",
            "grind"
          ],
          "body_tactics": [
            "exact",
            "grind"
          ],
          "new_tactics": [
            "exact",
            "grind"
          ],
          "removed_tactics": [],
          "topics": [
            "list",
            "set_theory"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "mem_cons_self",
            "mem_cons_of_mem",
            "List"
          ]
        }
      },
      {
        "id": 691,
        "before_code": "end IsSetSemiring",
        "suggestion": "\r\n  rcases h.eq_or_lt with rfl | huv\r\n  \u00b7 grind [Set.Ioc_eq_empty_iff]\r\n  rw [Set.Ioc_eq_Ioc_iff huv] at hu'v'\r\n  grind\r\n",
        "body": "```suggestion\r\n  rcases h.eq_or_lt with rfl | huv\r\n  \u00b7 grind [Set.Ioc_eq_empty_iff]\r\n  rw [Set.Ioc_eq_Ioc_iff huv] at hu'v'\r\n  grind\r\n```\r\ncombined with my other suggestion, this golfs quite a bit, and in my eyes without any loss of readability",
        "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "grind",
            "cases",
            "rw"
          ],
          "body_tactics": [
            "grind",
            "cases",
            "rw"
          ],
          "new_tactics": [
            "grind",
            "cases",
            "rw"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "IsSetSemiring",
            "end"
          ]
        }
      },
      {
        "id": 692,
        "before_code": "end IsSetSemiring",
        "suggestion": "\r\n  classical\r\n  rw [onIocAux, dite_eq_right_iff]\r\n  grind [Set.Ioc_eq_empty_iff]\r\n",
        "body": "```suggestion\r\n  classical\r\n  rw [onIocAux, dite_eq_right_iff]\r\n  grind [Set.Ioc_eq_empty_iff]\r\n```\r\na golf, if you like",
        "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "grind",
            "rw"
          ],
          "body_tactics": [
            "grind",
            "rw"
          ],
          "new_tactics": [
            "grind",
            "rw"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "IsSetSemiring",
            "end"
          ]
        }
      },
      {
        "id": 694,
        "before_code": "end IsSetSemiring",
        "suggestion": "      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n",
        "body": "```suggestion\n      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n```",
        "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "apply",
            "grind",
            "have",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "apply",
            "grind",
            "have",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "apply",
            "rw",
            "simp",
            "grind",
            "have"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "IsSetSemiring",
            "end"
          ]
        }
      },
      {
        "id": 695,
        "before_code": "end IsSetSemiring",
        "suggestion": "      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n",
        "body": "```suggestion\n      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n```",
        "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "grind",
            "obtain",
            "have"
          ],
          "body_tactics": [
            "grind",
            "obtain",
            "have"
          ],
          "new_tactics": [
            "grind",
            "obtain",
            "have"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "IsSetSemiring",
            "end"
          ]
        }
      },
      {
        "id": 696,
        "before_code": "end IsSetSemiring",
        "suggestion": "      have UI' : \u22c3\u2080 \u2191I' = Ioc u u' := by\n        have : (Ioc u' v \u222a \u22c3\u2080 \u2191I') \\ Ioc u' v = \u22c3\u2080 \u2191I' := by\n          refine Disjoint.sup_sdiff_cancel_left ?_\n          simp only [coe_erase, disjoint_sUnion_right, mem_diff, mem_singleton_iff, and_imp, I']\n          intro u hu hu'\n          exact (h'I hu tI hu').symm\n        simp only [I_eq_insert, coe_insert, sUnion_insert] at h'uv\n        grind\n",
        "body": "```suggestion\n      have UI' : \u22c3\u2080 \u2191I' = Ioc u u' := by\n        have : (Ioc u' v \u222a \u22c3\u2080 \u2191I') \\ Ioc u' v = \u22c3\u2080 \u2191I' := by\n          refine Disjoint.sup_sdiff_cancel_left ?_\n          simp only [coe_erase, disjoint_sUnion_right, mem_diff, mem_singleton_iff, and_imp, I']\n          intro u hu hu'\n          exact (h'I hu tI hu').symm\n        simp only [I_eq_insert, coe_insert, sUnion_insert] at h'uv\n        grind\n```",
        "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "refine",
            "exact",
            "grind",
            "have",
            "simp",
            "intro"
          ],
          "body_tactics": [
            "refine",
            "exact",
            "grind",
            "have",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "refine",
            "simp",
            "intro",
            "exact",
            "grind",
            "have"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "IsSetSemiring",
            "end"
          ]
        }
      },
      {
        "id": 697,
        "before_code": "end IsSetSemiring",
        "suggestion": "      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n",
        "body": "```suggestion\n      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n```",
        "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "grind",
            "have"
          ],
          "body_tactics": [
            "grind",
            "have"
          ],
          "new_tactics": [
            "grind",
            "have"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "IsSetSemiring",
            "end"
          ]
        }
      },
      {
        "id": 729,
        "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
        "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
        "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
        "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "topics": [
            "function",
            "nat",
            "equiv",
            "set_theory",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "rwa",
            "hij",
            "Type",
            "sorted",
            "lt_card_le_iff_apply_le_of_monotone",
            "Function",
            "dual_right",
            "elements",
            "mtr",
            "apply",
            "le_of_not_gt",
            "contrapose",
            "refine",
            "Finset",
            "have",
            "Prop",
            "h_sorted",
            "iff",
            "Equiv",
            "intro",
            "Antitone",
            "by_contra",
            "tuple",
            "card_fin_lt_of_le",
            "lia",
            "toDual",
            "lt_card_ge_iff_apply_ge_of_antitone",
            "for",
            "add_eq_left",
            "h_le",
            "hia",
            "variable",
            "then",
            "card_mono",
            "sumCompl",
            "Preorder",
            "card_subtype",
            "not_lt",
            "card_sum",
            "mem_Iio",
            "card_Iio",
            "card",
            "mem_filter_univ",
            "theorem",
            "exact",
            "card_pos_iff",
            "OrderDual",
            "Monotone",
            "suffices",
            "card_congr"
          ]
        }
      },
      {
        "id": 730,
        "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
        "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
        "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
        "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "topics": [
            "function",
            "nat",
            "equiv",
            "set_theory",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "rwa",
            "hij",
            "Type",
            "sorted",
            "lt_card_le_iff_apply_le_of_monotone",
            "Function",
            "dual_right",
            "elements",
            "mtr",
            "apply",
            "le_of_not_gt",
            "contrapose",
            "refine",
            "Finset",
            "have",
            "Prop",
            "h_sorted",
            "iff",
            "Equiv",
            "intro",
            "Antitone",
            "by_contra",
            "tuple",
            "card_fin_lt_of_le",
            "lia",
            "toDual",
            "lt_card_ge_iff_apply_ge_of_antitone",
            "for",
            "add_eq_left",
            "h_le",
            "hia",
            "variable",
            "then",
            "card_mono",
            "sumCompl",
            "Preorder",
            "card_subtype",
            "not_lt",
            "card_sum",
            "mem_Iio",
            "card_Iio",
            "card",
            "mem_filter_univ",
            "theorem",
            "exact",
            "card_pos_iff",
            "OrderDual",
            "Monotone",
            "suffices",
            "card_congr"
          ]
        }
      },
      {
        "id": 731,
        "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
        "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
        "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
        "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "topics": [
            "function",
            "nat",
            "equiv",
            "set_theory",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "rwa",
            "hij",
            "Type",
            "sorted",
            "lt_card_le_iff_apply_le_of_monotone",
            "Function",
            "dual_right",
            "elements",
            "mtr",
            "apply",
            "le_of_not_gt",
            "contrapose",
            "refine",
            "Finset",
            "have",
            "Prop",
            "h_sorted",
            "iff",
            "Equiv",
            "intro",
            "Antitone",
            "by_contra",
            "tuple",
            "card_fin_lt_of_le",
            "lia",
            "toDual",
            "lt_card_ge_iff_apply_ge_of_antitone",
            "for",
            "add_eq_left",
            "h_le",
            "hia",
            "variable",
            "then",
            "card_mono",
            "sumCompl",
            "Preorder",
            "card_subtype",
            "not_lt",
            "card_sum",
            "mem_Iio",
            "card_Iio",
            "card",
            "mem_filter_univ",
            "theorem",
            "exact",
            "card_pos_iff",
            "OrderDual",
            "Monotone",
            "suffices",
            "card_congr"
          ]
        }
      },
      {
        "id": 732,
        "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
        "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
        "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
        "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "topics": [
            "function",
            "nat",
            "equiv",
            "set_theory",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "rwa",
            "hij",
            "Type",
            "sorted",
            "lt_card_le_iff_apply_le_of_monotone",
            "Function",
            "dual_right",
            "elements",
            "mtr",
            "apply",
            "le_of_not_gt",
            "contrapose",
            "refine",
            "Finset",
            "have",
            "Prop",
            "h_sorted",
            "iff",
            "Equiv",
            "intro",
            "Antitone",
            "by_contra",
            "tuple",
            "card_fin_lt_of_le",
            "lia",
            "toDual",
            "lt_card_ge_iff_apply_ge_of_antitone",
            "for",
            "add_eq_left",
            "h_le",
            "hia",
            "variable",
            "then",
            "card_mono",
            "sumCompl",
            "Preorder",
            "card_subtype",
            "not_lt",
            "card_sum",
            "mem_Iio",
            "card_Iio",
            "card",
            "mem_filter_univ",
            "theorem",
            "exact",
            "card_pos_iff",
            "OrderDual",
            "Monotone",
            "suffices",
            "card_congr"
          ]
        }
      },
      {
        "id": 733,
        "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
        "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
        "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
        "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "topics": [
            "function",
            "nat",
            "equiv",
            "set_theory",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "rwa",
            "hij",
            "Type",
            "sorted",
            "lt_card_le_iff_apply_le_of_monotone",
            "Function",
            "dual_right",
            "elements",
            "mtr",
            "apply",
            "le_of_not_gt",
            "contrapose",
            "refine",
            "Finset",
            "have",
            "Prop",
            "h_sorted",
            "iff",
            "Equiv",
            "intro",
            "Antitone",
            "by_contra",
            "tuple",
            "card_fin_lt_of_le",
            "lia",
            "toDual",
            "lt_card_ge_iff_apply_ge_of_antitone",
            "for",
            "add_eq_left",
            "h_le",
            "hia",
            "variable",
            "then",
            "card_mono",
            "sumCompl",
            "Preorder",
            "card_subtype",
            "not_lt",
            "card_sum",
            "mem_Iio",
            "card_Iio",
            "card",
            "mem_filter_univ",
            "theorem",
            "exact",
            "card_pos_iff",
            "OrderDual",
            "Monotone",
            "suffices",
            "card_congr"
          ]
        }
      },
      {
        "id": 734,
        "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
        "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
        "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
        "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "topics": [
            "function",
            "nat",
            "equiv",
            "set_theory",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "rwa",
            "hij",
            "Type",
            "sorted",
            "lt_card_le_iff_apply_le_of_monotone",
            "Function",
            "dual_right",
            "elements",
            "mtr",
            "apply",
            "le_of_not_gt",
            "contrapose",
            "refine",
            "Finset",
            "have",
            "Prop",
            "h_sorted",
            "iff",
            "Equiv",
            "intro",
            "Antitone",
            "by_contra",
            "tuple",
            "card_fin_lt_of_le",
            "lia",
            "toDual",
            "lt_card_ge_iff_apply_ge_of_antitone",
            "for",
            "add_eq_left",
            "h_le",
            "hia",
            "variable",
            "then",
            "card_mono",
            "sumCompl",
            "Preorder",
            "card_subtype",
            "not_lt",
            "card_sum",
            "mem_Iio",
            "card_Iio",
            "card",
            "mem_filter_univ",
            "theorem",
            "exact",
            "card_pos_iff",
            "OrderDual",
            "Monotone",
            "suffices",
            "card_congr"
          ]
        }
      },
      {
        "id": 735,
        "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
        "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
        "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
        "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "topics": [
            "function",
            "nat",
            "equiv",
            "set_theory",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "rwa",
            "hij",
            "Type",
            "sorted",
            "lt_card_le_iff_apply_le_of_monotone",
            "Function",
            "dual_right",
            "elements",
            "mtr",
            "apply",
            "le_of_not_gt",
            "contrapose",
            "refine",
            "Finset",
            "have",
            "Prop",
            "h_sorted",
            "iff",
            "Equiv",
            "intro",
            "Antitone",
            "by_contra",
            "tuple",
            "card_fin_lt_of_le",
            "lia",
            "toDual",
            "lt_card_ge_iff_apply_ge_of_antitone",
            "for",
            "add_eq_left",
            "h_le",
            "hia",
            "variable",
            "then",
            "card_mono",
            "sumCompl",
            "Preorder",
            "card_subtype",
            "not_lt",
            "card_sum",
            "mem_Iio",
            "card_Iio",
            "card",
            "mem_filter_univ",
            "theorem",
            "exact",
            "card_pos_iff",
            "OrderDual",
            "Monotone",
            "suffices",
            "card_congr"
          ]
        }
      },
      {
        "id": 736,
        "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
        "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
        "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
        "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "exact",
            "have",
            "rw",
            "intro"
          ],
          "topics": [
            "function",
            "nat",
            "equiv",
            "set_theory",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "rwa",
            "hij",
            "Type",
            "sorted",
            "lt_card_le_iff_apply_le_of_monotone",
            "Function",
            "dual_right",
            "elements",
            "mtr",
            "apply",
            "le_of_not_gt",
            "contrapose",
            "refine",
            "Finset",
            "have",
            "Prop",
            "h_sorted",
            "iff",
            "Equiv",
            "intro",
            "Antitone",
            "by_contra",
            "tuple",
            "card_fin_lt_of_le",
            "lia",
            "toDual",
            "lt_card_ge_iff_apply_ge_of_antitone",
            "for",
            "add_eq_left",
            "h_le",
            "hia",
            "variable",
            "then",
            "card_mono",
            "sumCompl",
            "Preorder",
            "card_subtype",
            "not_lt",
            "card_sum",
            "mem_Iio",
            "card_Iio",
            "card",
            "mem_filter_univ",
            "theorem",
            "exact",
            "card_pos_iff",
            "OrderDual",
            "Monotone",
            "suffices",
            "card_congr"
          ]
        }
      },
      {
        "id": 756,
        "before_code": "simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b\u2081, h, \u2190 mul_assoc, mul_comm _ (f a)]",
        "suggestion": "    exact (hki.2 (hs hi hj hij k (by grind))).elim\n",
        "body": "```suggestion\n    exact (hki.2 (hs hi hj hij k (by grind))).elim\n```",
        "path": "Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean",
        "tags": {
          "before_tactics": [
            "rw",
            "simp"
          ],
          "suggestion_tactics": [
            "exact",
            "grind"
          ],
          "body_tactics": [
            "exact",
            "grind"
          ],
          "new_tactics": [
            "exact",
            "grind"
          ],
          "removed_tactics": [
            "rw",
            "simp"
          ],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "mul_assoc",
            "not_true_eq_false",
            "false_and",
            "mem_erase",
            "ne_eq",
            "not_false_eq_true",
            "simp",
            "mul_comm",
            "only",
            "prod_insert"
          ]
        }
      },
      {
        "id": 818,
        "before_code": "simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]",
        "suggestion": "  grind [Finset.card_eq_zero, primeFactors_eq_empty]\n",
        "body": "Looks like this can be:\n```suggestion\n  grind [Finset.card_eq_zero, primeFactors_eq_empty]\n```",
        "path": "Mathlib/Data/Nat/Factorization/PrimePow.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [],
          "topics": [
            "nat",
            "order",
            "finset"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "Finsupp",
            "support_factorization",
            "Nat",
            "pos_iff_ne_zero",
            "card_support_eq_one",
            "simp_rw",
            "isPrimePow_iff_factorization_eq_single"
          ]
        }
      },
      {
        "id": 871,
        "before_code": "have h\u2082 := cos_pi_div_three;\n    have h\u2082 := cos_zero] <;>\n  simp [injOn_cos h_bnd \u27e8by positivity, by linarith [pi_nonneg]\u27e9 (h\u2082 \u25b8 h)]",
        "suggestion": "  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n",
        "body": "```suggestion\n  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n```",
        "path": "Mathlib/NumberTheory/Niven.lean",
        "tags": {
          "before_tactics": [
            "positivity",
            "have",
            "simp",
            "linarith"
          ],
          "suggestion_tactics": [
            "apply",
            "gcongr",
            "grind",
            "have",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "body_tactics": [
            "apply",
            "gcongr",
            "grind",
            "have",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "new_tactics": [
            "apply",
            "gcongr",
            "grind",
            "simpa",
            "obtain",
            "constructor",
            "simp_all",
            "norm_cast"
          ],
          "removed_tactics": [
            "positivity",
            "simp",
            "linarith"
          ],
          "topics": [],
          "transforms": [
            "use_simpa",
            "use_grind"
          ],
          "keywords": [
            "injOn_cos",
            "cos_pi_div_three",
            "positivity",
            "pi_nonneg",
            "have",
            "h_bnd",
            "simp",
            "linarith",
            "cos_zero"
          ]
        }
      },
      {
        "id": 910,
        "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
        "suggestion": "          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_injOn hvs').mono (by grind)\n        case i_surj => grind [card_image_of_injOn, hvs'.mono]\n        case h =>\n          rw [eq_comm]\n          exact prod_image <| by grind [hvs'.mono]\n",
        "body": "```suggestion\n          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_in",
        "path": "Mathlib/LinearAlgebra/Lagrange.lean",
        "tags": {
          "before_tactics": [
            "exact"
          ],
          "suggestion_tactics": [
            "exact",
            "grind",
            "rw",
            "refine"
          ],
          "body_tactics": [
            "refine",
            "exact",
            "grind",
            "rw",
            "intro",
            "omega"
          ],
          "new_tactics": [
            "grind",
            "rw",
            "refine"
          ],
          "removed_tactics": [],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_omega",
            "use_grind"
          ],
          "keywords": [
            "mpr",
            "sdiff_singleton_eq_erase",
            "exact",
            "insert_subset_iff",
            "singleton_subset_iff"
          ]
        }
      },
      {
        "id": 928,
        "before_code": "lemma not_monotone_not_antitone_iff_exists_le_le :\n    \u00ac Monotone f \u2227 \u00ac Antitone f \u2194\n      \u2203 a b c, a \u2264 b \u2227 b \u2264 c \u2227 ((f a < f b \u2227 f c < f b) \u2228 (f b < f a \u2227 f b < f c)) := by\n  simp_rw [Monotone, Antitone, not_forall, not_le]\n  refine Iff.symm \u27e8?_, ?_\u27e9\n  \u00b7 rintro \u27e8a, b, c, hab, hbc, \u27e8hfab, hfcb\u27e9 | \u27e8hfba, hfbc\u27e9\u27e9\n    exacts [\u27e8\u27e8_, _, hbc, hfcb\u27e9, _, _, hab, hfab\u27e9, \u27e8\u27e8_, _, hab, hfba\u27e9, _, _, hbc, hfbc\u27e9]\n  rintro \u27e8\u27e8a, b, hab, hfba\u27e9, c, d, hcd, hfcd\u27e9\n  obtain hda | had := le_total d a\n  \u00b7 obtain hfad | hfda := le_total (f a) (f d)\n    \u00b7 exact \u27e8c, d, b, hcd, hda.trans hab, Or.inl \u27e8hfcd, hfba.trans_le hfad\u27e9\u27e9\n    \u00b7 exact \u27e8c, a, b, hcd.trans hda, hab, Or.inl \u27e8hfcd.trans_le hfda, hfba\u27e9\u27e9\n  obtain hac | hca := le_total a c\n  \u00b7 obtain hfdb | hfbd := le_or_gt (f d) (f b)\n    \u00b7 exact \u27e8a, c, d, hac, hcd, Or.inr \u27e8hfcd.trans <| hfdb.trans_lt hfba, hfcd\u27e9\u27e9\n    obtain hfca | hfac := lt_or_ge (f c) (f a)\n    \u00b7 exact \u27e8a, c, d, hac, hcd, Or.inr \u27e8hfca, hfcd\u27e9\u27e9\n    obtain hbd | hdb := le_total b d\n    \u00b7 exact \u27e8a, b, d, hab, hbd, Or.inr \u27e8hfba, hfbd\u27e9\u27e9\n    \u00b7 exact \u27e8a, d, b, had, hdb, Or.inl \u27e8hfac.trans_lt hfcd, hfbd\u27e9\u27e9\n  \u00b7 obtain hfdb | hfbd := le_or_gt (f d) (f b)\n    \u00b7 exact \u27e8c, a, b, hca, hab, Or.inl \u27e8hfcd.trans <| hfdb.trans_lt hfba, hfba\u27e9\u27e9\n    obtain hfca | hfac := lt_or_ge (f c) (f a)\n    \u00b7 exact \u27e8c, a, b, hca, hab, Or.inl \u27e8hfca, hfba\u27e9\u27e9\n    obtain hbd | hdb := le_total b d\n    \u00b7 exact \u27e8a, b, d, hab, hbd, Or.inr \u27e8hfba, hfbd\u27e9\u27e9\n    \u00b7 exact \u27e8a, d, b, had, hdb, Or.inl \u27e8hfac.trans_lt hfcd, hfbd\u27e9\u27e9",
        "suggestion": "  simp only [Monotone, Antitone]\n  grind [not_le]\n",
        "body": "Let's make it clear that `grind` only needs to know about `not_le`, especially as the pattern `grind [foo, bar, baz]` can be a bit brittle to changes in `grind`\n```suggestion\n  simp only [Monotone, Antitone]\n  grind [not_le]\n```",
        "path": "Mathlib/Order/Monotone/Basic.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain",
            "refine"
          ],
          "suggestion_tactics": [
            "grind",
            "simp"
          ],
          "body_tactics": [
            "grind",
            "simp"
          ],
          "new_tactics": [
            "grind",
            "simp"
          ],
          "removed_tactics": [
            "exact",
            "obtain",
            "refine"
          ],
          "topics": [
            "order"
          ],
          "transforms": [
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "lemma",
            "hca",
            "rintro",
            "Iff",
            "hfcb",
            "obtain",
            "hfac",
            "lt_or_ge",
            "inl",
            "hfba",
            "exacts",
            "symm",
            "refine",
            "not_le",
            "hfca",
            "hfbd",
            "Antitone",
            "simp_rw",
            "trans_le",
            "hfab",
            "hda",
            "hab",
            "hcd",
            "had",
            "not_monotone_not_antitone_iff_exists_le_le",
            "hbc",
            "hfbc",
            "hfdb",
            "hac",
            "le_total",
            "hfad",
            "exact",
            "Monotone",
            "hfcd",
            "le_or_gt",
            "not_forall",
            "trans",
            "hbd",
            "hdb",
            "trans_lt",
            "hfda",
            "inr"
          ]
        }
      },
      {
        "id": 1050,
        "before_code": "convert (sum_map _ (addRightEmbedding k) (\u00b7.choose k)).symm using 2\n  rw [map_add_right_Ico, zero_add, add_right_comm, Ico_add_one_right_eq_Icc]",
        "suggestion": "\r\nlemma sum_range_multichoose (n k : \u2115) :\r\n    \u2211 i \u2208 Finset.range (n + 1), k.multichoose i = (n + k).choose k := by\r\n  cases k with\r\n  | zero => simp [Finset.sum_range_succ']\r\n  | succ k => grind [multichoose_eq, choose_symm_of_eq_add, sum_range_add_choose]\r\n",
        "body": "```suggestion\r\nlemma sum_range_multichoose (n k : \u2115) :\r\n    \u2211 i \u2208 Finset.range (n + 1), k.multichoose i = (n + k).choose k := by\r\n  cases k with\r\n  | zero => simp [Finset.sum_range_succ']\r\n  | succ k => grind [multichoose_eq, choose_symm_of_eq_add, sum_range_add_choose]\r\n```\r\nThis theorem can be proved in a shorter way, and with fewer assumptions. \r\n(Also, I think patterns like `simp only [\u2190 h1 \u25b8 h2 \u25b8 (sum_Icc_choose (n + (k - 1)) (k - 1))` should be avoided from mathlib, since they're pretty to",
        "path": "Mathlib/Data/Nat/Choose/Sum.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "grind",
            "cases",
            "simp"
          ],
          "body_tactics": [
            "grind",
            "cases",
            "simp"
          ],
          "new_tactics": [
            "grind",
            "cases",
            "simp"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "Ico_add_one_right_eq_Icc",
            "addRightEmbedding",
            "symm",
            "convert",
            "zero_add",
            "add_right_comm",
            "choose",
            "sum_map",
            "map_add_right_Ico",
            "using"
          ]
        }
      },
      {
        "id": 1119,
        "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
        "suggestion": "\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    exact (one_ne_zero heq).elim\r\n",
        "body": "Here's a slight golf.\r\n```suggestion\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at he",
        "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "refine",
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "refine",
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "refine",
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [
            "finset",
            "nat"
          ],
          "transforms": [
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "two_pos",
            "mul_div_mul_left",
            "mul_pos",
            "card_comm_eq_card_conjClasses_mul_card",
            "card_commute_odd",
            "Nat",
            "pos",
            "mul_div_left",
            "mul_comm",
            "nat_card"
          ]
        }
      },
      {
        "id": 1121,
        "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
        "suggestion": "\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n",
        "body": "```suggestion\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n```\r\nThis is slightly shorter.",
        "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "refine",
            "grind",
            "cases",
            "have",
            "rw",
            "simp_all",
            "simp"
          ],
          "body_tactics": [
            "refine",
            "grind",
            "cases",
            "have",
            "rw",
            "simp_all",
            "simp"
          ],
          "new_tactics": [
            "refine",
            "grind",
            "cases",
            "have",
            "simp_all",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [
            "finset",
            "nat"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "two_pos",
            "mul_div_mul_left",
            "mul_pos",
            "card_comm_eq_card_conjClasses_mul_card",
            "card_commute_odd",
            "Nat",
            "pos",
            "mul_div_left",
            "mul_comm",
            "nat_card"
          ]
        }
      },
      {
        "id": 1122,
        "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
        "suggestion": "  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n",
        "body": "```suggestion\n  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n```",
        "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "grind",
            "simp_all",
            "have",
            "simp"
          ],
          "body_tactics": [
            "grind",
            "simp_all",
            "have",
            "simp"
          ],
          "new_tactics": [
            "grind",
            "have",
            "simp",
            "simp_all"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "finset",
            "nat"
          ],
          "transforms": [
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "two_pos",
            "mul_div_mul_left",
            "mul_pos",
            "card_comm_eq_card_conjClasses_mul_card",
            "card_commute_odd",
            "Nat",
            "pos",
            "mul_div_left",
            "mul_comm",
            "nat_card"
          ]
        }
      },
      {
        "id": 1142,
        "before_code": "@[simp]\ntheorem filter_ne_eq_erase' (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : f.filter (i \u2260 \u00b7) = f.erase i := by\n  rw [\u2190 filter_ne_eq_erase f i]\n  congr with j\n  exact ne_comm",
        "suggestion": "\r\n  ext; grind\r\n",
        "body": "```suggestion\r\n  ext; grind\r\n```\r\n\r\nIn the meantime, it is preferable to the one-liner `ext; grind`. (also `filter_ne_eq_erase` while you're at it)",
        "path": "Mathlib/Data/DFinsupp/Defs.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "congr",
            "rw",
            "simp"
          ],
          "suggestion_tactics": [
            "grind",
            "ext"
          ],
          "body_tactics": [
            "grind",
            "ext"
          ],
          "new_tactics": [
            "grind",
            "ext"
          ],
          "removed_tactics": [
            "exact",
            "congr",
            "rw",
            "simp"
          ],
          "topics": [],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "filter_ne_eq_erase",
            "erase",
            "theorem",
            "exact",
            "filter",
            "ne_comm",
            "simp",
            "congr"
          ]
        }
      },
      {
        "id": 1201,
        "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
        "suggestion": "\r\n  \u00b7 simp [\u2190 PrimeSpectrum.iSup_basicOpen_eq_top_iff, TopologicalSpace.Opens.ext_iff, Set.ext_iff]\r\n    grind\r\n",
        "body": "```suggestion\r\n  \u00b7 simp [\u2190 PrimeSpectrum.iSup_basicOpen_eq_top_iff, TopologicalSpace.Opens.ext_iff, Set.ext_iff]\r\n    grind\r\n```",
        "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
        "tags": {
          "before_tactics": [
            "refine",
            "simp"
          ],
          "suggestion_tactics": [
            "grind",
            "simp"
          ],
          "body_tactics": [
            "grind",
            "simp"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "refine"
          ],
          "topics": [
            "set_theory",
            "order",
            "algebra"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "Module",
            "inferInstance",
            "empty",
            "Basis",
            "refine",
            "Empty",
            "Set",
            "simp",
            "range_subset_iff"
          ]
        }
      },
      {
        "id": 1263,
        "before_code": "F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]",
        "suggestion": "\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n",
        "body": "```suggestion\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n```\r\nvery minor, but this way you don\u2019t have to guess what the `rwa` is proving from the source.",
        "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind",
            "have"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "isoAdd",
            "inv",
            "shiftFunctorAdd",
            "app",
            "_eq_shiftFunctorAdd",
            "map",
            "simp",
            "_inv_app",
            "only"
          ]
        }
      },
      {
        "id": 1387,
        "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
        "suggestion": "\r\ntheorem support_bot : (\u22a5 : SimpleGraph V).support = \u2205 := by\r\n  grind only [mem_support, Set.mem_empty_iff_false, bot_adj]\r\n",
        "body": "```suggestion\r\ntheorem support_bot : (\u22a5 : SimpleGraph V).support = \u2205 := by\r\n  grind only [mem_support, Set.mem_empty_iff_false, bot_adj]\r\n```",
        "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_grind"
          ],
          "keywords": [
            "SetRel",
            "support",
            "_uv",
            "theorem",
            "dom_mono",
            "huv",
            "support_mono",
            "SimpleGraph"
          ]
        }
      },
      {
        "id": 1658,
        "before_code": "Nat.cast_mul]\n      ring",
        "suggestion": "\r\ntheorem iterate_derivative_derivative_mul_X_pow {n m l : \u2115} (p : R[X]) (hl : m \u2264 l) :\r\n    derivative^[n] (derivative^[l] p * X ^ m) =\r\n      \u2211 k \u2208 range (min m n).succ,\r\n        ((n.choose k * m.descFactorial k) \u2022 (derivative^[n + (l - k)] p * X ^ (m - k))) := by\r\n  have {k : \u2115} (hk : k \u2208 range (min m n).succ) : n - k + l = n + (l - k) := by\r\n    replace hk : k \u2264 m \u2227 k \u2264 n := by simpa using hk\r\n    grind\r\n  simp_rw [iterate_derivative_mul_X_pow, \u2190 Function.iterate_add_apply]\r\n  exact Finset.sum_congr rfl fun k hk \u21a6 by simp [this hk]\r\n",
        "body": "I'm also dubious about this lemma since it's really just an extension of `iterate_derivative_mul_X_pow` which inlines a proof that `n + (m - k) = n - k + m` for `k` in the right range.\r\n\r\nOf course convenience lemmas can be justified if they come up enough. If you do have compelling evidence in favour then I think we should generalise since the repeated `m` is not relevant, and also avoid using low-level lemmas like `Nat.add_sub_assoc` as follows:\r\n```suggestion\r\ntheorem iterate_derivative_deriv",
        "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
        "tags": {
          "before_tactics": [
            "ring"
          ],
          "suggestion_tactics": [
            "exact",
            "grind",
            "have",
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "exact",
            "grind",
            "have",
            "simpa",
            "simp"
          ],
          "new_tactics": [
            "exact",
            "grind",
            "have",
            "simpa",
            "simp"
          ],
          "removed_tactics": [
            "ring"
          ],
          "topics": [
            "nat",
            "algebra"
          ],
          "transforms": [
            "use_simpa",
            "use_grind"
          ],
          "keywords": [
            "Nat",
            "ring",
            "cast_mul"
          ]
        }
      },
      {
        "id": 1679,
        "before_code": "theorem uniqueProd_apply [Preorder \u03b1] [Unique \u03b1] [LE \u03b2] (x : \u03b1 \u00d7\u2097 \u03b2) :\n    uniqueProd \u03b1 \u03b2 x = (ofLex x).2 := rfl",
        "suggestion": "\r\n    simp only [Prod.Lex.le_iff, Prod.Lex.lt_iff, Equiv.trans_apply, Equiv.prodCongr_apply,\r\n      Equiv.prodAssoc_apply]\r\n    grind [EmbeddingLike.apply_eq_iff_eq, ofLex_toLex]\r\n",
        "body": "```suggestion\r\n    simp only [Prod.Lex.le_iff, Prod.Lex.lt_iff, Equiv.trans_apply, Equiv.prodCongr_apply,\r\n      Equiv.prodAssoc_apply]\r\n    grind [EmbeddingLike.apply_eq_iff_eq, ofLex_toLex]\r\n```",
        "path": "Mathlib/Order/Hom/Lex.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "grind",
            "simp"
          ],
          "body_tactics": [
            "grind",
            "simp"
          ],
          "new_tactics": [
            "grind",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "ofLex",
            "theorem",
            "uniqueProd",
            "Preorder",
            "rfl",
            "Unique",
            "uniqueProd_apply"
          ]
        }
      },
      {
        "id": 1727,
        "before_code": "lemma reciprocalFactors_odd {n : \u2115} (h1 : n \u2260 1) (h2 : Odd n) :\n    reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1) := by\n  have h0 : n \u2260 0 := by\n    rintro rfl\n    norm_num [\u2190 Nat.not_even_iff_odd] at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.not_even_iff_odd.2 h2)]",
        "suggestion": "\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n",
        "body": "this is 10x slower than the previous proof. What about changing it to something like this?\r\n```suggestion\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n```\r\nso same as before, but the `n \u2260 0` is by `grind`.",
        "path": "Mathlib/GroupTheory/CommutingProbability.lean",
        "tags": {
          "before_tactics": [
            "norm_num",
            "rw",
            "have"
          ],
          "suggestion_tactics": [
            "simpa",
            "grind",
            "rw"
          ],
          "body_tactics": [
            "simpa",
            "grind",
            "rw"
          ],
          "new_tactics": [
            "simpa",
            "grind"
          ],
          "removed_tactics": [
            "norm_num",
            "have"
          ],
          "topics": [
            "nat",
            "norm"
          ],
          "transforms": [
            "use_simpa",
            "use_grind"
          ],
          "keywords": [
            "norm_num",
            "reciprocalFactors_odd",
            "lemma",
            "reciprocalFactors",
            "not_even_iff_odd",
            "Odd",
            "Nat",
            "dif_neg",
            "have",
            "rintro",
            "if_neg",
            "rfl"
          ]
        }
      },
      {
        "id": 1873,
        "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
        "suggestion": "/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced := by\n  rw [IsSimplyLaced, IsSimplyLaced, Pairwise, Pairwise, forall_comm]\n  aesop\n\ntheorem isSimplyLaced_A (n : \u2115) : IsSimplyLaced (A n) := by\n  intro i j h\n  simp only [A, of_apply]\n  grind\n\ntheorem isSimplyLaced_D (n : \u2115) : IsSimplyLaced (D n) := by\n  intro i j h\n  simp only [D, of_apply]\n  grind\n\ntheorem isSimplyLaced_E\u2086 : IsSimplyLaced E\u2086 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2086] at h \u22a2\n\ntheorem isSimplyLaced_E\u2087 : IsSimplyLaced E\u2087 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2087] at h \u22a2\n\ntheorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2\n",
        "body": "I've never seen being symmetric as a definition of begin simply laced before. Where does this come from?\n\nI would have expected something like:\n```suggestion\n/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced :",
        "path": "Mathlib/Data/Matrix/Cartan.lean",
        "tags": {
          "before_tactics": [
            "decide",
            "simp"
          ],
          "suggestion_tactics": [
            "aesop",
            "grind",
            "fin_cases",
            "rw",
            "simp",
            "intro"
          ],
          "body_tactics": [
            "aesop",
            "grind",
            "have",
            "fin_cases",
            "rw",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "aesop",
            "grind",
            "fin_cases",
            "rw",
            "intro"
          ],
          "removed_tactics": [
            "decide"
          ],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_aesop",
            "use_grind"
          ],
          "keywords": [
            "decide",
            "transpose",
            "simp",
            "theorem"
          ]
        }
      },
      {
        "id": 1906,
        "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
        "suggestion": "  obtain \u27e8\u27e8hF : F \u2264 G, hF' : F.IsAcyclic\u27e9, h\u27e9 := by simpa [Maximal] using h\n  ext u v\n  refine \u27e8fun h \u21a6 h.mono hF, ?_\u27e9\n  contrapose! h\n  obtain \u27e8\u27e8p : G.Walk u v\u27e9, h : \u00ac F.Reachable u v\u27e9 := h\n  let s : Set V := F.connectedComponentMk u\n  have hus : u \u2208 s := ConnectedComponent.connectedComponentMk_mem\n  have hvs : v \u2209 s := h \u2218 (F.connectedComponentMk u).reachable_of_mem_supp hus\n  obtain \u27e8\u27e8\u27e8u', v'\u27e9, huv : G.Adj u' v'\u27e9, -, hu : u' \u2208 s, hv : v' \u2209 s\u27e9 :=\n    p.exists_boundary_dart s hus hvs\n  suffices (F \u2294 fromEdgeSet {s(u', v')}).IsAcyclic by\n    refine \u27e8F \u2294 fromEdgeSet {s(u', v')}, ?_, this, le_sup_left, ?_\u27e9\n    \u00b7 have : G.Adj v' u' := G.symm huv\n      simp only [sup_le_iff, le_iff_adj, fromEdgeSet_adj, Set.mem_singleton_iff, Sym2.eq,\n        Sym2.rel_iff'] at hF \u22a2\n      grind\n    \u00b7 rw [le_iff_adj]\n      push_neg\n      refine \u27e8u', v', ?_, fun hc \u21a6 ?_\u27e9\n      \u00b7 simpa using Or.inr huv.ne\n      \u00b7 have := (F.connectedComponentMk u).mem_supp_congr_adj hc\n        grind\n  suffices \u00ac F.Reachable u'",
        "body": "The following is a slight golf. I was not trying to make it shorter though: I was trying to make it slightly more idiomatic and readable. I think what I've got is still not great but is acceptable (as was yours already). Two minor points I highlight are:\n\n- I've added various redundant type ascriptions (e.g., to the `obtain`s). These aid readability for a human.\n- I've use the `ext` tactic rather than directly calling the underlying very low-level `funext`, `propext`\n\nI also note that [Maximal](",
        "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain"
          ],
          "suggestion_tactics": [
            "refine",
            "ext",
            "exact",
            "grind",
            "have",
            "simpa",
            "obtain",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "funext",
            "refine",
            "ext",
            "exact",
            "grind",
            "have",
            "simpa",
            "obtain",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "refine",
            "ext",
            "grind",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa",
            "remove_redundant",
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "isTree_of_minimal_connected",
            "exact",
            "hmin",
            "exists_le_minimal",
            "obtain",
            "Connected",
            "hTG",
            "toFinite",
            "SimpleGraph"
          ]
        }
      },
      {
        "id": 1941,
        "before_code": "rcases h\u03be with \u27e8i, hin, hi, H\u27e9\n    exact \u27e8i, \u27e8hin, hi.symm\u27e9, H\u27e9",
        "suggestion": "\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n",
        "body": "```suggestion\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n```\r\nI think it\u2019s better practice to inline the \"haves\" when in term mode with a non-prop goal like this.\r\n\r\nalso, added the `@[simps! apply_coe]` adds the lemma saying that you\u2019re i",
        "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "cases"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "exact",
            "cases"
          ],
          "topics": [],
          "transforms": [
            "term_mode",
            "use_grind"
          ],
          "keywords": [
            "exact",
            "rcases",
            "symm",
            "hin"
          ]
        }
      }
    ],
    "use_fun_prop": [
      {
        "id": 94,
        "before_code": "simpa [map_coe, OrderHom.coe_mk, Set.range_comp]\n    using hf (by simp) (Set.range_nonempty _) (isChain_range c).directedOn (isLUB_range_\u03c9Sup c)",
        "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
        "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```\r\nThis way, the `fun_id` lemma is also tagged with fun_prop.",
        "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "simp"
          ],
          "suggestion_tactics": [
            "fun_prop",
            "simp"
          ],
          "body_tactics": [
            "fun_prop",
            "simp"
          ],
          "new_tactics": [
            "fun_prop"
          ],
          "removed_tactics": [
            "simpa"
          ],
          "topics": [
            "set_theory",
            "order"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "OrderHom",
            "range_comp",
            "map_coe",
            "coe_mk",
            "Set",
            "directedOn",
            "simpa",
            "simp",
            "range_nonempty",
            "isChain_range",
            "using"
          ]
        }
      },
      {
        "id": 95,
        "before_code": "inter_eq_self_of_subset_right (Ici_subset_Ici.2 hab)]\n  exact isLeast_Ici\n\n@[simp] lemma ScottContinuousOn.id : ScottContinuousOn D (id : \u03b1 \u2192 \u03b1) := by simp [ScottContinuousOn]\n\nvariable {g : \u03b1 \u2192 \u03b2}\n\nlemma ScottContinuousOn.prodMk (hD : \u2200 a b : \u03b1, a \u2264 b \u2192 {a, b} \u2208 D)",
        "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
        "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```",
        "path": "Mathlib/Order/ScottContinuity.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "simp"
          ],
          "suggestion_tactics": [
            "fun_prop",
            "simp"
          ],
          "body_tactics": [
            "fun_prop",
            "simp"
          ],
          "new_tactics": [
            "fun_prop"
          ],
          "removed_tactics": [
            "exact"
          ],
          "topics": [
            "continuity",
            "set_theory"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "Ici_subset_Ici",
            "inter_eq_self_of_subset_right",
            "lemma",
            "variable",
            "exact",
            "ScottContinuousOn",
            "hab",
            "isLeast_Ici",
            "simp",
            "prodMk"
          ]
        }
      },
      {
        "id": 1449,
        "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
        "suggestion": "\r\n      all_goals clear IH H U hU; fun_prop (disch := simp_all)\r\n",
        "body": "This is quite slow because the context here includes a lot of complicated stuff, and `simp_all` simplifies everything it sees (it has no way to determine which parts of the context are relevant and which aren't). The following speeds it up substantially:\r\n```suggestion\r\n      all_goals clear IH H U hU; fun_prop (disch := simp_all)\r\n```\r\nIt's still slower than the hand-rolled proof but I think it's tolerable.",
        "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "fun_prop",
            "simp_all"
          ],
          "body_tactics": [
            "fun_prop",
            "simp_all"
          ],
          "new_tactics": [
            "fun_prop",
            "simp_all"
          ],
          "removed_tactics": [],
          "topics": [
            "list"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "deriv_comp_neg",
            "neg_smul",
            "deriv_fun_const_smul",
            "iteratedDeriv"
          ]
        }
      },
      {
        "id": 1588,
        "before_code": "end Language\n\nend FirstOrder",
        "suggestion": "\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.const M C) :=\r\n  (TermDefinable.const C).termDefinable\u2081\r\n",
        "body": "Generalize\r\n\r\n```suggestion\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.c",
        "path": "Mathlib/ModelTheory/Definability.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "fun_prop",
            "simp"
          ],
          "body_tactics": [
            "fun_prop",
            "simp"
          ],
          "new_tactics": [
            "fun_prop",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_fun_prop"
          ],
          "keywords": [
            "FirstOrder",
            "end",
            "Language"
          ]
        }
      },
      {
        "id": 1589,
        "before_code": "end Language\n\nend FirstOrder",
        "suggestion": "\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp {f g : M \u2192 M} (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable\u2081 L g) :\r\n    A.TermDefinable\u2081 L (f \u2218 g) :=\r\n  (hf.termDefinable.comp fun _ \u21a6 hg.termDefinable).termDefinable\u2081\r\n\r\n/-- A `TermDefinable` function postcomposed with `TermDefinable\u2081` is `TermDefinable`. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp_termDefinable {f : M \u2192 M} {g : (\u03b1 \u2192 M) \u2192 M}\r\n    (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable L g) : A.TermDefinable L (f \u2218 g) :=\r\n  hf.termDefinable.comp fun _ \u21a6 hg\r\n",
        "body": "```suggestion\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop",
        "path": "Mathlib/ModelTheory/Definability.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "fun_prop",
            "obtain",
            "funext",
            "simp"
          ],
          "body_tactics": [
            "fun_prop",
            "obtain",
            "funext",
            "simp"
          ],
          "new_tactics": [
            "fun_prop",
            "obtain",
            "funext",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_fun_prop"
          ],
          "keywords": [
            "FirstOrder",
            "end",
            "Language"
          ]
        }
      },
      {
        "id": 1642,
        "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
        "suggestion": "  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n",
        "body": "I would like to reformat this to make it easier to distinguish the different arguments. I originally thought this was one argument to `mkCLM`.\n```suggestion\n  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n```\nThen indent the remainder of the proof, and remove the final `)`.",
        "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "ext",
            "simpa",
            "simp",
            "intro",
            "fun_prop"
          ],
          "body_tactics": [
            "ext",
            "simpa",
            "simp",
            "intro",
            "fun_prop"
          ],
          "new_tactics": [
            "simpa",
            "simp",
            "ext",
            "intro",
            "fun_prop"
          ],
          "removed_tactics": [],
          "topics": [
            "continuity"
          ],
          "transforms": [
            "use_simpa",
            "use_fun_prop"
          ],
          "keywords": [
            "theorem",
            "pairing_continuous_left",
            "pairing",
            "continuous",
            "flip",
            "Continuous"
          ]
        }
      },
      {
        "id": 1685,
        "before_code": "end derivWeierstrassP",
        "suggestion": "\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n",
        "body": "For this sort of argument (where `fun_prop` can't quite close the goal alone), I find it works well to put auxiliary facts into the context and then run `fun_prop` with a custom discharger:\r\n ```suggestion\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n```",
        "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "simpa",
            "fun_prop",
            "have",
            "simp"
          ],
          "body_tactics": [
            "simpa",
            "fun_prop",
            "have",
            "simp"
          ],
          "new_tactics": [
            "simpa",
            "fun_prop",
            "have",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa",
            "use_fun_prop"
          ],
          "keywords": [
            "derivWeierstrassP",
            "end"
          ]
        }
      },
      {
        "id": 1686,
        "before_code": "end derivWeierstrassP",
        "suggestion": "\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n",
        "body": "We can use more automation here too:\r\n```suggestion\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n```",
        "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "funext",
            "exact",
            "have",
            "simp",
            "fun_prop"
          ],
          "body_tactics": [
            "funext",
            "exact",
            "have",
            "simp",
            "fun_prop"
          ],
          "new_tactics": [
            "funext",
            "simp",
            "exact",
            "fun_prop",
            "have"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "derivWeierstrassP",
            "end"
          ]
        }
      },
      {
        "id": 2172,
        "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
        "suggestion": "    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
        "body": "```suggestion\n    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
        "path": "Mathlib/NumberTheory/Chebyshev.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "refine",
            "exact",
            "have",
            "fun_prop",
            "linarith",
            "congr"
          ],
          "body_tactics": [
            "refine",
            "exact",
            "have",
            "fun_prop",
            "linarith",
            "congr"
          ],
          "new_tactics": [
            "refine",
            "exact",
            "congr",
            "have",
            "linarith",
            "fun_prop"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [],
          "transforms": [
            "use_linarith",
            "use_fun_prop"
          ],
          "keywords": [
            "vonMangoldt_apply_prime",
            "simp"
          ]
        }
      },
      {
        "id": 2315,
        "before_code": "(by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n\nend MeromorphicOn",
        "suggestion": "@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3)) :\n    Meromorphic (\u2211 n \u2208 s, G n) := fun x \u21a6 MeromorphicAt.sum (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma sub (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f - g) := fun x \u21a6 (hf x).sub (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma mul {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f * g) := fun x \u21a6 (hf x).mul (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem prod (h : \u2200 \u03c3, Meromorphic (F \u03c3)) :\n    Meromorphic (\u220f n \u2208 s, F n) := fun x \u21a6 MeromorphicAt.prod (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma div {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f / g) := fun x \u21a6 (hf x).div (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma pow",
        "body": "There is some new metaprogramming that can help here: the `to_fun` attribute.\nTo get access, you need to add `import Mathlib.Tactic.ToFun` to the imports (doesn't need `public`).\n\n```suggestion\n@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3",
        "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "fun_prop"
          ],
          "body_tactics": [
            "fun_prop"
          ],
          "new_tactics": [
            "fun_prop"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "measurability",
            "set_theory"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "restrict",
            "measurable_of_countable",
            "end",
            "mem_compl_iff",
            "simp",
            "MeromorphicOn",
            "measurable"
          ]
        }
      },
      {
        "id": 2854,
        "before_code": "simpa [map_coe, OrderHom.coe_mk, Set.range_comp]\n    using hf (by simp) (Set.range_nonempty _) (isChain_range c).directedOn (isLUB_range_\u03c9Sup c)",
        "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
        "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```\r\nThis way, the `fun_id` lemma is also tagged with fun_prop.",
        "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "simp"
          ],
          "suggestion_tactics": [
            "fun_prop",
            "simp"
          ],
          "body_tactics": [
            "fun_prop",
            "simp"
          ],
          "new_tactics": [
            "fun_prop"
          ],
          "removed_tactics": [
            "simpa"
          ],
          "topics": [
            "set_theory",
            "order"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "OrderHom",
            "range_comp",
            "map_coe",
            "coe_mk",
            "Set",
            "directedOn",
            "simpa",
            "simp",
            "range_nonempty",
            "isChain_range",
            "using"
          ]
        }
      },
      {
        "id": 2855,
        "before_code": "inter_eq_self_of_subset_right (Ici_subset_Ici.2 hab)]\n  exact isLeast_Ici\n\n@[simp] lemma ScottContinuousOn.id : ScottContinuousOn D (id : \u03b1 \u2192 \u03b1) := by simp [ScottContinuousOn]\n\nvariable {g : \u03b1 \u2192 \u03b2}\n\nlemma ScottContinuousOn.prodMk (hD : \u2200 a b : \u03b1, a \u2264 b \u2192 {a, b} \u2208 D)",
        "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
        "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```",
        "path": "Mathlib/Order/ScottContinuity.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "simp"
          ],
          "suggestion_tactics": [
            "fun_prop",
            "simp"
          ],
          "body_tactics": [
            "fun_prop",
            "simp"
          ],
          "new_tactics": [
            "fun_prop"
          ],
          "removed_tactics": [
            "exact"
          ],
          "topics": [
            "continuity",
            "set_theory"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "Ici_subset_Ici",
            "inter_eq_self_of_subset_right",
            "lemma",
            "variable",
            "exact",
            "ScottContinuousOn",
            "hab",
            "isLeast_Ici",
            "simp",
            "prodMk"
          ]
        }
      },
      {
        "id": 2950,
        "before_code": "rw [\u2190 sub_pos] at hR\n    rcases eq_or_ne x 0 with rfl | hx\n    \u00b7 have A : ContinuousAt (fun p : \u211d \u00d7 E \u21a6 (p.1 - \u2016p.2\u2016) / (p.1 - 1)) (R, 0) :=\n        (continuousAt_fst.sub continuousAt_snd.norm).div\n          (continuousAt_fst.sub continuousAt_const) hR.ne'",
        "suggestion": "\r\n        by fun_prop (disch := grind)\r\n",
        "body": "Can't this be\r\n```suggestion\r\n        by fun_prop (disch := grind)\r\n```\r\nor similar with a weaker discharger?",
        "path": "Mathlib/Analysis/Calculus/BumpFunction/InnerProduct.lean",
        "tags": {
          "before_tactics": [
            "cases",
            "rw",
            "have"
          ],
          "suggestion_tactics": [
            "grind",
            "fun_prop"
          ],
          "body_tactics": [
            "grind",
            "fun_prop"
          ],
          "new_tactics": [
            "grind",
            "fun_prop"
          ],
          "removed_tactics": [
            "cases",
            "rw",
            "have"
          ],
          "topics": [
            "continuity",
            "real",
            "list",
            "norm"
          ],
          "transforms": [
            "use_fun_prop",
            "use_grind"
          ],
          "keywords": [
            "sub",
            "ContinuousAt",
            "have",
            "sub_pos",
            "div",
            "continuousAt_fst",
            "rcases",
            "norm",
            "rfl",
            "eq_or_ne",
            "continuousAt_snd",
            "continuousAt_const"
          ]
        }
      },
      {
        "id": 2952,
        "before_code": "congr 1\n      exact (norm_of_nonneg (posf _ _ x hx)).symm\n    \u00b7 refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi\n      refine (Continuous.continuousOn ?_).mul (continuousOn_of_forall_continuousAt fun x hx => ?_)\n      \u00b7 exact continuous_exp.comp (continuous_const.mul continuous_id')\n      \u00b7 exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')",
        "suggestion": "\r\n      refine .mul (by fun_prop)\r\n",
        "body": "```suggestion\r\n      refine .mul (by fun_prop)\r\n```\r\nmaybe?",
        "path": "Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "congr",
            "refine"
          ],
          "suggestion_tactics": [
            "fun_prop",
            "refine"
          ],
          "body_tactics": [
            "fun_prop",
            "refine"
          ],
          "new_tactics": [
            "fun_prop"
          ],
          "removed_tactics": [
            "exact",
            "congr"
          ],
          "topics": [
            "continuity",
            "list",
            "norm",
            "set_theory",
            "measurability"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "mem_Ioi",
            "posf",
            "ContinuousOn",
            "inl",
            "mul",
            "aestronglyMeasurable",
            "symm",
            "continuous_exp",
            "norm_of_nonneg",
            "refine",
            "continuousAt_rpow_const",
            "Continuous",
            "continuous_id",
            "continuousOn_of_forall_continuousAt",
            "continuous_const",
            "comp",
            "measurableSet_Ioi",
            "congr",
            "exact",
            "continuousOn"
          ]
        }
      },
      {
        "id": 3370,
        "before_code": "end Language\n\nend FirstOrder",
        "suggestion": "\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.const M C) :=\r\n  (TermDefinable.const C).termDefinable\u2081\r\n",
        "body": "Generalize\r\n\r\n```suggestion\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.c",
        "path": "Mathlib/ModelTheory/Definability.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "fun_prop",
            "simp"
          ],
          "body_tactics": [
            "fun_prop",
            "simp"
          ],
          "new_tactics": [
            "fun_prop",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_fun_prop"
          ],
          "keywords": [
            "FirstOrder",
            "end",
            "Language"
          ]
        }
      },
      {
        "id": 3371,
        "before_code": "end Language\n\nend FirstOrder",
        "suggestion": "\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp {f g : M \u2192 M} (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable\u2081 L g) :\r\n    A.TermDefinable\u2081 L (f \u2218 g) :=\r\n  (hf.termDefinable.comp fun _ \u21a6 hg.termDefinable).termDefinable\u2081\r\n\r\n/-- A `TermDefinable` function postcomposed with `TermDefinable\u2081` is `TermDefinable`. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp_termDefinable {f : M \u2192 M} {g : (\u03b1 \u2192 M) \u2192 M}\r\n    (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable L g) : A.TermDefinable L (f \u2218 g) :=\r\n  hf.termDefinable.comp fun _ \u21a6 hg\r\n",
        "body": "```suggestion\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop",
        "path": "Mathlib/ModelTheory/Definability.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "fun_prop",
            "obtain",
            "funext",
            "simp"
          ],
          "body_tactics": [
            "fun_prop",
            "obtain",
            "funext",
            "simp"
          ],
          "new_tactics": [
            "fun_prop",
            "obtain",
            "funext",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_fun_prop"
          ],
          "keywords": [
            "FirstOrder",
            "end",
            "Language"
          ]
        }
      },
      {
        "id": 3386,
        "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
        "suggestion": "  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n",
        "body": "I would like to reformat this to make it easier to distinguish the different arguments. I originally thought this was one argument to `mkCLM`.\n```suggestion\n  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n```\nThen indent the remainder of the proof, and remove the final `)`.",
        "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "ext",
            "simpa",
            "simp",
            "intro",
            "fun_prop"
          ],
          "body_tactics": [
            "ext",
            "simpa",
            "simp",
            "intro",
            "fun_prop"
          ],
          "new_tactics": [
            "simpa",
            "simp",
            "ext",
            "intro",
            "fun_prop"
          ],
          "removed_tactics": [],
          "topics": [
            "continuity"
          ],
          "transforms": [
            "use_simpa",
            "use_fun_prop"
          ],
          "keywords": [
            "theorem",
            "pairing_continuous_left",
            "pairing",
            "continuous",
            "flip",
            "Continuous"
          ]
        }
      },
      {
        "id": 3401,
        "before_code": "end derivWeierstrassP",
        "suggestion": "\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n",
        "body": "For this sort of argument (where `fun_prop` can't quite close the goal alone), I find it works well to put auxiliary facts into the context and then run `fun_prop` with a custom discharger:\r\n ```suggestion\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n```",
        "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "simpa",
            "fun_prop",
            "have",
            "simp"
          ],
          "body_tactics": [
            "simpa",
            "fun_prop",
            "have",
            "simp"
          ],
          "new_tactics": [
            "simpa",
            "fun_prop",
            "have",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa",
            "use_fun_prop"
          ],
          "keywords": [
            "derivWeierstrassP",
            "end"
          ]
        }
      },
      {
        "id": 3402,
        "before_code": "end derivWeierstrassP",
        "suggestion": "\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n",
        "body": "We can use more automation here too:\r\n```suggestion\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n```",
        "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "funext",
            "exact",
            "have",
            "simp",
            "fun_prop"
          ],
          "body_tactics": [
            "funext",
            "exact",
            "have",
            "simp",
            "fun_prop"
          ],
          "new_tactics": [
            "funext",
            "simp",
            "exact",
            "fun_prop",
            "have"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "derivWeierstrassP",
            "end"
          ]
        }
      },
      {
        "id": 3579,
        "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
        "suggestion": "    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
        "body": "```suggestion\n    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
        "path": "Mathlib/NumberTheory/Chebyshev.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "refine",
            "exact",
            "have",
            "fun_prop",
            "linarith",
            "congr"
          ],
          "body_tactics": [
            "refine",
            "exact",
            "have",
            "fun_prop",
            "linarith",
            "congr"
          ],
          "new_tactics": [
            "refine",
            "exact",
            "congr",
            "have",
            "linarith",
            "fun_prop"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [],
          "transforms": [
            "use_linarith",
            "use_fun_prop"
          ],
          "keywords": [
            "vonMangoldt_apply_prime",
            "simp"
          ]
        }
      },
      {
        "id": 3637,
        "before_code": "(by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n\nend MeromorphicOn",
        "suggestion": "@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3)) :\n    Meromorphic (\u2211 n \u2208 s, G n) := fun x \u21a6 MeromorphicAt.sum (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma sub (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f - g) := fun x \u21a6 (hf x).sub (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma mul {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f * g) := fun x \u21a6 (hf x).mul (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem prod (h : \u2200 \u03c3, Meromorphic (F \u03c3)) :\n    Meromorphic (\u220f n \u2208 s, F n) := fun x \u21a6 MeromorphicAt.prod (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma div {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f / g) := fun x \u21a6 (hf x).div (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma pow",
        "body": "There is some new metaprogramming that can help here: the `to_fun` attribute.\nTo get access, you need to add `import Mathlib.Tactic.ToFun` to the imports (doesn't need `public`).\n\n```suggestion\n@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3",
        "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "fun_prop"
          ],
          "body_tactics": [
            "fun_prop"
          ],
          "new_tactics": [
            "fun_prop"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "measurability",
            "set_theory"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "restrict",
            "measurable_of_countable",
            "end",
            "mem_compl_iff",
            "simp",
            "MeromorphicOn",
            "measurable"
          ]
        }
      },
      {
        "id": 3924,
        "before_code": "refine Continuous.if_le ?_ ?_ (continuous_subtype_val.comp continuous_snd) continuous_const ?_\n  \u00b7 change\n      Continuous ((fun p : \u03b9 \u00d7 \u211d => (\u03b3\u2081 p.1).extend p.2) \u2218 Prod.map id (fun x => 2 * x : I \u2192 \u211d))\n    exact h\u2081'.comp (continuous_id.prodMap <| continuous_const.mul continuous_subtype_val)",
        "suggestion": "\r\n    fun_prop\r\n",
        "body": "What's wrong with\r\n```suggestion\r\n    fun_prop\r\n```\r\n?",
        "path": "Mathlib/Topology/Path.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "refine"
          ],
          "suggestion_tactics": [
            "fun_prop"
          ],
          "body_tactics": [
            "fun_prop"
          ],
          "new_tactics": [
            "fun_prop"
          ],
          "removed_tactics": [
            "exact",
            "refine"
          ],
          "topics": [
            "continuity",
            "real",
            "list"
          ],
          "transforms": [
            "use_fun_prop"
          ],
          "keywords": [
            "continuous_snd",
            "prodMap",
            "refine",
            "continuous_subtype_val",
            "Prod",
            "extend",
            "continuous_id",
            "exact",
            "change",
            "continuous_const",
            "map",
            "if_le",
            "comp",
            "Continuous",
            "mul"
          ]
        }
      }
    ],
    "use_aesop": [
      {
        "id": 188,
        "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
        "suggestion": "\r\n    by_cases hn' : n \u2264 Nat.card \u03b1\r\n    \u00b7 apply IsPretransitive.of_surjective_map\r\n        (compl_bijective (alternatingGroup \u03b1) \u03b1 _).surjective this\r\n      aesop\r\n",
        "body": "I think `by_cases` makes more sense than `wlog` here.\r\n```suggestion\r\n    by_cases hn' : n \u2264 Nat.card \u03b1\r\n    \u00b7 apply IsPretransitive.of_surjective_map\r\n        (compl_bijective (alternatingGroup \u03b1) \u03b1 _).surjective this\r\n      aesop\r\n```",
        "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain"
          ],
          "suggestion_tactics": [
            "apply",
            "aesop"
          ],
          "body_tactics": [
            "apply",
            "aesop"
          ],
          "new_tactics": [
            "apply",
            "aesop"
          ],
          "removed_tactics": [
            "exact",
            "obtain"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "exact",
            "Finset",
            "card_eq_one",
            "obtain",
            "rfl"
          ]
        }
      },
      {
        "id": 576,
        "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
        "suggestion": "\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (m * z + n + 1)) =\r\n    1 / (m * z - b) - 1 / (m * z + b) := by\r\n  convert telescope_aux' b (fun n \u21a6 1 / ((m : \u2102) * z + n)) using 2 <;>\r\n  simp [add_assoc, sub_eq_add_neg]\r\n",
        "body": "I'd suggest splitting this up:\r\n```suggestion\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "rw"
          ],
          "suggestion_tactics": [
            "aesop",
            "grind",
            "induction",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "grind",
            "induction",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "grind",
            "aesop",
            "induction",
            "simp"
          ],
          "removed_tactics": [
            "simpa"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "cleanup_simp",
            "use_aesop",
            "use_grind"
          ],
          "keywords": [
            "neg",
            "summable_e2Summand_symmetricIcc",
            "tsum_symmetricIcc_eq_tsum_symmetricIco",
            "simpa",
            "comp",
            "tendsto_e2Summand_atTop_nhds_zero",
            "tendsto_natCast_atTop_atTop",
            "using"
          ]
        }
      },
      {
        "id": 581,
        "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
        "suggestion": "\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n",
        "body": "```suggestion\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n```\r\nAlso the capitalization is inconsistent: `Summable_cotTerm` is a proof of summability, not a statement of summability, so it should be lowercase \u2013 please change it wherever it's defined and here to match.",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "rw"
          ],
          "suggestion_tactics": [
            "simpa",
            "aesop",
            "have"
          ],
          "body_tactics": [
            "simpa",
            "aesop",
            "have"
          ],
          "new_tactics": [
            "aesop",
            "have"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_simpa",
            "use_aesop"
          ],
          "keywords": [
            "neg",
            "summable_e2Summand_symmetricIcc",
            "tsum_symmetricIcc_eq_tsum_symmetricIco",
            "simpa",
            "comp",
            "tendsto_e2Summand_atTop_nhds_zero",
            "tendsto_natCast_atTop_atTop",
            "using"
          ]
        }
      },
      {
        "id": 654,
        "before_code": ".of_isCoveringMap_subtype (by simp) _ isCoveringMap_exp\n\nend Complex",
        "suggestion": "\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n",
        "body": "```suggestion\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n```",
        "path": "Mathlib/Analysis/Complex/CoveringMap.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "aesop",
            "simp",
            "ext"
          ],
          "body_tactics": [
            "aesop",
            "simp",
            "ext"
          ],
          "new_tactics": [
            "aesop",
            "ext"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "of_isCoveringMap_subtype",
            "end",
            "Complex",
            "simp",
            "isCoveringMap_exp"
          ]
        }
      },
      {
        "id": 667,
        "before_code": "(hx : \u2200 r : R, r \u2022 x \u2208 Submodule.span R s \u2192 r = 0) : LinearIndepOn R id (insert x s) :=\n  hs.insert' <| by simpa",
        "suggestion": "/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?_\n  have aux (j : \u03b9) (hjs : j \u2208 s) (hji : j \u2260 i) : g j * (f i) (v j) = 0 := by simp [h1 hji.symm]\n  simpa [s.sum_eq_single i aux (by aesop), h2 i] using congr_arg (f i) hrel\n",
        "body": "Just a few minor style tweaks:\n```suggestion\n/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?",
        "path": "Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean",
        "tags": {
          "before_tactics": [
            "simpa"
          ],
          "suggestion_tactics": [
            "aesop",
            "refine",
            "have",
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "refine",
            "have",
            "simpa",
            "simp"
          ],
          "new_tactics": [
            "have",
            "aesop",
            "simp",
            "refine"
          ],
          "removed_tactics": [],
          "topics": [
            "algebra"
          ],
          "transforms": [
            "use_simpa",
            "use_aesop"
          ],
          "keywords": [
            "insert",
            "LinearIndepOn",
            "span",
            "simpa",
            "Submodule"
          ]
        }
      },
      {
        "id": 1084,
        "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
        "suggestion": "\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n",
        "body": "Untested, but something like this should work?\r\n```suggestion\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n```",
        "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "aesop",
            "rw",
            "refine"
          ],
          "body_tactics": [
            "aesop",
            "rw",
            "refine"
          ],
          "new_tactics": [
            "aesop",
            "rw",
            "refine"
          ],
          "removed_tactics": [],
          "topics": [
            "set_theory",
            "order"
          ],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "_ha",
            "mem_top",
            "le_top",
            "theorem"
          ]
        }
      },
      {
        "id": 1104,
        "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
        "suggestion": "\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n",
        "body": "(I don't know if this is recommended, but you _can_ technically do this in one line:\r\n```suggestion\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n```\r\n)\r\nProbably over-golfed though... so less of a suggestion, and more of an observation I guess",
        "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "aesop",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "simp"
          ],
          "new_tactics": [
            "aesop",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [
            "topology"
          ],
          "transforms": [
            "cleanup_simp",
            "use_aesop"
          ],
          "keywords": [
            "CompleteSpace",
            "instOrthogonalCompleteSpace",
            "isClosed_orthogonal",
            "instance",
            "completeSpace_coe"
          ]
        }
      },
      {
        "id": 1554,
        "before_code": "simp only [ContinuousLinearMap.ext_iff, ContinuousLinearMap.comp_apply] at hg'inv hg'invf \u22a2\n  simp [ContinuousLinearEquiv.eq_symm_apply, *]",
        "suggestion": "  simp_rw [nhds_prod_eq]\n  apply \u03c6.implicitFunction_apply_image.prod_mk \u03c6.prod_map_implicitFunction |>.mono\n  aesop\n",
        "body": "I'm proposing we drop this lemma but I'll note in passing that the proof can be just:\n```suggestion\n  simp_rw [nhds_prod_eq]\n  apply \u03c6.implicitFunction_apply_image.prod_mk \u03c6.prod_map_implicitFunction |>.mono\n  aesop\n```",
        "path": "Mathlib/Analysis/Calculus/Implicit.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "apply",
            "aesop"
          ],
          "body_tactics": [
            "apply",
            "aesop"
          ],
          "new_tactics": [
            "apply",
            "aesop"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "continuity"
          ],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "ContinuousLinearEquiv",
            "eq_symm_apply",
            "ext_iff",
            "ContinuousLinearMap",
            "inv",
            "comp_apply",
            "invf",
            "simp",
            "only"
          ]
        }
      },
      {
        "id": 1556,
        "before_code": "\u00b7 rw [h1]\n  \u00b7 rfl",
        "suggestion": "theorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitFunction xy.1 = xy.2 := by\n  refine h.implicitFunctionData.hasStrictFDerivAt.eventually_left_inverse.mono fun xy h\u2081 h\u2082 \u21a6 ?_\n  change (h.implicitFunctionData.implicitFunction xy.1 (f a)).2 = xy.2\n  change h.implicitFunctionData.implicitFunction xy.1 (f xy) = xy at h\u2081\n  aesop\n",
        "body": "I strongly encourage you to embrace the existing API for `ImplicitFunctionData`. You're currently fighting it quite a bit in this proof. I prefer the following golf not so much because it is shorter but because it makes it clear that this is really just a wrapper around `ImplicitFunctionData.hasStrictFDerivAt` and `HasStrictFDerivAt.eventually_left_inverse`:\n```suggestion\ntheorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitF",
        "path": "Mathlib/Analysis/Calculus/ImplicitContDiff.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "aesop",
            "refine"
          ],
          "body_tactics": [
            "aesop",
            "refine",
            "simp"
          ],
          "new_tactics": [
            "aesop",
            "refine"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "rfl"
          ]
        }
      },
      {
        "id": 1661,
        "before_code": "Nat.cast_mul]\n      ring",
        "suggestion": "theorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n    simp_rw [iterate_derivative_mul, iterate_derivative_X_pow_eq_smul, mul_smul]\n    congr! 2 with k hk\n    norm_cast\n    ring\n  rw [hsum]\n  refine sum_congr_of_eq_on_inter (fun k hk hk' \u21a6 ?_) (by aesop) (by simp)\n  rcases le_or_gt k m with hkm | hkm\n  \u00b7 replace hk' : n < k := by simpa [hkm] using hk'\n    simp [Nat.choose_eq_zero_of_lt hk']\n  \u00b7 simp [Nat.descFactorial_eq_zero_iff_lt.mpr hkm]\n",
        "body": "Here's a slight golf. It's happens to be shorter but my main aim was to make the formal proof match how I think about this argument a bit more closely:\n```suggestion\ntheorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivati",
        "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
        "tags": {
          "before_tactics": [
            "ring"
          ],
          "suggestion_tactics": [
            "aesop",
            "refine",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "congr",
            "ring",
            "norm_cast"
          ],
          "body_tactics": [
            "aesop",
            "refine",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "congr",
            "ring",
            "norm_cast"
          ],
          "new_tactics": [
            "aesop",
            "refine",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "congr",
            "norm_cast"
          ],
          "removed_tactics": [],
          "topics": [
            "nat",
            "algebra"
          ],
          "transforms": [
            "use_simpa",
            "use_ring",
            "use_aesop"
          ],
          "keywords": [
            "Nat",
            "ring",
            "cast_mul"
          ]
        }
      },
      {
        "id": 1773,
        "before_code": "natDegree (\u2211 i \u2208 s, f i) \u2264 n :=\n  le_trans (natDegree_sum_le s f) <| (Finset.fold_max_le n).mpr <| by simpa",
        "suggestion": "  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n",
        "body": "```suggestion\n  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n```",
        "path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
        "tags": {
          "before_tactics": [
            "simpa"
          ],
          "suggestion_tactics": [
            "apply",
            "obtain",
            "aesop",
            "simp_all"
          ],
          "body_tactics": [
            "apply",
            "obtain",
            "aesop",
            "simp_all"
          ],
          "new_tactics": [
            "apply",
            "obtain",
            "aesop",
            "simp_all"
          ],
          "removed_tactics": [
            "simpa"
          ],
          "topics": [
            "order",
            "finset"
          ],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "natDegree_sum_le",
            "natDegree",
            "mpr",
            "fold_max_le",
            "Finset",
            "simpa",
            "le_trans"
          ]
        }
      },
      {
        "id": 1873,
        "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
        "suggestion": "/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced := by\n  rw [IsSimplyLaced, IsSimplyLaced, Pairwise, Pairwise, forall_comm]\n  aesop\n\ntheorem isSimplyLaced_A (n : \u2115) : IsSimplyLaced (A n) := by\n  intro i j h\n  simp only [A, of_apply]\n  grind\n\ntheorem isSimplyLaced_D (n : \u2115) : IsSimplyLaced (D n) := by\n  intro i j h\n  simp only [D, of_apply]\n  grind\n\ntheorem isSimplyLaced_E\u2086 : IsSimplyLaced E\u2086 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2086] at h \u22a2\n\ntheorem isSimplyLaced_E\u2087 : IsSimplyLaced E\u2087 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2087] at h \u22a2\n\ntheorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2\n",
        "body": "I've never seen being symmetric as a definition of begin simply laced before. Where does this come from?\n\nI would have expected something like:\n```suggestion\n/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced :",
        "path": "Mathlib/Data/Matrix/Cartan.lean",
        "tags": {
          "before_tactics": [
            "decide",
            "simp"
          ],
          "suggestion_tactics": [
            "aesop",
            "grind",
            "fin_cases",
            "rw",
            "simp",
            "intro"
          ],
          "body_tactics": [
            "aesop",
            "grind",
            "have",
            "fin_cases",
            "rw",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "aesop",
            "grind",
            "fin_cases",
            "rw",
            "intro"
          ],
          "removed_tactics": [
            "decide"
          ],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_aesop",
            "use_grind"
          ],
          "keywords": [
            "decide",
            "transpose",
            "simp",
            "theorem"
          ]
        }
      },
      {
        "id": 1899,
        "before_code": "protected lemma Preconnected.mono {G G' : SimpleGraph V} (h : G \u2264 G') (hG : G.Preconnected) :\n    G'.Preconnected := fun u v => (hG u v).mono h",
        "suggestion": "  aesop (add simp Preconnected)\n",
        "body": "```suggestion\n  aesop (add simp Preconnected)\n```",
        "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Connected.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "aesop",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "simp"
          ],
          "new_tactics": [
            "aesop",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "lemma",
            "mono",
            "protected",
            "Preconnected",
            "SimpleGraph"
          ]
        }
      },
      {
        "id": 2148,
        "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
        "suggestion": "\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _)]\r\n  aesop\r\n",
        "body": "I'm not a fan of `simp only [massive list of stuff] at *`, it seems a bit of a \"scattergun\" approach. Here's a shorter and cleaner version:\r\n```suggestion\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "apply",
            "simp",
            "norm_cast"
          ],
          "suggestion_tactics": [
            "apply",
            "aesop",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "apply",
            "aesop",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "aesop",
            "rw",
            "have"
          ],
          "removed_tactics": [
            "norm_cast"
          ],
          "topics": [
            "norm",
            "real",
            "int"
          ],
          "transforms": [
            "use_simpa",
            "cleanup_simp",
            "use_aesop"
          ],
          "keywords": [
            "only",
            "apply",
            "pow_two",
            "Real",
            "norm_cast",
            "abs_mul_abs_self",
            "simpa",
            "Summable",
            "simp",
            "summable_inv_of_isBigO_rpow_inv",
            "sub_eq_add_neg",
            "using",
            "mul",
            "comp_neg_int",
            "rpow_two",
            "linear_inv_isBigO_right"
          ]
        }
      },
      {
        "id": 2245,
        "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
        "suggestion": "  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n",
        "body": "It's easier if you case split on whether the range of the function from the subtype is bounded above or not.\n```suggestion\n  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n```",
        "path": "Mathlib/Topology/Order/IsLUB.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "aesop",
            "refine",
            "exact",
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "refine",
            "exact",
            "simpa",
            "simp"
          ],
          "new_tactics": [
            "simpa",
            "aesop",
            "refine",
            "simp",
            "exact"
          ],
          "removed_tactics": [],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_simpa",
            "use_aesop"
          ],
          "keywords": [
            "IsGLB",
            "isLUB_inter_iff"
          ]
        }
      },
      {
        "id": 2607,
        "before_code": "end",
        "suggestion": "\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map f \u226b\r\n    (PreservesCoproduct.iso F _).hom \u226b (Sigma.mapIso fun b \u21a6 hf').hom\r\n  letI g_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map g\r\n  haveI H' : f_new \u226b g_new = 0 := by\r\n    simp_rw [f_new, g_new, Category.assoc, Iso.hom_inv_id_assoc,\r\n      Preadditive.IsIso.comp_left_eq_zero, IsHomLift.eq_of_isHomLift F (F.map f \u226b F.map g) (f \u226b g),\r\n      H, Functor.map_zero]\r\n  letI h' : IsColimit (CokernelCofork.of\u03c0 g_new H') := by\r\n    refine IsColimit.ofIsoColimit ((IsColimit.precomposeHom",
        "body": "This suggestion uses the modification suggested above for `Presentation.isColimit`\r\n\r\n```suggestion\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_ne",
        "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "apply",
            "aesop",
            "refine",
            "ext",
            "exact",
            "cases",
            "have",
            "simp",
            "intro"
          ],
          "body_tactics": [
            "apply",
            "aesop",
            "refine",
            "ext",
            "exact",
            "cases",
            "have",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "apply",
            "aesop",
            "refine",
            "ext",
            "exact",
            "cases",
            "have",
            "simp",
            "intro"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "end"
          ]
        }
      },
      {
        "id": 2743,
        "before_code": "theorem isCompact_generateFrom' [T : TopologicalSpace X]\n    {S : Set (Set X)} (hTS : T = generateFrom S) {s : Set X}\n    (h : \u2200 (\u03b9 : Type u) (U : \u03b9 \u2192 S), s \u2286 \u22c3 i, U i \u2192 \u2203 J : Set \u03b9, J.Finite \u2227 s \u2286 \u22c3 i \u2208 J, U i) :\n    IsCompact s := by\n  apply isCompact_generateFrom hTS\n  intro P hP hs\n  rw [Set.sUnion_eq_iUnion] at hs\n  obtain \u27e8J, hJ, cover\u27e9 := h P (fun a \u21a6 \u27e8a.1, hP a.2\u27e9) hs\n  refine \u27e8(fun x \u21a6 x.1) '' J, \u27e8by simp, Set.Finite.image _ hJ, ?_\u27e9\u27e9\n  simpa only [Set.sUnion_eq_iUnion, Set.iUnion_coe_set, Set.mem_image, Subtype.exists,\n    exists_and_right, exists_eq_right, Set.iUnion_exists] using cover",
        "suggestion": "\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n",
        "body": "```suggestion\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n```",
        "path": "Mathlib/Topology/Compactness/Compact.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "simpa",
            "obtain",
            "rw",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "aesop",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "simp"
          ],
          "new_tactics": [
            "aesop"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "simpa",
            "obtain",
            "rw",
            "intro"
          ],
          "topics": [
            "set_theory",
            "topology"
          ],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "Subtype",
            "exists_eq_right",
            "Type",
            "obtain",
            "exists",
            "apply",
            "refine",
            "intro",
            "sUnion_eq_iUnion",
            "IsCompact",
            "hTS",
            "TopologicalSpace",
            "exists_and_right",
            "simp",
            "generateFrom",
            "only",
            "isCompact_generateFrom",
            "Finite",
            "cover",
            "mem_image",
            "theorem",
            "Set",
            "iUnion_coe_set",
            "simpa",
            "image",
            "iUnion_exists",
            "using"
          ]
        }
      },
      {
        "id": 3020,
        "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
        "suggestion": "\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (m * z + n + 1)) =\r\n    1 / (m * z - b) - 1 / (m * z + b) := by\r\n  convert telescope_aux' b (fun n \u21a6 1 / ((m : \u2102) * z + n)) using 2 <;>\r\n  simp [add_assoc, sub_eq_add_neg]\r\n",
        "body": "I'd suggest splitting this up:\r\n```suggestion\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "rw"
          ],
          "suggestion_tactics": [
            "aesop",
            "grind",
            "induction",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "grind",
            "induction",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "grind",
            "aesop",
            "induction",
            "simp"
          ],
          "removed_tactics": [
            "simpa"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "cleanup_simp",
            "use_aesop",
            "use_grind"
          ],
          "keywords": [
            "neg",
            "summable_e2Summand_symmetricIcc",
            "tsum_symmetricIcc_eq_tsum_symmetricIco",
            "simpa",
            "comp",
            "tendsto_e2Summand_atTop_nhds_zero",
            "tendsto_natCast_atTop_atTop",
            "using"
          ]
        }
      },
      {
        "id": 3021,
        "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
        "suggestion": "\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n",
        "body": "```suggestion\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n```\r\nAlso the capitalization is inconsistent: `Summable_cotTerm` is a proof of summability, not a statement of summability, so it should be lowercase \u2013 please change it wherever it's defined and here to match.",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "rw"
          ],
          "suggestion_tactics": [
            "simpa",
            "aesop",
            "have"
          ],
          "body_tactics": [
            "simpa",
            "aesop",
            "have"
          ],
          "new_tactics": [
            "aesop",
            "have"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "finset"
          ],
          "transforms": [
            "use_simpa",
            "use_aesop"
          ],
          "keywords": [
            "neg",
            "summable_e2Summand_symmetricIcc",
            "tsum_symmetricIcc_eq_tsum_symmetricIco",
            "simpa",
            "comp",
            "tendsto_e2Summand_atTop_nhds_zero",
            "tendsto_natCast_atTop_atTop",
            "using"
          ]
        }
      },
      {
        "id": 3045,
        "before_code": ".of_isCoveringMap_subtype (by simp) _ isCoveringMap_exp\n\nend Complex",
        "suggestion": "\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n",
        "body": "```suggestion\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n```",
        "path": "Mathlib/Analysis/Complex/CoveringMap.lean",
        "tags": {
          "before_tactics": [
            "simp"
          ],
          "suggestion_tactics": [
            "aesop",
            "simp",
            "ext"
          ],
          "body_tactics": [
            "aesop",
            "simp",
            "ext"
          ],
          "new_tactics": [
            "aesop",
            "ext"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "of_isCoveringMap_subtype",
            "end",
            "Complex",
            "simp",
            "isCoveringMap_exp"
          ]
        }
      },
      {
        "id": 3056,
        "before_code": "(hx : \u2200 r : R, r \u2022 x \u2208 Submodule.span R s \u2192 r = 0) : LinearIndepOn R id (insert x s) :=\n  hs.insert' <| by simpa",
        "suggestion": "/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?_\n  have aux (j : \u03b9) (hjs : j \u2208 s) (hji : j \u2260 i) : g j * (f i) (v j) = 0 := by simp [h1 hji.symm]\n  simpa [s.sum_eq_single i aux (by aesop), h2 i] using congr_arg (f i) hrel\n",
        "body": "Just a few minor style tweaks:\n```suggestion\n/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?",
        "path": "Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean",
        "tags": {
          "before_tactics": [
            "simpa"
          ],
          "suggestion_tactics": [
            "aesop",
            "refine",
            "have",
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "refine",
            "have",
            "simpa",
            "simp"
          ],
          "new_tactics": [
            "have",
            "aesop",
            "simp",
            "refine"
          ],
          "removed_tactics": [],
          "topics": [
            "algebra"
          ],
          "transforms": [
            "use_simpa",
            "use_aesop"
          ],
          "keywords": [
            "insert",
            "LinearIndepOn",
            "span",
            "simpa",
            "Submodule"
          ]
        }
      },
      {
        "id": 3194,
        "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
        "suggestion": "\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n",
        "body": "Untested, but something like this should work?\r\n```suggestion\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n```",
        "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "aesop",
            "rw",
            "refine"
          ],
          "body_tactics": [
            "aesop",
            "rw",
            "refine"
          ],
          "new_tactics": [
            "aesop",
            "rw",
            "refine"
          ],
          "removed_tactics": [],
          "topics": [
            "set_theory",
            "order"
          ],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "_ha",
            "mem_top",
            "le_top",
            "theorem"
          ]
        }
      },
      {
        "id": 3199,
        "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
        "suggestion": "\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n",
        "body": "(I don't know if this is recommended, but you _can_ technically do this in one line:\r\n```suggestion\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n```\r\n)\r\nProbably over-golfed though... so less of a suggestion, and more of an observation I guess",
        "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "aesop",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "simp"
          ],
          "new_tactics": [
            "aesop",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [
            "topology"
          ],
          "transforms": [
            "cleanup_simp",
            "use_aesop"
          ],
          "keywords": [
            "CompleteSpace",
            "instOrthogonalCompleteSpace",
            "isClosed_orthogonal",
            "instance",
            "completeSpace_coe"
          ]
        }
      },
      {
        "id": 3356,
        "before_code": "\u00b7 rw [h1]\n  \u00b7 rfl",
        "suggestion": "theorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitFunction xy.1 = xy.2 := by\n  refine h.implicitFunctionData.hasStrictFDerivAt.eventually_left_inverse.mono fun xy h\u2081 h\u2082 \u21a6 ?_\n  change (h.implicitFunctionData.implicitFunction xy.1 (f a)).2 = xy.2\n  change h.implicitFunctionData.implicitFunction xy.1 (f xy) = xy at h\u2081\n  aesop\n",
        "body": "I strongly encourage you to embrace the existing API for `ImplicitFunctionData`. You're currently fighting it quite a bit in this proof. I prefer the following golf not so much because it is shorter but because it makes it clear that this is really just a wrapper around `ImplicitFunctionData.hasStrictFDerivAt` and `HasStrictFDerivAt.eventually_left_inverse`:\n```suggestion\ntheorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitF",
        "path": "Mathlib/Analysis/Calculus/ImplicitContDiff.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "aesop",
            "refine"
          ],
          "body_tactics": [
            "aesop",
            "refine",
            "simp"
          ],
          "new_tactics": [
            "aesop",
            "refine"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "rfl"
          ]
        }
      },
      {
        "id": 3395,
        "before_code": "Nat.cast_mul]\n      ring",
        "suggestion": "theorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n    simp_rw [iterate_derivative_mul, iterate_derivative_X_pow_eq_smul, mul_smul]\n    congr! 2 with k hk\n    norm_cast\n    ring\n  rw [hsum]\n  refine sum_congr_of_eq_on_inter (fun k hk hk' \u21a6 ?_) (by aesop) (by simp)\n  rcases le_or_gt k m with hkm | hkm\n  \u00b7 replace hk' : n < k := by simpa [hkm] using hk'\n    simp [Nat.choose_eq_zero_of_lt hk']\n  \u00b7 simp [Nat.descFactorial_eq_zero_iff_lt.mpr hkm]\n",
        "body": "Here's a slight golf. It's happens to be shorter but my main aim was to make the formal proof match how I think about this argument a bit more closely:\n```suggestion\ntheorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivati",
        "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
        "tags": {
          "before_tactics": [
            "ring"
          ],
          "suggestion_tactics": [
            "aesop",
            "refine",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "congr",
            "ring",
            "norm_cast"
          ],
          "body_tactics": [
            "aesop",
            "refine",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "congr",
            "ring",
            "norm_cast"
          ],
          "new_tactics": [
            "aesop",
            "refine",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "congr",
            "norm_cast"
          ],
          "removed_tactics": [],
          "topics": [
            "nat",
            "algebra"
          ],
          "transforms": [
            "use_simpa",
            "use_ring",
            "use_aesop"
          ],
          "keywords": [
            "Nat",
            "ring",
            "cast_mul"
          ]
        }
      },
      {
        "id": 3426,
        "before_code": "natDegree (\u2211 i \u2208 s, f i) \u2264 n :=\n  le_trans (natDegree_sum_le s f) <| (Finset.fold_max_le n).mpr <| by simpa",
        "suggestion": "  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n",
        "body": "```suggestion\n  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n```",
        "path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
        "tags": {
          "before_tactics": [
            "simpa"
          ],
          "suggestion_tactics": [
            "apply",
            "obtain",
            "aesop",
            "simp_all"
          ],
          "body_tactics": [
            "apply",
            "obtain",
            "aesop",
            "simp_all"
          ],
          "new_tactics": [
            "apply",
            "obtain",
            "aesop",
            "simp_all"
          ],
          "removed_tactics": [
            "simpa"
          ],
          "topics": [
            "order",
            "finset"
          ],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "natDegree_sum_le",
            "natDegree",
            "mpr",
            "fold_max_le",
            "Finset",
            "simpa",
            "le_trans"
          ]
        }
      },
      {
        "id": 3461,
        "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
        "suggestion": "/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced := by\n  rw [IsSimplyLaced, IsSimplyLaced, Pairwise, Pairwise, forall_comm]\n  aesop\n\ntheorem isSimplyLaced_A (n : \u2115) : IsSimplyLaced (A n) := by\n  intro i j h\n  simp only [A, of_apply]\n  grind\n\ntheorem isSimplyLaced_D (n : \u2115) : IsSimplyLaced (D n) := by\n  intro i j h\n  simp only [D, of_apply]\n  grind\n\ntheorem isSimplyLaced_E\u2086 : IsSimplyLaced E\u2086 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2086] at h \u22a2\n\ntheorem isSimplyLaced_E\u2087 : IsSimplyLaced E\u2087 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2087] at h \u22a2\n\ntheorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2\n",
        "body": "I've never seen being symmetric as a definition of begin simply laced before. Where does this come from?\n\nI would have expected something like:\n```suggestion\n/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced :",
        "path": "Mathlib/Data/Matrix/Cartan.lean",
        "tags": {
          "before_tactics": [
            "decide",
            "simp"
          ],
          "suggestion_tactics": [
            "aesop",
            "grind",
            "fin_cases",
            "rw",
            "simp",
            "intro"
          ],
          "body_tactics": [
            "aesop",
            "grind",
            "have",
            "fin_cases",
            "rw",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "aesop",
            "grind",
            "fin_cases",
            "rw",
            "intro"
          ],
          "removed_tactics": [
            "decide"
          ],
          "topics": [],
          "transforms": [
            "cleanup_simp",
            "use_aesop",
            "use_grind"
          ],
          "keywords": [
            "decide",
            "transpose",
            "simp",
            "theorem"
          ]
        }
      },
      {
        "id": 3557,
        "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
        "suggestion": "\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _)]\r\n  aesop\r\n",
        "body": "I'm not a fan of `simp only [massive list of stuff] at *`, it seems a bit of a \"scattergun\" approach. Here's a shorter and cleaner version:\r\n```suggestion\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _",
        "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
        "tags": {
          "before_tactics": [
            "simpa",
            "apply",
            "simp",
            "norm_cast"
          ],
          "suggestion_tactics": [
            "apply",
            "aesop",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "apply",
            "aesop",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "aesop",
            "rw",
            "have"
          ],
          "removed_tactics": [
            "norm_cast"
          ],
          "topics": [
            "norm",
            "real",
            "int"
          ],
          "transforms": [
            "use_simpa",
            "cleanup_simp",
            "use_aesop"
          ],
          "keywords": [
            "only",
            "apply",
            "pow_two",
            "Real",
            "norm_cast",
            "abs_mul_abs_self",
            "simpa",
            "Summable",
            "simp",
            "summable_inv_of_isBigO_rpow_inv",
            "sub_eq_add_neg",
            "using",
            "mul",
            "comp_neg_int",
            "rpow_two",
            "linear_inv_isBigO_right"
          ]
        }
      },
      {
        "id": 3607,
        "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
        "suggestion": "  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n",
        "body": "It's easier if you case split on whether the range of the function from the subtype is bounded above or not.\n```suggestion\n  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n```",
        "path": "Mathlib/Topology/Order/IsLUB.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "aesop",
            "refine",
            "exact",
            "simpa",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "refine",
            "exact",
            "simpa",
            "simp"
          ],
          "new_tactics": [
            "simpa",
            "aesop",
            "refine",
            "simp",
            "exact"
          ],
          "removed_tactics": [],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "use_simpa",
            "use_aesop"
          ],
          "keywords": [
            "IsGLB",
            "isLUB_inter_iff"
          ]
        }
      },
      {
        "id": 3723,
        "before_code": "end",
        "suggestion": "\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map f \u226b\r\n    (PreservesCoproduct.iso F _).hom \u226b (Sigma.mapIso fun b \u21a6 hf').hom\r\n  letI g_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map g\r\n  haveI H' : f_new \u226b g_new = 0 := by\r\n    simp_rw [f_new, g_new, Category.assoc, Iso.hom_inv_id_assoc,\r\n      Preadditive.IsIso.comp_left_eq_zero, IsHomLift.eq_of_isHomLift F (F.map f \u226b F.map g) (f \u226b g),\r\n      H, Functor.map_zero]\r\n  letI h' : IsColimit (CokernelCofork.of\u03c0 g_new H') := by\r\n    refine IsColimit.ofIsoColimit ((IsColimit.precomposeHom",
        "body": "This suggestion uses the modification suggested above for `Presentation.isColimit`\r\n\r\n```suggestion\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_ne",
        "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "apply",
            "aesop",
            "refine",
            "ext",
            "exact",
            "cases",
            "have",
            "simp",
            "intro"
          ],
          "body_tactics": [
            "apply",
            "aesop",
            "refine",
            "ext",
            "exact",
            "cases",
            "have",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "apply",
            "aesop",
            "refine",
            "ext",
            "exact",
            "cases",
            "have",
            "simp",
            "intro"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "end"
          ]
        }
      },
      {
        "id": 3769,
        "before_code": "theorem isCompact_generateFrom' [T : TopologicalSpace X]\n    {S : Set (Set X)} (hTS : T = generateFrom S) {s : Set X}\n    (h : \u2200 (\u03b9 : Type u) (U : \u03b9 \u2192 S), s \u2286 \u22c3 i, U i \u2192 \u2203 J : Set \u03b9, J.Finite \u2227 s \u2286 \u22c3 i \u2208 J, U i) :\n    IsCompact s := by\n  apply isCompact_generateFrom hTS\n  intro P hP hs\n  rw [Set.sUnion_eq_iUnion] at hs\n  obtain \u27e8J, hJ, cover\u27e9 := h P (fun a \u21a6 \u27e8a.1, hP a.2\u27e9) hs\n  refine \u27e8(fun x \u21a6 x.1) '' J, \u27e8by simp, Set.Finite.image _ hJ, ?_\u27e9\u27e9\n  simpa only [Set.sUnion_eq_iUnion, Set.iUnion_coe_set, Set.mem_image, Subtype.exists,\n    exists_and_right, exists_eq_right, Set.iUnion_exists] using cover",
        "suggestion": "\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n",
        "body": "```suggestion\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n```",
        "path": "Mathlib/Topology/Compactness/Compact.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "refine",
            "simpa",
            "obtain",
            "rw",
            "simp",
            "intro"
          ],
          "suggestion_tactics": [
            "aesop",
            "simp"
          ],
          "body_tactics": [
            "aesop",
            "simp"
          ],
          "new_tactics": [
            "aesop"
          ],
          "removed_tactics": [
            "apply",
            "refine",
            "simpa",
            "obtain",
            "rw",
            "intro"
          ],
          "topics": [
            "set_theory",
            "topology"
          ],
          "transforms": [
            "use_aesop"
          ],
          "keywords": [
            "Subtype",
            "exists_eq_right",
            "Type",
            "obtain",
            "exists",
            "apply",
            "refine",
            "intro",
            "sUnion_eq_iUnion",
            "IsCompact",
            "hTS",
            "TopologicalSpace",
            "exists_and_right",
            "simp",
            "generateFrom",
            "only",
            "isCompact_generateFrom",
            "Finite",
            "cover",
            "mem_image",
            "theorem",
            "Set",
            "iUnion_coe_set",
            "simpa",
            "image",
            "iUnion_exists",
            "using"
          ]
        }
      }
    ],
    "use_omega": [
      {
        "id": 198,
        "before_code": "end minpoly\n\nend Polynomial",
        "suggestion": "  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pred_eq_of_pos hprime.pos\n    -- Derive a vanishing relation with coefficients `\u03b1\u1d62 - \u03b1_{p-1}` and exponents `< n`.\n    have : \u2211 i \u2208 Finset.range (n + 1), \u03b1Nat i * \u03b6 ^ i = 0 := by\n      simpa [show n + 1 = p by omega, \u2190 Fin.sum_univ_eq_sum_range, h\u03b1Nat_val]\n    have : \u2211 i \u2208 Finset.range n, \u03b1Nat i * \u03b6 ^ i - \u03b1Nat n * \u2211 i \u2208 Finset.range n, \u03b6 ^ i = 0 := by\n      rw [Finset.sum_range_succ] at this\n      -- Use the standard relation for primitive roots: `\u03b6^{p-1} = -\u2211_{i<p-1} \u03b6^i`.\n      grind [h\u03b6.pow_sub_one_eq hprime.one_lt]\n    have h",
        "body": "Attempted golfing\n\n```suggestion\n  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pr",
        "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "body_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "new_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_omega",
            "cleanup_simp",
            "use_simpa",
            "use_grind",
            "use_ring"
          ],
          "keywords": [
            "Polynomial",
            "minpoly",
            "end"
          ]
        }
      },
      {
        "id": 634,
        "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero\n\nsection MultiplicativeNotation\n\n/-- Notation for `WithZero (Multiplicative \u2115)` -/\nscoped[Multiplicative] notation \"\u2115\u2098\u2080\" => WithZero (Multiplicative \u2115)\n\n/-- Notation for `WithZero (Multiplicative \u2124)` -/\nscoped[Multiplicative] notation \"\u2124\u2098\u2080\" => WithZero (Multiplicative \u2124)\n\nend MultiplicativeNotation",
        "suggestion": "\r\ntheorem Int.ofAdd_neg_natCast_lt_one {n : \u2115} : (Multiplicative.ofAdd (-n : \u2124) : \u2124\u2098\u2080) < 1 := by\r\n  rw [\u2190 coe_one, coe_lt_coe, \u2190 ofAdd_zero, ofAdd_lt]\r\n  omega\r\n",
        "body": "This lemma feels overly specific. Can you either:\r\n* drop it\r\n* generalise it, maybe something like\r\n```suggestion\r\ntheorem Int.ofAdd_neg_natCast_lt_one {n : \u2115} : (Multiplicative.ofAdd (-n : \u2124) : \u2124\u2098\u2080) < 1 := by\r\n  rw [\u2190 coe_one, coe_lt_coe, \u2190 ofAdd_zero, ofAdd_lt]\r\n  omega\r\n```\r\n(didn't fix the proof)",
        "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "rw",
            "omega"
          ],
          "body_tactics": [
            "rw",
            "omega"
          ],
          "new_tactics": [
            "rw",
            "omega"
          ],
          "removed_tactics": [],
          "topics": [
            "int",
            "nat",
            "algebra"
          ],
          "transforms": [
            "use_omega"
          ],
          "keywords": [
            "end",
            "Notation",
            "scoped",
            "WithZero",
            "MultiplicativeNotation",
            "instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "notation",
            "commGroupWithZero",
            "section",
            "for"
          ]
        }
      },
      {
        "id": 2890,
        "before_code": "end minpoly\n\nend Polynomial",
        "suggestion": "  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pred_eq_of_pos hprime.pos\n    -- Derive a vanishing relation with coefficients `\u03b1\u1d62 - \u03b1_{p-1}` and exponents `< n`.\n    have : \u2211 i \u2208 Finset.range (n + 1), \u03b1Nat i * \u03b6 ^ i = 0 := by\n      simpa [show n + 1 = p by omega, \u2190 Fin.sum_univ_eq_sum_range, h\u03b1Nat_val]\n    have : \u2211 i \u2208 Finset.range n, \u03b1Nat i * \u03b6 ^ i - \u03b1Nat n * \u2211 i \u2208 Finset.range n, \u03b6 ^ i = 0 := by\n      rw [Finset.sum_range_succ] at this\n      -- Use the standard relation for primitive roots: `\u03b6^{p-1} = -\u2211_{i<p-1} \u03b6^i`.\n      grind [h\u03b6.pow_sub_one_eq hprime.one_lt]\n    have h",
        "body": "Attempted golfing\n\n```suggestion\n  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pr",
        "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "body_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "new_tactics": [
            "ext",
            "exact",
            "grind",
            "cases",
            "have",
            "simpa",
            "rw",
            "simp",
            "constructor",
            "intro",
            "ring",
            "omega"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_omega",
            "cleanup_simp",
            "use_simpa",
            "use_grind",
            "use_ring"
          ],
          "keywords": [
            "Polynomial",
            "minpoly",
            "end"
          ]
        }
      }
    ],
    "inline_have": [],
    "term_mode": [
      {
        "id": 97,
        "before_code": "theorem \u03c9Sup_zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : \u03c9Sup (c\u2080.zip c\u2081) = (\u03c9Sup c\u2080, \u03c9Sup c\u2081) := rfl",
        "suggestion": "    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n",
        "body": "Something like\n```suggestion\n    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n```\nshould work, and then you can remove the `by exact` and (probably) format everything on one line.",
        "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "exact"
          ],
          "body_tactics": [
            "exact"
          ],
          "new_tactics": [
            "exact"
          ],
          "removed_tactics": [],
          "topics": [
            "order"
          ],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "rfl",
            "Chain",
            "zip",
            "theorem"
          ]
        }
      },
      {
        "id": 1241,
        "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
        "suggestion": "    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n",
        "body": "```suggestion\n    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n```\nMost of the time, `by exact` is useless.",
        "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [
            "exact"
          ],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "pairwise",
            "OrthogonalFamily",
            "hij"
          ]
        }
      },
      {
        "id": 1514,
        "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
        "suggestion": "    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n",
        "body": "There are two _independent_ changes here:\n\n1. Fix the `by exact` issue by adding `.toLinearMap` to help elaboration\n2. Add `.toSubmodule` rather than a coercion to avoid an indirect coercion (`LieIdeal` to `LieSubalgebra` to `Submodule`)\n```suggestion\n    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n```",
        "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "simp"
          ],
          "suggestion_tactics": [],
          "body_tactics": [
            "exact"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "exact",
            "simp"
          ],
          "topics": [
            "set_theory",
            "algebra"
          ],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "add_lie",
            "mem_coe",
            "SetLike",
            "exact",
            "Submodule",
            "add_mem",
            "simp",
            "carrier_eq_coe",
            "only"
          ]
        }
      },
      {
        "id": 1633,
        "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
        "suggestion": "  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n",
        "body": "```suggestion\n  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n```\n\n`by exact` is (almost always) a no-op.",
        "path": "Mathlib/Topology/Baire/Lemmas.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "have"
          ],
          "body_tactics": [
            "exact",
            "have"
          ],
          "new_tactics": [
            "have"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "BaireSpace",
            "Dense",
            "baire_property"
          ]
        }
      },
      {
        "id": 1769,
        "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
        "suggestion": "noncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n            all_goals\n              apply le_ciSup (f := (DFunLike.coe \u00b7 _) \u2218 Subtype.val) ?_ p\n              simpa [Set.range_comp] using Monotone.map_bddAbove (fun _ _ h' \u21a6 by exact h' _) h\n        inv' x := by simp }\n    else 0\n",
        "body": "I think `where` syntax is nicer here, and I provided a small golf to avoid the case split.\n```suggestion\nnoncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n     ",
        "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "apply",
            "gcongr",
            "refine",
            "exact",
            "have",
            "simpa",
            "obtain",
            "simp"
          ],
          "body_tactics": [
            "apply",
            "gcongr",
            "refine",
            "exact",
            "have",
            "simpa",
            "obtain",
            "simp"
          ],
          "new_tactics": [
            "apply",
            "gcongr",
            "refine",
            "exact",
            "have",
            "simpa",
            "obtain",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa",
            "term_mode"
          ],
          "keywords": [
            "community",
            "com",
            "https",
            "add_apply",
            "theorem",
            "too",
            "pull",
            "skeleton",
            "github",
            "issuecomment",
            "mathlib",
            "from",
            "leanprover",
            "rfl",
            "define",
            "TODO",
            "SupSet"
          ]
        }
      },
      {
        "id": 1812,
        "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
        "suggestion": "  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n",
        "body": "```suggestion\n  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n```\n`by exact` should be dropped most of the time.",
        "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "have"
          ],
          "body_tactics": [
            "exact",
            "have"
          ],
          "new_tactics": [
            "have"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "set_theory",
            "real",
            "order"
          ],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "intervalIntegral",
            "theorem",
            "integral_congr_codiscreteWithin",
            "interval_average_eq",
            "codiscreteWithin",
            "Filter",
            "intervalAverage_congr_codiscreteWithin"
          ]
        }
      },
      {
        "id": 1941,
        "before_code": "rcases h\u03be with \u27e8i, hin, hi, H\u27e9\n    exact \u27e8i, \u27e8hin, hi.symm\u27e9, H\u27e9",
        "suggestion": "\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n",
        "body": "```suggestion\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n```\r\nI think it\u2019s better practice to inline the \"haves\" when in term mode with a non-prop goal like this.\r\n\r\nalso, added the `@[simps! apply_coe]` adds the lemma saying that you\u2019re i",
        "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "cases"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "exact",
            "cases"
          ],
          "topics": [],
          "transforms": [
            "term_mode",
            "use_grind"
          ],
          "keywords": [
            "exact",
            "rcases",
            "symm",
            "hin"
          ]
        }
      },
      {
        "id": 2047,
        "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
        "suggestion": "\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n",
        "body": "We can also\r\n```suggestion\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n```",
        "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "term_mode"
          ],
          "keywords": []
        }
      },
      {
        "id": 2856,
        "before_code": "theorem \u03c9Sup_zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : \u03c9Sup (c\u2080.zip c\u2081) = (\u03c9Sup c\u2080, \u03c9Sup c\u2081) := rfl",
        "suggestion": "    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n",
        "body": "Something like\n```suggestion\n    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n```\nshould work, and then you can remove the `by exact` and (probably) format everything on one line.",
        "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "exact"
          ],
          "body_tactics": [
            "exact"
          ],
          "new_tactics": [
            "exact"
          ],
          "removed_tactics": [],
          "topics": [
            "order"
          ],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "rfl",
            "Chain",
            "zip",
            "theorem"
          ]
        }
      },
      {
        "id": 3243,
        "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
        "suggestion": "    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n",
        "body": "```suggestion\n    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n```\nMost of the time, `by exact` is useless.",
        "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [
            "exact"
          ],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "pairwise",
            "OrthogonalFamily",
            "hij"
          ]
        }
      },
      {
        "id": 3340,
        "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
        "suggestion": "    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n",
        "body": "There are two _independent_ changes here:\n\n1. Fix the `by exact` issue by adding `.toLinearMap` to help elaboration\n2. Add `.toSubmodule` rather than a coercion to avoid an indirect coercion (`LieIdeal` to `LieSubalgebra` to `Submodule`)\n```suggestion\n    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n```",
        "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "simp"
          ],
          "suggestion_tactics": [],
          "body_tactics": [
            "exact"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "exact",
            "simp"
          ],
          "topics": [
            "set_theory",
            "algebra"
          ],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "add_lie",
            "mem_coe",
            "SetLike",
            "exact",
            "Submodule",
            "add_mem",
            "simp",
            "carrier_eq_coe",
            "only"
          ]
        }
      },
      {
        "id": 3383,
        "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
        "suggestion": "  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n",
        "body": "```suggestion\n  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n```\n\n`by exact` is (almost always) a no-op.",
        "path": "Mathlib/Topology/Baire/Lemmas.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "have"
          ],
          "body_tactics": [
            "exact",
            "have"
          ],
          "new_tactics": [
            "have"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "BaireSpace",
            "Dense",
            "baire_property"
          ]
        }
      },
      {
        "id": 3424,
        "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
        "suggestion": "noncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n            all_goals\n              apply le_ciSup (f := (DFunLike.coe \u00b7 _) \u2218 Subtype.val) ?_ p\n              simpa [Set.range_comp] using Monotone.map_bddAbove (fun _ _ h' \u21a6 by exact h' _) h\n        inv' x := by simp }\n    else 0\n",
        "body": "I think `where` syntax is nicer here, and I provided a small golf to avoid the case split.\n```suggestion\nnoncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n     ",
        "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "apply",
            "gcongr",
            "refine",
            "exact",
            "have",
            "simpa",
            "obtain",
            "simp"
          ],
          "body_tactics": [
            "apply",
            "gcongr",
            "refine",
            "exact",
            "have",
            "simpa",
            "obtain",
            "simp"
          ],
          "new_tactics": [
            "apply",
            "gcongr",
            "refine",
            "exact",
            "have",
            "simpa",
            "obtain",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa",
            "term_mode"
          ],
          "keywords": [
            "community",
            "com",
            "https",
            "add_apply",
            "theorem",
            "too",
            "pull",
            "skeleton",
            "github",
            "issuecomment",
            "mathlib",
            "from",
            "leanprover",
            "rfl",
            "define",
            "TODO",
            "SupSet"
          ]
        }
      },
      {
        "id": 3436,
        "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
        "suggestion": "  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n",
        "body": "```suggestion\n  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n```\n`by exact` should be dropped most of the time.",
        "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "have"
          ],
          "body_tactics": [
            "exact",
            "have"
          ],
          "new_tactics": [
            "have"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "set_theory",
            "real",
            "order"
          ],
          "transforms": [
            "term_mode"
          ],
          "keywords": [
            "intervalIntegral",
            "theorem",
            "integral_congr_codiscreteWithin",
            "interval_average_eq",
            "codiscreteWithin",
            "Filter",
            "intervalAverage_congr_codiscreteWithin"
          ]
        }
      },
      {
        "id": 3481,
        "before_code": "rcases h\u03be with \u27e8i, hin, hi, H\u27e9\n    exact \u27e8i, \u27e8hin, hi.symm\u27e9, H\u27e9",
        "suggestion": "\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n",
        "body": "```suggestion\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n```\r\nI think it\u2019s better practice to inline the \"haves\" when in term mode with a non-prop goal like this.\r\n\r\nalso, added the `@[simps! apply_coe]` adds the lemma saying that you\u2019re i",
        "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "cases"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "exact",
            "cases"
          ],
          "topics": [],
          "transforms": [
            "term_mode",
            "use_grind"
          ],
          "keywords": [
            "exact",
            "rcases",
            "symm",
            "hin"
          ]
        }
      },
      {
        "id": 3517,
        "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
        "suggestion": "\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n",
        "body": "We can also\r\n```suggestion\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n```",
        "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "term_mode"
          ],
          "keywords": []
        }
      }
    ],
    "remove_redundant": [
      {
        "id": 324,
        "before_code": "module\n\npublic import Mathlib.Analysis.SpecialFunctions.Log.Basic",
        "suggestion": "\r\n",
        "body": "This import is redundant, let's not annoy Sebastian by making him do even more `shake` work :)\r\n```suggestion\r\n```",
        "path": "Mathlib/NumberTheory/Height/Basic.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [
            "algebra"
          ],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "Basic",
            "import",
            "Mathlib",
            "public",
            "module",
            "Log",
            "Analysis",
            "SpecialFunctions"
          ]
        }
      },
      {
        "id": 374,
        "before_code": "have : x = (fun \u03b5 : \u211d => mulExpNegMulSq \u03b5 x) 0 := by\n    simp only [mulExpNegMulSq, zero_mul, neg_zero, exp_zero, mul_one]\n  nth_rw 2 [this]\n  apply Continuous.tendsto (Continuous.mul continuous_const (by fun_prop))",
        "suggestion": "\r\n  apply Continuous.tendsto (by fun_prop)\r\n",
        "body": "Unnecessary diff? or maybe\r\n```suggestion\r\n  apply Continuous.tendsto (by fun_prop)\r\n```\r\nworks?",
        "path": "Mathlib/Analysis/SpecialFunctions/MulExpNegMulSq.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "have",
            "simp",
            "fun_prop"
          ],
          "suggestion_tactics": [
            "apply",
            "fun_prop"
          ],
          "body_tactics": [
            "apply",
            "fun_prop"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "simp",
            "have"
          ],
          "topics": [
            "continuity",
            "real",
            "list"
          ],
          "transforms": [
            "remove_redundant",
            "use_fun_prop"
          ],
          "keywords": [
            "apply",
            "nth_rw",
            "tendsto",
            "have",
            "this",
            "exp_zero",
            "mulExpNegMulSq",
            "continuous_const",
            "mul_one",
            "neg_zero",
            "simp",
            "Continuous",
            "fun_prop",
            "zero_mul",
            "mul",
            "only"
          ]
        }
      },
      {
        "id": 415,
        "before_code": "public import Mathlib.CategoryTheory.Functor.Category\npublic import Mathlib.CategoryTheory.Iso",
        "suggestion": "\r\n",
        "body": "```suggestion\r\n```\r\nThis import should now be redundant",
        "path": "Mathlib/CategoryTheory/NatIso.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "import",
            "Mathlib",
            "public",
            "Functor",
            "Category",
            "CategoryTheory",
            "Iso"
          ]
        }
      },
      {
        "id": 449,
        "before_code": "set f' := fun i => (f i : M\u2081 i \u2192\u2097[R] M\u2081' i)\n  rw [\u2190 zero_compLinearMap f', compLinearMap_inj f' fun i => (f i).surjective]",
        "suggestion": "\r\ndef compMultilinearMap (g : MultilinearMap R M\u2081 M\u2082) (f : (i : \u03b9) \u2192 MultilinearMap R (N i) (M\u2081 i)) :\r\n    MultilinearMap R (fun j : \u03a3 i, \u03b2 i \u21a6 N j.fst j.snd) M\u2082 where\r\n  toFun m := g fun i \u21a6 f i (Sigma.curry m i)\r\n  map_update_add' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n  map_update_smul' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n",
        "body": "A few changes and we can do it in a single `intro; classical; simp`:\r\n\r\n* `DecidableEq` is not needed to define `toFun`, so we should add this assumption (with `classical`) only for the proofs.\r\n* We only need to introduce `hDecEqSigma`, the rest is handled by `simp`. Might as well put the hypothesis before the colon (but I would also accept `intro` here).\r\n* `simp only` can do all the rewriting if we hint it what to exactly rewrite. In particular, breaking `[Sigma.apply_curry_update .., Sigma.c",
        "path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "simp"
          ],
          "body_tactics": [
            "rw",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "simp"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "function"
          ],
          "transforms": [
            "cleanup_simp",
            "line_break",
            "remove_redundant"
          ],
          "keywords": [
            "compLinearMap_inj",
            "zero_compLinearMap",
            "surjective",
            "set"
          ]
        }
      },
      {
        "id": 521,
        "before_code": "Indep m\u2081 m\u2083 \u03ba \u03bc :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)",
        "suggestion": "  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n",
        "body": "I suggest this proof instead:\n```suggestion\n  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n```\nIt's exactly the same but I reworked the variables (and removed unnecessary parentheses). We often use `s`, `t` for sets. Here `s` and `t` are not of the same kind (`s` is a finset of the index type while `t` is a family of sets) so it's better to use `s` and `t` rather than `t1` and `t2` which suggests they are of the same kind. As `i` is an element of the index type `\u03b9`, `i` is the usual",
        "path": "Mathlib/Probability/Independence/Kernel/Indep.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "ht1",
            "ht2",
            "h_indep",
            "h32",
            "Indep"
          ]
        }
      },
      {
        "id": 546,
        "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
        "suggestion": "\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family_span_fixedDegree_aux\r\n    {I : Type*} [LinearOrder I] (v : I \u2192 M) (\u03b1 : Fin n \u2192 I) :\r\n    ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) \u2208 span R (range (ExteriorAlgebra.\u03b9Multi_family R n v)) := by\r\n  by_cases \u03b1_inj : Injective \u03b1; swap\r\n  \u00b7 suffices ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) = 0 by simp [this]\r\n    exact AlternatingMap.map_eq_zero_of_not_injective _ _ <| fun h \u21a6 \u03b1_inj (Injective.of_comp h)\r\n",
        "body": "Looking at this one last time, even though it is a private \"auxiliary\" lemma, I think we should fold in the case analysis on whether `\u03b1` is injective so that we don't have a redundant hypothesis:\r\n```suggestion\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family",
        "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw"
          ],
          "suggestion_tactics": [
            "exact",
            "simp"
          ],
          "body_tactics": [
            "exact",
            "have",
            "simp"
          ],
          "new_tactics": [
            "simp"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "set_theory",
            "order",
            "function"
          ],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "comp_left",
            "exact",
            "Set",
            "range_eq_univ",
            "Surjective"
          ]
        }
      },
      {
        "id": 604,
        "before_code": "simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *\n  grind",
        "suggestion": "theorem disjoint_swap_swap {x y z t : \u03b1} (h : [x, y, z, t].Nodup) :\n    Disjoint (swap x y) (swap z t) := by\n  intro; grind\n",
        "body": "We should drop the redundant finiteness assumption. Luckily, `grind` comes to the rescue:\n```suggestion\ntheorem disjoint_swap_swap {x y z t : \u03b1} (h : [x, y, z, t].Nodup) :\n    Disjoint (swap x y) (swap z t) := by\n  intro; grind\n```",
        "path": "Mathlib/GroupTheory/Perm/Support.lean",
        "tags": {
          "before_tactics": [
            "grind",
            "simp"
          ],
          "suggestion_tactics": [
            "grind",
            "intro"
          ],
          "body_tactics": [
            "grind",
            "intro"
          ],
          "new_tactics": [
            "intro"
          ],
          "removed_tactics": [
            "simp"
          ],
          "topics": [
            "set_theory",
            "order",
            "function"
          ],
          "transforms": [
            "remove_redundant",
            "use_grind"
          ],
          "keywords": [
            "mul_apply",
            "swap_apply_def",
            "grind",
            "eq_iff",
            "mem_support",
            "simp",
            "injective",
            "only"
          ]
        }
      },
      {
        "id": 1315,
        "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm",
        "suggestion": "\r\n  rw (occs := [1]) [eq_interpolate hvs hP]\r\n  rw [interpolate_apply, finset_sum_coeff]\r\n  congr! with i hi\r\n  rw [coeff_C_mul, \u2190 natDegree_basis hvs hi, \u2190 leadingCoeff, leadingCoeff_basis hvs hi]\r\n  field_simp\r\n",
        "body": "The second arm of the rw is unnecessary--it's proving a hypothesis.\r\n```suggestion\r\n  rw (occs := [1]) [eq_interpolate hvs hP]\r\n  rw [interpolate_apply, finset_sum_coeff]\r\n  congr! with i hi\r\n  rw [coeff_C_mul, \u2190 natDegree_basis hvs hi, \u2190 leadingCoeff, leadingCoeff_basis hvs hi]\r\n  field_simp\r\n```",
        "path": "Mathlib/LinearAlgebra/Lagrange.lean",
        "tags": {
          "before_tactics": [
            "exact"
          ],
          "suggestion_tactics": [
            "congr",
            "field_simp",
            "rw"
          ],
          "body_tactics": [
            "congr",
            "field_simp",
            "rw"
          ],
          "new_tactics": [
            "congr",
            "rw",
            "field_simp"
          ],
          "removed_tactics": [
            "exact"
          ],
          "topics": [
            "set_theory"
          ],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "mpr",
            "eval",
            "Polynomial",
            "open",
            "symm",
            "scoped",
            "eq_interpolate",
            "interpolate",
            "insert_subset_iff",
            "InjOn",
            "sdiff_singleton_eq_erase",
            "hvs",
            "card",
            "Classical",
            "interpolate_poly_eq_self",
            "theorem",
            "exact",
            "Set",
            "degree",
            "singleton_subset_iff"
          ]
        }
      },
      {
        "id": 1460,
        "before_code": "\u00b7 intro Y hY\n    exact H _ hY",
        "suggestion": "",
        "body": "This line is unnecessary:\n```suggestion\n```",
        "path": "Mathlib/CategoryTheory/MorphismProperty/Ind.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "intro"
          ],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [
            "exact",
            "intro"
          ],
          "topics": [],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "exact",
            "intro"
          ]
        }
      },
      {
        "id": 1905,
        "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
        "suggestion": "",
        "body": "This looks redundant:\n```suggestion\n```",
        "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain"
          ],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [
            "exact",
            "obtain"
          ],
          "topics": [],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "isTree_of_minimal_connected",
            "exact",
            "hmin",
            "exists_le_minimal",
            "obtain",
            "Connected",
            "hTG",
            "toFinite",
            "SimpleGraph"
          ]
        }
      },
      {
        "id": 1906,
        "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
        "suggestion": "  obtain \u27e8\u27e8hF : F \u2264 G, hF' : F.IsAcyclic\u27e9, h\u27e9 := by simpa [Maximal] using h\n  ext u v\n  refine \u27e8fun h \u21a6 h.mono hF, ?_\u27e9\n  contrapose! h\n  obtain \u27e8\u27e8p : G.Walk u v\u27e9, h : \u00ac F.Reachable u v\u27e9 := h\n  let s : Set V := F.connectedComponentMk u\n  have hus : u \u2208 s := ConnectedComponent.connectedComponentMk_mem\n  have hvs : v \u2209 s := h \u2218 (F.connectedComponentMk u).reachable_of_mem_supp hus\n  obtain \u27e8\u27e8\u27e8u', v'\u27e9, huv : G.Adj u' v'\u27e9, -, hu : u' \u2208 s, hv : v' \u2209 s\u27e9 :=\n    p.exists_boundary_dart s hus hvs\n  suffices (F \u2294 fromEdgeSet {s(u', v')}).IsAcyclic by\n    refine \u27e8F \u2294 fromEdgeSet {s(u', v')}, ?_, this, le_sup_left, ?_\u27e9\n    \u00b7 have : G.Adj v' u' := G.symm huv\n      simp only [sup_le_iff, le_iff_adj, fromEdgeSet_adj, Set.mem_singleton_iff, Sym2.eq,\n        Sym2.rel_iff'] at hF \u22a2\n      grind\n    \u00b7 rw [le_iff_adj]\n      push_neg\n      refine \u27e8u', v', ?_, fun hc \u21a6 ?_\u27e9\n      \u00b7 simpa using Or.inr huv.ne\n      \u00b7 have := (F.connectedComponentMk u).mem_supp_congr_adj hc\n        grind\n  suffices \u00ac F.Reachable u'",
        "body": "The following is a slight golf. I was not trying to make it shorter though: I was trying to make it slightly more idiomatic and readable. I think what I've got is still not great but is acceptable (as was yours already). Two minor points I highlight are:\n\n- I've added various redundant type ascriptions (e.g., to the `obtain`s). These aid readability for a human.\n- I've use the `ext` tactic rather than directly calling the underlying very low-level `funext`, `propext`\n\nI also note that [Maximal](",
        "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain"
          ],
          "suggestion_tactics": [
            "refine",
            "ext",
            "exact",
            "grind",
            "have",
            "simpa",
            "obtain",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "funext",
            "refine",
            "ext",
            "exact",
            "grind",
            "have",
            "simpa",
            "obtain",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "refine",
            "ext",
            "grind",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa",
            "remove_redundant",
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "isTree_of_minimal_connected",
            "exact",
            "hmin",
            "exists_le_minimal",
            "obtain",
            "Connected",
            "hTG",
            "toFinite",
            "SimpleGraph"
          ]
        }
      },
      {
        "id": 2069,
        "before_code": "end card",
        "suggestion": "\r\n",
        "body": "I assume this is test code, and can be removed?\r\n```suggestion\r\n```",
        "path": "Mathlib/Order/Interval/Finset/Fin.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "end",
            "card"
          ]
        }
      },
      {
        "id": 2399,
        "before_code": "grw [\u2190 H2]\n  ring_nf; rfl",
        "suggestion": "\r\n  grind [abs, norm_smul, Real.norm_eq_abs, norm_zero, inner_eq_mul_norm_iff_angle_eq_zero, inner_eq_neg_mul_norm_iff_angle_eq_pi]\r\n",
        "body": "```suggestion\r\n  grind [abs, norm_smul, Real.norm_eq_abs, norm_zero, inner_eq_mul_norm_iff_angle_eq_zero, inner_eq_neg_mul_norm_iff_angle_eq_pi]\r\n```\r\n(there's an open PR tagging `abs` with `grind`, so that will soon be a redundant argument.",
        "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
        "tags": {
          "before_tactics": [
            "ring_nf"
          ],
          "suggestion_tactics": [
            "grind"
          ],
          "body_tactics": [
            "grind"
          ],
          "new_tactics": [
            "grind"
          ],
          "removed_tactics": [
            "ring_nf"
          ],
          "topics": [
            "algebra"
          ],
          "transforms": [
            "remove_redundant",
            "use_grind"
          ],
          "keywords": [
            "rfl",
            "grw",
            "ring_nf"
          ]
        }
      },
      {
        "id": 2421,
        "before_code": "(H \u2294 K).Connected :=\n  Subgraph.connected_sup hH.preconnected hK.preconnected hn",
        "suggestion": "\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degree_pos_of_nontrivial v\r\n",
        "body": "Even though you know the graph is nonempty I think it's better to assume the weaker `Preconnected` instead of `Connected`.\r\nAlso, the `by_contra` is redundant here.\r\n```suggestion\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degre",
        "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "simpa",
            "refine",
            "have"
          ],
          "body_tactics": [
            "simpa",
            "refine",
            "have"
          ],
          "new_tactics": [
            "simpa",
            "have",
            "refine"
          ],
          "removed_tactics": [],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa",
            "remove_redundant"
          ],
          "keywords": [
            "Connected",
            "connected_sup",
            "Subgraph",
            "preconnected"
          ]
        }
      },
      {
        "id": 2931,
        "before_code": "module\n\npublic import Mathlib.Analysis.SpecialFunctions.Log.Basic",
        "suggestion": "\r\n",
        "body": "This import is redundant, let's not annoy Sebastian by making him do even more `shake` work :)\r\n```suggestion\r\n```",
        "path": "Mathlib/NumberTheory/Height/Basic.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [
            "algebra"
          ],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "Basic",
            "import",
            "Mathlib",
            "public",
            "module",
            "Log",
            "Analysis",
            "SpecialFunctions"
          ]
        }
      },
      {
        "id": 2953,
        "before_code": "have : x = (fun \u03b5 : \u211d => mulExpNegMulSq \u03b5 x) 0 := by\n    simp only [mulExpNegMulSq, zero_mul, neg_zero, exp_zero, mul_one]\n  nth_rw 2 [this]\n  apply Continuous.tendsto (Continuous.mul continuous_const (by fun_prop))",
        "suggestion": "\r\n  apply Continuous.tendsto (by fun_prop)\r\n",
        "body": "Unnecessary diff? or maybe\r\n```suggestion\r\n  apply Continuous.tendsto (by fun_prop)\r\n```\r\nworks?",
        "path": "Mathlib/Analysis/SpecialFunctions/MulExpNegMulSq.lean",
        "tags": {
          "before_tactics": [
            "apply",
            "have",
            "simp",
            "fun_prop"
          ],
          "suggestion_tactics": [
            "apply",
            "fun_prop"
          ],
          "body_tactics": [
            "apply",
            "fun_prop"
          ],
          "new_tactics": [],
          "removed_tactics": [
            "simp",
            "have"
          ],
          "topics": [
            "continuity",
            "real",
            "list"
          ],
          "transforms": [
            "remove_redundant",
            "use_fun_prop"
          ],
          "keywords": [
            "apply",
            "nth_rw",
            "tendsto",
            "have",
            "this",
            "exp_zero",
            "mulExpNegMulSq",
            "continuous_const",
            "mul_one",
            "neg_zero",
            "simp",
            "Continuous",
            "fun_prop",
            "zero_mul",
            "mul",
            "only"
          ]
        }
      },
      {
        "id": 2977,
        "before_code": "set f' := fun i => (f i : M\u2081 i \u2192\u2097[R] M\u2081' i)\n  rw [\u2190 zero_compLinearMap f', compLinearMap_inj f' fun i => (f i).surjective]",
        "suggestion": "\r\ndef compMultilinearMap (g : MultilinearMap R M\u2081 M\u2082) (f : (i : \u03b9) \u2192 MultilinearMap R (N i) (M\u2081 i)) :\r\n    MultilinearMap R (fun j : \u03a3 i, \u03b2 i \u21a6 N j.fst j.snd) M\u2082 where\r\n  toFun m := g fun i \u21a6 f i (Sigma.curry m i)\r\n  map_update_add' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n  map_update_smul' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n",
        "body": "A few changes and we can do it in a single `intro; classical; simp`:\r\n\r\n* `DecidableEq` is not needed to define `toFun`, so we should add this assumption (with `classical`) only for the proofs.\r\n* We only need to introduce `hDecEqSigma`, the rest is handled by `simp`. Might as well put the hypothesis before the colon (but I would also accept `intro` here).\r\n* `simp only` can do all the rewriting if we hint it what to exactly rewrite. In particular, breaking `[Sigma.apply_curry_update .., Sigma.c",
        "path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
        "tags": {
          "before_tactics": [
            "rw"
          ],
          "suggestion_tactics": [
            "simp"
          ],
          "body_tactics": [
            "rw",
            "simp",
            "intro"
          ],
          "new_tactics": [
            "simp"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "function"
          ],
          "transforms": [
            "cleanup_simp",
            "line_break",
            "remove_redundant"
          ],
          "keywords": [
            "compLinearMap_inj",
            "zero_compLinearMap",
            "surjective",
            "set"
          ]
        }
      },
      {
        "id": 3002,
        "before_code": "Indep m\u2081 m\u2083 \u03ba \u03bc :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)",
        "suggestion": "  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n",
        "body": "I suggest this proof instead:\n```suggestion\n  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n```\nIt's exactly the same but I reworked the variables (and removed unnecessary parentheses). We often use `s`, `t` for sets. Here `s` and `t` are not of the same kind (`s` is a finset of the index type while `t` is a family of sets) so it's better to use `s` and `t` rather than `t1` and `t2` which suggests they are of the same kind. As `i` is an element of the index type `\u03b9`, `i` is the usual",
        "path": "Mathlib/Probability/Independence/Kernel/Indep.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "ht1",
            "ht2",
            "h_indep",
            "h32",
            "Indep"
          ]
        }
      },
      {
        "id": 3007,
        "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
        "suggestion": "\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family_span_fixedDegree_aux\r\n    {I : Type*} [LinearOrder I] (v : I \u2192 M) (\u03b1 : Fin n \u2192 I) :\r\n    ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) \u2208 span R (range (ExteriorAlgebra.\u03b9Multi_family R n v)) := by\r\n  by_cases \u03b1_inj : Injective \u03b1; swap\r\n  \u00b7 suffices ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) = 0 by simp [this]\r\n    exact AlternatingMap.map_eq_zero_of_not_injective _ _ <| fun h \u21a6 \u03b1_inj (Injective.of_comp h)\r\n",
        "body": "Looking at this one last time, even though it is a private \"auxiliary\" lemma, I think we should fold in the case analysis on whether `\u03b1` is injective so that we don't have a redundant hypothesis:\r\n```suggestion\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family",
        "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw"
          ],
          "suggestion_tactics": [
            "exact",
            "simp"
          ],
          "body_tactics": [
            "exact",
            "have",
            "simp"
          ],
          "new_tactics": [
            "simp"
          ],
          "removed_tactics": [
            "rw"
          ],
          "topics": [
            "set_theory",
            "order",
            "function"
          ],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "comp_left",
            "exact",
            "Set",
            "range_eq_univ",
            "Surjective"
          ]
        }
      },
      {
        "id": 3471,
        "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
        "suggestion": "  obtain \u27e8\u27e8hF : F \u2264 G, hF' : F.IsAcyclic\u27e9, h\u27e9 := by simpa [Maximal] using h\n  ext u v\n  refine \u27e8fun h \u21a6 h.mono hF, ?_\u27e9\n  contrapose! h\n  obtain \u27e8\u27e8p : G.Walk u v\u27e9, h : \u00ac F.Reachable u v\u27e9 := h\n  let s : Set V := F.connectedComponentMk u\n  have hus : u \u2208 s := ConnectedComponent.connectedComponentMk_mem\n  have hvs : v \u2209 s := h \u2218 (F.connectedComponentMk u).reachable_of_mem_supp hus\n  obtain \u27e8\u27e8\u27e8u', v'\u27e9, huv : G.Adj u' v'\u27e9, -, hu : u' \u2208 s, hv : v' \u2209 s\u27e9 :=\n    p.exists_boundary_dart s hus hvs\n  suffices (F \u2294 fromEdgeSet {s(u', v')}).IsAcyclic by\n    refine \u27e8F \u2294 fromEdgeSet {s(u', v')}, ?_, this, le_sup_left, ?_\u27e9\n    \u00b7 have : G.Adj v' u' := G.symm huv\n      simp only [sup_le_iff, le_iff_adj, fromEdgeSet_adj, Set.mem_singleton_iff, Sym2.eq,\n        Sym2.rel_iff'] at hF \u22a2\n      grind\n    \u00b7 rw [le_iff_adj]\n      push_neg\n      refine \u27e8u', v', ?_, fun hc \u21a6 ?_\u27e9\n      \u00b7 simpa using Or.inr huv.ne\n      \u00b7 have := (F.connectedComponentMk u).mem_supp_congr_adj hc\n        grind\n  suffices \u00ac F.Reachable u'",
        "body": "The following is a slight golf. I was not trying to make it shorter though: I was trying to make it slightly more idiomatic and readable. I think what I've got is still not great but is acceptable (as was yours already). Two minor points I highlight are:\n\n- I've added various redundant type ascriptions (e.g., to the `obtain`s). These aid readability for a human.\n- I've use the `ext` tactic rather than directly calling the underlying very low-level `funext`, `propext`\n\nI also note that [Maximal](",
        "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "obtain"
          ],
          "suggestion_tactics": [
            "refine",
            "ext",
            "exact",
            "grind",
            "have",
            "simpa",
            "obtain",
            "rw",
            "simp"
          ],
          "body_tactics": [
            "funext",
            "refine",
            "ext",
            "exact",
            "grind",
            "have",
            "simpa",
            "obtain",
            "rw",
            "simp"
          ],
          "new_tactics": [
            "refine",
            "ext",
            "grind",
            "have",
            "simpa",
            "rw",
            "simp"
          ],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "use_simpa",
            "remove_redundant",
            "cleanup_simp",
            "use_grind"
          ],
          "keywords": [
            "isTree_of_minimal_connected",
            "exact",
            "hmin",
            "exists_le_minimal",
            "obtain",
            "Connected",
            "hTG",
            "toFinite",
            "SimpleGraph"
          ]
        }
      },
      {
        "id": 3669,
        "before_code": "(H \u2294 K).Connected :=\n  Subgraph.connected_sup hH.preconnected hK.preconnected hn",
        "suggestion": "\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degree_pos_of_nontrivial v\r\n",
        "body": "Even though you know the graph is nonempty I think it's better to assume the weaker `Preconnected` instead of `Connected`.\r\nAlso, the `by_contra` is redundant here.\r\n```suggestion\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degre",
        "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [
            "simpa",
            "refine",
            "have"
          ],
          "body_tactics": [
            "simpa",
            "refine",
            "have"
          ],
          "new_tactics": [
            "simpa",
            "have",
            "refine"
          ],
          "removed_tactics": [],
          "topics": [
            "order"
          ],
          "transforms": [
            "use_simpa",
            "remove_redundant"
          ],
          "keywords": [
            "Connected",
            "connected_sup",
            "Subgraph",
            "preconnected"
          ]
        }
      },
      {
        "id": 4071,
        "before_code": "instance [Nontrivial M] : Nontrivial P.invtRootSubmodule where\n  exists_pair_ne := \u27e8\u22a5, \u22a4, by rw [ne_eq, Subtype.ext_iff]; exact bot_ne_top\u27e9",
        "suggestion": "",
        "body": "Not needed here:\n```suggestion\n```",
        "path": "Mathlib/LinearAlgebra/RootSystem/Irreducible.lean",
        "tags": {
          "before_tactics": [
            "exact",
            "rw"
          ],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [
            "exact",
            "rw"
          ],
          "topics": [
            "algebra"
          ],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "Subtype",
            "ext_iff",
            "Nontrivial",
            "exact",
            "invtRootSubmodule",
            "ne_eq",
            "exists_pair_ne",
            "instance",
            "bot_ne_top"
          ]
        }
      },
      {
        "id": 4161,
        "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
        "suggestion": "",
        "body": "```suggestion\n```\nNot needed",
        "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "pairwise",
            "OrthogonalFamily",
            "hij"
          ]
        }
      },
      {
        "id": 4267,
        "before_code": "\u2200\u1d50 (x : \u211d), x \u2208 uIcc a b \u2192 DifferentiableAt \u211d f x :=\n  hf.boundedVariationOn.ae_differentiableAt_of_mem_uIcc",
        "suggestion": "",
        "body": "```suggestion\n```\nNot needed since you've given the type.",
        "path": "Mathlib/MeasureTheory/Function/AbsolutelyContinuous.lean",
        "tags": {
          "before_tactics": [],
          "suggestion_tactics": [],
          "body_tactics": [],
          "new_tactics": [],
          "removed_tactics": [],
          "topics": [
            "real",
            "set_theory",
            "differentiability"
          ],
          "transforms": [
            "remove_redundant"
          ],
          "keywords": [
            "uIcc",
            "ae_differentiableAt_of_mem_uIcc",
            "boundedVariationOn",
            "DifferentiableAt"
          ]
        }
      }
    ]
  }
}