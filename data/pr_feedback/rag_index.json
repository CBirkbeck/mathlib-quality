{
  "by_tactic": {
    "have": [
      0,
      1,
      2,
      3,
      4,
      24,
      25,
      64,
      83,
      84,
      103,
      104,
      107,
      108,
      109,
      115,
      125,
      126,
      145,
      201,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      270,
      271,
      342,
      343,
      344,
      400,
      401,
      406,
      458,
      459,
      548,
      566,
      567,
      574,
      611,
      655,
      658,
      676,
      750,
      756,
      771,
      782,
      820,
      830,
      883,
      903,
      911,
      917,
      918,
      920,
      921,
      932,
      956,
      963,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      994,
      1029,
      1049,
      1125,
      1136,
      1178,
      1191,
      1237,
      1250,
      1324,
      1365,
      1385,
      1386,
      1387,
      1405,
      1407,
      1409,
      1410,
      1468,
      1471,
      1525,
      1582,
      1583,
      1585,
      1586,
      1587,
      1729,
      1730,
      1731,
      1776,
      1836,
      1858,
      1880,
      1881,
      1882,
      1886,
      1887
    ],
    "refine": [
      6,
      7,
      8,
      24,
      25,
      48,
      83,
      103,
      105,
      108,
      109,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      288,
      338,
      342,
      343,
      346,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      566,
      658,
      663,
      694,
      698,
      722,
      723,
      724,
      760,
      761,
      762,
      781,
      783,
      845,
      867,
      868,
      869,
      883,
      918,
      919,
      950,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1015,
      1031,
      1032,
      1033,
      1034,
      1035,
      1108,
      1178,
      1181,
      1211,
      1224,
      1225,
      1246,
      1251,
      1252,
      1278,
      1316,
      1317,
      1318,
      1337,
      1365,
      1382,
      1385,
      1386,
      1387,
      1521,
      1535,
      1536,
      1537,
      1542,
      1543,
      1544,
      1582,
      1583,
      1604,
      1688,
      1693,
      1722,
      1757,
      1776,
      1845,
      1846,
      1848,
      1858,
      1859,
      1881,
      1887,
      1892
    ],
    "simp": [
      6,
      7,
      8,
      12,
      17,
      18,
      21,
      22,
      25,
      29,
      31,
      34,
      35,
      36,
      37,
      48,
      60,
      61,
      64,
      83,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      104,
      107,
      108,
      109,
      110,
      115,
      125,
      126,
      127,
      145,
      163,
      187,
      194,
      195,
      196,
      199,
      202,
      217,
      218,
      219,
      232,
      238,
      248,
      254,
      255,
      256,
      257,
      263,
      264,
      269,
      270,
      271,
      277,
      278,
      289,
      291,
      292,
      293,
      295,
      329,
      330,
      342,
      343,
      346,
      347,
      357,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      385,
      394,
      395,
      400,
      401,
      402,
      406,
      410,
      411,
      412,
      413,
      414,
      415,
      420,
      435,
      436,
      437,
      438,
      460,
      468,
      469,
      470,
      471,
      474,
      478,
      479,
      481,
      518,
      520,
      533,
      549,
      550,
      567,
      569,
      570,
      571,
      574,
      576,
      579,
      593,
      594,
      595,
      596,
      597,
      614,
      620,
      621,
      622,
      623,
      630,
      638,
      641,
      642,
      643,
      644,
      655,
      658,
      661,
      662,
      664,
      665,
      666,
      667,
      668,
      669,
      670,
      672,
      673,
      674,
      676,
      677,
      679,
      680,
      681,
      682,
      683,
      684,
      685,
      686,
      701,
      702,
      703,
      704,
      705,
      707,
      716,
      721,
      722,
      723,
      724,
      725,
      727,
      728,
      732,
      733,
      734,
      735,
      736,
      740,
      751,
      752,
      760,
      761,
      762,
      763,
      764,
      766,
      771,
      775,
      781,
      782,
      783,
      784,
      804,
      805,
      820,
      831,
      832,
      839,
      840,
      841,
      845,
      846,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      862,
      863,
      864,
      865,
      866,
      867,
      868,
      869,
      879,
      880,
      887,
      900,
      901,
      903,
      912,
      914,
      915,
      916,
      920,
      921,
      924,
      925,
      932,
      952,
      956,
      957,
      958,
      960,
      964,
      969,
      978,
      982,
      986,
      987,
      988,
      989,
      991,
      992,
      994,
      1000,
      1008,
      1019,
      1031,
      1032,
      1033,
      1034,
      1035,
      1036,
      1040,
      1049,
      1052,
      1053,
      1066,
      1067,
      1076,
      1084,
      1085,
      1086,
      1091,
      1093,
      1115,
      1127,
      1136,
      1145,
      1146,
      1147,
      1157,
      1162,
      1163,
      1170,
      1171,
      1172,
      1174,
      1178,
      1179,
      1180,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1188,
      1189,
      1190,
      1191,
      1193,
      1194,
      1195,
      1198,
      1199,
      1200,
      1201,
      1202,
      1203,
      1204,
      1205,
      1206,
      1213,
      1223,
      1224,
      1225,
      1226,
      1227,
      1228,
      1229,
      1230,
      1238,
      1241,
      1247,
      1251,
      1252,
      1268,
      1275,
      1278,
      1279,
      1280,
      1281,
      1282,
      1316,
      1317,
      1318,
      1324,
      1337,
      1365,
      1376,
      1378,
      1385,
      1386,
      1387,
      1388,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410,
      1411,
      1419,
      1435,
      1436,
      1441,
      1447,
      1448,
      1460,
      1463,
      1464,
      1465,
      1468,
      1470,
      1473,
      1474,
      1484,
      1485,
      1489,
      1494,
      1495,
      1513,
      1516,
      1534,
      1535,
      1536,
      1537,
      1542,
      1543,
      1544,
      1545,
      1546,
      1547,
      1550,
      1551,
      1552,
      1559,
      1560,
      1561,
      1562,
      1564,
      1576,
      1577,
      1581,
      1585,
      1586,
      1587,
      1605,
      1676,
      1677,
      1690,
      1693,
      1695,
      1696,
      1697,
      1698,
      1699,
      1702,
      1704,
      1706,
      1707,
      1711,
      1712,
      1714,
      1715,
      1716,
      1722,
      1723,
      1747,
      1748,
      1749,
      1750,
      1755,
      1757,
      1764,
      1765,
      1769,
      1770,
      1771,
      1782,
      1783,
      1784,
      1822,
      1827,
      1828,
      1829,
      1836,
      1843,
      1845,
      1846,
      1854,
      1874,
      1875,
      1879,
      1880,
      1892,
      1901
    ],
    "rw": [
      9,
      10,
      12,
      20,
      24,
      34,
      35,
      48,
      50,
      51,
      62,
      67,
      72,
      74,
      75,
      76,
      77,
      78,
      79,
      83,
      97,
      99,
      100,
      101,
      102,
      105,
      107,
      108,
      109,
      116,
      123,
      125,
      126,
      128,
      133,
      141,
      145,
      146,
      147,
      148,
      149,
      154,
      155,
      156,
      157,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      190,
      191,
      194,
      199,
      205,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      238,
      244,
      245,
      248,
      251,
      252,
      253,
      258,
      262,
      325,
      327,
      338,
      339,
      340,
      341,
      342,
      343,
      347,
      406,
      408,
      440,
      447,
      454,
      459,
      475,
      480,
      488,
      533,
      548,
      549,
      550,
      572,
      573,
      574,
      579,
      587,
      588,
      589,
      590,
      591,
      592,
      648,
      649,
      650,
      651,
      652,
      653,
      658,
      660,
      663,
      671,
      672,
      673,
      674,
      676,
      678,
      688,
      693,
      694,
      695,
      696,
      697,
      698,
      700,
      702,
      703,
      704,
      705,
      721,
      768,
      769,
      772,
      773,
      782,
      783,
      804,
      820,
      821,
      822,
      824,
      829,
      835,
      845,
      872,
      873,
      882,
      883,
      895,
      902,
      908,
      909,
      917,
      923,
      926,
      932,
      933,
      934,
      935,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      950,
      956,
      957,
      960,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      982,
      990,
      1015,
      1016,
      1017,
      1018,
      1048,
      1049,
      1070,
      1072,
      1073,
      1087,
      1092,
      1100,
      1125,
      1134,
      1135,
      1136,
      1143,
      1144,
      1175,
      1176,
      1178,
      1181,
      1188,
      1189,
      1190,
      1191,
      1197,
      1210,
      1211,
      1212,
      1238,
      1239,
      1241,
      1242,
      1243,
      1244,
      1246,
      1250,
      1252,
      1273,
      1274,
      1277,
      1278,
      1351,
      1352,
      1353,
      1359,
      1365,
      1366,
      1377,
      1379,
      1380,
      1381,
      1385,
      1386,
      1387,
      1393,
      1394,
      1395,
      1396,
      1419,
      1420,
      1421,
      1422,
      1423,
      1424,
      1429,
      1430,
      1431,
      1432,
      1436,
      1440,
      1443,
      1459,
      1460,
      1468,
      1472,
      1473,
      1474,
      1482,
      1483,
      1488,
      1493,
      1515,
      1516,
      1517,
      1521,
      1524,
      1542,
      1543,
      1544,
      1555,
      1566,
      1582,
      1583,
      1587,
      1605,
      1606,
      1608,
      1609,
      1610,
      1626,
      1641,
      1676,
      1690,
      1692,
      1693,
      1694,
      1700,
      1705,
      1708,
      1709,
      1710,
      1723,
      1728,
      1747,
      1756,
      1757,
      1762,
      1763,
      1768,
      1776,
      1781,
      1782,
      1783,
      1784,
      1836,
      1847,
      1848,
      1875,
      1880,
      1881,
      1882,
      1887,
      1892
    ],
    "apply": [
      12,
      20,
      36,
      37,
      48,
      83,
      85,
      104,
      105,
      107,
      108,
      109,
      134,
      136,
      137,
      138,
      139,
      191,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      240,
      248,
      345,
      521,
      522,
      655,
      658,
      665,
      666,
      667,
      668,
      669,
      670,
      693,
      708,
      709,
      710,
      711,
      712,
      713,
      721,
      771,
      805,
      821,
      822,
      845,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      882,
      920,
      929,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      983,
      1116,
      1178,
      1183,
      1184,
      1185,
      1186,
      1187,
      1210,
      1216,
      1217,
      1218,
      1219,
      1228,
      1238,
      1273,
      1274,
      1278,
      1280,
      1281,
      1282,
      1331,
      1365,
      1368,
      1375,
      1385,
      1386,
      1387,
      1388,
      1440,
      1448,
      1475,
      1542,
      1543,
      1544,
      1551,
      1552,
      1563,
      1582,
      1583,
      1722,
      1747,
      1757,
      1765,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798,
      1858,
      1880,
      1884,
      1892,
      1901
    ],
    "grind": [
      12,
      14,
      107,
      108,
      109,
      187,
      276,
      406,
      410,
      411,
      412,
      413,
      519,
      876,
      995,
      1049,
      1052,
      1114,
      1332,
      1385,
      1386,
      1387,
      1577,
      1604
    ],
    "simpa": [
      17,
      25,
      63,
      83,
      129,
      130,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      204,
      262,
      319,
      423,
      439,
      472,
      565,
      574,
      598,
      617,
      622,
      623,
      645,
      646,
      647,
      655,
      658,
      666,
      667,
      668,
      669,
      670,
      671,
      676,
      714,
      718,
      740,
      747,
      749,
      760,
      761,
      762,
      845,
      846,
      879,
      927,
      928,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      952,
      965,
      1005,
      1088,
      1132,
      1136,
      1148,
      1162,
      1173,
      1178,
      1183,
      1184,
      1185,
      1186,
      1187,
      1191,
      1234,
      1278,
      1279,
      1324,
      1365,
      1429,
      1430,
      1431,
      1432,
      1436,
      1456,
      1471,
      1488,
      1542,
      1543,
      1544,
      1558,
      1593,
      1594,
      1687,
      1715,
      1735,
      1736,
      1752,
      1753,
      1765,
      1833,
      1845,
      1846,
      1871,
      1886,
      1887,
      1900
    ],
    "exact": [
      18,
      20,
      24,
      34,
      35,
      38,
      39,
      40,
      41,
      42,
      43,
      48,
      50,
      51,
      66,
      67,
      68,
      83,
      84,
      97,
      99,
      100,
      101,
      102,
      105,
      112,
      113,
      116,
      123,
      126,
      146,
      147,
      148,
      149,
      152,
      154,
      155,
      156,
      157,
      194,
      197,
      201,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      239,
      246,
      254,
      255,
      256,
      257,
      258,
      259,
      260,
      276,
      279,
      280,
      281,
      282,
      283,
      285,
      286,
      287,
      288,
      327,
      342,
      343,
      344,
      345,
      347,
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      382,
      383,
      400,
      401,
      402,
      405,
      406,
      407,
      417,
      418,
      433,
      439,
      449,
      450,
      451,
      459,
      469,
      471,
      481,
      501,
      502,
      510,
      511,
      549,
      550,
      574,
      584,
      585,
      586,
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      611,
      612,
      613,
      630,
      639,
      640,
      645,
      646,
      647,
      650,
      651,
      652,
      653,
      655,
      658,
      660,
      661,
      663,
      672,
      673,
      674,
      692,
      693,
      694,
      698,
      726,
      747,
      751,
      752,
      756,
      757,
      758,
      759,
      768,
      769,
      773,
      774,
      781,
      782,
      789,
      790,
      791,
      792,
      793,
      794,
      795,
      796,
      797,
      798,
      817,
      818,
      819,
      821,
      822,
      835,
      846,
      880,
      882,
      883,
      892,
      895,
      902,
      911,
      919,
      923,
      933,
      934,
      935,
      956,
      957,
      963,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      986,
      987,
      988,
      989,
      990,
      995,
      996,
      997,
      998,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1030,
      1048,
      1049,
      1054,
      1056,
      1077,
      1078,
      1079,
      1080,
      1085,
      1086,
      1093,
      1136,
      1140,
      1141,
      1142,
      1149,
      1150,
      1151,
      1152,
      1153,
      1155,
      1163,
      1168,
      1169,
      1173,
      1175,
      1176,
      1178,
      1179,
      1181,
      1188,
      1189,
      1190,
      1192,
      1209,
      1210,
      1211,
      1237,
      1238,
      1242,
      1243,
      1245,
      1246,
      1251,
      1255,
      1256,
      1257,
      1258,
      1259,
      1260,
      1269,
      1270,
      1271,
      1273,
      1274,
      1277,
      1279,
      1324,
      1327,
      1328,
      1339,
      1343,
      1344,
      1345,
      1346,
      1351,
      1352,
      1353,
      1360,
      1365,
      1366,
      1370,
      1371,
      1372,
      1373,
      1374,
      1379,
      1380,
      1381,
      1382,
      1385,
      1386,
      1387,
      1391,
      1393,
      1394,
      1395,
      1396,
      1420,
      1421,
      1422,
      1423,
      1424,
      1436,
      1448,
      1459,
      1468,
      1473,
      1474,
      1476,
      1483,
      1494,
      1496,
      1497,
      1499,
      1500,
      1501,
      1515,
      1517,
      1525,
      1530,
      1531,
      1532,
      1533,
      1541,
      1559,
      1560,
      1561,
      1562,
      1563,
      1566,
      1574,
      1575,
      1582,
      1583,
      1585,
      1586,
      1591,
      1606,
      1619,
      1620,
      1649,
      1700,
      1702,
      1718,
      1719,
      1729,
      1730,
      1731,
      1746,
      1749,
      1750,
      1762,
      1763,
      1774,
      1775,
      1776,
      1781,
      1833,
      1836,
      1843,
      1847,
      1848,
      1855,
      1859,
      1862,
      1875,
      1880,
      1881,
      1882,
      1884,
      1886,
      1887,
      1892,
      1893,
      1899
    ],
    "intro": [
      20,
      66,
      68,
      83,
      123,
      146,
      147,
      148,
      149,
      194,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      240,
      244,
      245,
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      400,
      401,
      402,
      451,
      549,
      550,
      574,
      579,
      639,
      640,
      707,
      740,
      782,
      783,
      831,
      832,
      845,
      882,
      923,
      933,
      934,
      957,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      983,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1136,
      1168,
      1169,
      1238,
      1252,
      1275,
      1278,
      1365,
      1420,
      1421,
      1422,
      1423,
      1424,
      1468,
      1530,
      1531,
      1532,
      1533,
      1542,
      1543,
      1544,
      1559,
      1560,
      1561,
      1562,
      1582,
      1583,
      1820,
      1880,
      1892
    ],
    "obtain": [
      24,
      38,
      39,
      40,
      41,
      42,
      43,
      67,
      84,
      112,
      113,
      123,
      126,
      146,
      147,
      148,
      149,
      276,
      288,
      295,
      346,
      382,
      383,
      400,
      401,
      402,
      459,
      481,
      567,
      574,
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      761,
      762,
      837,
      838,
      845,
      846,
      883,
      892,
      911,
      923,
      933,
      934,
      950,
      995,
      1093,
      1136,
      1149,
      1150,
      1151,
      1152,
      1153,
      1238,
      1246,
      1278,
      1279,
      1319,
      1343,
      1344,
      1345,
      1346,
      1370,
      1371,
      1372,
      1373,
      1374,
      1391,
      1420,
      1421,
      1422,
      1423,
      1424,
      1541,
      1559,
      1560,
      1561,
      1562,
      1582,
      1583,
      1688,
      1718,
      1719,
      1775,
      1846,
      1848,
      1892
    ],
    "induction": [
      24,
      622,
      623,
      658,
      740,
      883,
      904,
      905,
      956,
      1162,
      1178,
      1357,
      1358,
      1892
    ],
    "gcongr": [
      48,
      83,
      190,
      538,
      721,
      1074,
      1365,
      1546,
      1547,
      1673,
      1676
    ],
    "cases": [
      48,
      64,
      239,
      272,
      273,
      406,
      521,
      522,
      542,
      567,
      574,
      612,
      613,
      639,
      640,
      721,
      761,
      762,
      781,
      846,
      903,
      917,
      1049,
      1116,
      1133,
      1136,
      1155,
      1168,
      1169,
      1174,
      1251,
      1279,
      1468,
      1586,
      1659,
      1660,
      1688,
      1700,
      1820,
      1836,
      1846,
      1887,
      1892
    ],
    "congr": [
      48,
      347,
      406,
      440,
      655,
      658,
      694,
      698,
      721,
      782,
      783,
      919,
      1049,
      1178,
      1211,
      1252,
      1880
    ],
    "ext": [
      90,
      107,
      108,
      109,
      217,
      232,
      241,
      263,
      264,
      269,
      291,
      292,
      293,
      327,
      338,
      404,
      460,
      617,
      693,
      694,
      695,
      696,
      697,
      698,
      716,
      732,
      733,
      734,
      735,
      736,
      836,
      839,
      841,
      914,
      969,
      978,
      984,
      991,
      992,
      1000,
      1015,
      1076,
      1210,
      1211,
      1212,
      1227,
      1228,
      1229,
      1378,
      1385,
      1386,
      1387,
      1388,
      1435,
      1443,
      1463,
      1464,
      1465,
      1468,
      1475,
      1489,
      1521,
      1534,
      1564,
      1605,
      1693,
      1711,
      1712,
      1722,
      1723,
      1726,
      1735,
      1736,
      1745,
      1749,
      1750,
      1827,
      1828,
      1829,
      1855,
      1879,
      1880,
      1892,
      1893
    ],
    "fun_prop": [
      103,
      104,
      439,
      518,
      584,
      585,
      586,
      918,
      920,
      1068,
      1140,
      1141,
      1142,
      1250
    ],
    "aesop": [
      107,
      108,
      109,
      153,
      200,
      254,
      255,
      256,
      257,
      348,
      475,
      567,
      624,
      626,
      627,
      628,
      629,
      962,
      986,
      987,
      988,
      989,
      1385,
      1386,
      1387,
      1626,
      1742,
      1854
    ],
    "norm_num": [
      145,
      548,
      582,
      583,
      932,
      1125,
      1836,
      1872,
      1873
    ],
    "omega": [
      146,
      147,
      148,
      149,
      933,
      934,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "measurability": [
      160,
      937
    ],
    "norm_cast": [
      163,
      662,
      665,
      666,
      667,
      668,
      669,
      670,
      721,
      763,
      764,
      766,
      1180,
      1183,
      1184,
      1185,
      1186,
      1187,
      1693,
      1765
    ],
    "positivity": [
      270,
      271,
      348,
      598,
      721,
      835,
      994,
      1021,
      1148,
      1277,
      1573
    ],
    "linarith": [
      270,
      271,
      994,
      1289,
      1692
    ],
    "simp_all": [
      342,
      343,
      404,
      406,
      542,
      1049,
      1564,
      1757,
      1836,
      1881,
      1882
    ],
    "field_simp": [
      406,
      1049,
      1836
    ],
    "ring": [
      408,
      422,
      456,
      458,
      462,
      463,
      464,
      465,
      523,
      524,
      525,
      526,
      527,
      530,
      531,
      580,
      581,
      582,
      583,
      596,
      650,
      651,
      652,
      653,
      657,
      658,
      812,
      813,
      814,
      815,
      856,
      857,
      858,
      1082,
      1117,
      1118,
      1175,
      1176,
      1178,
      1283,
      1284,
      1285,
      1361,
      1473,
      1474,
      1506,
      1605,
      1621,
      1661,
      1662,
      1663,
      1693,
      1695,
      1727,
      1836,
      1842,
      1858,
      1870,
      1872,
      1873,
      1894,
      1902,
      1903
    ],
    "decide": [
      417,
      418,
      593,
      594,
      595,
      1054,
      1145,
      1146,
      1716
    ],
    "fin_cases": [
      435,
      436,
      437,
      438,
      1066,
      1067
    ],
    "funext": [
      622,
      623,
      1162,
      1196,
      1582,
      1583
    ],
    "ring_nf": [
      636,
      748,
      1835,
      1837,
      1838
    ],
    "push_cast": [
      636
    ],
    "constructor": [
      701,
      821,
      822,
      951,
      1213,
      1273,
      1274,
      1542,
      1543,
      1544,
      1550,
      1836
    ],
    "continuity": [
      1364,
      1606,
      1889
    ]
  },
  "by_topic": {
    "list": [
      0,
      1,
      2,
      3,
      4,
      12,
      14,
      22,
      23,
      48,
      82,
      83,
      85,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      104,
      105,
      123,
      137,
      138,
      139,
      160,
      161,
      162,
      184,
      185,
      186,
      197,
      221,
      222,
      231,
      239,
      248,
      261,
      329,
      330,
      385,
      400,
      401,
      402,
      428,
      429,
      430,
      431,
      432,
      442,
      443,
      444,
      445,
      446,
      461,
      482,
      483,
      484,
      485,
      486,
      487,
      520,
      521,
      522,
      622,
      623,
      655,
      663,
      664,
      701,
      722,
      723,
      724,
      774,
      805,
      820,
      821,
      822,
      843,
      851,
      852,
      853,
      854,
      855,
      876,
      915,
      916,
      917,
      919,
      920,
      923,
      937,
      938,
      948,
      949,
      951,
      956,
      1008,
      1036,
      1041,
      1045,
      1061,
      1062,
      1063,
      1064,
      1065,
      1069,
      1081,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1115,
      1116,
      1133,
      1162,
      1181,
      1182,
      1213,
      1224,
      1225,
      1230,
      1250,
      1273,
      1274,
      1280,
      1281,
      1282,
      1327,
      1328,
      1365,
      1366,
      1367,
      1368,
      1375,
      1382,
      1383,
      1428,
      1433,
      1434,
      1454,
      1487,
      1512,
      1513,
      1542,
      1543,
      1544,
      1545,
      1550,
      1559,
      1560,
      1561,
      1562,
      1568,
      1569,
      1570,
      1589,
      1590,
      1622,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640,
      1659,
      1660,
      1667,
      1668,
      1669,
      1670,
      1695,
      1746,
      1764,
      1803,
      1804,
      1808,
      1813,
      1814,
      1836,
      1879,
      1880,
      1883,
      1886,
      1887,
      1899
    ],
    "set_theory": [
      0,
      1,
      2,
      3,
      4,
      17,
      18,
      24,
      31,
      32,
      33,
      34,
      35,
      48,
      50,
      51,
      60,
      64,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      84,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      107,
      108,
      109,
      146,
      147,
      148,
      149,
      151,
      154,
      155,
      156,
      157,
      162,
      184,
      185,
      186,
      187,
      188,
      189,
      194,
      197,
      198,
      208,
      209,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      238,
      244,
      245,
      248,
      279,
      280,
      281,
      282,
      283,
      285,
      286,
      287,
      333,
      334,
      338,
      342,
      343,
      348,
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      400,
      401,
      402,
      405,
      406,
      407,
      414,
      415,
      459,
      461,
      469,
      471,
      481,
      488,
      510,
      511,
      512,
      567,
      572,
      573,
      574,
      577,
      578,
      587,
      588,
      589,
      590,
      591,
      592,
      610,
      611,
      618,
      619,
      625,
      641,
      657,
      661,
      695,
      696,
      697,
      706,
      707,
      725,
      729,
      730,
      753,
      776,
      782,
      783,
      789,
      790,
      791,
      792,
      793,
      794,
      795,
      796,
      797,
      798,
      804,
      816,
      817,
      818,
      819,
      843,
      845,
      871,
      879,
      880,
      883,
      887,
      890,
      891,
      895,
      901,
      903,
      906,
      907,
      908,
      909,
      911,
      915,
      916,
      919,
      933,
      934,
      935,
      948,
      949,
      953,
      956,
      957,
      959,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      982,
      996,
      997,
      998,
      1011,
      1012,
      1015,
      1019,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1031,
      1032,
      1033,
      1034,
      1035,
      1041,
      1042,
      1043,
      1044,
      1045,
      1046,
      1049,
      1050,
      1053,
      1077,
      1078,
      1079,
      1080,
      1081,
      1085,
      1086,
      1087,
      1093,
      1100,
      1134,
      1135,
      1136,
      1137,
      1139,
      1143,
      1144,
      1170,
      1171,
      1179,
      1212,
      1214,
      1215,
      1226,
      1238,
      1246,
      1248,
      1252,
      1255,
      1256,
      1257,
      1258,
      1259,
      1260,
      1269,
      1270,
      1271,
      1278,
      1324,
      1327,
      1328,
      1332,
      1341,
      1350,
      1351,
      1352,
      1353,
      1359,
      1360,
      1370,
      1371,
      1372,
      1373,
      1374,
      1385,
      1386,
      1387,
      1398,
      1411,
      1420,
      1421,
      1422,
      1423,
      1424,
      1427,
      1433,
      1434,
      1442,
      1444,
      1445,
      1446,
      1447,
      1448,
      1451,
      1453,
      1460,
      1468,
      1496,
      1497,
      1502,
      1509,
      1518,
      1521,
      1523,
      1525,
      1530,
      1531,
      1532,
      1533,
      1535,
      1536,
      1537,
      1558,
      1559,
      1560,
      1561,
      1562,
      1563,
      1564,
      1572,
      1574,
      1575,
      1576,
      1582,
      1583,
      1584,
      1605,
      1618,
      1619,
      1620,
      1623,
      1625,
      1641,
      1649,
      1657,
      1677,
      1687,
      1701,
      1705,
      1708,
      1709,
      1710,
      1729,
      1730,
      1731,
      1732,
      1737,
      1743,
      1744,
      1745,
      1757,
      1785,
      1786,
      1787,
      1788,
      1789,
      1790,
      1791,
      1792,
      1822,
      1823,
      1841,
      1848,
      1854,
      1855,
      1858,
      1862,
      1881,
      1886,
      1887,
      1892
    ],
    "nat": [
      6,
      7,
      8,
      12,
      24,
      83,
      84,
      123,
      125,
      126,
      145,
      192,
      219,
      220,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      250,
      327,
      339,
      340,
      341,
      391,
      406,
      417,
      418,
      481,
      501,
      523,
      524,
      525,
      526,
      527,
      528,
      548,
      554,
      566,
      598,
      622,
      623,
      658,
      676,
      678,
      701,
      721,
      727,
      728,
      739,
      750,
      760,
      761,
      762,
      763,
      764,
      765,
      766,
      776,
      784,
      834,
      867,
      868,
      869,
      883,
      911,
      923,
      932,
      954,
      956,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1016,
      1017,
      1018,
      1049,
      1050,
      1054,
      1093,
      1117,
      1118,
      1125,
      1127,
      1148,
      1162,
      1178,
      1191,
      1197,
      1213,
      1230,
      1235,
      1239,
      1248,
      1316,
      1317,
      1318,
      1341,
      1365,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1402,
      1419,
      1425,
      1436,
      1437,
      1438,
      1439,
      1479,
      1480,
      1524,
      1542,
      1543,
      1544,
      1576,
      1655,
      1661,
      1667,
      1668,
      1669,
      1670,
      1696,
      1697,
      1698,
      1699,
      1841,
      1842,
      1845,
      1846,
      1859,
      1892
    ],
    "continuity": [
      11,
      16,
      18,
      20,
      25,
      48,
      89,
      103,
      104,
      105,
      142,
      162,
      259,
      260,
      261,
      349,
      350,
      351,
      475,
      478,
      479,
      514,
      515,
      516,
      517,
      518,
      574,
      584,
      585,
      586,
      708,
      709,
      710,
      711,
      712,
      713,
      722,
      723,
      724,
      833,
      843,
      874,
      878,
      880,
      882,
      917,
      918,
      919,
      920,
      930,
      956,
      1020,
      1048,
      1091,
      1113,
      1136,
      1140,
      1141,
      1142,
      1157,
      1216,
      1217,
      1218,
      1219,
      1224,
      1225,
      1276,
      1331,
      1336,
      1364,
      1376,
      1382,
      1383,
      1427,
      1487,
      1554,
      1566,
      1582,
      1583,
      1598,
      1606,
      1626,
      1655,
      1687,
      1690,
      1693,
      1749,
      1750,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798,
      1820,
      1821,
      1822,
      1823,
      1888,
      1892
    ],
    "order": [
      12,
      14,
      16,
      17,
      19,
      20,
      24,
      31,
      34,
      35,
      48,
      60,
      66,
      68,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      108,
      109,
      123,
      126,
      129,
      130,
      145,
      152,
      154,
      155,
      156,
      157,
      160,
      187,
      194,
      197,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      235,
      236,
      237,
      240,
      248,
      250,
      254,
      255,
      256,
      257,
      276,
      288,
      290,
      327,
      333,
      334,
      335,
      342,
      343,
      345,
      357,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      382,
      383,
      391,
      400,
      401,
      402,
      422,
      424,
      425,
      426,
      427,
      434,
      449,
      450,
      475,
      520,
      521,
      522,
      561,
      562,
      563,
      564,
      565,
      566,
      567,
      572,
      573,
      574,
      587,
      588,
      589,
      590,
      591,
      592,
      610,
      617,
      618,
      619,
      639,
      640,
      641,
      642,
      643,
      644,
      655,
      688,
      690,
      700,
      702,
      703,
      704,
      705,
      707,
      721,
      727,
      728,
      754,
      755,
      760,
      761,
      762,
      772,
      775,
      776,
      777,
      781,
      785,
      789,
      790,
      791,
      792,
      793,
      794,
      795,
      796,
      797,
      798,
      804,
      805,
      835,
      843,
      846,
      871,
      876,
      877,
      878,
      879,
      881,
      882,
      883,
      887,
      901,
      911,
      912,
      913,
      923,
      927,
      928,
      932,
      935,
      937,
      950,
      956,
      957,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      980,
      981,
      983,
      986,
      987,
      988,
      989,
      991,
      995,
      999,
      1011,
      1012,
      1029,
      1031,
      1032,
      1033,
      1034,
      1035,
      1046,
      1057,
      1058,
      1059,
      1060,
      1115,
      1116,
      1127,
      1128,
      1129,
      1130,
      1131,
      1132,
      1134,
      1135,
      1136,
      1143,
      1144,
      1157,
      1168,
      1169,
      1170,
      1171,
      1172,
      1207,
      1236,
      1238,
      1239,
      1244,
      1247,
      1248,
      1251,
      1255,
      1256,
      1257,
      1258,
      1259,
      1260,
      1277,
      1279,
      1319,
      1322,
      1324,
      1327,
      1328,
      1331,
      1332,
      1335,
      1336,
      1350,
      1360,
      1365,
      1367,
      1368,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1375,
      1385,
      1386,
      1387,
      1411,
      1414,
      1435,
      1448,
      1453,
      1468,
      1471,
      1472,
      1473,
      1474,
      1479,
      1480,
      1484,
      1485,
      1489,
      1506,
      1525,
      1526,
      1535,
      1536,
      1537,
      1541,
      1542,
      1543,
      1544,
      1546,
      1547,
      1554,
      1559,
      1560,
      1562,
      1563,
      1578,
      1582,
      1583,
      1584,
      1585,
      1586,
      1587,
      1592,
      1594,
      1601,
      1605,
      1622,
      1626,
      1655,
      1659,
      1660,
      1673,
      1688,
      1696,
      1697,
      1698,
      1699,
      1701,
      1705,
      1708,
      1709,
      1710,
      1713,
      1714,
      1715,
      1723,
      1728,
      1735,
      1736,
      1737,
      1747,
      1757,
      1767,
      1776,
      1782,
      1783,
      1784,
      1799,
      1820,
      1836,
      1845,
      1846,
      1854,
      1856,
      1857,
      1858,
      1859,
      1862,
      1879,
      1880,
      1886,
      1887,
      1892,
      1895
    ],
    "function": [
      20,
      24,
      60,
      61,
      67,
      107,
      108,
      109,
      123,
      125,
      126,
      127,
      128,
      154,
      155,
      156,
      157,
      187,
      207,
      208,
      209,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      290,
      323,
      324,
      342,
      343,
      380,
      503,
      504,
      505,
      506,
      518,
      538,
      549,
      550,
      554,
      559,
      587,
      588,
      589,
      590,
      591,
      592,
      596,
      597,
      639,
      640,
      655,
      708,
      709,
      710,
      711,
      712,
      713,
      744,
      785,
      804,
      828,
      882,
      883,
      900,
      901,
      923,
      924,
      925,
      926,
      935,
      956,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      999,
      1126,
      1143,
      1144,
      1147,
      1168,
      1169,
      1216,
      1217,
      1218,
      1219,
      1246,
      1331,
      1385,
      1386,
      1387,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410,
      1443,
      1452,
      1673,
      1690,
      1701,
      1708,
      1709,
      1710,
      1722,
      1749,
      1750,
      1775,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798,
      1848,
      1859,
      1892
    ],
    "algebra": [
      24,
      34,
      35,
      61,
      62,
      64,
      66,
      67,
      68,
      81,
      83,
      97,
      99,
      100,
      101,
      102,
      106,
      151,
      152,
      192,
      193,
      194,
      204,
      220,
      235,
      258,
      261,
      285,
      286,
      287,
      291,
      292,
      293,
      294,
      310,
      311,
      312,
      318,
      319,
      321,
      322,
      323,
      324,
      331,
      332,
      344,
      346,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      384,
      399,
      400,
      401,
      402,
      408,
      422,
      449,
      450,
      456,
      458,
      459,
      461,
      462,
      463,
      464,
      465,
      469,
      471,
      500,
      501,
      502,
      503,
      504,
      505,
      506,
      521,
      522,
      523,
      524,
      525,
      526,
      527,
      529,
      530,
      531,
      532,
      554,
      557,
      558,
      560,
      562,
      564,
      580,
      581,
      582,
      583,
      596,
      597,
      617,
      622,
      623,
      636,
      650,
      651,
      652,
      653,
      657,
      658,
      676,
      693,
      694,
      698,
      714,
      731,
      734,
      735,
      736,
      737,
      738,
      748,
      804,
      812,
      813,
      814,
      815,
      820,
      856,
      857,
      858,
      883,
      900,
      903,
      910,
      954,
      955,
      957,
      965,
      980,
      990,
      998,
      1000,
      1005,
      1010,
      1029,
      1031,
      1032,
      1033,
      1034,
      1035,
      1050,
      1081,
      1082,
      1085,
      1086,
      1116,
      1117,
      1118,
      1119,
      1120,
      1121,
      1129,
      1131,
      1147,
      1162,
      1175,
      1176,
      1178,
      1191,
      1210,
      1211,
      1228,
      1229,
      1246,
      1272,
      1283,
      1284,
      1285,
      1332,
      1354,
      1361,
      1365,
      1379,
      1380,
      1381,
      1383,
      1384,
      1399,
      1400,
      1427,
      1437,
      1438,
      1439,
      1443,
      1462,
      1473,
      1474,
      1475,
      1483,
      1487,
      1490,
      1491,
      1493,
      1502,
      1506,
      1509,
      1514,
      1515,
      1517,
      1526,
      1535,
      1536,
      1537,
      1559,
      1560,
      1561,
      1562,
      1564,
      1565,
      1576,
      1592,
      1593,
      1605,
      1618,
      1621,
      1650,
      1651,
      1652,
      1653,
      1654,
      1658,
      1661,
      1662,
      1663,
      1664,
      1665,
      1666,
      1688,
      1693,
      1695,
      1701,
      1713,
      1714,
      1715,
      1717,
      1720,
      1721,
      1722,
      1727,
      1732,
      1735,
      1736,
      1744,
      1745,
      1747,
      1757,
      1758,
      1759,
      1760,
      1766,
      1768,
      1778,
      1800,
      1826,
      1835,
      1836,
      1837,
      1838,
      1842,
      1844,
      1848,
      1856,
      1857,
      1858,
      1870,
      1872,
      1873,
      1875,
      1886,
      1887,
      1888,
      1894,
      1900,
      1902,
      1903
    ],
    "finset": [
      24,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      67,
      125,
      126,
      150,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      208,
      209,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      250,
      319,
      325,
      339,
      340,
      341,
      382,
      383,
      406,
      565,
      584,
      585,
      586,
      642,
      643,
      644,
      672,
      673,
      674,
      676,
      678,
      687,
      727,
      728,
      747,
      783,
      784,
      803,
      804,
      805,
      816,
      846,
      862,
      863,
      864,
      865,
      866,
      883,
      892,
      912,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1005,
      1016,
      1017,
      1018,
      1022,
      1049,
      1132,
      1140,
      1141,
      1142,
      1172,
      1188,
      1189,
      1190,
      1191,
      1197,
      1230,
      1238,
      1252,
      1279,
      1319,
      1324,
      1336,
      1341,
      1342,
      1343,
      1344,
      1345,
      1346,
      1360,
      1429,
      1430,
      1431,
      1432,
      1436,
      1451,
      1453,
      1454,
      1479,
      1480,
      1516,
      1523,
      1524,
      1541,
      1543,
      1544,
      1578,
      1588,
      1693,
      1723,
      1768,
      1773,
      1833,
      1864,
      1865,
      1895
    ],
    "real": [
      25,
      80,
      82,
      83,
      84,
      85,
      104,
      318,
      321,
      322,
      348,
      520,
      572,
      573,
      574,
      663,
      664,
      665,
      666,
      667,
      668,
      669,
      670,
      708,
      709,
      710,
      711,
      712,
      713,
      714,
      721,
      744,
      843,
      911,
      917,
      920,
      1115,
      1134,
      1135,
      1136,
      1181,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1216,
      1217,
      1218,
      1219,
      1250,
      1336,
      1338,
      1362,
      1365,
      1367,
      1368,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1375,
      1382,
      1411,
      1494,
      1519,
      1520,
      1527,
      1571,
      1585,
      1586,
      1587,
      1604,
      1606,
      1623,
      1625,
      1688,
      1692,
      1693,
      1705,
      1764,
      1765,
      1768,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798,
      1799,
      1818,
      1836,
      1863,
      1886,
      1887,
      1892
    ],
    "complex": [
      25,
      105,
      163,
      318,
      321,
      322,
      447,
      662,
      663,
      664,
      851,
      852,
      853,
      854,
      855,
      1070,
      1180,
      1181,
      1182,
      1280,
      1281,
      1282,
      1336,
      1338,
      1693,
      1764,
      1818
    ],
    "norm": [
      25,
      26,
      27,
      28,
      62,
      64,
      82,
      83,
      85,
      103,
      145,
      162,
      163,
      220,
      237,
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      441,
      481,
      548,
      562,
      564,
      582,
      583,
      622,
      623,
      624,
      626,
      627,
      628,
      629,
      636,
      662,
      663,
      664,
      665,
      666,
      667,
      668,
      669,
      670,
      714,
      721,
      749,
      763,
      764,
      766,
      772,
      835,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      884,
      885,
      886,
      903,
      917,
      918,
      919,
      932,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1093,
      1125,
      1129,
      1131,
      1162,
      1180,
      1181,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1234,
      1244,
      1277,
      1280,
      1281,
      1282,
      1356,
      1365,
      1366,
      1367,
      1368,
      1375,
      1415,
      1427,
      1450,
      1526,
      1530,
      1531,
      1532,
      1533,
      1554,
      1565,
      1658,
      1688,
      1691,
      1693,
      1742,
      1764,
      1765,
      1766,
      1767,
      1775,
      1776,
      1799,
      1800,
      1836,
      1872,
      1873,
      1886,
      1887,
      1901
    ],
    "differentiability": [
      25,
      26,
      27,
      28,
      105,
      203,
      447,
      884,
      885,
      886,
      1070,
      1339,
      1623,
      1625
    ],
    "int": [
      25,
      64,
      111,
      192,
      378,
      379,
      391,
      458,
      459,
      481,
      580,
      581,
      663,
      664,
      665,
      666,
      667,
      668,
      669,
      670,
      671,
      676,
      701,
      740,
      812,
      813,
      814,
      815,
      851,
      852,
      853,
      854,
      855,
      903,
      954,
      1050,
      1093,
      1181,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1191,
      1213,
      1280,
      1281,
      1282,
      1336,
      1356,
      1389,
      1436,
      1437,
      1438,
      1439,
      1494,
      1576,
      1686,
      1764,
      1765,
      1799,
      1870,
      1871,
      1894
    ],
    "equiv": [
      29,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      261,
      296,
      319,
      348,
      477,
      530,
      531,
      630,
      635,
      695,
      696,
      697,
      718,
      751,
      752,
      780,
      799,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1005,
      1019,
      1050,
      1163,
      1212,
      1230,
      1245,
      1246,
      1392,
      1427,
      1487,
      1554,
      1576,
      1627,
      1628,
      1656,
      1662,
      1663,
      1666,
      1673,
      1722,
      1723,
      1727,
      1759,
      1821,
      1822,
      1843,
      1848,
      1875,
      1893
    ],
    "measurability": [
      32,
      33,
      48,
      49,
      52,
      53,
      54,
      55,
      56,
      57,
      160,
      190,
      233,
      290,
      393,
      522,
      725,
      773,
      781,
      783,
      843,
      860,
      861,
      890,
      891,
      896,
      897,
      898,
      919,
      937,
      979,
      999,
      1022,
      1039,
      1116,
      1226,
      1250,
      1251,
      1252,
      1287,
      1383,
      1411,
      1447,
      1448,
      1455,
      1467,
      1468,
      1553,
      1596,
      1597,
      1598,
      1624,
      1629,
      1667,
      1668,
      1669,
      1670,
      1861,
      1881,
      1882,
      1892
    ],
    "topology": [
      48,
      83,
      158,
      159,
      197,
      220,
      251,
      252,
      253,
      336,
      337,
      342,
      343,
      380,
      381,
      447,
      475,
      488,
      510,
      511,
      533,
      663,
      664,
      729,
      781,
      823,
      824,
      833,
      845,
      846,
      871,
      936,
      1013,
      1014,
      1070,
      1087,
      1100,
      1161,
      1181,
      1182,
      1223,
      1251,
      1276,
      1278,
      1279,
      1327,
      1328,
      1329,
      1330,
      1336,
      1364,
      1365,
      1366,
      1383,
      1444,
      1445,
      1446,
      1450,
      1467,
      1468,
      1482,
      1572,
      1582,
      1583,
      1584,
      1595,
      1626,
      1656,
      1658,
      1677,
      1685,
      1687,
      1688,
      1741,
      1751,
      1756,
      1757,
      1764,
      1776,
      1820,
      1849,
      1850,
      1861,
      1885,
      1886,
      1887,
      1892
    ]
  },
  "by_transform": {
    "use_simpa": [
      0,
      1,
      2,
      3,
      4,
      9,
      10,
      11,
      13,
      24,
      28,
      43,
      44,
      46,
      47,
      73,
      124,
      126,
      129,
      133,
      152,
      156,
      164,
      165,
      166,
      168,
      169,
      171,
      173,
      174,
      181,
      182,
      194,
      201,
      204,
      217,
      249,
      254,
      255,
      256,
      257,
      258,
      262,
      270,
      286,
      290,
      298,
      329,
      330,
      338,
      349,
      350,
      351,
      385,
      418,
      424,
      446,
      468,
      472,
      514,
      519,
      520,
      524,
      525,
      528,
      540,
      547,
      548,
      549,
      550,
      563,
      569,
      571,
      574,
      584,
      586,
      600,
      606,
      608,
      617,
      619,
      623,
      650,
      651,
      660,
      661,
      662,
      663,
      664,
      665,
      666,
      667,
      668,
      669,
      672,
      674,
      676,
      696,
      706,
      708,
      713,
      720,
      740,
      741,
      743,
      754,
      767,
      768,
      774,
      781,
      782,
      783,
      790,
      806,
      816,
      848,
      850,
      852,
      853,
      856,
      857,
      858,
      859,
      872,
      873,
      874,
      875,
      883,
      892,
      893,
      894,
      907,
      927,
      939,
      940,
      941,
      943,
      945,
      947,
      957,
      963,
      965,
      969,
      985,
      986,
      987,
      988,
      989,
      990,
      994,
      998,
      999,
      1002,
      1008,
      1015,
      1020,
      1036,
      1054,
      1057,
      1084,
      1088,
      1113,
      1114,
      1115,
      1117,
      1118,
      1122,
      1125,
      1130,
      1136,
      1140,
      1142,
      1149,
      1152,
      1153,
      1162,
      1175,
      1176,
      1179,
      1180,
      1181,
      1182,
      1184,
      1185,
      1186,
      1188,
      1190,
      1191,
      1215,
      1216,
      1219,
      1221,
      1231,
      1236,
      1240,
      1242,
      1251,
      1252,
      1256,
      1264,
      1281,
      1283,
      1284,
      1285,
      1286
    ],
    "use_aesop": [
      7,
      8,
      42,
      107,
      170,
      174,
      196,
      204,
      333,
      337,
      348,
      479,
      480,
      525,
      565,
      594,
      599,
      651,
      667,
      706,
      808,
      845,
      868,
      869,
      944,
      945,
      958,
      965,
      1011,
      1014,
      1092,
      1118,
      1132,
      1146,
      1176,
      1184,
      1215,
      1266,
      1278
    ],
    "use_grind": [
      7,
      15,
      29,
      32,
      37,
      41,
      46,
      72,
      73,
      146,
      147,
      151,
      166,
      170,
      172,
      178,
      184,
      185,
      187,
      210,
      211,
      213,
      214,
      215,
      216,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      238,
      250,
      270,
      276,
      282,
      288,
      325,
      339,
      340,
      341,
      347,
      374,
      394,
      425,
      524,
      537,
      548,
      594,
      604,
      606,
      613,
      633,
      639,
      640,
      642,
      643,
      678,
      679,
      719,
      748,
      749,
      789,
      800,
      818,
      819,
      858,
      868,
      890,
      894,
      907,
      917,
      933,
      941,
      944,
      946,
      948,
      949,
      966,
      967,
      968,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      982,
      994,
      995,
      997,
      1009,
      1016,
      1017,
      1018,
      1040,
      1117,
      1125,
      1146,
      1151,
      1152,
      1155,
      1161,
      1164,
      1165,
      1166,
      1168,
      1169,
      1172,
      1197,
      1198,
      1220,
      1228,
      1234,
      1255,
      1261,
      1262,
      1270,
      1271,
      1285,
      1288,
      1324,
      1344,
      1419,
      1432,
      1442,
      1480,
      1537,
      1674,
      1675,
      1700,
      1764,
      1829,
      1835,
      1899,
      1902
    ],
    "cleanup_simp": [
      13,
      26,
      29,
      46,
      51,
      55,
      56,
      72,
      98,
      128,
      170,
      175,
      180,
      182,
      215,
      234,
      288,
      290,
      325,
      329,
      336,
      337,
      339,
      341,
      362,
      420,
      442,
      471,
      474,
      489,
      491,
      495,
      496,
      515,
      518,
      537,
      569,
      571,
      594,
      597,
      606,
      658,
      667,
      669,
      676,
      690,
      707,
      735,
      740,
      749,
      756,
      779,
      780,
      789,
      790,
      805,
      815,
      835,
      841,
      848,
      875,
      884,
      894,
      897,
      926,
      944,
      999,
      1013,
      1014,
      1016,
      1018,
      1024,
      1086,
      1101,
      1102,
      1103,
      1146,
      1147,
      1152,
      1178,
      1184,
      1186,
      1191,
      1207,
      1234,
      1237,
      1255,
      1256,
      1277
    ],
    "use_fun_prop": [
      17,
      18,
      103,
      104,
      160,
      444,
      495,
      496,
      514,
      540,
      541,
      683,
      725,
      879,
      880,
      917,
      918,
      919,
      920,
      937,
      1068,
      1102,
      1103,
      1113,
      1122,
      1123,
      1202,
      1226,
      1250,
      1382
    ],
    "term_mode": [
      19,
      389,
      469,
      508,
      563,
      572,
      613,
      634,
      881,
      1037,
      1085,
      1110,
      1130,
      1134,
      1155,
      1167
    ],
    "use_omega": [
      46,
      169,
      192,
      282,
      373,
      894,
      943,
      997
    ],
    "use_ring": [
      46,
      200,
      247,
      251,
      252,
      253,
      269,
      300,
      305,
      306,
      375,
      450,
      454,
      516,
      525,
      527,
      596,
      894,
      962,
      1118
    ],
    "use_linarith": [
      57,
      682,
      683,
      684,
      686,
      724,
      759,
      790,
      898,
      1201,
      1202,
      1203,
      1206,
      1225,
      1256
    ],
    "remove_redundant": [
      81,
      104,
      117,
      128,
      144,
      154,
      187,
      407,
      451,
      605,
      606,
      637,
      748,
      754,
      910,
      920,
      926,
      931,
      935,
      1152,
      1236,
      1483,
      1548,
      1625
    ],
    "use_simp": [
      89,
      399,
      442,
      597,
      735,
      1147
    ],
    "line_break": [
      128,
      191,
      428,
      471,
      635,
      636,
      735,
      859,
      926,
      1061,
      1086,
      1286,
      1486,
      1509,
      1510,
      1552
    ],
    "naming": [
      163,
      219,
      421,
      423,
      526,
      554
    ]
  },
  "by_new_tactic": {
    "simpa": [
      0,
      1,
      2,
      3,
      4,
      9,
      10,
      11,
      13,
      24,
      28,
      43,
      44,
      46,
      47,
      73,
      124,
      126,
      133,
      152,
      156,
      194,
      201,
      217,
      249,
      254,
      255,
      256,
      257,
      258,
      270,
      286,
      290,
      298,
      330,
      338,
      349,
      350,
      351,
      385,
      418,
      424,
      446,
      468,
      514,
      519,
      520,
      524,
      525,
      528,
      540,
      547,
      548,
      549,
      550,
      563,
      569,
      571,
      584,
      600,
      606,
      608,
      619,
      650,
      651,
      660,
      661,
      662,
      663,
      664,
      665,
      672,
      674,
      696,
      706,
      708,
      713,
      720,
      741,
      743,
      754,
      767,
      768,
      774,
      781,
      782,
      783,
      790,
      806,
      816,
      848,
      850,
      852,
      853,
      856,
      857,
      858,
      859,
      872,
      873,
      874,
      875,
      883,
      892,
      893,
      894,
      907,
      957,
      963,
      969,
      985,
      986,
      987,
      988,
      989,
      990,
      994,
      998,
      999,
      1002,
      1008,
      1015,
      1020,
      1036,
      1054,
      1057,
      1084,
      1113,
      1114,
      1115,
      1117,
      1118,
      1122,
      1125,
      1130,
      1140,
      1149,
      1152,
      1153,
      1175,
      1176,
      1179,
      1180,
      1181,
      1182,
      1188,
      1190,
      1215,
      1216,
      1219,
      1221,
      1231,
      1236,
      1240,
      1242,
      1251,
      1252,
      1256,
      1264,
      1281,
      1283,
      1284,
      1285,
      1286
    ],
    "exact": [
      6,
      19,
      27,
      32,
      46,
      54,
      71,
      74,
      75,
      76,
      77,
      78,
      79,
      88,
      125,
      132,
      169,
      178,
      179,
      181,
      185,
      191,
      199,
      207,
      215,
      234,
      238,
      242,
      243,
      299,
      335,
      336,
      338,
      339,
      357,
      377,
      466,
      467,
      468,
      470,
      488,
      506,
      520,
      524,
      527,
      533,
      541,
      542,
      559,
      561,
      562,
      563,
      564,
      570,
      587,
      609,
      648,
      649,
      657,
      678,
      683,
      687,
      690,
      695,
      703,
      704,
      706,
      716,
      721,
      724,
      742,
      743,
      749,
      753,
      767,
      801,
      802,
      808,
      828,
      831,
      851,
      854,
      855,
      859,
      861,
      881,
      885,
      890,
      894,
      896,
      908,
      909,
      943,
      946,
      947,
      949,
      960,
      982,
      1013,
      1015,
      1016,
      1035,
      1083,
      1084,
      1100,
      1115,
      1117,
      1123,
      1126,
      1128,
      1129,
      1130,
      1131,
      1197,
      1202,
      1207,
      1215,
      1225,
      1231,
      1234,
      1240,
      1266,
      1275,
      1280,
      1282,
      1286
    ],
    "congr": [
      9,
      10,
      166,
      178,
      183,
      301,
      407,
      471,
      491,
      520,
      525,
      562,
      564,
      657,
      683,
      716,
      741,
      743,
      790,
      834,
      872,
      873,
      941,
      946,
      1086,
      1101,
      1115,
      1118,
      1129,
      1131,
      1202,
      1231,
      1256,
      1602
    ],
    "apply": [
      13,
      15,
      16,
      33,
      41,
      42,
      43,
      129,
      135,
      142,
      151,
      152,
      166,
      167,
      176,
      183,
      213,
      261,
      270,
      299,
      420,
      433,
      479,
      515,
      516,
      546,
      561,
      562,
      563,
      565,
      614,
      663,
      664,
      678,
      684,
      688,
      690,
      703,
      704,
      726,
      741,
      743,
      789,
      790,
      808,
      875,
      878,
      891,
      892,
      927,
      941,
      942,
      966,
      994,
      1128,
      1129,
      1130,
      1132,
      1181,
      1182,
      1197,
      1203,
      1207,
      1231,
      1255,
      1256,
      1266
    ],
    "rw": [
      13,
      25,
      26,
      27,
      36,
      37,
      40,
      41,
      43,
      46,
      66,
      71,
      73,
      88,
      151,
      186,
      192,
      193,
      200,
      210,
      211,
      213,
      282,
      283,
      328,
      332,
      333,
      359,
      360,
      365,
      407,
      424,
      464,
      468,
      470,
      491,
      497,
      515,
      520,
      525,
      527,
      530,
      532,
      542,
      546,
      564,
      575,
      578,
      584,
      594,
      598,
      600,
      604,
      606,
      608,
      624,
      631,
      632,
      633,
      645,
      667,
      669,
      675,
      680,
      690,
      709,
      711,
      712,
      714,
      716,
      719,
      733,
      742,
      743,
      749,
      756,
      758,
      779,
      780,
      784,
      787,
      790,
      798,
      801,
      806,
      812,
      813,
      817,
      818,
      849,
      852,
      854,
      855,
      857,
      858,
      859,
      875,
      884,
      885,
      886,
      892,
      894,
      907,
      955,
      962,
      966,
      996,
      997,
      1006,
      1007,
      1010,
      1011,
      1027,
      1057,
      1082,
      1084,
      1101,
      1104,
      1115,
      1118,
      1119,
      1131,
      1139,
      1140,
      1146,
      1148,
      1149,
      1151,
      1152,
      1153,
      1184,
      1186,
      1207,
      1217,
      1218,
      1220,
      1231,
      1234,
      1237,
      1254,
      1256,
      1260,
      1264,
      1268,
      1270,
      1281,
      1282,
      1284,
      1285,
      1286,
      1333,
      1341,
      1391,
      1433,
      1434,
      1480,
      1504,
      1533,
      1594,
      1627,
      1730,
      1731,
      1840,
      1864,
      1903
    ],
    "simp": [
      13,
      14,
      23,
      43,
      45,
      46,
      51,
      55,
      56,
      58,
      70,
      72,
      73,
      76,
      77,
      84,
      89,
      128,
      151,
      154,
      158,
      159,
      170,
      175,
      180,
      186,
      204,
      212,
      213,
      215,
      234,
      235,
      236,
      241,
      258,
      259,
      260,
      265,
      266,
      267,
      268,
      279,
      283,
      284,
      287,
      288,
      297,
      298,
      299,
      306,
      308,
      312,
      314,
      315,
      323,
      324,
      325,
      327,
      328,
      331,
      336,
      337,
      339,
      340,
      341,
      365,
      380,
      381,
      396,
      397,
      405,
      408,
      409,
      416,
      422,
      424,
      426,
      439,
      440,
      441,
      442,
      443,
      445,
      447,
      462,
      463,
      473,
      475,
      477,
      488,
      489,
      491,
      495,
      496,
      499,
      509,
      513,
      514,
      515,
      517,
      519,
      524,
      525,
      526,
      527,
      528,
      532,
      537,
      540,
      541,
      543,
      547,
      551,
      552,
      553,
      554,
      559,
      561,
      562,
      563,
      564,
      573,
      575,
      578,
      580,
      581,
      582,
      583,
      584,
      588,
      589,
      592,
      598,
      599,
      602,
      603,
      606,
      615,
      618,
      624,
      626,
      627,
      628,
      629,
      645,
      646,
      652,
      653,
      671,
      678,
      690,
      692,
      697,
      700,
      706,
      709,
      710,
      711,
      712,
      714,
      715,
      719,
      720,
      744,
      749,
      756,
      768,
      777,
      779,
      780,
      787,
      788,
      790,
      792,
      795,
      797,
      798,
      806,
      807,
      808,
      810,
      812,
      813,
      814,
      815,
      816,
      818,
      825,
      826,
      827,
      829,
      835,
      843,
      860,
      875,
      876,
      892,
      894,
      897,
      899,
      906,
      907,
      908,
      909,
      911,
      926,
      935,
      944,
      965,
      966,
      980,
      981,
      984,
      990,
      1001,
      1002,
      1013,
      1014,
      1016,
      1017,
      1018,
      1027,
      1051,
      1057,
      1058,
      1069,
      1070,
      1089,
      1100,
      1101,
      1102,
      1103,
      1107,
      1111,
      1112,
      1113,
      1114,
      1117,
      1118,
      1119,
      1122,
      1123,
      1124,
      1126,
      1128,
      1129,
      1130,
      1131,
      1135,
      1139,
      1140,
      1143,
      1144,
      1148,
      1152,
      1197,
      1207,
      1212,
      1215,
      1217,
      1218,
      1220,
      1221,
      1234,
      1237,
      1242,
      1254,
      1256,
      1257,
      1258,
      1259,
      1260,
      1264,
      1265,
      1266,
      1267,
      1270,
      1277,
      1287
    ],
    "have": [
      13,
      28,
      36,
      37,
      38,
      39,
      41,
      46,
      53,
      57,
      62,
      70,
      73,
      74,
      97,
      100,
      101,
      105,
      130,
      136,
      146,
      147,
      148,
      166,
      174,
      177,
      184,
      186,
      204,
      213,
      214,
      215,
      216,
      249,
      276,
      297,
      298,
      338,
      339,
      340,
      341,
      359,
      361,
      365,
      368,
      369,
      370,
      371,
      372,
      382,
      436,
      437,
      457,
      464,
      501,
      505,
      508,
      511,
      515,
      520,
      524,
      525,
      540,
      541,
      555,
      561,
      562,
      563,
      572,
      573,
      577,
      578,
      598,
      600,
      604,
      606,
      608,
      661,
      664,
      667,
      669,
      673,
      677,
      678,
      679,
      681,
      683,
      685,
      686,
      690,
      702,
      719,
      720,
      722,
      727,
      732,
      743,
      749,
      754,
      755,
      757,
      762,
      763,
      764,
      767,
      779,
      790,
      792,
      794,
      800,
      806,
      808,
      812,
      816,
      819,
      831,
      835,
      846,
      851,
      852,
      859,
      861,
      875,
      894,
      898,
      906,
      907,
      929,
      933,
      941,
      945,
      948,
      965,
      966,
      967,
      968,
      985,
      995,
      1001,
      1002,
      1015,
      1016,
      1017,
      1018,
      1027,
      1030,
      1066,
      1067,
      1075,
      1082,
      1110,
      1115,
      1117,
      1118,
      1122,
      1123,
      1128,
      1129,
      1130,
      1134,
      1135,
      1137,
      1139,
      1148,
      1149,
      1151,
      1152,
      1153,
      1179,
      1182,
      1184,
      1186,
      1189,
      1195,
      1197,
      1198,
      1200,
      1202,
      1205,
      1206,
      1207,
      1220,
      1221,
      1224,
      1227,
      1231,
      1234,
      1236,
      1240,
      1256,
      1257,
      1261,
      1264,
      1266,
      1271,
      1275,
      1277,
      1279,
      1280,
      1281,
      1286
    ],
    "cases": [
      14,
      41,
      46,
      210,
      325,
      338,
      339,
      340,
      438,
      515,
      525,
      526,
      527,
      528,
      551,
      552,
      553,
      646,
      652,
      720,
      732,
      790,
      808,
      876,
      894,
      1015,
      1016,
      1017,
      1118,
      1221,
      1227,
      1256,
      1266
    ],
    "nlinarith": [
      15
    ],
    "grind": [
      15,
      29,
      32,
      37,
      41,
      46,
      72,
      73,
      146,
      147,
      151,
      166,
      170,
      172,
      178,
      184,
      185,
      210,
      211,
      213,
      214,
      215,
      216,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      238,
      250,
      270,
      282,
      288,
      325,
      339,
      340,
      341,
      347,
      374,
      394,
      425,
      524,
      537,
      548,
      594,
      606,
      613,
      633,
      642,
      643,
      678,
      679,
      719,
      748,
      749,
      789,
      800,
      818,
      819,
      858,
      890,
      894,
      907,
      917,
      933,
      941,
      944,
      946,
      948,
      949,
      966,
      967,
      968,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      982,
      994,
      997,
      1016,
      1017,
      1018,
      1040,
      1117,
      1125,
      1146,
      1152,
      1155,
      1161,
      1164,
      1165,
      1166,
      1172,
      1197,
      1198,
      1220,
      1228,
      1234,
      1255,
      1261,
      1262,
      1270,
      1271,
      1285,
      1288,
      1324,
      1344,
      1419,
      1432,
      1442,
      1480,
      1537,
      1674,
      1675,
      1700,
      1764,
      1829,
      1835,
      1899,
      1902
    ],
    "constructor": [
      15,
      46,
      270,
      378,
      597,
      780,
      790,
      894,
      994,
      1147,
      1256
    ],
    "fun_prop": [
      17,
      18,
      444,
      495,
      496,
      514,
      540,
      541,
      683,
      725,
      879,
      880,
      917,
      919,
      1102,
      1103,
      1113,
      1122,
      1123,
      1202,
      1226,
      1382
    ],
    "positivity": [
      27,
      330,
      515,
      662,
      719,
      720,
      724,
      797,
      885,
      1006,
      1007,
      1008,
      1180,
      1220,
      1221,
      1225,
      1259
    ],
    "ext": [
      29,
      46,
      91,
      95,
      196,
      299,
      301,
      339,
      347,
      365,
      371,
      420,
      471,
      497,
      514,
      532,
      551,
      552,
      553,
      564,
      588,
      592,
      606,
      660,
      775,
      790,
      808,
      894,
      895,
      915,
      916,
      958,
      1009,
      1016,
      1027,
      1086,
      1104,
      1113,
      1119,
      1131,
      1143,
      1144,
      1152,
      1247,
      1256,
      1266,
      1516,
      1617,
      1762,
      1763
    ],
    "simp_all": [
      31,
      50,
      106,
      270,
      340,
      341,
      438,
      444,
      561,
      562,
      565,
      620,
      641,
      650,
      711,
      712,
      743,
      773,
      786,
      789,
      818,
      819,
      887,
      994,
      1017,
      1018,
      1128,
      1129,
      1132,
      1170,
      1175,
      1217,
      1218,
      1231,
      1255,
      1270,
      1271
    ],
    "induction": [
      31,
      170,
      239,
      323,
      489,
      519,
      786,
      803,
      887,
      944,
      1114
    ],
    "refine": [
      31,
      55,
      72,
      73,
      146,
      151,
      204,
      215,
      240,
      282,
      286,
      333,
      334,
      339,
      340,
      364,
      365,
      471,
      480,
      491,
      525,
      561,
      562,
      563,
      584,
      598,
      601,
      604,
      606,
      608,
      681,
      683,
      684,
      690,
      706,
      708,
      711,
      712,
      713,
      720,
      754,
      768,
      779,
      780,
      789,
      790,
      801,
      803,
      808,
      887,
      895,
      897,
      907,
      928,
      933,
      951,
      952,
      961,
      965,
      983,
      997,
      998,
      1011,
      1012,
      1016,
      1017,
      1026,
      1027,
      1086,
      1092,
      1101,
      1118,
      1128,
      1129,
      1130,
      1140,
      1148,
      1150,
      1151,
      1152,
      1153,
      1174,
      1200,
      1202,
      1203,
      1207,
      1215,
      1216,
      1217,
      1218,
      1219,
      1221,
      1223,
      1236,
      1238,
      1242,
      1243,
      1253,
      1255,
      1256,
      1266,
      1431
    ],
    "aesop": [
      42,
      170,
      174,
      196,
      204,
      333,
      337,
      479,
      480,
      525,
      565,
      594,
      599,
      667,
      706,
      808,
      845,
      944,
      945,
      958,
      965,
      1011,
      1014,
      1092,
      1118,
      1132,
      1146,
      1184,
      1215,
      1266,
      1278
    ],
    "norm_num": [
      43,
      520,
      685,
      709,
      835,
      892,
      1115,
      1205,
      1277
    ],
    "intro": [
      46,
      62,
      160,
      187,
      215,
      239,
      249,
      286,
      468,
      470,
      514,
      573,
      594,
      600,
      608,
      660,
      690,
      709,
      767,
      772,
      780,
      790,
      808,
      817,
      861,
      894,
      937,
      985,
      998,
      1084,
      1113,
      1135,
      1146,
      1149,
      1153,
      1207,
      1240,
      1256,
      1266,
      1460,
      1737,
      1864
    ],
    "ring": [
      46,
      200,
      247,
      251,
      252,
      253,
      269,
      300,
      305,
      306,
      375,
      450,
      454,
      516,
      894,
      962
    ],
    "omega": [
      46,
      192,
      894
    ],
    "obtain": [
      52,
      58,
      66,
      86,
      114,
      151,
      155,
      184,
      214,
      270,
      299,
      300,
      364,
      376,
      442,
      443,
      489,
      490,
      493,
      496,
      497,
      512,
      519,
      546,
      561,
      562,
      563,
      565,
      578,
      584,
      587,
      588,
      590,
      591,
      592,
      618,
      650,
      651,
      660,
      690,
      741,
      743,
      749,
      753,
      790,
      793,
      809,
      817,
      851,
      859,
      899,
      913,
      948,
      967,
      994,
      1026,
      1069,
      1103,
      1104,
      1114,
      1128,
      1129,
      1130,
      1132,
      1139,
      1140,
      1143,
      1144,
      1175,
      1176,
      1207,
      1231,
      1234,
      1256,
      1280,
      1286
    ],
    "funext": [
      58,
      489,
      496,
      541,
      744,
      899,
      1103,
      1123
    ],
    "decide": [
      149,
      436,
      437,
      934,
      1066,
      1067
    ],
    "gcongr": [
      199,
      201,
      270,
      419,
      517,
      563,
      684,
      724,
      789,
      790,
      855,
      960,
      963,
      994,
      1130,
      1203,
      1225,
      1255,
      1256,
      1282
    ],
    "norm_cast": [
      270,
      391,
      525,
      719,
      749,
      849,
      994,
      1118,
      1220,
      1234
    ],
    "measurability": [
      290,
      790,
      999,
      1256
    ],
    "field_simp": [
      407,
      578,
      1139
    ],
    "push_cast": [
      424,
      1057
    ],
    "fin_cases": [
      594,
      1146
    ],
    "linarith": [
      682,
      683,
      684,
      686,
      724,
      759,
      790,
      1201,
      1202,
      1203,
      1206,
      1225,
      1256
    ],
    "ring_nf": [
      790,
      815,
      1256
    ],
    "continuity": [
      800,
      1261,
      1262
    ]
  },
  "by_keyword": {
    "cons_head": [
      0,
      1,
      2,
      3,
      4
    ],
    "rwa": [
      0,
      1,
      2,
      3,
      4,
      24,
      64,
      72,
      74,
      75,
      76,
      77,
      78,
      79,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      242,
      243,
      342,
      343,
      378,
      379,
      574,
      676,
      699,
      700,
      701,
      761,
      762,
      770,
      781,
      883,
      903,
      908,
      909,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1136,
      1191,
      1213,
      1246,
      1251,
      1359,
      1448,
      1471,
      1779,
      1780,
      1781,
      1846,
      1848,
      1858
    ],
    "theorem": [
      0,
      1,
      2,
      3,
      4,
      11,
      19,
      60,
      67,
      90,
      111,
      122,
      127,
      131,
      132,
      141,
      158,
      159,
      194,
      195,
      208,
      209,
      218,
      236,
      240,
      241,
      249,
      276,
      327,
      330,
      333,
      334,
      344,
      346,
      347,
      380,
      381,
      405,
      407,
      414,
      415,
      425,
      426,
      427,
      435,
      436,
      437,
      438,
      458,
      459,
      460,
      481,
      501,
      512,
      514,
      515,
      516,
      517,
      534,
      535,
      537,
      538,
      550,
      555,
      556,
      561,
      563,
      564,
      568,
      572,
      573,
      593,
      594,
      595,
      596,
      597,
      598,
      638,
      639,
      640,
      656,
      657,
      694,
      695,
      696,
      697,
      698,
      700,
      701,
      714,
      734,
      735,
      736,
      741,
      742,
      743,
      744,
      763,
      764,
      765,
      766,
      776,
      803,
      804,
      805,
      823,
      824,
      836,
      846,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      862,
      863,
      864,
      865,
      866,
      874,
      877,
      881,
      901,
      902,
      914,
      922,
      924,
      925,
      936,
      950,
      951,
      957,
      981,
      983,
      984,
      985,
      995,
      1008,
      1009,
      1011,
      1012,
      1019,
      1053,
      1058,
      1059,
      1060,
      1066,
      1067,
      1076,
      1093,
      1113,
      1128,
      1130,
      1131,
      1133,
      1134,
      1135,
      1145,
      1146,
      1147,
      1148,
      1157,
      1168,
      1169,
      1192,
      1196,
      1211,
      1212,
      1213,
      1229,
      1230,
      1231,
      1248,
      1268,
      1279,
      1280,
      1281,
      1282,
      1293,
      1294,
      1298,
      1299,
      1303,
      1304,
      1308,
      1309,
      1313,
      1314,
      1341,
      1364,
      1378,
      1388,
      1399,
      1400,
      1403,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410,
      1411,
      1417,
      1418,
      1419,
      1435,
      1448,
      1459,
      1465,
      1467,
      1469,
      1470,
      1471,
      1486,
      1493,
      1494,
      1503,
      1504,
      1522,
      1542,
      1543,
      1544,
      1564,
      1571,
      1574,
      1575,
      1584,
      1592,
      1593,
      1594,
      1601,
      1606,
      1629,
      1672,
      1673,
      1676,
      1700,
      1703,
      1705,
      1714,
      1715,
      1716,
      1717,
      1735,
      1744,
      1745,
      1748,
      1755,
      1756,
      1761,
      1767,
      1775,
      1781,
      1822,
      1864,
      1865,
      1901
    ],
    "inhabited": [
      0,
      1,
      2,
      3,
      4,
      562,
      1129,
      1133
    ],
    "head": [
      0,
      1,
      2,
      3,
      4,
      1569,
      1570,
      1899
    ],
    "have": [
      0,
      1,
      2,
      3,
      4,
      24,
      64,
      83,
      84,
      103,
      104,
      107,
      108,
      109,
      115,
      125,
      126,
      145,
      201,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      270,
      271,
      342,
      343,
      344,
      400,
      401,
      406,
      458,
      459,
      548,
      566,
      567,
      574,
      611,
      655,
      676,
      750,
      756,
      771,
      782,
      820,
      830,
      883,
      903,
      911,
      917,
      918,
      920,
      921,
      932,
      963,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      994,
      1029,
      1049,
      1125,
      1136,
      1191,
      1237,
      1250,
      1324,
      1365,
      1385,
      1386,
      1387,
      1405,
      1407,
      1409,
      1410,
      1468,
      1471,
      1525,
      1582,
      1583,
      1585,
      1586,
      1587,
      1729,
      1730,
      1731,
      1776,
      1858,
      1881,
      1882,
      1886,
      1887
    ],
    "nil": [
      0,
      1,
      2,
      3,
      4,
      1746,
      1746
    ],
    "_mem_head": [
      0,
      1,
      2,
      3,
      4
    ],
    "list": [
      0,
      1,
      2,
      3,
      4,
      12,
      184,
      185,
      186,
      221,
      222,
      231,
      616,
      948,
      949,
      1158,
      1159,
      1160,
      1230,
      1433,
      1434,
      1454,
      1695
    ],
    "mem_cons_self": [
      0,
      1,
      2,
      3,
      4,
      184,
      185,
      186,
      948,
      949,
      1433,
      1434
    ],
    "tail": [
      0,
      1,
      2,
      3,
      4,
      14,
      239,
      774,
      876,
      1899
    ],
    "_mem_self": [
      0,
      1,
      2,
      3,
      4
    ],
    "_tail": [
      0,
      1,
      2,
      3,
      4
    ],
    "was": [
      5,
      1291,
      1296,
      1301,
      1306,
      1311,
      1315,
      1519,
      1520
    ],
    "tagged": [
      5,
      1315
    ],
    "to_dual": [
      5,
      1315
    ],
    "already": [
      5,
      115,
      921,
      1315
    ],
    "troubleshooting": [
      5,
      1315
    ],
    "when": [
      5,
      1228,
      1315,
      1490,
      1491,
      1622,
      1826,
      1844
    ],
    "add": [
      5,
      25,
      83,
      254,
      255,
      256,
      257,
      519,
      521,
      522,
      567,
      658,
      986,
      987,
      988,
      989,
      991,
      1114,
      1116,
      1178,
      1315,
      1322,
      1365,
      1489,
      1568
    ],
    "replacing": [
      5,
      1315
    ],
    "this": [
      5,
      6,
      7,
      8,
      22,
      23,
      61,
      104,
      115,
      123,
      261,
      294,
      344,
      455,
      461,
      465,
      501,
      502,
      660,
      693,
      747,
      782,
      783,
      830,
      837,
      838,
      867,
      868,
      869,
      900,
      920,
      921,
      923,
      1068,
      1081,
      1210,
      1232,
      1241,
      1252,
      1315,
      1316,
      1317,
      1318,
      1335,
      1336,
      1450,
      1471,
      1484,
      1485,
      1487,
      1519,
      1520,
      1525,
      1553,
      1596,
      1597,
      1617,
      1629,
      1686,
      1686,
      1749,
      1750,
      1758,
      1759,
      1762,
      1763,
      1776,
      1778,
      1803,
      1804,
      1813,
      1814,
      1818,
      1833
    ],
    "original": [
      5,
      272,
      273,
      1315
    ],
    "works": [
      5,
      1315
    ],
    "tag": [
      5,
      1315
    ],
    "see": [
      5,
      160,
      937,
      1315,
      1336,
      1361,
      1554,
      1772,
      1886,
      1887
    ],
    "also": [
      5,
      1045,
      1050,
      1228,
      1315,
      1629,
      1772,
      1886,
      1887
    ],
    "can": [
      5,
      274,
      275,
      657,
      889,
      1291,
      1296,
      1301,
      1306,
      1311,
      1315,
      1402,
      1605,
      1728,
      1834,
      1894
    ],
    "attr": [
      5,
      771,
      1315,
      1747
    ],
    "none": [
      5,
      161,
      938,
      1315,
      1428,
      1834
    ],
    "_assoc": [
      5,
      1315
    ],
    "you": [
      5,
      134,
      136,
      929,
      1315,
      1585,
      1586
    ],
    "will": [
      5,
      391,
      771,
      1315,
      1569,
      1570,
      1688
    ],
    "refine": [
      6,
      7,
      8,
      24,
      25,
      48,
      103,
      105,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      288,
      338,
      342,
      343,
      346,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      566,
      663,
      694,
      698,
      722,
      723,
      724,
      760,
      761,
      762,
      781,
      783,
      845,
      867,
      868,
      869,
      883,
      918,
      919,
      950,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1015,
      1031,
      1032,
      1033,
      1034,
      1035,
      1108,
      1181,
      1211,
      1224,
      1225,
      1246,
      1251,
      1252,
      1278,
      1316,
      1317,
      1318,
      1337,
      1382,
      1521,
      1535,
      1536,
      1537,
      1542,
      1543,
      1544,
      1582,
      1583,
      1604,
      1693,
      1722,
      1757,
      1776,
      1845,
      1846,
      1848,
      1858,
      1859,
      1881
    ],
    "one_le_iff_ne_zero": [
      6,
      7,
      8,
      867,
      868,
      869,
      1316,
      1317,
      1318,
      1542,
      1543,
      1544
    ],
    "nat": [
      6,
      7,
      8,
      12,
      126,
      219,
      250,
      339,
      340,
      341,
      406,
      501,
      523,
      524,
      525,
      526,
      527,
      548,
      566,
      676,
      678,
      727,
      728,
      760,
      761,
      762,
      763,
      764,
      766,
      867,
      868,
      869,
      1016,
      1017,
      1018,
      1049,
      1050,
      1117,
      1118,
      1125,
      1127,
      1191,
      1197,
      1239,
      1249,
      1316,
      1317,
      1318,
      1341,
      1436,
      1479,
      1480,
      1524,
      1542,
      1543,
      1544,
      1661,
      1695,
      1696,
      1697,
      1698,
      1699,
      1845,
      1846,
      1859
    ],
    "trans": [
      6,
      7,
      8,
      63,
      276,
      338,
      349,
      350,
      351,
      410,
      411,
      412,
      413,
      503,
      504,
      505,
      506,
      551,
      552,
      553,
      610,
      616,
      618,
      619,
      656,
      867,
      868,
      869,
      995,
      1015,
      1020,
      1052,
      1158,
      1159,
      1160,
      1230,
      1239,
      1316,
      1317,
      1318,
      1331,
      1337,
      1390,
      1484,
      1485,
      1521,
      1546,
      1577,
      1578,
      1737,
      1761,
      1775,
      1898
    ],
    "simp": [
      6,
      7,
      8,
      12,
      17,
      18,
      21,
      22,
      29,
      31,
      36,
      37,
      60,
      61,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      104,
      110,
      115,
      125,
      127,
      145,
      163,
      187,
      194,
      195,
      196,
      199,
      202,
      217,
      218,
      219,
      232,
      238,
      254,
      255,
      256,
      257,
      263,
      264,
      269,
      270,
      271,
      277,
      278,
      289,
      291,
      292,
      293,
      295,
      329,
      330,
      346,
      347,
      357,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      385,
      394,
      395,
      410,
      411,
      412,
      413,
      414,
      415,
      420,
      435,
      436,
      437,
      438,
      460,
      468,
      469,
      470,
      471,
      474,
      478,
      479,
      481,
      518,
      520,
      533,
      549,
      550,
      567,
      569,
      570,
      571,
      574,
      576,
      579,
      593,
      594,
      595,
      596,
      597,
      614,
      620,
      621,
      622,
      623,
      630,
      638,
      641,
      642,
      643,
      644,
      655,
      661,
      662,
      664,
      665,
      666,
      667,
      668,
      669,
      670,
      672,
      673,
      674,
      677,
      679,
      680,
      681,
      682,
      683,
      684,
      685,
      686,
      701,
      702,
      703,
      704,
      705,
      707,
      716,
      722,
      723,
      724,
      725,
      727,
      728,
      732,
      733,
      734,
      735,
      736,
      740,
      751,
      752,
      760,
      763,
      764,
      766,
      771,
      775,
      781,
      782,
      783,
      784,
      804,
      805,
      831,
      832,
      839,
      840,
      845,
      846,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      862,
      863,
      864,
      865,
      866,
      867,
      868,
      869,
      879,
      880,
      887,
      900,
      901,
      912,
      914,
      915,
      916,
      920,
      921,
      924,
      925,
      932,
      952,
      957,
      958,
      960,
      964,
      969,
      978,
      982,
      986,
      987,
      988,
      989,
      991,
      992,
      994,
      1000,
      1008,
      1019,
      1031,
      1032,
      1033,
      1034,
      1035,
      1036,
      1040,
      1052,
      1053,
      1066,
      1067,
      1076,
      1084,
      1085,
      1086,
      1091,
      1093,
      1115,
      1127,
      1136,
      1145,
      1146,
      1147,
      1157,
      1162,
      1163,
      1170,
      1171,
      1172,
      1174,
      1179,
      1180,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1188,
      1189,
      1190,
      1193,
      1194,
      1195,
      1198,
      1199,
      1200,
      1201,
      1202,
      1203,
      1204,
      1205,
      1206,
      1213,
      1223,
      1224,
      1225,
      1226,
      1227,
      1229,
      1230,
      1238,
      1241,
      1247,
      1251,
      1252,
      1268,
      1275,
      1278,
      1279,
      1280,
      1281,
      1282,
      1316,
      1317,
      1318,
      1324,
      1337,
      1376,
      1378,
      1388,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410,
      1411,
      1419,
      1435,
      1441,
      1447,
      1448,
      1460,
      1463,
      1464,
      1465,
      1470,
      1474,
      1484,
      1485,
      1489,
      1494,
      1495,
      1513,
      1516,
      1534,
      1535,
      1536,
      1537,
      1542,
      1543,
      1544,
      1545,
      1546,
      1547,
      1550,
      1551,
      1552,
      1564,
      1577,
      1581,
      1585,
      1676,
      1677,
      1690,
      1693,
      1695,
      1696,
      1697,
      1698,
      1699,
      1702,
      1704,
      1706,
      1707,
      1711,
      1712,
      1714,
      1715,
      1716,
      1723,
      1748,
      1749,
      1750,
      1755,
      1757,
      1764,
      1765,
      1769,
      1770,
      1771,
      1782,
      1783,
      1784,
      1822,
      1827,
      1828,
      1829,
      1843,
      1845,
      1874,
      1879,
      1901
    ],
    "inner_zero_right": [
      9,
      10,
      872,
      873
    ],
    "end": [
      9,
      10,
      30,
      44,
      45,
      46,
      47,
      69,
      90,
      102,
      140,
      188,
      189,
      192,
      193,
      196,
      206,
      207,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      234,
      247,
      267,
      268,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      309,
      384,
      396,
      397,
      398,
      421,
      441,
      448,
      449,
      450,
      466,
      467,
      489,
      490,
      491,
      492,
      493,
      494,
      495,
      496,
      497,
      498,
      499,
      539,
      540,
      541,
      543,
      544,
      545,
      546,
      547,
      586,
      624,
      626,
      627,
      628,
      629,
      635,
      637,
      638,
      689,
      691,
      725,
      734,
      735,
      736,
      745,
      746,
      767,
      775,
      778,
      779,
      787,
      788,
      789,
      790,
      791,
      792,
      793,
      794,
      795,
      796,
      797,
      798,
      806,
      807,
      808,
      809,
      810,
      811,
      833,
      856,
      857,
      858,
      860,
      861,
      872,
      873,
      893,
      894,
      912,
      914,
      953,
      954,
      955,
      958,
      966,
      967,
      968,
      991,
      993,
      1001,
      1002,
      1003,
      1006,
      1007,
      1083,
      1101,
      1102,
      1103,
      1104,
      1105,
      1106,
      1107,
      1122,
      1123,
      1124,
      1127,
      1142,
      1208,
      1226,
      1229,
      1232,
      1233,
      1240,
      1247,
      1249,
      1253,
      1254,
      1255,
      1256,
      1257,
      1258,
      1259,
      1260,
      1264,
      1265,
      1266,
      1267,
      1276,
      1283,
      1284,
      1285,
      1287,
      1347,
      1348,
      1349,
      1355,
      1378,
      1381,
      1404,
      1437,
      1438,
      1439,
      1449,
      1452,
      1456,
      1465,
      1466,
      1467,
      1468,
      1472,
      1473,
      1474,
      1477,
      1478,
      1489,
      1507,
      1508,
      1511,
      1556,
      1557,
      1558,
      1572,
      1584,
      1603,
      1642,
      1643,
      1644,
      1645,
      1646,
      1647,
      1648,
      1674,
      1675,
      1678,
      1679,
      1680,
      1681,
      1682,
      1683,
      1684,
      1686,
      1691,
      1695,
      1696,
      1697,
      1698,
      1723,
      1727,
      1738,
      1739,
      1740,
      1742,
      1748,
      1760,
      1800,
      1824,
      1825,
      1831,
      1832,
      1849,
      1850,
      1851,
      1862,
      1866,
      1867,
      1868,
      1869,
      1902,
      1903,
      1904
    ],
    "dense": [
      9,
      10,
      507,
      508,
      509,
      513,
      872,
      873,
      1109,
      1110,
      1111,
      1112,
      1893
    ],
    "eq_of_inner_right": [
      9,
      10,
      872,
      873
    ],
    "closure": [
      11,
      25,
      510,
      511,
      641,
      721,
      870,
      874,
      1170,
      1171,
      1502
    ],
    "continuous_closure": [
      11,
      874
    ],
    "continuous": [
      11,
      11,
      48,
      104,
      105,
      259,
      260,
      514,
      514,
      515,
      515,
      516,
      516,
      517,
      517,
      584,
      585,
      586,
      874,
      874,
      919,
      920,
      1113,
      1113,
      1140,
      1141,
      1142,
      1331,
      1336,
      1364,
      1382,
      1598,
      1606,
      1687,
      1749,
      1750,
      1822
    ],
    "closeds": [
      11,
      874
    ],
    "uniformcontinuous_closure": [
      11,
      874
    ],
    "support_eq_cons": [
      12
    ],
    "apply": [
      12,
      20,
      36,
      37,
      48,
      85,
      104,
      105,
      134,
      136,
      137,
      138,
      139,
      191,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      240,
      248,
      345,
      655,
      665,
      666,
      667,
      668,
      669,
      670,
      693,
      708,
      709,
      710,
      711,
      712,
      713,
      771,
      805,
      821,
      822,
      845,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      882,
      920,
      929,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      983,
      1183,
      1184,
      1185,
      1186,
      1187,
      1210,
      1216,
      1217,
      1218,
      1219,
      1228,
      1238,
      1273,
      1274,
      1278,
      1280,
      1281,
      1282,
      1331,
      1368,
      1375,
      1388,
      1440,
      1448,
      1475,
      1542,
      1543,
      1544,
      1551,
      1552,
      1563,
      1582,
      1583,
      1722,
      1747,
      1757,
      1765,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798,
      1858,
      1880,
      1884,
      1901
    ],
    "take_append": [
      12
    ],
    "grind": [
      12,
      14,
      187,
      276,
      406,
      410,
      411,
      412,
      413,
      519,
      876,
      995,
      1049,
      1052,
      1114,
      1332,
      1577,
      1604
    ],
    "support_copy": [
      12
    ],
    "drop_support_eq_support_drop_min": [
      12
    ],
    "length_support": [
      12
    ],
    "lia": [
      12,
      378,
      379,
      760,
      761,
      762,
      1845,
      1846
    ],
    "drop_eq_nil_of_le": [
      12
    ],
    "support_append": [
      12
    ],
    "tail_drop": [
      12
    ],
    "arith": [
      12
    ],
    "only": [
      12,
      31,
      104,
      127,
      187,
      194,
      238,
      385,
      394,
      395,
      414,
      415,
      423,
      469,
      471,
      478,
      479,
      518,
      549,
      550,
      576,
      614,
      622,
      623,
      630,
      661,
      664,
      665,
      666,
      667,
      668,
      669,
      670,
      671,
      707,
      714,
      718,
      727,
      728,
      740,
      781,
      783,
      805,
      845,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      887,
      920,
      924,
      925,
      957,
      982,
      991,
      1036,
      1040,
      1053,
      1085,
      1086,
      1091,
      1157,
      1162,
      1163,
      1179,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1223,
      1251,
      1252,
      1278,
      1280,
      1281,
      1282,
      1332,
      1337,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410,
      1419,
      1435,
      1441,
      1460,
      1471,
      1474,
      1489,
      1506,
      1545,
      1594,
      1677,
      1687,
      1690,
      1695,
      1702,
      1706,
      1707,
      1764,
      1765,
      1834,
      1871,
      1879,
      1881,
      1882,
      1901
    ],
    "take_support_eq_support_take_succ": [
      12
    ],
    "min_eq_left": [
      12
    ],
    "drop_append": [
      12
    ],
    "ext_support": [
      12
    ],
    "isregularepi": [
      13,
      875,
      1325,
      1326
    ],
    "regularepiofextremalepi": [
      13,
      875,
      1325,
      1326
    ],
    "isregularepi_of_extremalepi": [
      13,
      875,
      1325,
      1326
    ],
    "instance": [
      13,
      60,
      65,
      120,
      258,
      296,
      310,
      311,
      312,
      336,
      337,
      345,
      353,
      355,
      424,
      457,
      562,
      564,
      576,
      616,
      716,
      823,
      824,
      828,
      836,
      842,
      844,
      875,
      901,
      990,
      1013,
      1014,
      1057,
      1075,
      1129,
      1131,
      1158,
      1159,
      1160,
      1272,
      1325,
      1326,
      1383,
      1443,
      1483,
      1540,
      1576,
      1654,
      1656,
      1706,
      1707,
      1778,
      1816,
      1821,
      1822,
      1877,
      1896
    ],
    "extremalepi": [
      13,
      875,
      1325,
      1326
    ],
    "support": [
      14,
      425,
      426,
      427,
      804,
      876,
      1058,
      1059,
      1060,
      1238,
      1820
    ],
    "map_snd_darts": [
      14,
      876
    ],
    "snd": [
      14,
      20,
      342,
      343,
      349,
      350,
      351,
      876,
      882,
      956,
      1020,
      1133,
      1331
    ],
    "darts": [
      14,
      876
    ],
    "wbtw": [
      15
    ],
    "trans_right_left": [
      15
    ],
    "sbtw": [
      15,
      569,
      570,
      571,
      1704
    ],
    "ne_left": [
      15
    ],
    "left_ne": [
      15
    ],
    "monotone": [
      16,
      20,
      84,
      86,
      87,
      88,
      878,
      882,
      911,
      913,
      1331,
      1369,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1473,
      1474,
      1892
    ],
    "congr_fun": [
      16,
      878
    ],
    "orderhom": [
      17,
      20,
      879,
      882
    ],
    "range_comp": [
      17,
      879
    ],
    "map_coe": [
      17,
      879
    ],
    "coe_mk": [
      17,
      342,
      343,
      659,
      879,
      1228
    ],
    "set": [
      17,
      32,
      33,
      60,
      61,
      61,
      67,
      128,
      146,
      147,
      148,
      149,
      151,
      154,
      155,
      156,
      157,
      218,
      220,
      220,
      338,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      381,
      382,
      383,
      405,
      407,
      414,
      415,
      481,
      512,
      555,
      556,
      661,
      707,
      753,
      776,
      782,
      846,
      879,
      890,
      891,
      900,
      900,
      901,
      926,
      933,
      934,
      935,
      1015,
      1031,
      1032,
      1033,
      1034,
      1035,
      1053,
      1068,
      1093,
      1157,
      1179,
      1248,
      1279,
      1360,
      1398,
      1420,
      1421,
      1422,
      1423,
      1424,
      1447,
      1451,
      1456,
      1467,
      1521,
      1535,
      1536,
      1537,
      1541,
      1555,
      1567,
      1574,
      1575,
      1585,
      1586,
      1587,
      1588,
      1594,
      1641,
      1649,
      1659,
      1667,
      1668,
      1669,
      1670,
      1676,
      1677,
      1701,
      1717,
      1752,
      1753,
      1818,
      1881
    ],
    "directedon": [
      17,
      879
    ],
    "simpa": [
      17,
      63,
      129,
      130,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      204,
      262,
      319,
      423,
      439,
      472,
      565,
      598,
      645,
      646,
      647,
      666,
      667,
      668,
      669,
      670,
      671,
      714,
      718,
      740,
      747,
      749,
      760,
      879,
      927,
      928,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      952,
      965,
      1005,
      1088,
      1132,
      1148,
      1173,
      1183,
      1184,
      1185,
      1186,
      1187,
      1234,
      1324,
      1429,
      1430,
      1431,
      1432,
      1456,
      1471,
      1488,
      1542,
      1543,
      1544,
      1558,
      1593,
      1594,
      1687,
      1715,
      1735,
      1752,
      1753,
      1765,
      1833,
      1845,
      1871,
      1900
    ],
    "range_nonempty": [
      17,
      84,
      879,
      911,
      1370,
      1371,
      1372,
      1373,
      1374
    ],
    "ischain_range": [
      17,
      879
    ],
    "using": [
      17,
      83,
      125,
      126,
      129,
      130,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      262,
      325,
      338,
      423,
      439,
      468,
      470,
      472,
      519,
      598,
      645,
      646,
      647,
      666,
      667,
      668,
      669,
      670,
      671,
      714,
      718,
      747,
      749,
      837,
      879,
      927,
      928,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      952,
      1015,
      1084,
      1088,
      1114,
      1148,
      1173,
      1183,
      1184,
      1185,
      1186,
      1187,
      1234,
      1365,
      1429,
      1430,
      1431,
      1432,
      1456,
      1471,
      1488,
      1521,
      1558,
      1593,
      1594,
      1687,
      1715,
      1735,
      1752,
      1753,
      1765,
      1833,
      1871,
      1900
    ],
    "ici_subset_ici": [
      18,
      880
    ],
    "inter_eq_self_of_subset_right": [
      18,
      880
    ],
    "lemma": [
      18,
      24,
      34,
      35,
      48,
      60,
      64,
      80,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      123,
      127,
      163,
      198,
      202,
      203,
      218,
      219,
      237,
      288,
      342,
      343,
      382,
      383,
      417,
      418,
      447,
      528,
      548,
      599,
      622,
      623,
      641,
      655,
      662,
      663,
      664,
      721,
      737,
      738,
      750,
      760,
      761,
      762,
      773,
      837,
      838,
      880,
      883,
      901,
      903,
      912,
      915,
      916,
      923,
      924,
      925,
      952,
      959,
      964,
      1046,
      1054,
      1070,
      1125,
      1162,
      1170,
      1171,
      1180,
      1181,
      1182,
      1235,
      1250,
      1324,
      1332,
      1360,
      1362,
      1363,
      1389,
      1390,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410,
      1436,
      1442,
      1451,
      1472,
      1473,
      1474,
      1475,
      1502,
      1541,
      1546,
      1547,
      1573,
      1641,
      1667,
      1668,
      1669,
      1670,
      1677,
      1686,
      1713,
      1715,
      1722,
      1732,
      1752,
      1753,
      1760,
      1764,
      1820,
      1836,
      1841,
      1842,
      1845,
      1846,
      1854,
      1858,
      1874,
      1875
    ],
    "variable": [
      18,
      34,
      35,
      63,
      90,
      122,
      220,
      294,
      346,
      391,
      393,
      557,
      558,
      560,
      609,
      622,
      623,
      635,
      657,
      714,
      734,
      735,
      736,
      773,
      804,
      834,
      859,
      880,
      914,
      922,
      1039,
      1154,
      1161,
      1162,
      1222,
      1229,
      1250,
      1272,
      1286,
      1361,
      1378,
      1397,
      1402,
      1425,
      1443,
      1448,
      1461,
      1485,
      1498,
      1523,
      1588,
      1649,
      1720,
      1721,
      1724,
      1727,
      1732,
      1741,
      1777,
      1858,
      1861,
      1895
    ],
    "exact": [
      18,
      38,
      39,
      40,
      41,
      42,
      43,
      50,
      51,
      66,
      67,
      68,
      97,
      99,
      100,
      101,
      102,
      105,
      112,
      113,
      116,
      146,
      147,
      148,
      149,
      152,
      154,
      155,
      156,
      157,
      194,
      197,
      201,
      239,
      246,
      254,
      255,
      256,
      257,
      258,
      259,
      260,
      276,
      279,
      280,
      281,
      282,
      283,
      285,
      286,
      287,
      327,
      344,
      345,
      347,
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      382,
      383,
      405,
      407,
      417,
      418,
      433,
      439,
      449,
      450,
      451,
      459,
      469,
      471,
      481,
      501,
      502,
      510,
      511,
      549,
      550,
      584,
      585,
      586,
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      611,
      612,
      613,
      630,
      639,
      640,
      645,
      646,
      647,
      650,
      651,
      652,
      653,
      660,
      661,
      663,
      672,
      673,
      674,
      692,
      693,
      694,
      698,
      726,
      747,
      751,
      752,
      756,
      757,
      758,
      759,
      768,
      769,
      773,
      774,
      782,
      789,
      790,
      791,
      792,
      793,
      794,
      795,
      796,
      797,
      798,
      817,
      818,
      819,
      821,
      822,
      835,
      846,
      880,
      892,
      895,
      902,
      919,
      933,
      934,
      935,
      957,
      963,
      986,
      987,
      988,
      989,
      990,
      995,
      996,
      997,
      998,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1030,
      1048,
      1054,
      1056,
      1077,
      1078,
      1079,
      1080,
      1085,
      1086,
      1093,
      1140,
      1141,
      1142,
      1149,
      1150,
      1151,
      1152,
      1153,
      1155,
      1163,
      1168,
      1169,
      1173,
      1175,
      1176,
      1179,
      1181,
      1188,
      1189,
      1190,
      1192,
      1209,
      1210,
      1211,
      1237,
      1238,
      1242,
      1243,
      1245,
      1255,
      1256,
      1257,
      1258,
      1259,
      1260,
      1269,
      1270,
      1271,
      1273,
      1274,
      1277,
      1279,
      1324,
      1327,
      1328,
      1339,
      1343,
      1344,
      1345,
      1346,
      1351,
      1352,
      1353,
      1360,
      1366,
      1379,
      1380,
      1381,
      1382,
      1391,
      1393,
      1394,
      1395,
      1396,
      1420,
      1421,
      1422,
      1423,
      1424,
      1448,
      1459,
      1476,
      1483,
      1494,
      1496,
      1497,
      1499,
      1500,
      1501,
      1515,
      1517,
      1525,
      1530,
      1531,
      1532,
      1533,
      1541,
      1563,
      1566,
      1574,
      1575,
      1591,
      1606,
      1619,
      1620,
      1649,
      1649,
      1700,
      1702,
      1718,
      1719,
      1729,
      1730,
      1731,
      1746,
      1749,
      1750,
      1762,
      1763,
      1774,
      1775,
      1776,
      1781,
      1833,
      1843,
      1847,
      1855,
      1859,
      1862,
      1881,
      1882,
      1884,
      1893,
      1899
    ],
    "scottcontinuouson": [
      18,
      880
    ],
    "hab": [
      18,
      574,
      880,
      1136,
      1411,
      1444,
      1445,
      1446
    ],
    "isleast_ici": [
      18,
      880
    ],
    "prodmk": [
      18,
      349,
      350,
      351,
      880,
      1020,
      1667,
      1668,
      1669,
      1670,
      1817
    ],
    "rfl": [
      19,
      20,
      38,
      39,
      40,
      41,
      42,
      43,
      60,
      67,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      112,
      113,
      158,
      159,
      163,
      197,
      198,
      259,
      260,
      295,
      305,
      306,
      314,
      315,
      316,
      317,
      320,
      323,
      324,
      328,
      344,
      346,
      368,
      369,
      370,
      381,
      417,
      418,
      452,
      459,
      480,
      534,
      535,
      536,
      537,
      542,
      548,
      551,
      552,
      553,
      561,
      563,
      564,
      568,
      596,
      597,
      620,
      621,
      639,
      640,
      655,
      659,
      662,
      693,
      694,
      698,
      699,
      700,
      701,
      726,
      738,
      748,
      765,
      781,
      786,
      803,
      828,
      877,
      881,
      882,
      892,
      901,
      915,
      916,
      917,
      936,
      959,
      961,
      1004,
      1030,
      1054,
      1071,
      1092,
      1125,
      1128,
      1130,
      1131,
      1133,
      1147,
      1168,
      1169,
      1180,
      1210,
      1211,
      1213,
      1251,
      1319,
      1327,
      1328,
      1331,
      1333,
      1341,
      1343,
      1344,
      1345,
      1346,
      1354,
      1391,
      1399,
      1400,
      1441,
      1442,
      1486,
      1494,
      1525,
      1564,
      1571,
      1671,
      1672,
      1686,
      1703,
      1717,
      1779,
      1780,
      1822,
      1835,
      1837,
      1838,
      1864,
      1865,
      1884
    ],
    "chain": [
      19,
      877,
      881,
      1844
    ],
    "zip": [
      19,
      877,
      881
    ],
    "monotone_fst": [
      20,
      882
    ],
    "le_antisymm": [
      20,
      24,
      34,
      35,
      424,
      617,
      642,
      643,
      644,
      785,
      882,
      883,
      1057,
      1172,
      1673,
      1735,
      1736,
      1757
    ],
    "le_max_left": [
      20,
      772,
      882,
      1244
    ],
    "lift": [
      20,
      25,
      60,
      739,
      820,
      825,
      826,
      827,
      882,
      901,
      1108,
      1331,
      1722,
      1772,
      1876
    ],
    "apply_mono": [
      20,
      882
    ],
    "mono": [
      20,
      107,
      233,
      382,
      383,
      510,
      511,
      599,
      773,
      882,
      979,
      1411,
      1455,
      1459,
      1468,
      1541
    ],
    "fst": [
      20,
      342,
      343,
      349,
      350,
      351,
      782,
      882,
      956,
      1020,
      1331
    ],
    "omegacompletepartialorder": [
      20,
      882,
      1331,
      1572
    ],
    "max": [
      20,
      65,
      146,
      147,
      148,
      149,
      160,
      564,
      657,
      825,
      826,
      827,
      836,
      882,
      933,
      934,
      937,
      1131,
      1365,
      1420,
      1421,
      1422,
      1423,
      1424,
      1519,
      1520,
      1876,
      1883
    ],
    "intro": [
      20,
      66,
      68,
      83,
      146,
      147,
      148,
      149,
      194,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      240,
      244,
      245,
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      400,
      401,
      451,
      549,
      550,
      574,
      579,
      639,
      640,
      707,
      740,
      782,
      783,
      831,
      832,
      845,
      882,
      933,
      934,
      957,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      983,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1136,
      1168,
      1169,
      1238,
      1252,
      1275,
      1278,
      1365,
      1420,
      1421,
      1422,
      1423,
      1424,
      1468,
      1530,
      1531,
      1532,
      1533,
      1542,
      1543,
      1544,
      1561,
      1820,
      1892
    ],
    "prod": [
      20,
      385,
      782,
      882,
      1036,
      1331,
      1382,
      1545,
      1701
    ],
    "def": [
      20,
      82,
      83,
      85,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      115,
      145,
      220,
      392,
      400,
      401,
      428,
      429,
      430,
      431,
      432,
      482,
      483,
      484,
      485,
      486,
      487,
      521,
      657,
      701,
      737,
      738,
      739,
      784,
      804,
      825,
      827,
      840,
      841,
      882,
      889,
      904,
      905,
      915,
      916,
      921,
      932,
      1038,
      1041,
      1061,
      1062,
      1063,
      1064,
      1065,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1108,
      1213,
      1232,
      1241,
      1245,
      1289,
      1290,
      1295,
      1300,
      1305,
      1310,
      1331,
      1338,
      1357,
      1358,
      1365,
      1367,
      1368,
      1375,
      1402,
      1419,
      1425,
      1550,
      1573,
      1588,
      1589,
      1605,
      1618,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640,
      1649,
      1723,
      1727,
      1747,
      1752,
      1753,
      1758,
      1759,
      1778,
      1824,
      1825,
      1875,
      1876,
      1890,
      1891,
      1892,
      1893,
      1894
    ],
    "tofun": [
      20,
      319,
      784,
      882,
      1005,
      1108,
      1232,
      1331,
      1618,
      1723
    ],
    "simps": [
      20,
      882,
      1232,
      1331,
      1618,
      1723,
      1758,
      1759
    ],
    "application": [
      20,
      882,
      1331
    ],
    "done": [
      21,
      22,
      1512
    ],
    "continue": [
      21,
      22,
      115,
      921,
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "post": [
      21,
      1805,
      1806,
      1808,
      1809
    ],
    "nctx": [
      21,
      22
    ],
    "parent": [
      21
    ],
    "pre": [
      21,
      1622
    ],
    "catch": [
      21,
      22
    ],
    "ctx": [
      21,
      22,
      482,
      483,
      484,
      485,
      486,
      487,
      1041,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "pure": [
      21,
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "methods": [
      21,
      22
    ],
    "main": [
      21,
      22,
      261,
      465,
      530,
      531,
      843,
      1289,
      1356,
      1487,
      1553,
      1568,
      1597,
      1598,
      1599,
      1600,
      1662,
      1663,
      1666,
      1853,
      1861
    ],
    "postdefault": [
      21
    ],
    "consistently": [
      22,
      23
    ],
    "reference": [
      22,
      23
    ],
    "persisting": [
      22,
      23
    ],
    "ordering": [
      22,
      23
    ],
    "configuration": [
      22,
      23,
      134,
      136,
      137,
      138,
      139,
      929,
      1241
    ],
    "initial": [
      22
    ],
    "across": [
      22,
      23
    ],
    "runs": [
      22,
      1320,
      1323,
      1334
    ],
    "monad": [
      22
    ],
    "recursem": [
      22
    ],
    "for": [
      22,
      23,
      61,
      160,
      162,
      192,
      237,
      272,
      273,
      274,
      275,
      455,
      701,
      900,
      904,
      905,
      937,
      954,
      991,
      1138,
      1213,
      1289,
      1336,
      1336,
      1357,
      1358,
      1361,
      1366,
      1415,
      1437,
      1438,
      1439,
      1489,
      1506,
      1550,
      1554,
      1588,
      1617,
      1622,
      1629,
      1659,
      1693,
      1772,
      1778,
      1805,
      1806,
      1808,
      1809,
      1818,
      1883
    ],
    "cfg": [
      23,
      353,
      355,
      1569,
      1570
    ],
    "options": [
      23
    ],
    "used": [
      23,
      274,
      275,
      1045,
      1241,
      1596,
      1597,
      1834
    ],
    "mutable": [
      23
    ],
    "ensures": [
      23
    ],
    "that": [
      23,
      83,
      160,
      272,
      273,
      274,
      275,
      391,
      400,
      401,
      455,
      474,
      574,
      722,
      723,
      724,
      771,
      937,
      1136,
      1224,
      1225,
      1365,
      1509,
      1523,
      1554,
      1617,
      1629,
      1688,
      1727,
      1818,
      1883,
      1886,
      1887
    ],
    "state": [
      23,
      482,
      483,
      484,
      485,
      486,
      1097,
      1098,
      1630,
      1631,
      1632
    ],
    "atomm": [
      23
    ],
    "calls": [
      23
    ],
    "atom": [
      23
    ],
    "module": [
      24,
      34,
      35,
      61,
      62,
      64,
      67,
      81,
      220,
      294,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      400,
      401,
      402,
      530,
      531,
      557,
      558,
      560,
      617,
      657,
      658,
      694,
      698,
      731,
      734,
      735,
      736,
      883,
      900,
      903,
      910,
      1031,
      1032,
      1033,
      1034,
      1035,
      1050,
      1178,
      1211,
      1228,
      1229,
      1462,
      1490,
      1491,
      1506,
      1509,
      1535,
      1536,
      1537,
      1559,
      1560,
      1561,
      1562,
      1576,
      1662,
      1663,
      1665,
      1665,
      1666,
      1666,
      1735,
      1736,
      1760,
      1766,
      1826,
      1856,
      1857,
      1858,
      1886,
      1887,
      1888
    ],
    "fg_restrictscalars": [
      24,
      67,
      883
    ],
    "type": [
      24,
      34,
      35,
      61,
      65,
      67,
      108,
      109,
      122,
      123,
      160,
      160,
      195,
      220,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      274,
      275,
      294,
      346,
      391,
      393,
      456,
      473,
      530,
      531,
      557,
      558,
      560,
      596,
      617,
      635,
      656,
      657,
      658,
      695,
      696,
      697,
      714,
      717,
      739,
      804,
      825,
      827,
      844,
      845,
      883,
      900,
      922,
      923,
      937,
      937,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1039,
      1050,
      1089,
      1178,
      1212,
      1222,
      1228,
      1230,
      1250,
      1272,
      1278,
      1361,
      1383,
      1385,
      1386,
      1387,
      1397,
      1403,
      1427,
      1443,
      1461,
      1462,
      1506,
      1523,
      1526,
      1526,
      1564,
      1565,
      1572,
      1576,
      1622,
      1656,
      1662,
      1663,
      1688,
      1713,
      1714,
      1715,
      1720,
      1721,
      1722,
      1726,
      1727,
      1735,
      1736,
      1747,
      1761,
      1768,
      1777,
      1778,
      1778,
      1806,
      1807,
      1809,
      1810,
      1852,
      1853,
      1854,
      1858,
      1861,
      1876,
      1883,
      1886,
      1887,
      1890,
      1891,
      1893,
      1894,
      1896
    ],
    "change": [
      24,
      820,
      883,
      1250,
      1382,
      1563,
      1722
    ],
    "obtain": [
      24,
      38,
      39,
      40,
      41,
      42,
      43,
      67,
      84,
      112,
      113,
      123,
      126,
      146,
      147,
      148,
      149,
      276,
      288,
      295,
      346,
      382,
      383,
      402,
      459,
      481,
      567,
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      761,
      762,
      837,
      838,
      845,
      846,
      883,
      892,
      911,
      923,
      933,
      934,
      950,
      995,
      1093,
      1149,
      1150,
      1151,
      1152,
      1153,
      1238,
      1246,
      1278,
      1279,
      1319,
      1343,
      1344,
      1345,
      1346,
      1370,
      1371,
      1372,
      1373,
      1374,
      1391,
      1420,
      1421,
      1422,
      1423,
      1424,
      1541,
      1559,
      1560,
      1561,
      1562,
      1582,
      1583,
      1718,
      1719,
      1775,
      1846,
      1848
    ],
    "of_restrictscalars": [
      24,
      883
    ],
    "function": [
      24,
      67,
      125,
      126,
      127,
      208,
      209,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      290,
      342,
      343,
      380,
      518,
      538,
      549,
      550,
      554,
      587,
      588,
      589,
      590,
      591,
      592,
      655,
      804,
      843,
      883,
      924,
      925,
      956,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      999,
      1143,
      1144,
      1331,
      1336,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410,
      1673,
      1690,
      1708,
      1709,
      1710,
      1820,
      1859,
      1863
    ],
    "span_zero_singleton": [
      24,
      883
    ],
    "coe_empty": [
      24,
      883
    ],
    "empty": [
      24,
      371,
      371,
      372,
      372,
      373,
      373,
      374,
      374,
      375,
      375,
      376,
      376,
      377,
      377,
      472,
      883,
      1031,
      1031,
      1032,
      1032,
      1033,
      1033,
      1034,
      1034,
      1035,
      1035,
      1088,
      1535,
      1535,
      1536,
      1536,
      1537,
      1537,
      1585,
      1586,
      1587
    ],
    "insert": [
      24,
      204,
      272,
      273,
      883,
      965
    ],
    "restrictscalars": [
      24,
      67,
      883,
      1605
    ],
    "symm": [
      24,
      48,
      63,
      67,
      146,
      147,
      148,
      149,
      195,
      241,
      246,
      265,
      266,
      288,
      325,
      328,
      335,
      353,
      355,
      402,
      405,
      406,
      407,
      410,
      411,
      412,
      413,
      440,
      449,
      450,
      476,
      477,
      503,
      504,
      505,
      506,
      536,
      569,
      570,
      571,
      612,
      613,
      616,
      617,
      639,
      640,
      702,
      703,
      704,
      705,
      707,
      718,
      737,
      738,
      747,
      760,
      761,
      762,
      782,
      783,
      784,
      785,
      842,
      883,
      902,
      919,
      933,
      934,
      961,
      984,
      1046,
      1049,
      1052,
      1090,
      1155,
      1158,
      1159,
      1160,
      1168,
      1169,
      1230,
      1246,
      1252,
      1360,
      1420,
      1421,
      1422,
      1423,
      1424,
      1459,
      1463,
      1464,
      1465,
      1469,
      1476,
      1486,
      1522,
      1559,
      1560,
      1561,
      1562,
      1574,
      1575,
      1576,
      1577,
      1618,
      1627,
      1628,
      1671,
      1673,
      1704,
      1722,
      1725,
      1736,
      1749,
      1750,
      1767,
      1775,
      1776,
      1782,
      1783,
      1784,
      1822,
      1833,
      1845,
      1846,
      1848,
      1855,
      1875,
      1880,
      1881,
      1893,
      1898
    ],
    "span_insert": [
      24,
      67,
      883
    ],
    "finset": [
      24,
      38,
      39,
      40,
      41,
      42,
      43,
      67,
      125,
      126,
      150,
      208,
      209,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      319,
      382,
      383,
      565,
      783,
      784,
      804,
      805,
      846,
      883,
      892,
      912,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1005,
      1132,
      1238,
      1252,
      1279,
      1341,
      1342,
      1343,
      1344,
      1345,
      1346,
      1451,
      1453,
      1516,
      1523,
      1541,
      1543,
      1544,
      1578,
      1588,
      1768,
      1895
    ],
    "completespace": [
      25,
      336,
      337,
      676,
      1013,
      1014,
      1191,
      1565
    ],
    "norm_deriv_le_aux": [
      25,
      26,
      27,
      28,
      884,
      885,
      886
    ],
    "its": [
      25,
      956,
      1332,
      1565
    ],
    "complex": [
      25,
      25,
      161,
      161,
      163,
      196,
      662,
      851,
      852,
      853,
      854,
      855,
      938,
      938,
      958,
      1180,
      1280,
      1281,
      1282,
      1428,
      1428,
      1693,
      1844
    ],
    "deriv_eq_smul_circleintegral": [
      25
    ],
    "metric": [
      25,
      48,
      220,
      714,
      833,
      1276,
      1587,
      1629
    ],
    "represented": [
      25
    ],
    "open": [
      25,
      107,
      108,
      109,
      134,
      135,
      136,
      137,
      138,
      139,
      220,
      261,
      274,
      275,
      294,
      405,
      406,
      407,
      428,
      429,
      430,
      431,
      432,
      453,
      530,
      531,
      609,
      617,
      843,
      929,
      1049,
      1050,
      1061,
      1062,
      1063,
      1064,
      1065,
      1154,
      1385,
      1386,
      1387,
      1487,
      1505,
      1567,
      1572,
      1573,
      1574,
      1575,
      1576,
      1587,
      1589,
      1590,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616,
      1662,
      1663,
      1688,
      1720,
      1721,
      1722,
      1724,
      1736,
      1745,
      1861,
      1886,
      1887,
      1892
    ],
    "center": [
      25,
      120,
      1398,
      1399,
      1400
    ],
    "todo": [
      25,
      162,
      248,
      530,
      531,
      561,
      562,
      563,
      564,
      828,
      991,
      1128,
      1129,
      1130,
      1131,
      1427,
      1489,
      1662,
      1663,
      1686,
      1728
    ],
    "circle": [
      25
    ],
    "derivatives": [
      25
    ],
    "mul_inv": [
      25,
      1337
    ],
    "div_eq_inv_mul": [
      25,
      1447,
      1448
    ],
    "norm_smul": [
      25
    ],
    "completion": [
      26,
      27,
      28,
      884,
      885,
      886
    ],
    "trans_le": [
      26,
      27,
      28,
      288,
      884,
      885,
      886,
      1522
    ],
    "uniformspace": [
      26,
      27,
      28,
      884,
      885,
      886,
      1584
    ],
    "norm_coe": [
      26,
      27,
      28,
      884,
      885,
      886
    ],
    "comp_diffcontoncl": [
      26,
      27,
      28,
      884,
      885,
      886
    ],
    "differentiable": [
      26,
      27,
      28,
      884,
      885,
      886
    ],
    "eq_symm_apply": [
      29,
      478,
      479,
      1091
    ],
    "equiv": [
      29,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      319,
      477,
      630,
      635,
      695,
      696,
      697,
      718,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1005,
      1163,
      1212,
      1230,
      1392,
      1627,
      1628,
      1723
    ],
    "case": [
      29,
      406,
      1049,
      1291,
      1296,
      1301,
      1306,
      1311,
      1768
    ],
    "topequiv_apply": [
      29
    ],
    "algebra": [
      30,
      31,
      248,
      302,
      303,
      304,
      318,
      321,
      322,
      460,
      596,
      693,
      887,
      1003,
      1029,
      1076,
      1210,
      1506,
      1506,
      1508,
      1522,
      1523,
      1665,
      1689,
      1691,
      1693,
      1720,
      1721,
      1722,
      1747,
      1888
    ],
    "mvpolynomial": [
      30,
      805,
      1401,
      1711,
      1712
    ],
    "mem_adjoin_iff_div": [
      31,
      887
    ],
    "mem_range": [
      31,
      887
    ],
    "exists_exists_eq_and": [
      31,
      887
    ],
    "alghom": [
      31,
      887,
      1722
    ],
    "adjoin_singleton_eq_range_aeval": [
      31,
      887
    ],
    "nullmeasurable": [
      32,
      33,
      890,
      891
    ],
    "g_mble": [
      32,
      33,
      890,
      891
    ],
    "countable": [
      32,
      33,
      567,
      844,
      890,
      891,
      1467,
      1468
    ],
    "measurable": [
      32,
      33,
      190,
      725,
      890,
      891,
      1226,
      1383,
      1598,
      1667,
      1668,
      1669,
      1670
    ],
    "generators_card": [
      34,
      35
    ],
    "spanfinrank_map_le_of_fg": [
      34,
      35
    ],
    "mpr": [
      34,
      35,
      48,
      84,
      105,
      142,
      146,
      147,
      148,
      149,
      203,
      279,
      280,
      281,
      282,
      283,
      285,
      286,
      287,
      405,
      406,
      407,
      458,
      459,
      565,
      584,
      585,
      586,
      617,
      655,
      658,
      663,
      749,
      756,
      760,
      761,
      762,
      776,
      816,
      817,
      818,
      819,
      911,
      930,
      933,
      934,
      996,
      997,
      998,
      1029,
      1049,
      1132,
      1140,
      1141,
      1142,
      1178,
      1181,
      1234,
      1237,
      1248,
      1269,
      1270,
      1271,
      1420,
      1421,
      1422,
      1423,
      1424,
      1496,
      1497,
      1525,
      1563,
      1574,
      1575,
      1735,
      1736,
      1799,
      1845,
      1846,
      1885,
      1886,
      1887
    ],
    "mk_image_le": [
      34,
      35
    ],
    "spanfinrank": [
      34,
      35
    ],
    "section": [
      34,
      35,
      84,
      86,
      87,
      88,
      90,
      134,
      135,
      136,
      137,
      138,
      139,
      192,
      234,
      261,
      294,
      402,
      530,
      531,
      622,
      623,
      657,
      843,
      911,
      913,
      914,
      929,
      954,
      1050,
      1161,
      1162,
      1364,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1378,
      1437,
      1438,
      1439,
      1473,
      1474,
      1484,
      1485,
      1487,
      1519,
      1520,
      1559,
      1560,
      1561,
      1562,
      1567,
      1576,
      1587,
      1588,
      1602,
      1650,
      1651,
      1652,
      1662,
      1663,
      1720,
      1721,
      1722,
      1741,
      1751,
      1754,
      1861
    ],
    "spanrank_finite_iff_fg": [
      34,
      35
    ],
    "spanrank_le_iff_exists_span_set_card_le": [
      34,
      35
    ],
    "universe": [
      34,
      35,
      261,
      294,
      530,
      531,
      1397,
      1461,
      1487,
      1662,
      1663,
      1777,
      1883
    ],
    "tonat_le_iff_le_of_lt_aleph0": [
      34,
      35
    ],
    "submodule": [
      34,
      35,
      66,
      67,
      68,
      151,
      152,
      194,
      204,
      235,
      285,
      286,
      287,
      458,
      459,
      469,
      471,
      957,
      965,
      980,
      998,
      1085,
      1086,
      1475,
      1493,
      1515,
      1517,
      1561,
      1592,
      1605,
      1605,
      1618,
      1701,
      1744,
      1745,
      1757,
      1758,
      1759,
      1858
    ],
    "map": [
      34,
      35,
      61,
      62,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      153,
      190,
      200,
      234,
      236,
      335,
      394,
      395,
      529,
      532,
      657,
      820,
      840,
      841,
      900,
      915,
      916,
      962,
      981,
      1040,
      1046,
      1119,
      1120,
      1121,
      1133,
      1250,
      1382,
      1388,
      1403,
      1470,
      1473,
      1474,
      1490,
      1491,
      1528,
      1529,
      1654,
      1664,
      1711,
      1712,
      1758,
      1759,
      1772,
      1824,
      1825,
      1826,
      1831,
      1854
    ],
    "cardinal": [
      34,
      35,
      327,
      690,
      1207
    ],
    "generators": [
      34,
      35
    ],
    "semiring": [
      34,
      35,
      67,
      424,
      656,
      745,
      746,
      1057,
      1233,
      1404,
      1761,
      1832
    ],
    "card_eq_coe_natcard": [
      36,
      37
    ],
    "nontrivial": [
      36,
      37,
      258,
      554,
      902,
      990,
      1245,
      1246,
      1436,
      1483,
      1582,
      1583,
      1848,
      1858
    ],
    "enat": [
      36,
      37
    ],
    "card_eq_one": [
      38,
      39,
      40,
      41,
      42,
      43,
      892,
      1343,
      1344,
      1345,
      1346
    ],
    "polynomial": [
      44,
      45,
      46,
      47,
      295,
      405,
      406,
      407,
      465,
      465,
      893,
      894,
      1022,
      1022,
      1049,
      1238,
      1347,
      1348,
      1349,
      1361,
      1503,
      1504,
      1574,
      1575
    ],
    "minpoly": [
      44,
      45,
      46,
      47,
      893,
      894,
      1347,
      1348,
      1349
    ],
    "tendsto_right_iff": [
      48
    ],
    "edist_def": [
      48
    ],
    "calc": [
      48,
      400,
      401,
      402,
      410,
      411,
      412,
      413,
      721,
      1052,
      1230,
      1559,
      1560,
      1562,
      1577,
      1892
    ],
    "hasbasis_nhds_of_ne_top": [
      48
    ],
    "rcases": [
      48,
      239,
      542,
      567,
      612,
      613,
      639,
      640,
      721,
      781,
      846,
      917,
      1155,
      1168,
      1169,
      1174,
      1251,
      1279,
      1468,
      1586,
      1820,
      1836
    ],
    "a_1": [
      48
    ],
    "symmdiff": [
      48
    ],
    "continuous_measure": [
      48
    ],
    "mem_eball": [
      48
    ],
    "contrapose": [
      48,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      472,
      707,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1088,
      1836
    ],
    "gcongr": [
      48,
      190,
      538,
      1074,
      1546,
      1547,
      1673,
      1676
    ],
    "filter_upwards": [
      48,
      520,
      1077,
      1078,
      1079,
      1080,
      1115,
      1690
    ],
    "tendsto_const_nhds": [
      48,
      1366
    ],
    "stronglymeasurable": [
      49,
      52,
      53,
      54,
      55,
      56,
      57,
      896,
      897,
      898
    ],
    "ite": [
      49,
      52,
      53,
      54,
      55,
      56,
      57,
      221,
      222,
      231,
      896,
      897,
      898,
      1454
    ],
    "piecewise": [
      49,
      52,
      53,
      54,
      55,
      56,
      57,
      896,
      897,
      898,
      1687,
      1888
    ],
    "iunion": [
      50,
      51,
      512,
      895,
      1351,
      1352,
      1353
    ],
    "hg_bij": [
      50,
      51,
      895,
      1351,
      1352,
      1353
    ],
    "bijon_iunion": [
      50,
      51,
      895,
      1351,
      1352,
      1353
    ],
    "hg_inj": [
      50,
      51,
      895,
      1351,
      1352,
      1353
    ],
    "bijon_univ": [
      50,
      51,
      895,
      1351,
      1352,
      1353
    ],
    "separatespoints": [
      58,
      899
    ],
    "hxy": [
      58,
      639,
      640,
      645,
      646,
      647,
      655,
      816,
      899,
      1168,
      1169,
      1173,
      1563
    ],
    "separates": [
      58,
      899
    ],
    "hsep": [
      58,
      899
    ],
    "introducing": [
      59
    ],
    "lean3": [
      59
    ],
    "would": [
      59,
      830
    ],
    "down": [
      59
    ],
    "lean4": [
      59
    ],
    "give": [
      59
    ],
    "just": [
      59,
      830,
      1686
    ],
    "note": [
      59,
      107,
      108,
      109,
      274,
      275,
      455,
      771,
      1385,
      1386,
      1387,
      1617,
      1659,
      1660,
      1768
    ],
    "subtypes": [
      59
    ],
    "way": [
      59
    ],
    "porting": [
      59
    ],
    "but": [
      59,
      134,
      136,
      137,
      138,
      139,
      261,
      771,
      929,
      1487,
      1568,
      1883
    ],
    "goes": [
      59
    ],
    "all": [
      59,
      465,
      1336,
      1818
    ],
    "setlike": [
      60,
      61,
      380,
      469,
      471,
      641,
      900,
      901,
      1085,
      1086,
      1170,
      1171,
      1475,
      1605,
      1701
    ],
    "le_def": [
      60,
      641,
      901,
      1170,
      1171,
      1854
    ],
    "setof_mem_eq": [
      60,
      901
    ],
    "coe": [
      60,
      380,
      901,
      1815,
      1860
    ],
    "partialorder": [
      60,
      206,
      901,
      1009,
      1449
    ],
    "iff": [
      60,
      123,
      158,
      159,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      288,
      568,
      901,
      923,
      936,
      956,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1332,
      1506,
      1649,
      1703,
      1854
    ],
    "instpartialorder": [
      60,
      901
    ],
    "priority": [
      60,
      107,
      108,
      109,
      400,
      401,
      901,
      1385,
      1386,
      1387,
      1561,
      1656
    ],
    "coe_injective": [
      60,
      323,
      324,
      380,
      901,
      1701
    ],
    "boilerplate": [
      61,
      900
    ],
    "has": [
      61,
      84,
      160,
      900,
      911,
      937,
      1250,
      1291,
      1296,
      1301,
      1306,
      1311,
      1335,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1506,
      1676
    ],
    "elements": [
      61,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      402,
      900,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1457,
      1458,
      1526,
      1559,
      1560,
      1561,
      1562
    ],
    "standard": [
      61,
      900,
      1596,
      1597
    ],
    "injective": [
      61,
      187,
      208,
      209,
      380,
      554,
      559,
      596,
      597,
      639,
      640,
      708,
      709,
      710,
      711,
      712,
      713,
      900,
      1126,
      1147,
      1168,
      1169,
      1216,
      1217,
      1218,
      1219,
      1673,
      1749,
      1750,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798,
      1859,
      1859
    ],
    "various": [
      61,
      900
    ],
    "extensionality": [
      61,
      900
    ],
    "coe_sort": [
      61,
      900
    ],
    "general": [
      61,
      900,
      1565
    ],
    "lemmas": [
      61,
      900,
      1888
    ],
    "every": [
      61,
      900,
      1366,
      1861
    ],
    "ideal": [
      62,
      236,
      382,
      383,
      400,
      401,
      402,
      656,
      902,
      981,
      1046,
      1245,
      1541,
      1559,
      1560,
      1561,
      1562,
      1761
    ],
    "isscalartower": [
      62,
      67,
      1462
    ],
    "map_map": [
      62
    ],
    "finrank": [
      62
    ],
    "relnorm_algebramap": [
      62
    ],
    "fractionring": [
      62
    ],
    "algebramap": [
      62
    ],
    "algebramap_eq": [
      62
    ],
    "differentialideal_le_fractionalideal_iff": [
      63
    ],
    "fractionalideal": [
      63,
      1245,
      1493
    ],
    "coeideal_le_coeideal": [
      63
    ],
    "discr_mem_differentideal": [
      64,
      903
    ],
    "cast_natcast": [
      64,
      671,
      903
    ],
    "eq_neg_comm": [
      64,
      903
    ],
    "inl": [
      64,
      288,
      434,
      536,
      903,
      919,
      1619,
      1620,
      1671
    ],
    "neg_mem_iff": [
      64,
      903
    ],
    "absnorm_mem": [
      64,
      903
    ],
    "cases": [
      64,
      272,
      273,
      406,
      761,
      762,
      903,
      1049,
      1133,
      1659,
      1660,
      1700,
      1846
    ],
    "ringofintegers": [
      64,
      903
    ],
    "discr": [
      64,
      903
    ],
    "map_mul": [
      64,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      903,
      1280,
      1281,
      1282,
      1441,
      1618,
      1747,
      1901
    ],
    "numberfield": [
      64,
      903,
      1356
    ],
    "natabs_eq": [
      64,
      903
    ],
    "differentideal": [
      64,
      903,
      1356
    ],
    "integralbasis_apply": [
      64,
      903
    ],
    "int": [
      64,
      378,
      379,
      459,
      580,
      581,
      663,
      664,
      671,
      812,
      813,
      814,
      815,
      851,
      852,
      853,
      854,
      855,
      903,
      1181,
      1182,
      1280,
      1281,
      1282,
      1686,
      1764,
      1799,
      1870,
      1871
    ],
    "mul_comm": [
      64,
      83,
      195,
      238,
      339,
      340,
      341,
      454,
      672,
      673,
      674,
      676,
      903,
      982,
      1016,
      1017,
      1018,
      1188,
      1189,
      1190,
      1191,
      1460,
      1524,
      1546,
      1547,
      1690
    ],
    "to_additive": [
      65,
      237,
      414,
      415,
      416,
      501,
      550,
      564,
      641,
      676,
      771,
      1053,
      1131,
      1170,
      1171,
      1191,
      1747,
      1752,
      1753
    ],
    "grpcat": [
      65
    ],
    "preserves": [
      65,
      1572,
      1772
    ],
    "noncomputable": [
      65,
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      123,
      248,
      261,
      843,
      915,
      916,
      923,
      1245,
      1246,
      1338,
      1487,
      1618,
      1720,
      1721,
      1722,
      1848,
      1893
    ],
    "category": [
      65,
      117,
      821,
      822,
      836,
      1222,
      1273,
      1274,
      1665,
      1685,
      1778,
      1879,
      1883,
      1890,
      1891,
      1893
    ],
    "islimitofreflects": [
      65
    ],
    "islimitofpreserves": [
      65
    ],
    "categorytheory": [
      65,
      117,
      261,
      530,
      531,
      717,
      1487,
      1662,
      1663,
      1853
    ],
    "forget": [
      65,
      296,
      452,
      1071,
      1875,
      1879
    ],
    "uliftfunctor_preserveslimit": [
      65
    ],
    "uliftfunctor": [
      65
    ],
    "preserveslimit": [
      65,
      1772
    ],
    "finite_sup": [
      66,
      68
    ],
    "commsemiring": [
      67,
      400,
      401,
      635,
      1228,
      1720,
      1721,
      1747
    ],
    "hfin": [
      67,
      773
    ],
    "use": [
      67,
      346,
      577,
      578,
      904,
      905,
      1137,
      1139,
      1238,
      1319,
      1357,
      1358,
      1509,
      1714,
      1715,
      1803,
      1804,
      1813,
      1814,
      1820
    ],
    "addcommmonoid": [
      67,
      220,
      294,
      804,
      1462
    ],
    "h_dis": [
      70,
      71,
      73,
      906,
      907
    ],
    "h_ss": [
      70,
      71,
      73,
      906,
      907
    ],
    "sunion": [
      70,
      71,
      73,
      512,
      906,
      907
    ],
    "h_mem": [
      70,
      71,
      73,
      906,
      907
    ],
    "hst": [
      72,
      74,
      75,
      76,
      77,
      78,
      79,
      908,
      909,
      1359
    ],
    "sunion_insert_disjointofdiff": [
      72,
      74,
      75,
      76,
      77,
      78,
      79,
      908,
      909,
      1359
    ],
    "coe_insert": [
      72,
      74,
      75,
      76,
      77,
      78,
      79,
      908,
      909,
      1359
    ],
    "log_nonneg": [
      80,
      1362,
      1363
    ],
    "real": [
      80,
      82,
      82,
      85,
      85,
      520,
      663,
      665,
      666,
      667,
      668,
      669,
      670,
      781,
      843,
      1006,
      1007,
      1115,
      1181,
      1183,
      1184,
      1185,
      1186,
      1187,
      1250,
      1251,
      1336,
      1362,
      1367,
      1367,
      1368,
      1368,
      1370,
      1371,
      1372,
      1373,
      1374,
      1375,
      1375,
      1427,
      1554,
      1604,
      1606,
      1692,
      1765,
      1768,
      1863
    ],
    "basic": [
      81,
      530,
      531,
      910,
      1509,
      1553,
      1662,
      1663,
      1665,
      1666,
      1689
    ],
    "import": [
      81,
      117,
      465,
      530,
      531,
      910,
      1662,
      1663,
      1665,
      1666,
      1689,
      1766,
      1888
    ],
    "mathlib": [
      81,
      117,
      134,
      135,
      136,
      137,
      138,
      139,
      453,
      461,
      465,
      530,
      531,
      561,
      562,
      563,
      564,
      910,
      929,
      1041,
      1042,
      1081,
      1128,
      1129,
      1130,
      1131,
      1289,
      1292,
      1297,
      1302,
      1307,
      1312,
      1573,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616,
      1657,
      1662,
      1663,
      1665,
      1666,
      1689,
      1766,
      1801,
      1802,
      1803,
      1804,
      1805,
      1810,
      1811,
      1812,
      1813,
      1814,
      1844,
      1888
    ],
    "public": [
      81,
      117,
      134,
      135,
      136,
      137,
      138,
      139,
      294,
      910,
      929,
      1050,
      1567,
      1665,
      1666,
      1689,
      1720,
      1721,
      1754,
      1766,
      1861,
      1888
    ],
    "log": [
      81,
      744,
      910,
      1196
    ],
    "analysis": [
      81,
      910,
      1688,
      1689,
      1766
    ],
    "specialfunctions": [
      81,
      910
    ],
    "div_eq_mul_inv": [
      82,
      85,
      1367,
      1368,
      1375
    ],
    "infinity": [
      82,
      83,
      85,
      123,
      923,
      1365,
      1367,
      1368,
      1375
    ],
    "tends": [
      82,
      83,
      85,
      722,
      723,
      724,
      956,
      1224,
      1225,
      1365,
      1367,
      1368,
      1375
    ],
    "seminormfromconst": [
      82,
      83,
      85,
      1365,
      1366,
      1366,
      1367,
      1368,
      1375
    ],
    "hf1": [
      82,
      83,
      85,
      1365,
      1366,
      1367,
      1368,
      1375
    ],
    "attop": [
      82,
      84,
      85,
      201,
      220,
      567,
      911,
      963,
      1367,
      1368,
      1370,
      1371,
      1372,
      1373,
      1374,
      1375
    ],
    "seminormfromconst_seq": [
      82,
      83,
      85,
      1365,
      1367,
      1368,
      1375
    ],
    "one_mul": [
      82,
      85,
      835,
      1277,
      1367,
      1368,
      1375
    ],
    "limit": [
      82,
      83,
      84,
      85,
      911,
      1108,
      1365,
      1367,
      1368,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1375,
      1879,
      1880,
      1892
    ],
    "seminormfromconst_islimit": [
      82,
      85,
      1366,
      1367,
      1368,
      1375
    ],
    "prove": [
      82,
      85,
      1367,
      1368,
      1375,
      1728,
      1844
    ],
    "pow_ne_zero": [
      82,
      85,
      1366,
      1367,
      1368,
      1375,
      1690
    ],
    "choose_spec": [
      82,
      85,
      1245,
      1367,
      1368,
      1375
    ],
    "seminormfromconst_seq_antitone": [
      82,
      85,
      1367,
      1368,
      1375
    ],
    "sending": [
      82,
      85,
      657,
      1367,
      1368,
      1375
    ],
    "tendsto": [
      82,
      83,
      85,
      103,
      103,
      104,
      105,
      220,
      477,
      520,
      722,
      723,
      724,
      773,
      781,
      918,
      918,
      920,
      1115,
      1224,
      1225,
      1251,
      1365,
      1367,
      1368,
      1370,
      1371,
      1372,
      1373,
      1374,
      1375,
      1411,
      1459,
      1627,
      1628,
      1690,
      1892
    ],
    "sequence": [
      82,
      272,
      273,
      1367,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1553,
      1597
    ],
    "neg": [
      83,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      519,
      521,
      522,
      522,
      658,
      658,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      1114,
      1116,
      1116,
      1178,
      1178,
      1365,
      1429,
      1430,
      1431,
      1432,
      1576,
      1582,
      1582,
      1583,
      1583
    ],
    "map_zero": [
      83,
      248,
      1365,
      1471,
      1618
    ],
    "seminormfromconst_seq_one": [
      83,
      1365
    ],
    "div_mul_div_comm": [
      83,
      1365
    ],
    "mul": [
      83,
      104,
      314,
      315,
      316,
      317,
      320,
      521,
      522,
      658,
      666,
      667,
      668,
      669,
      670,
      676,
      722,
      723,
      724,
      919,
      920,
      1004,
      1116,
      1178,
      1183,
      1184,
      1185,
      1186,
      1187,
      1191,
      1224,
      1225,
      1365,
      1382,
      1593,
      1747,
      1765
    ],
    "ge_iff_le": [
      83,
      1365
    ],
    "lowerbounds": [
      84,
      911
    ],
    "antitone": [
      84,
      84,
      240,
      288,
      911,
      911,
      983,
      1371,
      1372,
      1372,
      1373,
      1373,
      1374,
      1374
    ],
    "rintro": [
      84,
      197,
      259,
      260,
      288,
      368,
      369,
      370,
      417,
      418,
      548,
      655,
      726,
      821,
      822,
      911,
      1030,
      1054,
      1125,
      1273,
      1274,
      1327,
      1328,
      1494,
      1525,
      1582,
      1583,
      1757,
      1879,
      1880,
      1884
    ],
    "hl0": [
      84,
      911
    ],
    "finite": [
      84,
      501,
      512,
      688,
      694,
      698,
      845,
      911,
      1211,
      1238,
      1278,
      1369,
      1370,
      1371,
      1372,
      1373,
      1374,
      1448,
      1502,
      1506,
      1588,
      1844,
      1858,
      1861
    ],
    "_root_": [
      84,
      346,
      402,
      657,
      911,
      1370,
      1371,
      1372,
      1373,
      1374,
      1436,
      1559,
      1560,
      1562
    ],
    "isglb_of_tendsto_attop": [
      84,
      911
    ],
    "exists_islub": [
      84,
      911,
      1370,
      1371,
      1372,
      1373,
      1374
    ],
    "simp_rw": [
      84,
      221,
      222,
      231,
      250,
      288,
      290,
      342,
      343,
      566,
      693,
      694,
      695,
      696,
      697,
      698,
      782,
      911,
      999,
      1210,
      1211,
      1212,
      1392,
      1454,
      1468,
      1479,
      1480,
      1618
    ],
    "h_mon": [
      84,
      911,
      1370,
      1371,
      1372,
      1373,
      1374
    ],
    "schwartzmap": [
      89,
      1376
    ],
    "else": [
      89,
      161,
      428,
      429,
      430,
      431,
      432,
      483,
      487,
      521,
      522,
      784,
      938,
      1061,
      1062,
      1063,
      1064,
      1065,
      1094,
      1095,
      1096,
      1097,
      1099,
      1116,
      1376,
      1427,
      1428,
      1481,
      1589,
      1590,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640,
      1659,
      1660
    ],
    "continuouslinearmap": [
      89,
      349,
      350,
      351,
      478,
      479,
      1020,
      1091,
      1376,
      1749,
      1750
    ],
    "lsmul": [
      89,
      1376
    ],
    "flip": [
      89,
      514,
      515,
      516,
      517,
      1113,
      1376,
      1768
    ],
    "bilinleftclm": [
      89,
      1376
    ],
    "ext": [
      90,
      217,
      232,
      241,
      263,
      264,
      269,
      291,
      292,
      293,
      327,
      338,
      404,
      460,
      617,
      693,
      694,
      695,
      696,
      697,
      698,
      716,
      732,
      733,
      734,
      735,
      736,
      836,
      839,
      841,
      914,
      969,
      978,
      984,
      991,
      992,
      1000,
      1015,
      1076,
      1210,
      1211,
      1212,
      1227,
      1228,
      1229,
      1378,
      1388,
      1435,
      1443,
      1463,
      1464,
      1465,
      1468,
      1475,
      1489,
      1521,
      1534,
      1564,
      1605,
      1693,
      1711,
      1712,
      1722,
      1723,
      1726,
      1735,
      1736,
      1745,
      1749,
      1750,
      1827,
      1828,
      1829,
      1855,
      1879,
      1880,
      1893
    ],
    "by_cases": [
      90,
      569,
      570,
      571,
      782,
      914,
      1238,
      1378,
      1704
    ],
    "matrix": [
      90,
      284,
      319,
      423,
      914,
      951,
      952,
      1005,
      1332,
      1378,
      1665
    ],
    "diagonal": [
      90,
      914,
      1378,
      1588
    ],
    "hadamard_one": [
      90,
      914,
      1378
    ],
    "one": [
      90,
      914,
      1378,
      1436,
      1593,
      1871
    ],
    "decidableeq": [
      90,
      195,
      382,
      383,
      554,
      914,
      1378,
      1436,
      1541,
      1588
    ],
    "mulzerooneclass": [
      90,
      914,
      1378
    ],
    "zero": [
      90,
      622,
      623,
      722,
      723,
      724,
      740,
      763,
      764,
      766,
      778,
      914,
      952,
      1162,
      1224,
      1225,
      1378,
      1585,
      1649,
      1851,
      1871,
      1895
    ],
    "one_hadamard": [
      90,
      914
    ],
    "intertwining": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      915,
      916
    ],
    "linearmap": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      241,
      242,
      243,
      267,
      268,
      449,
      450,
      460,
      529,
      530,
      531,
      532,
      617,
      635,
      659,
      737,
      738,
      775,
      915,
      916,
      984,
      991,
      993,
      1076,
      1119,
      1120,
      1121,
      1228,
      1246,
      1247,
      1426,
      1489,
      1490,
      1491,
      1662,
      1663,
      1664,
      1666,
      1701,
      1735,
      1736,
      1745,
      1749,
      1750,
      1756,
      1757,
      1758,
      1760,
      1767,
      1768,
      1826,
      1848,
      1859
    ],
    "id_apply": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      549,
      550,
      915,
      916
    ],
    "isintertwining": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      915,
      916
    ],
    "right_inv": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      800,
      801,
      802,
      915,
      916,
      1261,
      1262,
      1263,
      1441,
      1723
    ],
    "representation": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      294,
      294,
      915,
      916,
      1138,
      1844
    ],
    "considered": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      915,
      916
    ],
    "intertwiningmap": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      915,
      916
    ],
    "from": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      242,
      243,
      254,
      255,
      256,
      257,
      561,
      562,
      563,
      564,
      915,
      916,
      986,
      987,
      988,
      989,
      1128,
      1129,
      1130,
      1131,
      1232,
      1364,
      1443,
      1450,
      1726,
      1749,
      1750,
      1863
    ],
    "tolinearmap": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      241,
      551,
      552,
      553,
      785,
      915,
      916,
      984,
      1246,
      1749,
      1750,
      1848
    ],
    "identity": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      915,
      916
    ],
    "itself": [
      91,
      92,
      93,
      94,
      95,
      96,
      98,
      474,
      915,
      916,
      1585,
      1586
    ],
    "submodulesubrepresentationorderiso": [
      97,
      99,
      100,
      101,
      102,
      1379,
      1380,
      1381
    ],
    "isirreducible_iff": [
      97,
      99,
      100,
      101,
      102,
      1379,
      1380,
      1381
    ],
    "issimplemodule_iff": [
      97,
      99,
      100,
      101,
      102,
      1379,
      1380,
      1381
    ],
    "issimpleorder_iff": [
      97,
      99,
      100,
      101,
      102,
      1379,
      1380,
      1381
    ],
    "subrepresentation": [
      97,
      99,
      100,
      101,
      102,
      1379,
      1380,
      1381
    ],
    "orderiso": [
      97,
      99,
      100,
      101,
      102,
      1379,
      1380,
      1381
    ],
    "continuouswithinat": [
      103,
      103,
      918,
      918
    ],
    "tendsto_nhdswithin_iff": [
      103,
      918
    ],
    "continuousat": [
      103,
      103,
      105,
      105,
      917,
      918,
      918,
      1582,
      1583,
      1690
    ],
    "norm": [
      103,
      237,
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      636,
      917,
      918,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1356,
      1530,
      1531,
      1532,
      1533
    ],
    "g_an": [
      103,
      918
    ],
    "fun_prop": [
      103,
      104,
      439,
      518,
      584,
      585,
      586,
      918,
      920,
      1068,
      1140,
      1141,
      1142,
      1250
    ],
    "nth_rw": [
      104,
      920
    ],
    "exp_zero": [
      104,
      920
    ],
    "mulexpnegmulsq": [
      104,
      920
    ],
    "continuous_const": [
      104,
      722,
      723,
      724,
      919,
      920,
      1224,
      1225,
      1382,
      1383
    ],
    "mul_one": [
      104,
      400,
      401,
      920,
      1366
    ],
    "neg_zero": [
      104,
      920
    ],
    "zero_mul": [
      104,
      768,
      769,
      920,
      1239,
      1242,
      1243,
      1847
    ],
    "smul": [
      105,
      1383,
      1564
    ],
    "ofreal_ne_zero": [
      105
    ],
    "zero_smul": [
      105,
      1884
    ],
    "sub_self": [
      105,
      1694
    ],
    "div": [
      105,
      439,
      917
    ],
    "continuousat_id": [
      105
    ],
    "continuous_sub_right": [
      105
    ],
    "continuousat_const": [
      105,
      917
    ],
    "irreducible_iff_prime": [
      106,
      1384
    ],
    "uniquefactorizationmonoid": [
      106,
      1384
    ],
    "prime_factors_unique": [
      106,
      1384
    ],
    "symm_inv": [
      107,
      108,
      109,
      1385,
      1386,
      1387
    ],
    "isiso": [
      107,
      108,
      109,
      116,
      1385,
      1386,
      1387,
      1388,
      1393,
      1394,
      1395,
      1396
    ],
    "lean": [
      107,
      108,
      109,
      134,
      135,
      136,
      137,
      138,
      139,
      348,
      453,
      461,
      929,
      1081,
      1241,
      1291,
      1296,
      1301,
      1306,
      1311,
      1385,
      1386,
      1387,
      1509,
      1573,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616,
      1772,
      1844
    ],
    "typeclass": [
      107,
      108,
      109,
      160,
      937,
      1361,
      1385,
      1386,
      1387
    ],
    "epi_of_iso": [
      107,
      108,
      109,
      1385,
      1386,
      1387
    ],
    "eq_comm": [
      107,
      108,
      109,
      617,
      658,
      1178,
      1192,
      1385,
      1386,
      1387,
      1576,
      1735,
      1736
    ],
    "been": [
      107,
      108,
      109,
      115,
      921,
      1385,
      1386,
      1387
    ],
    "trans_assoc": [
      107,
      108,
      109,
      1385,
      1386,
      1387
    ],
    "inv_hom_id": [
      107,
      108,
      109,
      1385,
      1386,
      1387
    ],
    "prop": [
      107,
      108,
      109,
      145,
      160,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      566,
      932,
      937,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1050,
      1385,
      1386,
      1387,
      1402,
      1419,
      1425,
      1572,
      1649,
      1658,
      1723,
      1726,
      1727,
      1752,
      1753,
      1894
    ],
    "failing": [
      107,
      108,
      109,
      1385,
      1386,
      1387
    ],
    "epi": [
      107
    ],
    "iso": [
      107,
      117,
      307,
      308,
      313,
      576,
      717,
      799,
      841,
      1388,
      1706,
      1707,
      1875,
      1893
    ],
    "inv_comp_eq_id": [
      107
    ],
    "inverse": [
      107,
      549,
      550,
      751,
      752,
      780,
      1108,
      1843,
      1855,
      1863
    ],
    "inferinstance": [
      108,
      109,
      118,
      119,
      121,
      318,
      321,
      322,
      331,
      332,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      694,
      698,
      751,
      752,
      1010,
      1031,
      1032,
      1033,
      1034,
      1035,
      1211,
      1385,
      1386,
      1387,
      1514,
      1535,
      1536,
      1537,
      1843,
      1854,
      1885
    ],
    "loop": [
      108,
      109,
      1385,
      1386,
      1387
    ],
    "make": [
      108,
      109,
      1385,
      1386,
      1387,
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "easier": [
      108,
      109,
      1385,
      1386,
      1387
    ],
    "of_mul_left": [
      111
    ],
    "mod_mul_left_mod": [
      111
    ],
    "mod_modeq": [
      111
    ],
    "hcodisjoint": [
      112,
      113,
      1391
    ],
    "inf_le_right": [
      112,
      113,
      1391,
      1878
    ],
    "exists_inf_eq_and_codisjoint": [
      112,
      113,
      1391
    ],
    "isprimitive_def": [
      114
    ],
    "dirichletcharacter": [
      114
    ],
    "primitivecharacter_isprimitive": [
      114
    ],
    "conductor_one": [
      114
    ],
    "let_expr": [
      115,
      921
    ],
    "traversed": [
      115,
      921
    ],
    "necessary": [
      115,
      921
    ],
    "mostly": [
      115,
      921
    ],
    "better": [
      115,
      921
    ],
    "work": [
      115,
      522,
      830,
      921,
      1116
    ],
    "simproc": [
      115,
      921
    ],
    "here": [
      115,
      921,
      1554,
      1801,
      1802,
      1805,
      1811,
      1812,
      1844
    ],
    "instcat": [
      115,
      921
    ],
    "withreducible": [
      115,
      921
    ],
    "procedure": [
      115,
      921
    ],
    "return": [
      115,
      428,
      429,
      430,
      431,
      432,
      482,
      483,
      484,
      485,
      486,
      487,
      521,
      921,
      1061,
      1062,
      1063,
      1064,
      1065,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1340,
      1415,
      1589,
      1590,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "comp": [
      115,
      125,
      142,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      328,
      549,
      550,
      551,
      552,
      553,
      708,
      709,
      710,
      711,
      712,
      713,
      737,
      738,
      773,
      919,
      921,
      930,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      1133,
      1216,
      1217,
      1218,
      1219,
      1333,
      1382,
      1429,
      1430,
      1431,
      1432,
      1606,
      1667,
      1668,
      1669,
      1670,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798,
      1859
    ],
    "hom_inv_id_assoc": [
      116,
      1393,
      1394,
      1395,
      1396
    ],
    "functor": [
      117,
      396,
      397,
      455,
      530,
      531,
      576,
      840,
      841,
      1443,
      1556,
      1557,
      1617,
      1662,
      1663,
      1666,
      1706,
      1707,
      1824,
      1825,
      1860
    ],
    "smulcommclass": [
      118,
      119,
      120,
      121,
      1564
    ],
    "smulcommclass_right": [
      120
    ],
    "subsemiring": [
      120
    ],
    "adj": [
      122,
      568,
      842,
      922,
      1703
    ],
    "map_rel": [
      122,
      922
    ],
    "abbrev": [
      122,
      399,
      455,
      456,
      824,
      922,
      1572,
      1617,
      1653
    ],
    "coloring": [
      122,
      123,
      123,
      125,
      126,
      922,
      923,
      923,
      1402
    ],
    "valid": [
      122,
      922
    ],
    "completegraph": [
      122,
      922
    ],
    "selfcoloring": [
      123,
      923
    ],
    "simple": [
      123,
      923,
      1403
    ],
    "chromaticnumber": [
      123,
      126,
      923
    ],
    "const": [
      123,
      923,
      1133,
      1512,
      1568
    ],
    "many": [
      123,
      428,
      429,
      430,
      431,
      432,
      923,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "chromatic": [
      123,
      923
    ],
    "tautological": [
      123,
      923
    ],
    "colorable": [
      123,
      123,
      125,
      126,
      923,
      923,
      1402,
      1403,
      1403
    ],
    "extend": [
      123,
      923,
      1382
    ],
    "setof": [
      123,
      923
    ],
    "cliques": [
      124,
      125,
      126
    ],
    "convert": [
      125,
      126,
      261,
      325,
      338,
      519,
      678,
      688,
      693,
      694,
      698,
      721,
      1015,
      1114,
      1197,
      1210,
      1211,
      1487,
      1521
    ],
    "injective_of_top_hom": [
      125,
      126
    ],
    "tohom": [
      125,
      126,
      1673
    ],
    "card_le_of_colorable": [
      125,
      126
    ],
    "card_le_of_coloring": [
      125,
      126
    ],
    "subtype": [
      125,
      126,
      258,
      391,
      845,
      990,
      1246,
      1278,
      1483,
      1564,
      1702,
      1848
    ],
    "embedding": [
      125,
      799
    ],
    "isclique": [
      125
    ],
    "induce": [
      125
    ],
    "card_le_of_injective": [
      125,
      208,
      209
    ],
    "card": [
      125,
      150,
      208,
      209,
      405,
      407,
      501,
      637,
      862,
      863,
      864,
      865,
      866,
      1324,
      1447,
      1448,
      1574,
      1575
    ],
    "chromaticnumber_ne_top_iff_exists": [
      126
    ],
    "cast_le": [
      126
    ],
    "le_top": [
      126,
      333,
      334,
      400,
      401,
      1011,
      1012,
      1854
    ],
    "card_le_chromaticnumber": [
      126
    ],
    "bitotal_iff_isempty_left": [
      127,
      924,
      925,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410
    ],
    "of_isempty": [
      127,
      924,
      925,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410
    ],
    "righttotal_empty": [
      127,
      924,
      925,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410
    ],
    "and_true": [
      127,
      924,
      925,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410
    ],
    "isempty": [
      127,
      414,
      415,
      924,
      925,
      1053,
      1405,
      1405,
      1406,
      1407,
      1407,
      1408,
      1409,
      1409,
      1410,
      1410
    ],
    "lefttotal_iff_isempty_left": [
      127,
      924,
      925,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410
    ],
    "bitotal": [
      127,
      924,
      925,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410
    ],
    "bijective": [
      127,
      924,
      925,
      1405,
      1406,
      1407,
      1408,
      1409,
      1410
    ],
    "complinearmap_inj": [
      128,
      926
    ],
    "zero_complinearmap": [
      128,
      926
    ],
    "surjective": [
      128,
      154,
      155,
      156,
      157,
      785,
      926,
      935,
      1443
    ],
    "orthogonalprojection": [
      129,
      130,
      927,
      928,
      1745
    ],
    "hausdorffmeasure_image_le": [
      129,
      130,
      927,
      928
    ],
    "lipschitzwith_orthogonalprojection": [
      129,
      130,
      927,
      928
    ],
    "restrict": [
      131,
      132,
      725,
      1226,
      1246,
      1624,
      1848,
      1881,
      1882
    ],
    "ico_ae_eq_ioc": [
      131,
      132
    ],
    "restrict_congr_set": [
      131,
      132
    ],
    "ico": [
      131,
      132
    ],
    "ioc": [
      131,
      132,
      1624
    ],
    "restrict_ico_eq_restrict_ioc": [
      131,
      132
    ],
    "discretetopology_subtype_iff": [
      133,
      1676
    ],
    "isdiscrete_iff_discretetopology": [
      133
    ],
    "isdiscrete": [
      133
    ],
    "operation": [
      134,
      136,
      137,
      138,
      139,
      929
    ],
    "pass": [
      134,
      136,
      137,
      138,
      139,
      929
    ],
    "applyconfig": [
      134,
      136,
      137,
      138,
      139,
      929
    ],
    "like": [
      134,
      136,
      137,
      138,
      139,
      521,
      929,
      1659,
      1883
    ],
    "elab": [
      134,
      135,
      136,
      137,
      137,
      138,
      138,
      139,
      139,
      453,
      929,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "underlying": [
      134,
      136,
      137,
      138,
      139,
      929,
      1509,
      1875
    ],
    "allows": [
      134,
      136,
      137,
      138,
      139,
      929
    ],
    "term": [
      134,
      135,
      136,
      161,
      353,
      355,
      453,
      929,
      938,
      1157,
      1401,
      1428,
      1555,
      1570,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "provide": [
      134,
      136,
      929
    ],
    "namespace": [
      134,
      135,
      136,
      284,
      409,
      453,
      455,
      615,
      635,
      773,
      929,
      1042,
      1051,
      1156,
      1331,
      1451,
      1601,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616,
      1617,
      1720,
      1721,
      1733,
      1734,
      1861
    ],
    "config": [
      134,
      136,
      352,
      929
    ],
    "meta": [
      135,
      135,
      1074,
      1573
    ],
    "tactic": [
      135,
      272,
      273,
      348,
      352,
      353,
      354,
      355,
      453,
      461,
      1081,
      1289,
      1289,
      1555,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "applywith": [
      137,
      138,
      139
    ],
    "mkconst": [
      137,
      138,
      139,
      161,
      938,
      1428
    ],
    "unsafe": [
      137,
      138,
      139
    ],
    "name": [
      137,
      138,
      139,
      348,
      428,
      429,
      430,
      431,
      432,
      453,
      1061,
      1062,
      1063,
      1064,
      1065,
      1322,
      1335,
      1401,
      1589,
      1590,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616,
      1803,
      1804,
      1805,
      1806,
      1808,
      1809,
      1813,
      1814
    ],
    "median": [
      140
    ],
    "prealeph": [
      141
    ],
    "ordinal": [
      141,
      739,
      739,
      1775,
      1776
    ],
    "prealeph_le_prealeph": [
      141
    ],
    "aleph0_le_prealeph": [
      141
    ],
    "prealeph_omega0": [
      141
    ],
    "units": [
      142,
      930,
      1441,
      1565
    ],
    "continuous_pi": [
      142,
      930
    ],
    "continuous_iff": [
      142,
      930
    ],
    "continuous_coe_inv": [
      142,
      930
    ],
    "continuous_apply": [
      142,
      930
    ],
    "continuous_val": [
      142,
      930
    ],
    "continuous_invfun": [
      142,
      584,
      585,
      586,
      930,
      1140,
      1141,
      1142
    ],
    "ht1": [
      143,
      144,
      931
    ],
    "ht2": [
      143,
      144,
      931
    ],
    "h_indep": [
      143,
      144,
      931,
      1416
    ],
    "h32": [
      143,
      144,
      931,
      1416
    ],
    "indep": [
      143,
      144,
      931,
      1416
    ],
    "nonpos_iff_eq_zero": [
      145,
      932,
      1419,
      1892
    ],
    "abundant_twelve": [
      145,
      932
    ],
    "show": [
      145,
      242,
      243,
      566,
      722,
      723,
      724,
      846,
      932,
      1224,
      1225,
      1279,
      1361
    ],
    "deficient_three": [
      145,
      932
    ],
    "ne_eq": [
      145,
      238,
      258,
      932,
      982,
      990,
      1419,
      1460,
      1483,
      1702
    ],
    "not_and": [
      145,
      932,
      1419
    ],
    "deficient_one": [
      145,
      932
    ],
    "norm_num": [
      145,
      548,
      582,
      583,
      932,
      1125,
      1872,
      1873
    ],
    "not_pseudoperfect_iff_forall": [
      145,
      932,
      1419
    ],
    "deficient": [
      145,
      146,
      147,
      148,
      149,
      932,
      933,
      934,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "pseudoperfect": [
      145,
      932,
      1419
    ],
    "weird_seventy": [
      145,
      932
    ],
    "not_and_or": [
      145,
      932,
      1419
    ],
    "properdivisors": [
      145,
      932,
      1419,
      1425
    ],
    "abundant": [
      145,
      932,
      1419,
      1425
    ],
    "weird": [
      145,
      932,
      1419
    ],
    "infinite_iff_exists_gt": [
      146,
      147,
      148,
      149,
      933,
      934,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "mem_setof": [
      146,
      147,
      148,
      149,
      776,
      933,
      934,
      1248,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "exists_infinite_primes": [
      146,
      147,
      148,
      149,
      933,
      934,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "odd_of_ne_two": [
      146,
      147,
      148,
      149,
      933,
      934,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "ne_of_lt": [
      146,
      147,
      148,
      149,
      933,
      934,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "prime": [
      146,
      147,
      148,
      149,
      501,
      933,
      934,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "omega": [
      146,
      147,
      148,
      149,
      933,
      934,
      1420,
      1421,
      1422,
      1423,
      1424
    ],
    "property": [
      150,
      468,
      470,
      1084,
      1108,
      1629
    ],
    "orderisooffin": [
      150,
      784
    ],
    "val": [
      150,
      672,
      673,
      674,
      763,
      764,
      766,
      1174,
      1188,
      1189,
      1190,
      1555
    ],
    "range": [
      151,
      567,
      617,
      1370,
      1371,
      1372,
      1373,
      1374,
      1649,
      1735,
      1736,
      1755,
      1756,
      1757,
      1760
    ],
    "span": [
      151,
      204,
      965,
      1509,
      1618
    ],
    "exterioralgebra": [
      151,
      152
    ],
    "range_subtype": [
      152
    ],
    "aesop": [
      153,
      200,
      254,
      255,
      256,
      257,
      475,
      567,
      624,
      626,
      627,
      628,
      629,
      962,
      986,
      987,
      988,
      989,
      1626,
      1742
    ],
    "comp_left": [
      154,
      155,
      156,
      157,
      935
    ],
    "range_eq_univ": [
      154,
      155,
      156,
      157,
      935
    ],
    "isopen_implies_isopen_iff": [
      158,
      159,
      936
    ],
    "isopen": [
      158,
      159,
      936,
      1677
    ],
    "class": [
      160,
      937,
      1526,
      1726,
      1727
    ],
    "measurablesup": [
      160,
      937
    ],
    "are": [
      160,
      272,
      273,
      274,
      275,
      838,
      937,
      1291,
      1296,
      1301,
      1306,
      1311,
      1335,
      1509,
      1596,
      1597,
      1622,
      1662,
      1760,
      1772,
      1883
    ],
    "say": [
      160,
      937,
      1727
    ],
    "assuming": [
      160,
      937
    ],
    "measurable_sup_const": [
      160,
      937
    ],
    "measurability": [
      160,
      937
    ],
    "measurablespace": [
      160,
      290,
      393,
      937,
      999,
      1039,
      1383,
      1467,
      1861,
      1881,
      1882
    ],
    "measurable_const_sup": [
      160,
      937
    ],
    "uncurry": [
      160,
      937,
      1817
    ],
    "functions": [
      160,
      937,
      1331,
      1818
    ],
    "half": [
      161,
      938,
      1428
    ],
    "elabterm": [
      161,
      938,
      1427,
      1428
    ],
    "exprtosyntax": [
      161,
      938,
      1428
    ],
    "throwerror": [
      161,
      938,
      1415,
      1428,
      1573,
      1834
    ],
    "plane": [
      161,
      938,
      1428
    ],
    "upper": [
      161,
      938,
      1022,
      1428
    ],
    "findmodel": [
      162
    ],
    "fromclm": [
      162,
      1427
    ],
    "trace": [
      162,
      1427,
      1512,
      1657
    ],
    "metam": [
      162,
      837,
      1241,
      1512,
      1622
    ],
    "normedfield": [
      162,
      1415
    ],
    "expr": [
      162,
      837,
      888,
      889,
      1427,
      1512
    ],
    "termelabm": [
      162,
      1427
    ],
    "trystrategy": [
      162,
      1415
    ],
    "fromtotalspace": [
      162
    ],
    "find": [
      162,
      353,
      355,
      1415,
      1427
    ],
    "lowering": [
      162
    ],
    "tangentbundle": [
      162
    ],
    "manifold": [
      162
    ],
    "fromtangentbundle": [
      162
    ],
    "mdiff": [
      162,
      1427
    ],
    "frommanifold": [
      162
    ],
    "fromnormedspace": [
      162
    ],
    "finding": [
      162
    ],
    "coe_i": [
      163,
      662,
      1180
    ],
    "norm_cast": [
      163,
      662,
      665,
      666,
      667,
      668,
      669,
      670,
      763,
      764,
      766,
      1180,
      1183,
      1184,
      1185,
      1186,
      1187,
      1693,
      1765
    ],
    "summable_e2summand_symmetricicc": [
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      1429,
      1430,
      1431,
      1432
    ],
    "tsum_symmetricicc_eq_tsum_symmetricico": [
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      1429,
      1430,
      1431,
      1432
    ],
    "tendsto_e2summand_attop_nhds_zero": [
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      1429,
      1430,
      1431,
      1432
    ],
    "tendsto_natcast_attop_attop": [
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      1429,
      1430,
      1431,
      1432
    ],
    "mem_cons_of_mem": [
      184,
      185,
      186,
      948,
      949,
      1433,
      1434
    ],
    "mul_apply": [
      187
    ],
    "swap_apply_def": [
      187
    ],
    "eq_iff": [
      187,
      596,
      597,
      1147,
      1749,
      1750
    ],
    "mem_support": [
      187,
      587,
      588,
      589,
      590,
      591,
      592,
      1143,
      1144,
      1324,
      1708,
      1709,
      1710
    ],
    "disjointofunion": [
      188,
      189,
      953
    ],
    "map_apply": [
      190
    ],
    "hft": [
      190
    ],
    "htm": [
      190
    ],
    "measure_tomeasurable": [
      190
    ],
    "zpow_natcast": [
      191,
      1440
    ],
    "one_le_pow_of_one_le": [
      191,
      1440
    ],
    "notation": [
      192,
      192,
      739,
      954,
      954,
      1437,
      1437,
      1438,
      1438,
      1439,
      1439
    ],
    "scoped": [
      192,
      220,
      405,
      406,
      407,
      739,
      954,
      1049,
      1437,
      1438,
      1439,
      1574,
      1575,
      1861
    ],
    "withzero": [
      192,
      193,
      954,
      955,
      1437,
      1438,
      1439
    ],
    "multiplicativenotation": [
      192,
      954,
      1437,
      1438,
      1439
    ],
    "instlinearorderedcommmonoidwithzero": [
      192,
      193,
      954,
      955,
      1437,
      1438,
      1439
    ],
    "multiplicative": [
      192,
      657,
      954,
      1437,
      1438,
      1439
    ],
    "commgroupwithzero": [
      192,
      193,
      954,
      955,
      1437,
      1438,
      1439
    ],
    "tosubmodule_inf": [
      194,
      957
    ],
    "eq_bot_iff": [
      194,
      957
    ],
    "mem_inf": [
      194,
      957,
      1332
    ],
    "tosubmodule_bot": [
      194,
      957
    ],
    "mem_bot": [
      194,
      957
    ],
    "and_imp": [
      194,
      957
    ],
    "orthogonal_tosubmodule_eq": [
      194,
      957
    ],
    "inner_self_eq_zero": [
      194,
      957
    ],
    "inf_orthogonal_eq_bot": [
      194,
      957
    ],
    "toeuclideanlin": [
      195
    ],
    "rankone": [
      195
    ],
    "symm_toeuclideanlin_rankone": [
      195
    ],
    "euclideanspace": [
      195
    ],
    "rclike": [
      195,
      409,
      1051,
      1377
    ],
    "star": [
      195,
      423,
      638,
      820,
      1748
    ],
    "vecmulvec_apply": [
      195
    ],
    "tomatrix": [
      195
    ],
    "vecmulvec": [
      195
    ],
    "innerproductspace": [
      195,
      1415
    ],
    "ext_iff": [
      195,
      219,
      258,
      478,
      479,
      549,
      550,
      617,
      990,
      1091,
      1483,
      1700,
      1735,
      1736,
      1749,
      1750
    ],
    "fintype": [
      195,
      319,
      804,
      950,
      1005,
      1324,
      1447,
      1896
    ],
    "inner_single_right": [
      195
    ],
    "of_iscoveringmap_subtype": [
      196,
      958
    ],
    "iscoveringmap_exp": [
      196,
      958
    ],
    "mem_nhds": [
      197,
      1327,
      1328
    ],
    "eventually_constant_or_nhds_le_map_nhds": [
      197,
      1327,
      1328
    ],
    "hs1": [
      197,
      1327,
      1328
    ],
    "image_mem_map": [
      197,
      1327,
      1328
    ],
    "hs2": [
      197,
      1327,
      1328
    ],
    "resolve_left": [
      197,
      501,
      502,
      1327,
      1328
    ],
    "hw1": [
      197,
      1327,
      1328
    ],
    "single_mem_stdsimplex": [
      198,
      959,
      1442
    ],
    "stdsimplexhomeomorphunitinterval": [
      198,
      959,
      1442
    ],
    "stdsimplexhomeomorphunitinterval_one": [
      198,
      959,
      1442
    ],
    "isbigowith_mul_iff_isbigowith_div": [
      199,
      960
    ],
    "islittleo_iff_forall_isbigowith": [
      199,
      960
    ],
    "exp": [
      201,
      744,
      842,
      963,
      1693,
      1725
    ],
    "eventually_attop": [
      201,
      963
    ],
    "tendsto_attop_mono": [
      201,
      963
    ],
    "add_one_le_exp": [
      201,
      963
    ],
    "uioo_of_gt": [
      202,
      964
    ],
    "uioo": [
      202,
      964
    ],
    "uioo_self": [
      202,
      964
    ],
    "uioo_of_ge": [
      202,
      964
    ],
    "ioo": [
      202,
      843,
      964,
      1444,
      1445,
      1446
    ],
    "univ": [
      203,
      753,
      776,
      846,
      1248,
      1279,
      1447,
      1448,
      1752,
      1753
    ],
    "meromorphicnfon": [
      203,
      203
    ],
    "analyticonnhd": [
      203,
      447,
      447,
      1070,
      1070
    ],
    "meromorphicnfon_inv": [
      203
    ],
    "analyticonnhd_univ_iff_differentiable": [
      203
    ],
    "differentiable_one_div_gamma": [
      203
    ],
    "meromorphicon": [
      203,
      203,
      725,
      1226
    ],
    "gamma": [
      203
    ],
    "linearindepon": [
      204,
      965
    ],
    "subsingleton": [
      205,
      1752,
      1753
    ],
    "alleq": [
      205
    ],
    "reachable": [
      205,
      1324
    ],
    "injectiveresolution": [
      207,
      1452
    ],
    "mem_univ": [
      208,
      209,
      783,
      1252,
      1453
    ],
    "card_le_card_of_injon": [
      208,
      209
    ],
    "issetsemiring": [
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      966,
      967,
      968,
      1451
    ],
    "contextual": [
      217,
      277,
      278,
      969,
      1495
    ],
    "imp_false": [
      217,
      969
    ],
    "deleteedges_deleteedges": [
      218
    ],
    "deleteedges_empty": [
      218
    ],
    "deleteedges": [
      218
    ],
    "sym2": [
      218
    ],
    "sdiff_sdiff": [
      218
    ],
    "natcast_eq_zero": [
      219
    ],
    "nezero": [
      219,
      611,
      760,
      763,
      764,
      765,
      766,
      1403,
      1729,
      1730,
      1731,
      1845
    ],
    "dvd_iff_mod_eq_zero": [
      219
    ],
    "fin": [
      219,
      318,
      321,
      322,
      327,
      763,
      764,
      765,
      766,
      784,
      1401,
      1402,
      1470,
      1700,
      1859
    ],
    "topology": [
      220,
      843,
      1572,
      1658,
      1676,
      1688,
      1861,
      1888
    ],
    "tangentconeat": [
      220
    ],
    "filter": [
      220,
      347,
      567,
      572,
      573,
      574,
      773,
      1134,
      1135,
      1136,
      1582,
      1583,
      1676,
      1705,
      1800,
      1861
    ],
    "point": [
      220,
      474,
      1068,
      1587
    ],
    "topologicalspace": [
      220,
      729,
      845,
      1161,
      1278,
      1329,
      1330,
      1383,
      1467,
      1572,
      1656,
      1658,
      1685,
      1688,
      1741,
      1861,
      1886,
      1887
    ],
    "pointwise": [
      220,
      294
    ],
    "tangent": [
      220
    ],
    "nontriviallynormedfield": [
      220
    ],
    "card_filter_univ_succ": [
      221,
      222,
      231,
      1454
    ],
    "tolist_cons": [
      221,
      222,
      231,
      1454
    ],
    "hxs": [
      221,
      222,
      231,
      1454
    ],
    "beq_iff_eq": [
      221,
      222,
      231,
      1454
    ],
    "add_comm": [
      221,
      222,
      231,
      655,
      721,
      740,
      1250,
      1454
    ],
    "get_cons_succ": [
      221,
      222,
      231,
      1454
    ],
    "count_cons": [
      221,
      222,
      231,
      1454
    ],
    "vector": [
      221,
      222,
      231,
      1230,
      1450,
      1454
    ],
    "get_cons_zero": [
      221,
      222,
      231,
      1454
    ],
    "hij": [
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      386,
      387,
      388,
      389,
      390,
      760,
      761,
      762,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977,
      1037,
      1548,
      1549,
      1845,
      1846
    ],
    "sorted": [
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977
    ],
    "lt_card_le_iff_apply_le_of_monotone": [
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977
    ],
    "dual_right": [
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977
    ],
    "mtr": [
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977
    ],
    "le_of_not_gt": [
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977
    ],
    "h_sorted": [
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      970,
      971,
      972,
      973,
      974,
      975,
      976,
      977
    ],
    "bind": [
      233,
      751,
      752,
      979,
      1455,
      1843
    ],
    "hfm": [
      233,
      979,
      1455
    ],
    "measurable_bind": [
      233,
      979,
      1455
    ],
    "ae_ae_of_ae_join": [
      233,
      979,
      1455
    ],
    "bind_congr_right": [
      233,
      979,
      1455
    ],
    "gc_map_comap": [
      235,
      236,
      980,
      981
    ],
    "comap": [
      235,
      236,
      242,
      243,
      654,
      980,
      981,
      1046,
      1177,
      1333,
      1701
    ],
    "u_iinf": [
      235,
      236,
      980,
      981
    ],
    "galoisconnection": [
      236,
      981,
      1046
    ],
    "comap_iinf": [
      236,
      981
    ],
    "iinf": [
      236,
      981,
      1854
    ],
    "le_rfl": [
      237,
      1411,
      1820
    ],
    "inequality": [
      237
    ],
    "norm_mul_le_of_le": [
      237
    ],
    "triangle": [
      237
    ],
    "norm_mul_le": [
      237,
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282,
      1901
    ],
    "mul_assoc": [
      238,
      982,
      1460
    ],
    "not_true_eq_false": [
      238,
      982,
      1460
    ],
    "false_and": [
      238,
      982,
      1460
    ],
    "mem_erase": [
      238,
      982,
      1460
    ],
    "not_false_eq_true": [
      238,
      982,
      1460
    ],
    "prod_insert": [
      238,
      982,
      1460
    ],
    "had": [
      239
    ],
    "hdb": [
      239
    ],
    "hbc": [
      239,
      774,
      1899
    ],
    "antitone_nat_of_succ_le": [
      240,
      983
    ],
    "precantorset": [
      240,
      983
    ],
    "precantorset_antitone": [
      240,
      983
    ],
    "symm_apply_apply": [
      241,
      984,
      1469
    ],
    "symm_comp": [
      241,
      984
    ],
    "inf_of_le_right": [
      242,
      243
    ],
    "comap_mono": [
      242,
      243
    ],
    "bot_le": [
      242,
      243,
      277,
      278,
      1495
    ],
    "ker": [
      242,
      243,
      617,
      1333,
      1735,
      1736,
      1755,
      1756,
      1757,
      1760
    ],
    "mem_valuationsubring_iff": [
      244,
      245
    ],
    "valuation_le_one_iff": [
      244,
      245
    ],
    "valuationsubring": [
      244,
      245
    ],
    "picongrleft": [
      246,
      1476
    ],
    "infer_instance": [
      246,
      251,
      252,
      253,
      462,
      463,
      464,
      533,
      693,
      1082,
      1210,
      1250,
      1476,
      1482,
      1621
    ],
    "pioptionequivprod": [
      246,
      1476
    ],
    "isnoetherianring_of_ringequiv": [
      246,
      1476
    ],
    "isnontrivial": [
      247,
      1477,
      1478,
      1713,
      1714,
      1715
    ],
    "map_one": [
      248,
      1472,
      1473,
      1474,
      1618
    ],
    "dir": [
      248
    ],
    "iunionlift_binary": [
      248
    ],
    "subst": [
      248
    ],
    "assumption": [
      248,
      482,
      484,
      485,
      486,
      1098,
      1568,
      1630,
      1631,
      1632
    ],
    "hjk": [
      248
    ],
    "proving": [
      248,
      274,
      275,
      721
    ],
    "subalgebra": [
      248,
      248,
      459
    ],
    "each": [
      248,
      296,
      1232
    ],
    "defining": [
      248
    ],
    "turn": [
      248,
      1605
    ],
    "hik": [
      248
    ],
    "intersection": [
      248,
      1509
    ],
    "commutes": [
      248,
      622,
      623,
      1162
    ],
    "irreducible": [
      249,
      249,
      741,
      741,
      742,
      742,
      743,
      743,
      985,
      985,
      1231,
      1231,
      1752,
      1753,
      1894
    ],
    "factors": [
      249,
      985
    ],
    "irreducible_of_factor": [
      249,
      985
    ],
    "prime_of_factor": [
      249,
      985
    ],
    "finsupp": [
      250,
      702,
      703,
      704,
      705,
      775,
      804,
      805,
      991,
      1247,
      1319,
      1479,
      1480,
      1489,
      1723,
      1728,
      1747,
      1782,
      1783,
      1784
    ],
    "support_factorization": [
      250,
      1479,
      1480
    ],
    "pos_iff_ne_zero": [
      250,
      1479,
      1480
    ],
    "card_support_eq_one": [
      250,
      1479,
      1480
    ],
    "isprimepow_iff_factorization_eq_single": [
      250,
      1479,
      1480
    ],
    "primespectrum": [
      251,
      252,
      253,
      345,
      1482
    ],
    "isclosed_singleton_iff_ismaximal": [
      251,
      252,
      253,
      1482
    ],
    "closedpoint": [
      251,
      252,
      253,
      1482
    ],
    "le_of_lt": [
      254,
      255,
      256,
      257,
      520,
      574,
      760,
      761,
      762,
      986,
      987,
      988,
      989,
      1115,
      1136,
      1414,
      1845,
      1846
    ],
    "upperbounds": [
      254,
      255,
      256,
      257,
      986,
      987,
      988,
      989
    ],
    "succ": [
      254,
      255,
      256,
      257,
      622,
      623,
      658,
      740,
      761,
      762,
      956,
      986,
      987,
      988,
      989,
      1162,
      1178,
      1846
    ],
    "suffices": [
      254,
      255,
      256,
      257,
      693,
      694,
      698,
      986,
      987,
      988,
      989,
      1210,
      1211,
      1749,
      1750,
      1776
    ],
    "rec": [
      254,
      255,
      256,
      257,
      904,
      905,
      986,
      987,
      988,
      989,
      1357,
      1358
    ],
    "invtrootsubmodule": [
      258,
      990,
      1483
    ],
    "exists_pair_ne": [
      258,
      990,
      1483
    ],
    "bot_ne_top": [
      258,
      990,
      1483
    ],
    "congr_arg": [
      259,
      260,
      630,
      718,
      1163
    ],
    "quotient": [
      259,
      260,
      399,
      657,
      658,
      820,
      862,
      863,
      864,
      865,
      866,
      1178
    ],
    "map_trans": [
      259,
      260
    ],
    "map_comp": [
      259,
      260,
      529,
      530,
      531,
      532,
      841,
      1119,
      1120,
      1121,
      1388,
      1550,
      1663,
      1664,
      1685
    ],
    "map_id": [
      259,
      260,
      529,
      532,
      576,
      840,
      1119,
      1120,
      1121,
      1388,
      1664,
      1706,
      1707
    ],
    "fundamentalgroupoid": [
      261,
      399,
      1487
    ],
    "natural": [
      261,
      274,
      275,
      1487
    ],
    "homotopicmapsnatiso": [
      261,
      1487
    ],
    "expose": [
      261,
      294,
      530,
      531,
      843,
      1050,
      1487,
      1567,
      1576,
      1662,
      1663,
      1688,
      1720,
      1721,
      1722,
      1754,
      1861
    ],
    "after": [
      261,
      837,
      1322,
      1487
    ],
    "which": [
      261,
      721,
      830,
      837,
      838,
      843,
      1487,
      1509,
      1554,
      1568,
      1569,
      1570,
      1573,
      1585,
      1586,
      1587,
      1629,
      1772,
      1844,
      1892
    ],
    "isomorphism": [
      261,
      1487,
      1875
    ],
    "paths": [
      261,
      1487
    ],
    "equivofhomotopyequiv": [
      261,
      1487
    ],
    "corresponding": [
      261,
      1487,
      1526,
      1587,
      1875
    ],
    "notes": [
      261,
      1487
    ],
    "totient_mul": [
      262,
      1488
    ],
    "totient_prime": [
      262,
      1488
    ],
    "coprime_or_dvd_of_prime": [
      262,
      1488
    ],
    "issymm": [
      265,
      266,
      616,
      1158,
      1159,
      1160
    ],
    "entourageprod": [
      265,
      266
    ],
    "imp": [
      265,
      266,
      1414
    ],
    "transvection": [
      267,
      268,
      732,
      733,
      993,
      1227,
      1228,
      1463,
      1464,
      1465,
      1490,
      1491,
      1826,
      1827,
      1828,
      1829
    ],
    "basechange": [
      267,
      268,
      993
    ],
    "injon_cos": [
      270,
      271,
      994
    ],
    "cos_pi_div_three": [
      270,
      271,
      994
    ],
    "positivity": [
      270,
      271,
      348,
      598,
      835,
      994,
      1021,
      1148,
      1277,
      1573,
      1573
    ],
    "pi_nonneg": [
      270,
      271,
      994
    ],
    "h_bnd": [
      270,
      271,
      994
    ],
    "linarith": [
      270,
      271,
      994,
      1289,
      1692
    ],
    "cos_zero": [
      270,
      271,
      994
    ],
    "modifier": [
      272,
      273
    ],
    "pendingmvarid": [
      272,
      273
    ],
    "recover": [
      272,
      273
    ],
    "adds": [
      272,
      273
    ],
    "applies": [
      272,
      273
    ],
    "closed": [
      272,
      273,
      842,
      842,
      1361,
      1738,
      1739,
      1740
    ],
    "starting": [
      272,
      273
    ],
    "goals": [
      272,
      273,
      274,
      275
    ],
    "then": [
      272,
      273,
      657,
      722,
      723,
      724,
      784,
      1157,
      1224,
      1225,
      1403,
      1415,
      1481,
      1605,
      1622,
      1676,
      1693,
      1747,
      1883,
      1893
    ],
    "tacs": [
      272,
      273
    ],
    "incorrectly": [
      272,
      273
    ],
    "modify": [
      272,
      273
    ],
    "arrow": [
      274,
      275
    ],
    "local": [
      274,
      275,
      1572
    ],
    "form": [
      274,
      275,
      348,
      1228,
      1526,
      1569,
      1570,
      1573,
      1588,
      1649,
      1768,
      1834
    ],
    "indices": [
      274,
      275
    ],
    "context": [
      274,
      275,
      1241
    ],
    "hypothesis": [
      274,
      275
    ],
    "tfae": [
      274,
      275
    ],
    "beginning": [
      274,
      275
    ],
    "number": [
      274,
      275,
      1022
    ],
    "mul_self_eq_mul_self_iff": [
      276,
      995
    ],
    "mul_self_inj_of_nonneg": [
      276,
      995
    ],
    "d_ab": [
      276,
      995
    ],
    "exists_lt_mul_right_of_nonneg": [
      276,
      995
    ],
    "or_iff_left_of_imp": [
      276,
      995
    ],
    "bot": [
      277,
      278,
      326,
      326,
      1495
    ],
    "sdiff_singleton_eq_erase": [
      279,
      280,
      281,
      282,
      283,
      405,
      407,
      817,
      818,
      819,
      996,
      997,
      1269,
      1270,
      1271,
      1496,
      1497,
      1574,
      1575
    ],
    "insert_subset_iff": [
      279,
      280,
      281,
      282,
      283,
      405,
      407,
      817,
      818,
      819,
      996,
      997,
      1269,
      1270,
      1271,
      1496,
      1497,
      1574,
      1575
    ],
    "singleton_subset_iff": [
      279,
      280,
      281,
      282,
      283,
      405,
      407,
      817,
      818,
      819,
      996,
      997,
      1269,
      1270,
      1271,
      1496,
      1497,
      1574,
      1575
    ],
    "tmul_subset_maxtensorproduct": [
      285,
      286,
      287,
      998
    ],
    "maxtensorproduct": [
      285,
      286,
      287,
      998
    ],
    "mintensorproduct": [
      285,
      286,
      287,
      998
    ],
    "span_le": [
      285,
      286,
      287,
      998
    ],
    "hca": [
      288
    ],
    "hfcb": [
      288
    ],
    "hfac": [
      288
    ],
    "lt_or_ge": [
      288,
      1836
    ],
    "hfba": [
      288
    ],
    "exacts": [
      288,
      708,
      709,
      710,
      711,
      712,
      713,
      1216,
      1217,
      1218,
      1219,
      1582,
      1583,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798
    ],
    "not_le": [
      288,
      1859
    ],
    "hfca": [
      288
    ],
    "hfbd": [
      288
    ],
    "hfab": [
      288
    ],
    "ispullback_inl_inl_coprodmap": [
      289
    ],
    "of_iso": [
      289,
      777
    ],
    "braiding": [
      289
    ],
    "refl": [
      289,
      307,
      308,
      313,
      717,
      774,
      1388,
      1576,
      1893,
      1897
    ],
    "coprod": [
      289
    ],
    "comp_def": [
      290,
      999
    ],
    "isup_le_iff": [
      290,
      999
    ],
    "comap_isup": [
      290,
      999
    ],
    "comap_comp": [
      290,
      999
    ],
    "measurable_iff_comap_le": [
      290,
      999
    ],
    "frommodulecattomodulecatlinearequivtomodulecatobj": [
      291,
      292,
      293,
      1000
    ],
    "intros": [
      291,
      292,
      293,
      1000
    ],
    "file": [
      294,
      461,
      465,
      721,
      731,
      1081,
      1450,
      1553,
      1596,
      1597,
      1818,
      1844
    ],
    "group": [
      294,
      294,
      384,
      521,
      1383,
      1565
    ],
    "subrepresentations": [
      294,
      294
    ],
    "commring": [
      294,
      596,
      1564,
      1726,
      1727
    ],
    "defines": [
      294,
      1108,
      1450,
      1553,
      1596,
      1818
    ],
    "isunit_iff": [
      295
    ],
    "natdegree_c_mul": [
      295
    ],
    "binary": [
      296,
      474
    ],
    "isleftadjoint": [
      296
    ],
    "product": [
      296,
      1366,
      1768
    ],
    "existence": [
      296
    ],
    "over": [
      296,
      391,
      458,
      1401,
      1506,
      1603,
      1607,
      1693
    ],
    "forgetadjstar": [
      296
    ],
    "equivalent": [
      296,
      1554,
      1662,
      1727
    ],
    "quasifinite": [
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      1001,
      1002,
      1003,
      1506,
      1507,
      1508
    ],
    "hom": [
      305,
      306,
      392,
      529,
      530,
      531,
      532,
      538,
      620,
      621,
      820,
      821,
      822,
      840,
      841,
      1038,
      1119,
      1120,
      1121,
      1222,
      1273,
      1274,
      1663,
      1664,
      1673,
      1685,
      1824,
      1825,
      1875,
      1880
    ],
    "map_smul": [
      305,
      306,
      1228,
      1747
    ],
    "map_add": [
      305,
      306,
      378,
      379,
      631,
      632,
      1781
    ],
    "pushforward": [
      307,
      308,
      313,
      1046
    ],
    "abelian": [
      310,
      311,
      312,
      1498
    ],
    "modules": [
      310,
      311,
      312
    ],
    "inferinstanceas": [
      310,
      311,
      312,
      1402,
      1778
    ],
    "sheafofmodules": [
      310,
      311,
      312
    ],
    "ringcatsheaf": [
      310,
      311,
      312
    ],
    "slashinvariantform": [
      314,
      315,
      316,
      317,
      320,
      1004
    ],
    "subgroup": [
      318,
      319,
      321,
      322,
      501,
      502,
      820,
      1005,
      1383
    ],
    "example": [
      318,
      321,
      322,
      1021,
      1289,
      1519,
      1520,
      1527,
      1565
    ],
    "hasdetone": [
      318,
      321,
      322
    ],
    "modularform": [
      318,
      319,
      321,
      322,
      1005
    ],
    "prod_comp": [
      319,
      1005
    ],
    "quotientfunc": [
      319,
      1005
    ],
    "univ_nonempty": [
      319,
      1005
    ],
    "quotientfunc_smul": [
      319,
      1005
    ],
    "mulaction": [
      319,
      1005,
      1564
    ],
    "slash_action_eq": [
      319,
      1005
    ],
    "offinite": [
      319,
      1005
    ],
    "generallineargroup": [
      319,
      737,
      738,
      1005
    ],
    "hasdetplusminusone": [
      319,
      1005,
      1174
    ],
    "val_det_apply": [
      319,
      1005
    ],
    "abs_det": [
      319,
      1005
    ],
    "prod_slash": [
      319,
      1005
    ],
    "dfunlike": [
      323,
      324
    ],
    "addcommgroup": [
      323,
      324,
      557,
      558,
      560,
      617,
      1050,
      1735,
      1736,
      1778
    ],
    "ico_add_one_right_eq_icc": [
      325
    ],
    "addrightembedding": [
      325
    ],
    "zero_add": [
      325,
      658,
      1178
    ],
    "add_right_comm": [
      325
    ],
    "choose": [
      325,
      567
    ],
    "sum_map": [
      325
    ],
    "map_add_right_ico": [
      325
    ],
    "top": [
      326,
      326,
      1526
    ],
    "match_pattern": [
      326
    ],
    "attribute": [
      326,
      616,
      771,
      1158,
      1159,
      1160,
      1519,
      1520,
      1834
    ],
    "about": [
      327,
      391
    ],
    "aleph0": [
      327
    ],
    "properties": [
      327,
      465,
      1587
    ],
    "nat_succ": [
      327
    ],
    "lift_mk_le": [
      327
    ],
    "lift_mk_fin": [
      327
    ],
    "succ_le_iff": [
      327
    ],
    "nat_lt_aleph0": [
      327
    ],
    "conj": [
      328,
      1875
    ],
    "logcounting_sub_const": [
      329,
      1513
    ],
    "proximity": [
      329,
      1513
    ],
    "sub_def": [
      329,
      1513
    ],
    "characteristic": [
      329,
      1513
    ],
    "logcounting": [
      330,
      1008
    ],
    "withtop": [
      330,
      554,
      586,
      1008,
      1142,
      1468,
      1689
    ],
    "logcounting_const_zero": [
      330,
      1008
    ],
    "logcounting_const": [
      330,
      1008
    ],
    "islocalizedmodule_iff_islocalization": [
      331,
      332,
      1010,
      1514
    ],
    "_ha": [
      333,
      334,
      1011,
      1012,
      1519,
      1520
    ],
    "mem_top": [
      333,
      334,
      1011,
      1012
    ],
    "orthogonalprojectionspan_congr": [
      335
    ],
    "reindex": [
      335,
      695,
      696,
      697,
      751,
      752,
      1212,
      1843
    ],
    "signs": [
      335
    ],
    "touchpoint": [
      335
    ],
    "range_faceopposite_reindex": [
      335
    ],
    "excenter_reindex": [
      335
    ],
    "instorthogonalcompletespace": [
      336,
      337,
      1013,
      1014
    ],
    "isclosed_orthogonal": [
      336,
      337,
      1013,
      1014
    ],
    "completespace_coe": [
      336,
      337,
      1013,
      1014
    ],
    "and_right_comm": [
      338,
      1015,
      1521
    ],
    "f_inv": [
      338,
      1015,
      1521
    ],
    "open_iff": [
      338,
      1015,
      1521
    ],
    "dif_pos": [
      338,
      648,
      649,
      1015,
      1521,
      1781
    ],
    "inter": [
      338,
      1015,
      1521,
      1572
    ],
    "and_congr_right": [
      338,
      488,
      1015,
      1087,
      1100,
      1521
    ],
    "subset_rfl": [
      338,
      1015,
      1518,
      1521
    ],
    "open_w": [
      338,
      1015,
      1521
    ],
    "inv_u": [
      338,
      1015,
      1521
    ],
    "mem_preimage": [
      338,
      1015,
      1521
    ],
    "open_v": [
      338,
      1015,
      1521
    ],
    "inj": [
      338,
      1015,
      1521
    ],
    "two_pos": [
      339,
      340,
      341,
      1016,
      1017,
      1018,
      1524
    ],
    "mul_div_mul_left": [
      339,
      340,
      341,
      1016,
      1017,
      1018,
      1524
    ],
    "mul_pos": [
      339,
      340,
      341,
      1016,
      1017,
      1018,
      1524
    ],
    "card_comm_eq_card_conjclasses_mul_card": [
      339,
      340,
      341,
      1016,
      1017,
      1018,
      1524
    ],
    "card_commute_odd": [
      339,
      340,
      341,
      1016,
      1017,
      1018,
      1524
    ],
    "pos": [
      339,
      340,
      341,
      1016,
      1017,
      1018,
      1524
    ],
    "mul_div_left": [
      339,
      340,
      341,
      1016,
      1017,
      1018,
      1524
    ],
    "nat_card": [
      339,
      340,
      341,
      1016,
      1017,
      1018,
      1524
    ],
    "iscompact_iunion": [
      342,
      343
    ],
    "isup_mk": [
      342,
      343
    ],
    "hvc": [
      342,
      343
    ],
    "of_iunion_eq_of_finite": [
      342,
      343
    ],
    "simp_all": [
      342,
      343,
      404,
      406,
      542,
      1049,
      1564,
      1757,
      1836,
      1881,
      1882
    ],
    "iff_iscompactopencovered_sigmamk": [
      342,
      343
    ],
    "heq": [
      342,
      343,
      1241,
      1525,
      1690
    ],
    "iscompact": [
      342,
      343,
      510,
      511,
      845,
      846,
      1278,
      1279,
      1595
    ],
    "iscompactopencovered": [
      342,
      343
    ],
    "comp_apply": [
      342,
      343,
      478,
      479,
      518,
      549,
      550,
      648,
      649,
      1091,
      1690
    ],
    "hveq": [
      342,
      343
    ],
    "cancelmonoidwithzero": [
      344
    ],
    "hcd": [
      344
    ],
    "hdc": [
      344
    ],
    "hac0": [
      344
    ],
    "dvd_dvd_iff_associated": [
      344
    ],
    "istotal": [
      345,
      346,
      1563
    ],
    "asideal": [
      345,
      462,
      463,
      464,
      1082,
      1621
    ],
    "all_goals": [
      345,
      678,
      783,
      1197,
      1252,
      1757
    ],
    "le_ofprime": [
      345
    ],
    "ofprime_le_of_le": [
      345
    ],
    "le_total_ideal": [
      345
    ],
    "semigroup": [
      346
    ],
    "cond": [
      346
    ],
    "total": [
      346
    ],
    "prevaluationring": [
      346
    ],
    "iff_dvd_total": [
      346
    ],
    "classical": [
      346,
      405,
      407,
      694,
      698,
      782,
      1211,
      1574,
      1575,
      1728,
      1895
    ],
    "filter_ne_eq_erase": [
      347
    ],
    "erase": [
      347,
      382,
      383,
      461,
      1081,
      1541
    ],
    "ne_comm": [
      347,
      1836
    ],
    "congr": [
      347,
      440,
      655,
      694,
      698,
      782,
      783,
      919,
      1211,
      1252
    ],
    "tactic_clause": [
      348
    ],
    "reducible": [
      348,
      1427
    ],
    "reals": [
      348
    ],
    "true": [
      348,
      357,
      1232,
      1241,
      1350,
      1622,
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "safe": [
      348
    ],
    "terminal": [
      348
    ],
    "nonnegative": [
      348,
      1587
    ],
    "equivalently": [
      348
    ],
    "mkident": [
      348
    ],
    "finiteness": [
      348,
      781,
      1251,
      1519,
      1520,
      1527,
      1587
    ],
    "builtin": [
      348
    ],
    "linter": [
      348,
      461,
      1041,
      1041,
      1042,
      1043,
      1044,
      1045,
      1046,
      1081,
      1572,
      1841
    ],
    "introstransparency": [
      348
    ],
    "false": [
      348,
      1043,
      1044,
      1045,
      1046,
      1241,
      1572,
      1841
    ],
    "solve": [
      348
    ],
    "isbigotvs_comp": [
      349,
      350,
      351,
      1020
    ],
    "elabdeprewriteconfig": [
      352
    ],
    "deprewrite": [
      352,
      353,
      354,
      355
    ],
    "elaborate": [
      352
    ],
    "declare_config_elab": [
      352
    ],
    "inherit_doc": [
      352,
      353,
      354,
      355,
      739,
      799,
      1041
    ],
    "deprewriteseq": [
      352,
      354
    ],
    "deprewritetarget": [
      353,
      355
    ],
    "did": [
      353,
      355
    ],
    "goal": [
      353,
      355
    ],
    "current": [
      353,
      355,
      771
    ],
    "pattern": [
      353,
      355
    ],
    "deprwseq": [
      353,
      355
    ],
    "throwtacticex": [
      353,
      355
    ],
    "mvarids": [
      354
    ],
    "withmaincontext": [
      354,
      1555
    ],
    "replacemaingoal": [
      354
    ],
    "cleanupcasts": [
      354
    ],
    "getmaingoal": [
      354
    ],
    "getmaintarget": [
      354
    ],
    "deprw": [
      355
    ],
    "_eq_one": [
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1530,
      1531,
      1532,
      1533
    ],
    "isprimitiveroot_of_mem_primitiveroots": [
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1530,
      1531,
      1532,
      1533
    ],
    "isprimitiveroot": [
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      1023,
      1024,
      1025,
      1026,
      1027,
      1028,
      1530,
      1531,
      1532,
      1533
    ],
    "le_prod_of_submultiplicative_on_pred_of_nonneg": [
      357
    ],
    "h_one": [
      357
    ],
    "h_mul": [
      357
    ],
    "basis": [
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      695,
      696,
      697,
      734,
      735,
      736,
      1031,
      1032,
      1033,
      1034,
      1035,
      1212,
      1229,
      1535,
      1536,
      1537
    ],
    "range_subset_iff": [
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      1031,
      1032,
      1033,
      1034,
      1035,
      1535,
      1536,
      1537
    ],
    "cast_one": [
      378,
      379,
      1799
    ],
    "cast_inj": [
      378,
      379
    ],
    "contra": [
      378,
      379,
      1858
    ],
    "cast_add": [
      378,
      379
    ],
    "tocompacts": [
      380
    ],
    "tocompacts_injective": [
      380
    ],
    "of_comp": [
      380
    ],
    "coe_bot": [
      381,
      1717
    ],
    "compacts": [
      381,
      1336
    ],
    "islasker": [
      382,
      383,
      1541
    ],
    "radical": [
      382,
      383,
      1541
    ],
    "inf": [
      382,
      383,
      1541,
      1578
    ],
    "hut": [
      382,
      383,
      1541
    ],
    "isprimary": [
      382,
      383,
      1541
    ],
    "pairwise": [
      382,
      383,
      386,
      387,
      388,
      389,
      390,
      568,
      1037,
      1541,
      1548,
      1549,
      1703,
      1878
    ],
    "minimal": [
      382,
      383,
      1541
    ],
    "exists_minimal_isprimary_decomposition_of_isprimary_decomposition": [
      382,
      383,
      1541
    ],
    "decomposition_erase_inf": [
      382,
      383,
      1541
    ],
    "coeff": [
      385,
      1036,
      1545
    ],
    "coeff_zero_eq_constantcoeff_apply": [
      385,
      1036,
      1545
    ],
    "coeff_subst": [
      385,
      1036,
      1545
    ],
    "finsum": [
      385,
      1036,
      1545
    ],
    "constantcoeff": [
      385,
      1036,
      1542,
      1543,
      1544,
      1545
    ],
    "orthogonalfamily": [
      386,
      387,
      388,
      389,
      390,
      1037,
      1548,
      1549
    ],
    "supertype": [
      391
    ],
    "concerning": [
      391
    ],
    "changing": [
      391
    ],
    "changes": [
      391
    ],
    "integer": [
      391,
      700,
      1022
    ],
    "given": [
      391,
      1157,
      1232,
      1490,
      1491,
      1588,
      1772,
      1826
    ],
    "propositions": [
      391
    ],
    "zify": [
      391
    ],
    "without": [
      391
    ],
    "any": [
      391,
      482,
      484,
      485,
      486,
      1098,
      1630,
      1631,
      1632
    ],
    "still": [
      391
    ],
    "proof": [
      391,
      1688
    ],
    "fullsubcategory": [
      392,
      1038
    ],
    "hommk": [
      392,
      1038
    ],
    "obj": [
      392,
      455,
      840,
      1038,
      1388,
      1617,
      1653,
      1654,
      1824,
      1825,
      1860
    ],
    "filtration": [
      393,
      615,
      1039,
      1156,
      1467,
      1468,
      1553,
      1733,
      1734
    ],
    "preorder": [
      393,
      534,
      535,
      537,
      1039,
      1672,
      1727,
      1727
    ],
    "isoadd": [
      394,
      395,
      1040
    ],
    "inv": [
      394,
      395,
      478,
      479,
      664,
      820,
      822,
      823,
      824,
      1040,
      1091,
      1182,
      1196,
      1196,
      1274,
      1388,
      1764
    ],
    "shiftfunctoradd": [
      394,
      395,
      1040
    ],
    "app": [
      394,
      395,
      836,
      840,
      841,
      888,
      1040,
      1573,
      1607
    ],
    "_eq_shiftfunctoradd": [
      394,
      395,
      1040
    ],
    "_inv_app": [
      394,
      395,
      1040
    ],
    "grothendiecktopology": [
      398
    ],
    "frompath": [
      399
    ],
    "path": [
      399
    ],
    "homotopic": [
      399
    ],
    "mul_mem_of_left": [
      400,
      401,
      402,
      1559,
      1560,
      1561,
      1562
    ],
    "smul_set_subset_iff": [
      400,
      401,
      402,
      1559,
      1560,
      1561,
      1562
    ],
    "le_refl": [
      400,
      401,
      402,
      776,
      1248,
      1559,
      1560,
      1562
    ],
    "add_smul_subset": [
      400,
      401,
      402,
      1559,
      1560,
      1561,
      1562
    ],
    "annihilator": [
      400,
      401,
      402,
      1559,
      1560,
      1561,
      1562
    ],
    "add_subset_add": [
      400,
      401,
      402,
      1559,
      1560,
      1561,
      1562
    ],
    "map_le_iff_le_comap": [
      400,
      401,
      956
    ],
    "such": [
      400,
      401,
      574,
      1136,
      1523,
      1572,
      1818,
      1886,
      1887
    ],
    "trivial": [
      400,
      401,
      1538,
      1539,
      1844,
      1858,
      1886,
      1887
    ],
    "colon": [
      402,
      1559,
      1560,
      1561,
      1562
    ],
    "colon_bot": [
      402,
      1559,
      1560,
      1561,
      1562
    ],
    "nonempty": [
      402,
      510,
      511,
      707,
      753,
      1324,
      1402,
      1448,
      1559,
      1560,
      1561,
      1562
    ],
    "zero_mem": [
      402,
      459,
      1559,
      1560,
      1561,
      1562
    ],
    "mem_annihilator": [
      402,
      1559,
      1560,
      1561,
      1562
    ],
    "colon_mono": [
      402,
      1559,
      1560,
      1562
    ],
    "cartan": [
      403,
      1047
    ],
    "exceptional": [
      403,
      1047
    ],
    "matrices": [
      403,
      1047
    ],
    "eval": [
      405,
      406,
      407,
      1049,
      1573,
      1574,
      1575
    ],
    "eq_interpolate": [
      405,
      406,
      407,
      1049,
      1574,
      1575
    ],
    "interpolate": [
      405,
      406,
      407,
      1049,
      1574,
      1575
    ],
    "injon": [
      405,
      407,
      1360,
      1574,
      1575
    ],
    "hvs": [
      405,
      407,
      1574,
      1575
    ],
    "interpolate_poly_eq_self": [
      405,
      407,
      1574,
      1575
    ],
    "degree": [
      405,
      407,
      741,
      742,
      743,
      803,
      804,
      805,
      1022,
      1231,
      1574,
      1575,
      1864,
      1865
    ],
    "leadingcoeff_basis": [
      406,
      1049
    ],
    "interpolate_apply": [
      406,
      1049
    ],
    "leadingcoeff_eq_sum": [
      406,
      1049
    ],
    "natdegree_eq_of_degree_eq_some": [
      406,
      1049
    ],
    "occs": [
      406,
      453,
      1049,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "coe_inj": [
      406,
      1049,
      1426,
      1441
    ],
    "ring": [
      408,
      422,
      456,
      458,
      462,
      463,
      464,
      523,
      524,
      525,
      526,
      527,
      530,
      531,
      580,
      581,
      582,
      583,
      596,
      650,
      651,
      652,
      653,
      657,
      812,
      813,
      814,
      815,
      856,
      857,
      858,
      1082,
      1117,
      1118,
      1175,
      1176,
      1283,
      1284,
      1285,
      1361,
      1473,
      1474,
      1506,
      1621,
      1661,
      1662,
      1663,
      1695,
      1727,
      1842,
      1870,
      1872,
      1873,
      1894,
      1902,
      1903
    ],
    "i_sq": [
      408
    ],
    "top_eq_univ": [
      414,
      415,
      1053,
      1238
    ],
    "mem_empty_iff_false": [
      414,
      415,
      1053
    ],
    "centralizer_empty": [
      414,
      415,
      1053
    ],
    "setof_true": [
      414,
      415,
      1053
    ],
    "implies_true": [
      414,
      415,
      695,
      696,
      697,
      783,
      1053,
      1212,
      1252
    ],
    "centralizer": [
      414,
      415,
      1053
    ],
    "addcentralizer_empty": [
      414,
      415,
      416,
      1053
    ],
    "forall_iff": [
      414,
      415,
      1053
    ],
    "h_comm": [
      415,
      416,
      1053
    ],
    "odd": [
      417,
      418,
      548,
      1054,
      1125
    ],
    "decide": [
      417,
      418,
      593,
      594,
      595,
      1054,
      1145,
      1146,
      1716
    ],
    "absurd": [
      417,
      418,
      639,
      640,
      1054,
      1168,
      1169
    ],
    "of_dvd_nat": [
      417,
      418,
      1054
    ],
    "ne_two_of_dvd_nat": [
      417,
      418,
      1054
    ],
    "behaviour": [
      419,
      1055,
      1579,
      1580
    ],
    "operations": [
      419,
      1055,
      1509,
      1526,
      1579,
      1580
    ],
    "arithmetic": [
      419,
      1055,
      1579,
      1580
    ],
    "under": [
      419,
      731,
      1055,
      1336,
      1579,
      1580,
      1760
    ],
    "ext1": [
      420,
      433,
      840,
      841,
      1581,
      1591
    ],
    "possemidef": [
      421,
      951,
      952,
      1436
    ],
    "le_add_of_nonneg_right": [
      422,
      424,
      1057
    ],
    "sq_nonneg": [
      422
    ],
    "_apply": [
      423
    ],
    "dotproduct_mulvec_zero_iff": [
      423
    ],
    "existsaddofle": [
      424,
      1057
    ],
    "zero_ne_one": [
      424,
      1057
    ],
    "amo": [
      424,
      1057
    ],
    "le_of_le_of_eq": [
      424,
      1057
    ],
    "one_add_ne_zero": [
      424,
      1057,
      1593
    ],
    "linearorder": [
      424,
      639,
      640,
      951,
      1057,
      1168,
      1169
    ],
    "issemireal": [
      424,
      1057,
      1593
    ],
    "isstrictorderedring": [
      424,
      951,
      1057
    ],
    "zero_le_one": [
      424,
      1057
    ],
    "nonneg": [
      424,
      1057
    ],
    "setrel": [
      425,
      426,
      427,
      1058,
      1059,
      1060
    ],
    "_uv": [
      425,
      426,
      427,
      1058,
      1059,
      1060
    ],
    "dom_mono": [
      425,
      426,
      427,
      1058,
      1059,
      1060
    ],
    "huv": [
      425,
      426,
      427,
      520,
      773,
      1058,
      1059,
      1060,
      1115,
      1459
    ],
    "support_mono": [
      425,
      426,
      427,
      1058,
      1059,
      1060
    ],
    "simplegraph": [
      425,
      426,
      427,
      599,
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      1058,
      1059,
      1060,
      1149,
      1150,
      1151,
      1152,
      1153,
      1232,
      1403,
      1718,
      1719
    ],
    "solvereturn": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "string": [
      428,
      429,
      430,
      431,
      432,
      521,
      522,
      1061,
      1062,
      1063,
      1064,
      1065,
      1116,
      1289,
      1589,
      1590,
      1659,
      1660
    ],
    "zooming": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "until": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "mut": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "correct": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "while": [
      428,
      429,
      430,
      431,
      432,
      956,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "private": [
      428,
      429,
      430,
      431,
      432,
      658,
      820,
      1061,
      1062,
      1063,
      1064,
      1065,
      1178,
      1241,
      1589,
      1590,
      1894,
      1895
    ],
    "panic": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "lam": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "selected": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1590
    ],
    "arguments": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589,
      1768
    ],
    "reach": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589
    ],
    "listrest": [
      428,
      429,
      430,
      431,
      432,
      1061,
      1062,
      1063,
      1064,
      1065,
      1589
    ],
    "smulleftclm_smulleftclm_apply": [
      433,
      1591
    ],
    "le_sup_left": [
      434
    ],
    "le_sup_right": [
      434,
      641,
      1170,
      1171,
      1484,
      1485
    ],
    "le_sinf": [
      434
    ],
    "sup_le": [
      434
    ],
    "inr": [
      434,
      536,
      663,
      1181,
      1619,
      1620,
      1671
    ],
    "fin_cases": [
      435,
      436,
      437,
      438,
      1066,
      1067
    ],
    "issimplylaced": [
      435,
      436,
      437,
      438,
      1066,
      1067
    ],
    "sub": [
      439,
      917
    ],
    "analyticorderat_of_not_analyticat": [
      440
    ],
    "hfg": [
      440
    ],
    "normedlinearorderedfield_comap": [
      441
    ],
    "deriv_comp_neg": [
      442,
      443,
      444,
      445,
      446,
      1069
    ],
    "neg_smul": [
      442,
      443,
      444,
      445,
      446,
      1069
    ],
    "deriv_fun_const_smul": [
      442,
      443,
      444,
      445,
      446,
      1069
    ],
    "iteratedderiv": [
      442,
      443,
      444,
      445,
      446,
      1069
    ],
    "analyticonnhd_weierstrasspexcept": [
      447,
      1070
    ],
    "formalmultilinearseries": [
      447,
      1070
    ],
    "weierstrasspexceptseries": [
      447,
      1070
    ],
    "coeff_ofscalars": [
      447,
      1070
    ],
    "isopen_compl_lattice_diff": [
      447,
      1070
    ],
    "ofscalars_apply_eq": [
      447,
      1070
    ],
    "differentiableon_weierstrasspexcept": [
      447,
      1070
    ],
    "smul_eq_mul": [
      447,
      740,
      1070,
      1228,
      1686,
      1690
    ],
    "lattice": [
      447,
      1070,
      1412,
      1413,
      1509,
      1526
    ],
    "analytic": [
      448,
      1689
    ],
    "jordanholdermodule": [
      449,
      450
    ],
    "quotientinfequivsupquotient": [
      449,
      450
    ],
    "left": [
      452,
      821,
      822,
      1071,
      1273,
      1274,
      1607,
      1878
    ],
    "iteratedslicebackward": [
      452,
      1071
    ],
    "pat": [
      453,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "seq": [
      453,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "conv_lhs": [
      453,
      579,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "lhs": [
      453,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "syntax": [
      453,
      1401,
      1569,
      1570,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "convseq": [
      453,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "macro_rules": [
      453,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "conv": [
      453,
      453,
      1569,
      1570,
      1611,
      1611,
      1612,
      1612,
      1613,
      1613,
      1614,
      1614,
      1615,
      1615,
      1616,
      1616
    ],
    "ident": [
      453,
      1401,
      1555,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616
    ],
    "parser": [
      453,
      482,
      484,
      485,
      486,
      1098,
      1289,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616,
      1630,
      1631,
      1632
    ],
    "mul_smul": [
      454,
      1690
    ],
    "smul_comm": [
      454
    ],
    "single_zero_smul_eq_smul": [
      454
    ],
    "object": [
      455,
      1617
    ],
    "whiskeringright": [
      455,
      1617
    ],
    "exactly": [
      455,
      1617
    ],
    "what": [
      455,
      1617
    ],
    "catcommsqover": [
      455,
      1617
    ],
    "abbreviation": [
      455,
      1617
    ],
    "fact": [
      455,
      690,
      1207,
      1617
    ],
    "weierstrass": [
      456
    ],
    "curve": [
      456
    ],
    "coordinate": [
      456
    ],
    "coordinatering": [
      456
    ],
    "affine": [
      456
    ],
    "isembedding": [
      457,
      833,
      1075,
      1276
    ],
    "t5space": [
      457,
      457,
      1075,
      1075
    ],
    "ulift": [
      457,
      1075
    ],
    "uliftdown": [
      457,
      1075
    ],
    "instt5space": [
      457,
      1075
    ],
    "nonzero": [
      458
    ],
    "finitedimensional": [
      458,
      459
    ],
    "adjoin": [
      458,
      459,
      1522,
      1523
    ],
    "field": [
      458,
      458,
      951,
      1361,
      1523,
      1523
    ],
    "isunit": [
      458,
      458,
      700,
      1732
    ],
    "fg_adjoin_singleton": [
      458,
      459
    ],
    "unit": [
      458,
      521,
      522,
      1116
    ],
    "isdomain": [
      458,
      750,
      902,
      1235
    ],
    "domain": [
      458
    ],
    "isintegral": [
      458,
      459,
      481,
      1093
    ],
    "element": [
      458
    ],
    "fg_top": [
      458,
      459
    ],
    "inv_mem_adjoin": [
      459
    ],
    "inv_zero": [
      459,
      1781
    ],
    "eq_or_ne": [
      459,
      542,
      917
    ],
    "tospansingleton": [
      460,
      1076,
      1426
    ],
    "tospansingleton_eq_algebra_linearmap": [
      460,
      1076
    ],
    "moduleswithoutmathlibimports": [
      461,
      1081
    ],
    "header": [
      461,
      1081
    ],
    "missing": [
      461,
      1081
    ],
    "directorydependency": [
      461,
      1081
    ],
    "imported": [
      461,
      1081
    ],
    "krulldimle_iff": [
      462,
      463,
      464,
      1082,
      1621
    ],
    "residuefield": [
      462,
      463,
      464,
      465,
      1082,
      1621
    ],
    "polyequivtensor": [
      462,
      463,
      464,
      1082,
      1621
    ],
    "ringkrulldim_eq_of_ringequiv": [
      462,
      463,
      464,
      1082,
      1621
    ],
    "toringequiv": [
      462,
      463,
      464,
      1082,
      1621
    ],
    "fielddivision": [
      465
    ],
    "results": [
      465,
      482,
      483,
      484,
      485,
      486,
      487,
      763,
      764,
      766,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1356,
      1509,
      1598,
      1599,
      1600,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640,
      1853
    ],
    "jingting": [
      465
    ],
    "apache": [
      465,
      731,
      1688
    ],
    "ringtheory": [
      465
    ],
    "krull": [
      465
    ],
    "license": [
      465,
      731,
      731
    ],
    "localring": [
      465
    ],
    "ringkrulldim_le": [
      465
    ],
    "authors": [
      465,
      731
    ],
    "single": [
      466,
      467,
      1083,
      1722,
      1897,
      1899
    ],
    "rootspaceproduct": [
      468,
      470,
      1084
    ],
    "add_neg_cancel": [
      468,
      470,
      1084
    ],
    "hyz": [
      468,
      470,
      1084
    ],
    "add_lie": [
      469,
      471,
      1085,
      1086
    ],
    "mem_coe": [
      469,
      471,
      1085,
      1086
    ],
    "add_mem": [
      469,
      471,
      1085,
      1086
    ],
    "carrier_eq_coe": [
      469,
      471,
      1085,
      1086
    ],
    "ismeagre": [
      472,
      1088
    ],
    "auxlemmas": [
      473,
      1089,
      1622
    ],
    "unfold": [
      473,
      1089,
      1606,
      1781
    ],
    "value": [
      473,
      763,
      764,
      766,
      1089
    ],
    "applyreplacementfun": [
      473,
      1089,
      1512
    ],
    "returns": [
      474
    ],
    "convexcombopair": [
      474
    ],
    "combination": [
      474,
      1341,
      1342
    ],
    "second": [
      474
    ],
    "convexcombination": [
      474
    ],
    "duple": [
      474
    ],
    "convexcombopair_same": [
      474
    ],
    "convexcombopair_zero": [
      474
    ],
    "proof_wanted": [
      474
    ],
    "convexcombopair_one": [
      474
    ],
    "first": [
      474,
      739,
      1596
    ],
    "weight": [
      474
    ],
    "convex": [
      474,
      714
    ],
    "isopenmap": [
      475,
      1626
    ],
    "lowerhemicontinuous": [
      475,
      1626
    ],
    "isopenmap_iff_kernimage": [
      475,
      1626
    ],
    "lowerhemicontinuous_iff_isclosed_preimage_iic": [
      475,
      1626
    ],
    "finprod_prod_comm": [
      476,
      1090
    ],
    "prod_assoc_symm": [
      477,
      1627,
      1628
    ],
    "prodassoc": [
      477,
      1627,
      1628
    ],
    "continuouslinearequiv": [
      478,
      479,
      1091,
      1822
    ],
    "invf": [
      478,
      479,
      1091
    ],
    "exists_ne_map_eq_of_mapsto": [
      481,
      1093
    ],
    "hxi": [
      481,
      1093
    ],
    "infinite_univ": [
      481,
      1093
    ],
    "infinite": [
      481,
      739,
      1093
    ],
    "pow_eq_one_of_norm_le_one": [
      481,
      1093
    ],
    "norm_nonneg": [
      481,
      1093
    ],
    "pow": [
      481,
      834,
      1093
    ],
    "habne": [
      481,
      1093
    ],
    "read": [
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1322,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "piece": [
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "flatten": [
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "findtacticseqs": [
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "children": [
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "getkind": [
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "bytactic": [
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "out": [
      482,
      483,
      484,
      485,
      486,
      487,
      690,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1207,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "env": [
      482,
      483,
      484,
      485,
      486,
      487,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1630,
      1631,
      1632,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640,
      1657,
      1801,
      1802,
      1805,
      1807,
      1810,
      1811,
      1812
    ],
    "blocks": [
      482,
      484,
      485,
      486,
      1098,
      1630,
      1631,
      1632
    ],
    "tactics": [
      482,
      484,
      485,
      486,
      1098,
      1630,
      1631,
      1632
    ],
    "discard": [
      483,
      487,
      1094,
      1095,
      1096,
      1097,
      1099,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "plain": [
      483,
      487,
      1094,
      1095,
      1096,
      1097,
      1099,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "remaining": [
      483,
      487,
      1094,
      1095,
      1096,
      1097,
      1099,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "tactictry_": [
      483,
      487,
      1094,
      1095,
      1096,
      1097,
      1099,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "getd": [
      487,
      1094,
      1095,
      1096,
      1099,
      1633,
      1634,
      1635,
      1636,
      1637,
      1638,
      1639,
      1640
    ],
    "interior_eq_empty_iff_dense_compl": [
      488,
      1087,
      1100
    ],
    "isopen_compl_iff": [
      488,
      1087,
      1100
    ],
    "isclosed": [
      488,
      781,
      1087,
      1100,
      1223,
      1251,
      1688
    ],
    "isnowheredense_iff": [
      488,
      1087,
      1100
    ],
    "firstorder": [
      489,
      490,
      491,
      492,
      493,
      494,
      495,
      496,
      497,
      498,
      499,
      1101,
      1102,
      1103,
      1104,
      1105,
      1106,
      1107,
      1642,
      1643,
      1644,
      1645,
      1646,
      1647,
      1648
    ],
    "language": [
      489,
      490,
      491,
      492,
      493,
      494,
      495,
      496,
      497,
      498,
      499,
      1101,
      1102,
      1103,
      1104,
      1105,
      1106,
      1107,
      1642,
      1643,
      1644,
      1645,
      1646,
      1647,
      1648
    ],
    "modularcharacter": [
      500
    ],
    "subnegzeromonoid": [
      500
    ],
    "subnegzeroaddmonoid": [
      500
    ],
    "subtractionmonoid": [
      500,
      522,
      1116
    ],
    "divisionaddmonoid": [
      500
    ],
    "addmodularcharacter": [
      500
    ],
    "isquotientcoveringmap": [
      500
    ],
    "isaddquotientcoveringmap": [
      500
    ],
    "eq_bot_or_eq_top": [
      501,
      502
    ],
    "zpowers": [
      501,
      502
    ],
    "eq_top_iff": [
      501,
      502
    ],
    "prime_card": [
      501
    ],
    "zpowers_ne_bot": [
      501,
      502
    ],
    "quotientaddgroup": [
      503,
      504,
      505,
      506
    ],
    "quotientaddequivofeq": [
      503,
      504,
      505,
      506
    ],
    "quotientkerequivofsurjective": [
      503,
      504,
      505,
      506
    ],
    "kereq": [
      503,
      504,
      505,
      506
    ],
    "zmultipleshom": [
      503,
      504,
      505,
      506
    ],
    "surj": [
      503,
      504,
      505,
      506
    ],
    "bairespace": [
      507,
      508,
      509,
      513,
      1109,
      1110,
      1111,
      1112,
      1161,
      1741
    ],
    "baire_property": [
      507,
      508,
      509,
      513,
      1109,
      1110,
      1111,
      1112
    ],
    "hk_nonempty": [
      510,
      511
    ],
    "closure_mono": [
      510,
      511
    ],
    "hk_subset": [
      510,
      511
    ],
    "isclosed_closure": [
      510,
      511
    ],
    "hk_anti": [
      510,
      511
    ],
    "forall_mem_range": [
      512
    ],
    "finite_range": [
      512
    ],
    "pairing_continuous_left": [
      514,
      515,
      516,
      517,
      1113
    ],
    "pairing": [
      514,
      515,
      516,
      517,
      1113
    ],
    "sqrt_mul_sqrt": [
      518
    ],
    "continuouson_sqrt": [
      518
    ],
    "sqrt_nonneg": [
      518
    ],
    "eventually_const_lt": [
      520,
      1115
    ],
    "zero_lt_one": [
      520,
      1115
    ],
    "mul_rpow": [
      520,
      1115
    ],
    "monoid": [
      521,
      522,
      658,
      1116,
      1178,
      1443,
      1564,
      1778
    ],
    "divisible": [
      521,
      522,
      1116
    ],
    "isupper": [
      521,
      522,
      1116,
      1659,
      1660
    ],
    "submonoid": [
      521,
      522,
      1116,
      1332,
      1717,
      1732
    ],
    "next": [
      521,
      522,
      1116,
      1659,
      1660
    ],
    "grp": [
      521
    ],
    "toupper": [
      521,
      905,
      1659,
      1660
    ],
    "rootable": [
      521
    ],
    "hmul": [
      521
    ],
    "mconv": [
      521
    ],
    "indicator": [
      522,
      782,
      1116,
      1888
    ],
    "nsmul": [
      522,
      1116
    ],
    "iscanceladd": [
      522,
      522,
      1116,
      1116
    ],
    "addcancel": [
      522,
      1116
    ],
    "isleftcanceladd": [
      522,
      1116
    ],
    "cast_mul": [
      523,
      524,
      525,
      526,
      527,
      671,
      1117,
      1118,
      1661
    ],
    "two_dvd_mul_add_one": [
      528
    ],
    "even_mul_succ_self": [
      528
    ],
    "even_iff_two_dvd": [
      528
    ],
    "mapmatrixmodule": [
      529,
      530,
      531,
      532,
      1119,
      1120,
      1121,
      1662,
      1663,
      1664,
      1666
    ],
    "mapmatrixmodule_id": [
      529,
      532,
      1119,
      1120,
      1121,
      1664
    ],
    "modulecat": [
      529,
      530,
      531,
      532,
      1119,
      1120,
      1121,
      1662,
      1663,
      1664,
      1665,
      1666,
      1875
    ],
    "hom_ext": [
      529,
      532,
      1119,
      1120,
      1121,
      1664
    ],
    "ofhom": [
      529,
      532,
      1119,
      1120,
      1121,
      1654,
      1664
    ],
    "mapmatrixmodule_comp": [
      529,
      532,
      1119,
      1120,
      1121,
      1664
    ],
    "mapmodule": [
      530,
      531,
      1662,
      1663
    ],
    "lift_fac": [
      533
    ],
    "isopenimmersion": [
      533,
      823,
      824
    ],
    "oflex": [
      534,
      535,
      537,
      1672
    ],
    "uniqueprod": [
      534,
      535,
      537,
      1672
    ],
    "unique": [
      534,
      535,
      537,
      1672
    ],
    "uniqueprod_apply": [
      534,
      535,
      537,
      1672
    ],
    "sumlexdualantidistrib": [
      536,
      1671
    ],
    "todual": [
      536,
      1671
    ],
    "vertexcovernum_mono": [
      538,
      1673
    ],
    "vertexcovernum_le_vertexcovernum_of_injective": [
      538,
      1673
    ],
    "ofle": [
      538,
      1673
    ],
    "vertexcovernum": [
      538,
      1673
    ],
    "injective_id": [
      538,
      1673
    ],
    "derivweierstrassp": [
      539,
      540,
      541,
      1122,
      1123,
      1674,
      1675
    ],
    "one_apply_of_ne_zero": [
      542
    ],
    "hx0": [
      542,
      1715
    ],
    "isbipartite": [
      543,
      544,
      545,
      546,
      547,
      1124,
      1678,
      1679,
      1680,
      1681,
      1682,
      1684
    ],
    "reciprocalfactors_odd": [
      548,
      1125
    ],
    "reciprocalfactors": [
      548,
      1125
    ],
    "not_even_iff_odd": [
      548,
      1125
    ],
    "dif_neg": [
      548,
      1125
    ],
    "if_neg": [
      548,
      1125
    ],
    "rightinverse": [
      549,
      550
    ],
    "mulactionhom": [
      549,
      550
    ],
    "comptriple": [
      549,
      550
    ],
    "leftinverse": [
      549,
      550
    ],
    "comp_inv": [
      549,
      550
    ],
    "_comp": [
      550
    ],
    "enatmap": [
      554
    ],
    "toaddmonoidhom": [
      554
    ],
    "monoidwithzerohom": [
      554
    ],
    "tomonoidwithzerohom": [
      554
    ],
    "coplanar_triple": [
      555,
      556
    ],
    "coplanar": [
      555,
      556
    ],
    "coplanar_insert": [
      555,
      556
    ],
    "collinear_pair": [
      555,
      556
    ],
    "divisionring": [
      557,
      558,
      560
    ],
    "affinespace": [
      557,
      558,
      560
    ],
    "independent": [
      559,
      1126,
      1858
    ],
    "affineindependent": [
      559,
      1126
    ],
    "community": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131,
      1292,
      1297,
      1302,
      1307,
      1312,
      1320,
      1334,
      1335
    ],
    "com": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131,
      1290,
      1295,
      1300,
      1305,
      1310
    ],
    "https": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131,
      1290,
      1295,
      1300,
      1305,
      1310,
      1457,
      1458,
      1889
    ],
    "add_apply": [
      561,
      563,
      564,
      1128,
      1130,
      1131,
      1228,
      1892
    ],
    "too": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131
    ],
    "pull": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131
    ],
    "skeleton": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131
    ],
    "github": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131,
      1290,
      1295,
      1300,
      1305,
      1310,
      1320,
      1321,
      1334,
      1335,
      1457,
      1458,
      1806,
      1807,
      1809,
      1810
    ],
    "issuecomment": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131
    ],
    "leanprover": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131,
      1292,
      1297,
      1302,
      1307,
      1312,
      1320,
      1334,
      1335
    ],
    "define": [
      561,
      562,
      563,
      1128,
      1129,
      1130,
      1693,
      1852,
      1853
    ],
    "supset": [
      561,
      562,
      563,
      564,
      1128,
      1129,
      1130,
      1131
    ],
    "nonarchaddgroupseminorm": [
      562,
      1129
    ],
    "groupseminorm": [
      564,
      1131
    ],
    "natdegree_sum_le": [
      565,
      1132
    ],
    "natdegree": [
      565,
      1132
    ],
    "fold_max_le": [
      565,
      1132
    ],
    "le_trans": [
      565,
      1132
    ],
    "not_lt": [
      566,
      1419
    ],
    "trans_lt": [
      566,
      1700
    ],
    "tauto": [
      566
    ],
    "exists_and_left": [
      566
    ],
    "le_of_dvd": [
      566
    ],
    "exists_congr": [
      566
    ],
    "pos_of_ne_zero": [
      566,
      1542,
      1543,
      1544
    ],
    "nonempty_iff_ne_empty": [
      567
    ],
    "exists_countable_basis": [
      567
    ],
    "secondcountabletopology": [
      567,
      1885
    ],
    "countable_image_lt_image_ioi": [
      567
    ],
    "eq_empty_or_nonempty": [
      567,
      1586
    ],
    "instiscountablygenerated_attop": [
      567
    ],
    "istop": [
      567
    ],
    "b_ne": [
      567
    ],
    "ici": [
      567,
      1009
    ],
    "isindepset_iff": [
      568,
      1703
    ],
    "isindepset": [
      568,
      1703
    ],
    "intervalintegral": [
      572,
      573,
      574,
      1134,
      1135,
      1136,
      1705
    ],
    "integral_congr_codiscretewithin": [
      572,
      573,
      1134,
      1135,
      1705
    ],
    "interval_average_eq": [
      572,
      573,
      1134,
      1135,
      1705
    ],
    "codiscretewithin": [
      572,
      573,
      574,
      1134,
      1135,
      1136,
      1676,
      1705
    ],
    "intervalaverage_congr_codiscretewithin": [
      572,
      573,
      1134,
      1135,
      1705
    ],
    "interval_average_symm": [
      574,
      1136
    ],
    "ioo_subset_icc_self": [
      574,
      1136
    ],
    "mem_ioo": [
      574,
      1136,
      1582,
      1583
    ],
    "notmem_singleton_iff": [
      574,
      1136
    ],
    "integrableon_uicc": [
      574,
      1136
    ],
    "hc2_mem": [
      574,
      1136
    ],
    "uioc_of_le": [
      574,
      1136
    ],
    "h_ave": [
      574,
      1136
    ],
    "volume": [
      574,
      1136
    ],
    "alias": [
      575,
      617,
      625,
      675,
      715,
      719,
      720,
      1220,
      1221,
      1468,
      1542,
      1546,
      1547,
      1576,
      1595,
      1735,
      1736,
      1743,
      1744,
      1745,
      1819
    ],
    "mulvec_stdbasismatrix": [
      575
    ],
    "since": [
      575,
      625,
      675,
      715,
      1291,
      1296,
      1301,
      1306,
      1311,
      1468,
      1546,
      1547,
      1572,
      1622,
      1743,
      1744,
      1745
    ],
    "single_mulvec": [
      575
    ],
    "deprecated": [
      575,
      625,
      675,
      715,
      1546,
      1743,
      1744,
      1745
    ],
    "assoc": [
      576,
      821,
      822,
      841,
      1273,
      1274,
      1685,
      1706,
      1707,
      1879,
      1880
    ],
    "mapderivedcategory": [
      576,
      1706,
      1707
    ],
    "comp_id": [
      576,
      841,
      1706,
      1707
    ],
    "inv_hom_id_app": [
      576,
      841,
      1706,
      1707
    ],
    "istriangulated": [
      576,
      1706,
      1707
    ],
    "id_comp": [
      576,
      839,
      1706,
      1707
    ],
    "mapderivedcategoryfactorsh_hom_app": [
      576,
      1706,
      1707
    ],
    "comp_obj": [
      576,
      1706,
      1707,
      1879
    ],
    "mapderivedcategoryfactorsh": [
      576,
      1706,
      1707
    ],
    "map_comp_assoc": [
      576,
      840,
      1706,
      1707
    ],
    "istriangulated_of_precomp_iso": [
      576,
      1706,
      1707
    ],
    "ite_mem": [
      579
    ],
    "negonepow_sub": [
      580,
      581,
      812,
      813,
      814,
      815,
      1870
    ],
    "comp_continuouson": [
      584,
      585,
      586,
      1140,
      1141,
      1142
    ],
    "continuous_sum_dom": [
      584,
      585,
      586,
      1140,
      1141,
      1142
    ],
    "continuouson_untopa": [
      584,
      585,
      586,
      1140,
      1141,
      1142
    ],
    "contradiction": [
      587,
      588,
      589,
      590,
      591,
      592,
      1143,
      1144,
      1708,
      1709,
      1710
    ],
    "coeff_apply": [
      587,
      588,
      589,
      590,
      591,
      592,
      1143,
      1144,
      1708,
      1709,
      1710
    ],
    "coeff_expand_smul": [
      587,
      588,
      589,
      590,
      591,
      592,
      1143,
      1144,
      1708,
      1709,
      1710
    ],
    "transpose": [
      593,
      594,
      595,
      1145,
      1146,
      1332,
      1716
    ],
    "tosubmodule_eq_top": [
      596,
      597,
      1147
    ],
    "tosubmodule": [
      596,
      597,
      1147
    ],
    "top_tosubmodule": [
      596,
      597,
      1147
    ],
    "tononunitalsubsemiring_eq_top": [
      596,
      597,
      1147
    ],
    "top_tononunitalsubsemiring": [
      596,
      597,
      1147
    ],
    "tononunitalsubsemiring": [
      596,
      597,
      1147
    ],
    "nonunitalsubalgebra": [
      596,
      597,
      1147
    ],
    "tononunitalsubsemiring_injective": [
      596,
      597,
      1147
    ],
    "to_subring_eq_top": [
      596
    ],
    "tononunitalsubring": [
      596,
      597,
      1147
    ],
    "mul_cast_floor_div_cancel_of_pos": [
      598,
      1148
    ],
    "mul_natcast_floor_div_cancel": [
      598,
      1148
    ],
    "protected": [
      599,
      701,
      904,
      905,
      952,
      1213,
      1357,
      1358,
      1436,
      1601,
      1775
    ],
    "preconnected": [
      599,
      753,
      754,
      755,
      1236
    ],
    "istree_of_minimal_connected": [
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      1149,
      1150,
      1151,
      1152,
      1153,
      1718,
      1719
    ],
    "hmin": [
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      1149,
      1150,
      1151,
      1152,
      1153,
      1718,
      1719
    ],
    "exists_le_minimal": [
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      1149,
      1150,
      1151,
      1152,
      1153,
      1718,
      1719
    ],
    "connected": [
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      754,
      755,
      1149,
      1150,
      1151,
      1152,
      1153,
      1232,
      1236,
      1718,
      1719
    ],
    "htg": [
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      1149,
      1150,
      1151,
      1152,
      1153,
      1718,
      1719
    ],
    "tofinite": [
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      1149,
      1150,
      1151,
      1152,
      1153,
      1718,
      1719
    ],
    "withzeromulint": [
      609,
      1154,
      1724
    ],
    "support_mul_subset": [
      610,
      618,
      619,
      1737
    ],
    "mk_le_mk_of_subset": [
      610,
      618,
      619,
      1737
    ],
    "cardsupp": [
      610,
      618,
      619,
      1737
    ],
    "mk_add_le": [
      610,
      618,
      619,
      1737
    ],
    "nthroots_one_eq_biunion_primitiveroots": [
      611,
      1729,
      1730,
      1731
    ],
    "hin": [
      612,
      613,
      1155
    ],
    "order_mul_of_nonzero": [
      614
    ],
    "leadingcoeff_eq": [
      614
    ],
    "leadingcoeff": [
      614
    ],
    "coeff_mul_order_add_order": [
      614
    ],
    "perm": [
      616,
      1158,
      1159,
      1160
    ],
    "range_eq_ker": [
      617,
      1735,
      1736
    ],
    "ker_eq_range": [
      617,
      1736
    ],
    "isidempotentelem": [
      617,
      1735,
      1736,
      1760
    ],
    "one_sub_mul_self": [
      617,
      1735,
      1736
    ],
    "sub_eq_zero": [
      617,
      1735,
      1736
    ],
    "range_le_ker_iff": [
      617,
      1735,
      1736
    ],
    "inv_hom_id_tonattrans_app": [
      620,
      621
    ],
    "cat": [
      620,
      621,
      836,
      841,
      842,
      1890,
      1891
    ],
    "hom_self": [
      620,
      621
    ],
    "funext": [
      622,
      623,
      1162,
      1196,
      1582,
      1583
    ],
    "deriv_comp_add_const": [
      622,
      623,
      1162
    ],
    "iterated": [
      622,
      623,
      1162
    ],
    "iteratedderiv_succ": [
      622,
      623,
      1162
    ],
    "right": [
      622,
      623,
      843,
      1133,
      1162,
      1238,
      1526,
      1878
    ],
    "iteratedderiv_comp_const_add": [
      622,
      623,
      1162
    ],
    "normedaddcommgroup": [
      622,
      623,
      714,
      1162,
      1565
    ],
    "constant": [
      622,
      623,
      1162,
      1569
    ],
    "derivative": [
      622,
      623,
      1162,
      1694
    ],
    "shift_invariance": [
      622,
      623,
      1162
    ],
    "induction": [
      622,
      623,
      740,
      904,
      905,
      1162,
      1357,
      1358
    ],
    "iteratedderiv_comp_add_const": [
      622,
      623,
      1162
    ],
    "orthonormalbasis": [
      624,
      626,
      627,
      628,
      629,
      1742
    ],
    "iscompl": [
      625,
      1743
    ],
    "linearprojofiscompl_eq_self_iff": [
      625,
      1743
    ],
    "projection_eq_self_iff": [
      625,
      1743
    ],
    "smul_sub": [
      630,
      1163
    ],
    "smul_add": [
      630,
      1163
    ],
    "bracket_oftwococycle": [
      630,
      1163
    ],
    "neg_add_rev": [
      631,
      632
    ],
    "abel_nf": [
      631,
      632
    ],
    "sub_add_cancel_right": [
      631,
      632
    ],
    "push_cast": [
      636
    ],
    "ring_nf": [
      636,
      748,
      1835,
      1837,
      1838
    ],
    "linear_combination": [
      636
    ],
    "intrinsicstar_map": [
      638,
      1748
    ],
    "rtensor": [
      638,
      1748
    ],
    "tensorproduct": [
      638,
      991,
      1486,
      1489,
      1505,
      1720,
      1721,
      1748
    ],
    "intrinsicstar_rtensor": [
      638,
      1748
    ],
    "lt_trichotomy": [
      639,
      640,
      1168,
      1169
    ],
    "injective_of_lt_imp_ne": [
      639,
      640,
      1168,
      1169
    ],
    "subset_closure": [
      641,
      1170,
      1171
    ],
    "closure_pow_le": [
      641,
      1170,
      1171
    ],
    "le_isup_of_le": [
      642,
      643,
      644,
      1172
    ],
    "trans_eq": [
      642,
      643,
      644,
      1172
    ],
    "packingnumber_le_encard_self": [
      642,
      643,
      644,
      1172
    ],
    "edist_comm": [
      645,
      646,
      647,
      1173
    ],
    "stdpart": [
      648,
      649,
      1571,
      1781
    ],
    "orderringhom": [
      648,
      649
    ],
    "comp_assoc": [
      648,
      649,
      775,
      991,
      1247,
      1489
    ],
    "apply_eq_self": [
      648,
      649
    ],
    "inverse_one": [
      650,
      651,
      652,
      653,
      1175,
      1176
    ],
    "ringinverse_eq_inverse": [
      650,
      651,
      652,
      653,
      1175,
      1176
    ],
    "injective_add_left_of_ne_top": [
      655
    ],
    "strictmono_add_left_of_ne_top": [
      655
    ],
    "ne_top": [
      655
    ],
    "neg_add_cancel_of_ne_top": [
      655
    ],
    "injective_add_right_of_ne_top": [
      655
    ],
    "strictmono_add_right_of_ne_top": [
      655
    ],
    "add_const": [
      655
    ],
    "left_neg_eq_right_neg": [
      655
    ],
    "or_iff_not_imp_right": [
      655
    ],
    "isnoetherianring_iff_ideal_fg": [
      656,
      1761
    ],
    "isnoetherian_def": [
      656,
      1761
    ],
    "isnoetherianring_iff": [
      656,
      1761
    ],
    "isnoetherianring": [
      656,
      1761
    ],
    "mk_eq": [
      657
    ],
    "localizedmodule": [
      657
    ],
    "setoid": [
      657
    ],
    "subset": [
      657,
      1238
    ],
    "localize": [
      657
    ],
    "hasnatsmul": [
      658,
      1178
    ],
    "mul_smul_comm": [
      658,
      1178
    ],
    "terms": [
      658,
      1178,
      1241
    ],
    "mul_right_comm": [
      658,
      1178
    ],
    "lifton": [
      658,
      1178
    ],
    "zero_mk": [
      658,
      1178
    ],
    "neg_add_cancel": [
      658,
      1178
    ],
    "addhom": [
      659
    ],
    "algebramap_matrix_apply": [
      659
    ],
    "split_ifs": [
      659
    ],
    "shortcomplex": [
      660,
      1762,
      1763
    ],
    "ab_exact_iff": [
      660,
      1762,
      1763
    ],
    "mem_setof_eq": [
      661,
      707,
      1179
    ],
    "mem_inter_iff": [
      661,
      1179
    ],
    "upperhalfplane": [
      661,
      1179
    ],
    "coe_mem_integercomplement": [
      661,
      1179
    ],
    "and_iff_left_iff_imp": [
      661,
      1179
    ],
    "neg_nonpos": [
      663,
      1181
    ],
    "cofinite": [
      663,
      664,
      1181,
      1182,
      1764
    ],
    "islittleo_const_left": [
      663,
      664,
      1181,
      1182,
      1764
    ],
    "tendsto_norm_comp_cofinite_attop_of_isclosedembedding": [
      663,
      664,
      1181,
      1182,
      1764
    ],
    "rpow_le_rpow_of_nonpos": [
      663,
      1181
    ],
    "isclosedembedding_coe_real": [
      663,
      664,
      1181,
      1182,
      1764
    ],
    "add_istheta": [
      663,
      1181
    ],
    "linear_istheta_right": [
      663,
      664,
      1181,
      1182,
      1764
    ],
    "islittleo": [
      663,
      1181,
      1450
    ],
    "r_pos": [
      663,
      1181
    ],
    "r_lower_bound_on_verticalstrip": [
      663,
      1181
    ],
    "asymptotics": [
      663,
      1181,
      1450
    ],
    "cast_complex_istheta_cast_real": [
      663,
      1181
    ],
    "isbigo": [
      664,
      1182,
      1450,
      1764
    ],
    "cast_eq_zero": [
      664,
      1182,
      1764
    ],
    "linear_inv_isbigo_left": [
      664,
      1182,
      1764
    ],
    "or_true": [
      664,
      1182,
      1764
    ],
    "linear_istheta_left": [
      664,
      1182,
      1764
    ],
    "linear_inv_isbigo_right": [
      664,
      666,
      667,
      668,
      669,
      670,
      1182,
      1183,
      1184,
      1185,
      1186,
      1187,
      1764,
      1765
    ],
    "pow_two": [
      665,
      666,
      667,
      668,
      669,
      670,
      1183,
      1184,
      1185,
      1186,
      1187,
      1765
    ],
    "abs_mul_abs_self": [
      665,
      666,
      667,
      668,
      669,
      670,
      1183,
      1184,
      1185,
      1186,
      1187,
      1765
    ],
    "summable": [
      665,
      666,
      667,
      668,
      669,
      670,
      1183,
      1184,
      1185,
      1186,
      1187,
      1765
    ],
    "summable_inv_of_isbigo_rpow_inv": [
      665,
      666,
      667,
      668,
      669,
      670,
      1183,
      1184,
      1185,
      1186,
      1187,
      1765
    ],
    "rpow_two": [
      665,
      666,
      667,
      668,
      669,
      670,
      1183,
      1184,
      1185,
      1186,
      1187,
      1765
    ],
    "sub_eq_add_neg": [
      666,
      667,
      668,
      669,
      670,
      1183,
      1184,
      1185,
      1186,
      1187,
      1765
    ],
    "comp_neg_int": [
      666,
      667,
      668,
      669,
      670,
      1183,
      1184,
      1185,
      1186,
      1187,
      1765
    ],
    "modular_t_zpow_smul": [
      671
    ],
    "vadd_width_periodic": [
      671
    ],
    "h00": [
      672,
      673,
      674,
      1188,
      1189,
      1190
    ],
    "pow_mul": [
      672,
      673,
      674,
      1188,
      1189,
      1190,
      1690
    ],
    "pnat_multipliable_iff_multipliable_succ": [
      675
    ],
    "multipliable_pnat_iff_multipliable_succ": [
      675,
      676,
      1191
    ],
    "multipliable": [
      676,
      1191
    ],
    "multipliable_nat_add_iff": [
      676,
      1191
    ],
    "tsum_int_eq_zero_add_two_mul_tsum_pnat": [
      676,
      1191
    ],
    "isuniformgroup": [
      676,
      1191
    ],
    "multipliable_int_iff_multipliable_nat_and_neg": [
      676,
      1191
    ],
    "hf4": [
      676,
      1191
    ],
    "cast_zero": [
      676,
      1191
    ],
    "tprod_zero_pnat_eq_tprod_nat": [
      676,
      1191
    ],
    "hf3": [
      676,
      1191
    ],
    "mul_right_inj": [
      676,
      1191
    ],
    "tprod_pnat_eq_tprod_succ": [
      676,
      1191
    ],
    "t2space": [
      676,
      1191
    ],
    "vonmangoldt_apply_prime": [
      677,
      679,
      680,
      681,
      682,
      683,
      684,
      685,
      686,
      1193,
      1194,
      1195,
      1198,
      1199,
      1200,
      1201,
      1202,
      1203,
      1204,
      1205,
      1206,
      1769,
      1770,
      1771
    ],
    "floor_natcast": [
      678,
      721,
      1197
    ],
    "hf_int": [
      678,
      1197
    ],
    "hf_diff": [
      678,
      1197
    ],
    "hasprod": [
      687,
      1773
    ],
    "tprod_eq": [
      687,
      1773
    ],
    "hasprod_one_add_of_hassum_prod": [
      687,
      1773
    ],
    "hassum": [
      687,
      1773
    ],
    "le_cisup": [
      688
    ],
    "bddabove_range": [
      688
    ],
    "colex": [
      689
    ],
    "aleph0_le": [
      690,
      1207
    ],
    "sup": [
      690,
      912,
      1207,
      1336
    ],
    "isregular": [
      690,
      1207
    ],
    "ofarrows": [
      692,
      1209,
      1774
    ],
    "introv": [
      693,
      694,
      698,
      1210,
      1211
    ],
    "finitepresentation_respectsiso": [
      693,
      1210
    ],
    "smul_def": [
      693,
      694,
      698,
      1210,
      1211,
      1691
    ],
    "isstableunderbasechange": [
      693,
      694,
      698,
      1210,
      1211
    ],
    "finitepresentation_algebramap": [
      693,
      1210
    ],
    "ringhom": [
      693,
      694,
      698,
      1210,
      1211,
      1228,
      1768
    ],
    "finitepresentation": [
      693,
      1210
    ],
    "finite_respectsiso": [
      694,
      698,
      1211
    ],
    "finite_isstableunderbasechange": [
      694,
      698,
      1211
    ],
    "replace": [
      694,
      698,
      1211
    ],
    "fundamentaldomain_reindex": [
      695,
      696,
      697,
      1212
    ],
    "fundamentaldomain": [
      695,
      696,
      697,
      1212
    ],
    "forall_congr": [
      695,
      696,
      697,
      783,
      1212,
      1252
    ],
    "mem_fundamentaldomain": [
      695,
      696,
      697,
      1212
    ],
    "repr_reindex_apply": [
      695,
      696,
      697,
      1212
    ],
    "mk_neg": [
      699,
      700,
      701,
      1213,
      1779,
      1780
    ],
    "finiteelement": [
      699,
      700,
      701,
      1213,
      1779,
      1780,
      1781
    ],
    "ge_iff_eq": [
      700
    ],
    "lt_iff_not_ge": [
      700
    ],
    "isunit_iff_mk_eq_zero": [
      700
    ],
    "not_iff_not": [
      700
    ],
    "not_isunit_iff_valuation_lt_one": [
      700
    ],
    "valuation": [
      700,
      1473,
      1474,
      1713,
      1714,
      1715,
      1727,
      1727
    ],
    "not_isunit_iff_mk_pos": [
      700
    ],
    "mk_zero": [
      701,
      1213
    ],
    "mk_one": [
      701,
      1213
    ],
    "constructor": [
      701,
      821,
      822,
      951,
      1213,
      1273,
      1274,
      1542,
      1543,
      1544,
      1550
    ],
    "mk_natcast": [
      701,
      1213
    ],
    "mk_intcast": [
      701,
      1213
    ],
    "factorization": [
      702,
      703,
      704,
      705,
      1782,
      1783,
      1784
    ],
    "ordproj_dvd": [
      702,
      703,
      704,
      705,
      1782,
      1783,
      1784
    ],
    "hqp": [
      702,
      703,
      704,
      705,
      1782,
      1783,
      1784
    ],
    "factorization_div": [
      702,
      703,
      704,
      705,
      1782,
      1783,
      1784
    ],
    "erase_ne": [
      702,
      703,
      704,
      705,
      1782,
      1783,
      1784
    ],
    "isglb": [
      706,
      1214,
      1215,
      1785,
      1786,
      1787,
      1788,
      1789,
      1790,
      1791,
      1792
    ],
    "islub_inter_iff": [
      706,
      1214,
      1215,
      1785,
      1786,
      1787,
      1788,
      1789,
      1790,
      1791,
      1792
    ],
    "ispwo_support": [
      707
    ],
    "vaddantidiagonal": [
      707
    ],
    "contdiff": [
      708,
      708,
      709,
      709,
      710,
      710,
      711,
      711,
      712,
      712,
      713,
      713,
      1216,
      1216,
      1217,
      1217,
      1218,
      1218,
      1219,
      1219,
      1793,
      1793,
      1794,
      1794,
      1795,
      1795,
      1796,
      1796,
      1797,
      1797,
      1798,
      1798,
      1820
    ],
    "dist": [
      708,
      709,
      710,
      711,
      712,
      713,
      722,
      723,
      724,
      1216,
      1217,
      1218,
      1219,
      1224,
      1225,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798
    ],
    "toeuclidean": [
      708,
      709,
      710,
      711,
      712,
      713,
      1216,
      1217,
      1218,
      1219,
      1793,
      1794,
      1795,
      1796,
      1797,
      1798
    ],
    "convex_closedball": [
      714
    ],
    "normedspace": [
      714,
      1565
    ],
    "closedball": [
      714
    ],
    "sep_univ": [
      714
    ],
    "convexon_univ_dist": [
      714
    ],
    "convex_le": [
      714
    ],
    "tospansingleton_apply_one": [
      715
    ],
    "tospansingleton_one": [
      715
    ],
    "instfourierpairinv": [
      716
    ],
    "fourier_fourierinv_eq": [
      716
    ],
    "fourierinvpair": [
      716
    ],
    "sheaftopresheaf": [
      717
    ],
    "yoneda": [
      717,
      1816
    ],
    "apply_symm_apply": [
      718,
      783,
      1252,
      1392
    ],
    "yonedaequiv": [
      718
    ],
    "yonedaequiv_comp": [
      718
    ],
    "pow_nthroot_le": [
      719,
      720,
      1220,
      1221,
      1819
    ],
    "pow_nthroot_le_iff": [
      719,
      720,
      1220,
      1221,
      1819
    ],
    "add_mul_div_left": [
      721
    ],
    "currently": [
      721
    ],
    "lt_pow_go_succ_aux": [
      721
    ],
    "try": [
      721,
      771
    ],
    "increases": [
      721
    ],
    "eq_zero_or_pos": [
      721
    ],
    "relies": [
      721
    ],
    "elementary": [
      721
    ],
    "estimate": [
      721
    ],
    "floor_div_natcast": [
      721
    ],
    "continuous_id": [
      722,
      723,
      724,
      919,
      1224,
      1225,
      1382,
      1383
    ],
    "measurable_of_countable": [
      725,
      1226
    ],
    "mem_compl_iff": [
      725,
      1226
    ],
    "heval": [
      726
    ],
    "gcd_comm": [
      727,
      728
    ],
    "totient_eq_card_lt_and_coprime": [
      727,
      728
    ],
    "iscoveringmap": [
      729,
      729
    ],
    "bundle": [
      729
    ],
    "isfiberbundle": [
      729
    ],
    "trivializationat": [
      729
    ],
    "fiberbundle": [
      729
    ],
    "mem_baseset_trivializationat": [
      729
    ],
    "totalspace": [
      729
    ],
    "discretetopology": [
      729,
      1676,
      1677
    ],
    "mul_subset_mul": [
      730
    ],
    "loir": [
      731
    ],
    "released": [
      731
    ],
    "chambert": [
      731
    ],
    "described": [
      731
    ],
    "antoine": [
      731
    ],
    "free": [
      734,
      734,
      735,
      735,
      736,
      736,
      1229,
      1229
    ],
    "basis_repr_comp_apply": [
      734,
      735,
      736,
      1229
    ],
    "isbasechange": [
      734,
      735,
      736,
      1229
    ],
    "include": [
      734,
      735,
      736,
      1229
    ],
    "choosebasis": [
      734,
      735,
      736,
      1229
    ],
    "of_basis": [
      734,
      735,
      736,
      1229
    ],
    "ibc": [
      734,
      735,
      736,
      1229
    ],
    "generallinearequiv": [
      737,
      738
    ],
    "tomonoidhom": [
      737,
      738,
      1875
    ],
    "speciallineargroup": [
      737,
      738
    ],
    "togenerallineargroup": [
      737,
      738
    ],
    "tolinearequiv": [
      737,
      738,
      1822
    ],
    "togenerallineargroup_tolinearequiv_apply": [
      737,
      738
    ],
    "coe_togenerallineargroup_apply": [
      738
    ],
    "omega0": [
      739
    ],
    "typelt": [
      739
    ],
    "order": [
      739,
      1543,
      1544,
      1689
    ],
    "defined": [
      739,
      1245,
      1509,
      1818
    ],
    "zpow_add": [
      740
    ],
    "one_smul": [
      740,
      1564
    ],
    "prop_red_t": [
      740
    ],
    "zpow_zero": [
      740
    ],
    "zpow_one": [
      740
    ],
    "smul_assoc": [
      740,
      1836
    ],
    "monic": [
      741,
      742,
      743,
      1231
    ],
    "hp1": [
      741,
      742,
      743,
      1231
    ],
    "prime_of_degree_eq_one": [
      741,
      742,
      743,
      1231
    ],
    "irreducible_of_degree_eq_one": [
      741,
      742,
      743,
      1231
    ],
    "exp_injective": [
      744
    ],
    "exp_log": [
      744,
      1604
    ],
    "log_exp": [
      744
    ],
    "exp_pos": [
      744
    ],
    "hpn": [
      747,
      1833
    ],
    "zmod": [
      747,
      1833
    ],
    "pow_card_sub_one_eq_one": [
      747,
      1833
    ],
    "intcast_eq_intcast_iff": [
      747,
      1833
    ],
    "grw": [
      748,
      772,
      1244,
      1835,
      1837,
      1838
    ],
    "angle_le_angle_add_angle_of_norm_eq_one": [
      749,
      1234
    ],
    "norm_normalize_eq_one_iff": [
      749,
      1234
    ],
    "pow_toend_f_eq_zero_of_eq_nat": [
      750,
      1235
    ],
    "hasprimitivevectorwith": [
      750,
      1841
    ],
    "isnoetherian": [
      750,
      1235,
      1858
    ],
    "nozerosmuldivisors": [
      750,
      1235,
      1245
    ],
    "by_contra": [
      750,
      1859
    ],
    "charzero": [
      750,
      1235
    ],
    "shrinkhoms": [
      751,
      752,
      1843
    ],
    "equivalence": [
      751,
      752,
      1245,
      1246,
      1843,
      1848,
      1893
    ],
    "pres": [
      751,
      752,
      1843
    ],
    "walk": [
      753,
      1746
    ],
    "hconn": [
      753
    ],
    "set_univ_walk_nonempty": [
      753
    ],
    "connected_sup": [
      754,
      755,
      1236
    ],
    "subgraph": [
      754,
      755,
      1236
    ],
    "nonneg_of_mul_nonneg_left": [
      756,
      1237
    ],
    "dist_pos": [
      756,
      1237
    ],
    "dist_nonneg": [
      756,
      1237,
      1585,
      1586
    ],
    "mul_nonneg": [
      756,
      1237,
      1836
    ],
    "vsub_eq_zero_iff_eq": [
      757,
      758,
      759
    ],
    "vsub_sub_vsub_cancel_right": [
      757,
      758,
      759
    ],
    "angle_add_angle_sub_add_angle_sub_eq_pi": [
      757,
      758,
      759
    ],
    "sub_val_lt_sub": [
      760,
      761,
      762,
      1845,
      1846
    ],
    "castlt": [
      760,
      761,
      762,
      1845,
      1846
    ],
    "sub_lt_sub_right": [
      760,
      761,
      762,
      1845,
      1846
    ],
    "sub_val_of_le": [
      760,
      761,
      762,
      1845,
      1846
    ],
    "castlt_sub_nezero": [
      760,
      761,
      762,
      1845,
      1846
    ],
    "nezero_iff": [
      760,
      1845
    ],
    "islt": [
      760,
      1845
    ],
    "leti": [
      760,
      825,
      1845,
      1859,
      1876
    ],
    "ne_of_val_ne": [
      760,
      1845
    ],
    "zero_le": [
      761,
      762,
      1700,
      1846
    ],
    "le_iff_val_le_val": [
      761,
      762,
      1846
    ],
    "val_one": [
      761,
      762,
      1846
    ],
    "mod_eq_of_lt": [
      763,
      764,
      766,
      1390
    ],
    "converting": [
      763,
      764,
      766
    ],
    "val_cast_of_lt": [
      763,
      764,
      766
    ],
    "same": [
      763,
      764,
      766,
      1860
    ],
    "cast_val_eq_self": [
      763,
      764,
      766
    ],
    "non": [
      763,
      764,
      766,
      1043,
      1044,
      1045,
      1510
    ],
    "ofnat": [
      765,
      1436
    ],
    "val_add_one_of_lt": [
      765
    ],
    "northcott": [
      767,
      1240
    ],
    "c_0": [
      768,
      769,
      1242,
      1243,
      1847
    ],
    "iscoprime_zero_right": [
      768,
      769,
      1242,
      1243,
      1847
    ],
    "not_isunit_x_pow_sub_one": [
      768,
      769,
      1242,
      1243,
      1847
    ],
    "charp": [
      770
    ],
    "separable_x_pow_sub_c": [
      770
    ],
    "cast_eq_zero_iff": [
      770
    ],
    "separable": [
      770
    ],
    "shorten": [
      771
    ],
    "behavior": [
      771
    ],
    "declarations": [
      771,
      1622
    ],
    "causes": [
      771,
      1894
    ],
    "elementwise": [
      771
    ],
    "both": [
      771,
      1412,
      1413,
      1760
    ],
    "twice": [
      771
    ],
    "issues": [
      771
    ],
    "norm_indicator_eq_indicator_norm": [
      772,
      1244
    ],
    "ennreal": [
      773,
      1411,
      1447,
      1448,
      1527,
      1861,
      1888
    ],
    "tendstoinmeasure": [
      773
    ],
    "mono_left": [
      773
    ],
    "edist": [
      773,
      1629
    ],
    "hns": [
      773
    ],
    "zero_ne_top": [
      773
    ],
    "tendsto_tonnreal_iff": [
      773
    ],
    "inf_iinf_nat_succ": [
      776,
      1248
    ],
    "iunion_le_nat": [
      776,
      1248
    ],
    "subset_antisymm": [
      776,
      1248
    ],
    "subset_univ": [
      776,
      1248
    ],
    "mem_iunion_of_mem": [
      776,
      1248
    ],
    "exactat": [
      777
    ],
    "exactat_of_issupported": [
      777
    ],
    "inducedtopology": [
      780
    ],
    "preservessheafification": [
      780
    ],
    "transport": [
      780
    ],
    "equivsmallmodel": [
      780
    ],
    "of_forall": [
      781,
      1251,
      1459
    ],
    "limsup_le_of_le": [
      781,
      1251
    ],
    "specialize": [
      781,
      1251
    ],
    "real_def": [
      781,
      1251
    ],
    "measure": [
      781,
      860,
      861,
      1022,
      1250,
      1251,
      1287,
      1447,
      1448,
      1629,
      1861
    ],
    "iscoboundedunder_le_of_le": [
      781,
      1251
    ],
    "limsup": [
      781,
      1251
    ],
    "eq_or_nebot": [
      781,
      1251
    ],
    "hne": [
      781,
      1251,
      1690,
      1702
    ],
    "prob_le_one": [
      781,
      1251
    ],
    "compprod_apply": [
      782
    ],
    "condkernel": [
      782
    ],
    "lintegral_indicator": [
      782
    ],
    "preimage": [
      782,
      871
    ],
    "kernel": [
      782,
      1416,
      1667,
      1668,
      1669,
      1670
    ],
    "disintegrate": [
      782
    ],
    "picongrleft_apply_apply": [
      783,
      1252
    ],
    "pi_pi": [
      783,
      1252
    ],
    "measurableequiv": [
      783,
      1252
    ],
    "prod_equiv": [
      783,
      1252
    ],
    "erw": [
      784
    ],
    "restr": [
      784
    ],
    "multilinearmap": [
      784
    ],
    "map_update_smul": [
      784
    ],
    "map_update_add": [
      784
    ],
    "toequiv": [
      784
    ],
    "dite_comp_equiv_update": [
      784
    ],
    "eq_of_fin_equiv": [
      785
    ],
    "le_of_fin_surjective": [
      785
    ],
    "dualdistrib": [
      786
    ],
    "istightmeasureset": [
      787,
      788,
      789,
      790,
      791,
      792,
      793,
      794,
      795,
      796,
      797,
      798,
      1253,
      1254,
      1255,
      1256,
      1257,
      1258,
      1259,
      1260,
      1862
    ],
    "subset_preimage_image": [
      789,
      790,
      791,
      792,
      793,
      794,
      795,
      796,
      797,
      798,
      1255,
      1256,
      1257,
      1258,
      1259,
      1260,
      1862
    ],
    "infixl": [
      799
    ],
    "cosh_arcosh": [
      800,
      801,
      802,
      1261,
      1262,
      1263
    ],
    "left_inv": [
      800,
      801,
      802,
      1261,
      1262,
      1263
    ],
    "arcosh_cosh": [
      800,
      801,
      802,
      1261,
      1262,
      1263
    ],
    "degree_add": [
      803,
      1864,
      1865
    ],
    "sum_add_index": [
      803,
      1864,
      1865
    ],
    "congrfun": [
      803,
      1864,
      1865
    ],
    "sum_subset": [
      804
    ],
    "degree_eq_sum": [
      804
    ],
    "zero_apply": [
      805,
      1435
    ],
    "ishomogeneous_c": [
      805
    ],
    "sum_const_zero": [
      805
    ],
    "ishomogeneous": [
      805
    ],
    "ishomogeneous_monomial": [
      805
    ],
    "basis_pair_left": [
      816
    ],
    "sum_singleton": [
      816
    ],
    "notmem_singleton": [
      816
    ],
    "basis_pair_right": [
      816
    ],
    "sum_insert": [
      816
    ],
    "cocone": [
      820,
      1880
    ],
    "quotientgroup": [
      820,
      1383
    ],
    "coconequotientdiag": [
      820
    ],
    "action": [
      820,
      1443,
      1605,
      1875,
      1875
    ],
    "comp_map": [
      820,
      841,
      1880
    ],
    "quotientdiag_map": [
      820
    ],
    "quotientdiag_obj": [
      820
    ],
    "conv_rhs": [
      820
    ],
    "singleobj": [
      820
    ],
    "quotientdiag": [
      820
    ],
    "monoover": [
      821,
      822,
      1273,
      1274
    ],
    "propext": [
      821,
      822,
      1273,
      1274
    ],
    "gluediso": [
      823,
      824
    ],
    "togluedata": [
      823,
      824
    ],
    "forgettopresheafedspace": [
      823
    ],
    "topresheafedspacegluedata": [
      823
    ],
    "isopresheafedspace": [
      823
    ],
    "tosheafedspace": [
      824
    ],
    "isosheafedspace": [
      824
    ],
    "forgettosheafedspace": [
      824
    ],
    "delta": [
      824
    ],
    "glued": [
      824
    ],
    "tosheafedspacegluedata": [
      824
    ],
    "fac": [
      825,
      1876
    ],
    "limits": [
      825,
      826,
      827,
      1653,
      1772,
      1876
    ],
    "uniq": [
      825,
      826,
      827,
      1876
    ],
    "smallcategory": [
      825,
      827,
      1876
    ],
    "islimit": [
      825,
      826,
      827,
      1876,
      1877
    ],
    "limitcone": [
      825,
      826,
      827,
      1876
    ],
    "comphaus": [
      825,
      826,
      827,
      1876
    ],
    "mapcone": [
      825,
      826,
      827,
      1772,
      1876
    ],
    "comphaustotop": [
      825,
      1876
    ],
    "topcat": [
      825,
      828,
      1654,
      1656,
      1860,
      1876
    ],
    "limitconeislimit": [
      825,
      826,
      827,
      1876
    ],
    "lightprofinite": [
      826
    ],
    "lightprofinitetocomphaus": [
      826
    ],
    "profinitetocomphaus": [
      827
    ],
    "profinite": [
      827
    ],
    "forgettotop_full": [
      828
    ],
    "map_surjective": [
      828
    ],
    "faithful": [
      828,
      1443,
      1443,
      1816,
      1816
    ],
    "alexdisc": [
      828
    ],
    "generalize": [
      828
    ],
    "forgettotop_faithful": [
      828
    ],
    "full": [
      828,
      1443
    ],
    "inducedcategory": [
      828,
      1272,
      1272
    ],
    "subspace": [
      829,
      1688
    ],
    "toperfpair": [
      829
    ],
    "finrank_eq": [
      829
    ],
    "dual_finrank_eq": [
      829
    ],
    "finrank_corootspan_eq": [
      829
    ],
    "finrank_top": [
      829
    ],
    "usable": [
      830
    ],
    "framework": [
      830
    ],
    "nice": [
      830
    ],
    "future": [
      830
    ],
    "enriched": [
      830
    ],
    "became": [
      830
    ],
    "categories": [
      830
    ],
    "separating_f": [
      833,
      1276
    ],
    "metrizablespace": [
      833,
      1276
    ],
    "topinathomeo": [
      833,
      1276
    ],
    "continuous_f": [
      833,
      1276
    ],
    "compactspace": [
      833,
      846,
      1276,
      1279
    ],
    "pinatembed": [
      833,
      1276
    ],
    "nonassocring": [
      834
    ],
    "binomialring": [
      834
    ],
    "norm_pow": [
      835,
      1277
    ],
    "le_add_of_nonneg_left": [
      835,
      1277
    ],
    "add_pow_two": [
      835,
      1277
    ],
    "norm_norm": [
      835,
      1277
    ],
    "strictbicategory": [
      836
    ],
    "nattrans": [
      836,
      837,
      838,
      839,
      1880
    ],
    "largecategory": [
      836
    ],
    "binder": [
      837
    ],
    "morphisms": [
      837,
      838,
      1222,
      1778,
      1883
    ],
    "produce": [
      837
    ],
    "taking": [
      837,
      838
    ],
    "bicategory": [
      837,
      838
    ],
    "to_app": [
      837,
      838
    ],
    "new": [
      837,
      838,
      1512,
      1568
    ],
    "simplify": [
      837,
      1241
    ],
    "place": [
      837,
      838
    ],
    "named": [
      837,
      838
    ],
    "simptype": [
      837
    ],
    "id_app": [
      838
    ],
    "comp_app": [
      838
    ],
    "whiskerleft_app": [
      838
    ],
    "create": [
      838
    ],
    "eqtohom_app": [
      838
    ],
    "equality": [
      838,
      1728
    ],
    "adding": [
      838
    ],
    "rightunitor_eqtoiso": [
      839
    ],
    "mapcomp_id_right_inv_app": [
      839
    ],
    "naturality_assoc": [
      839
    ],
    "strict": [
      839,
      1727
    ],
    "strongtrans": [
      840,
      841
    ],
    "base": [
      840,
      841,
      1722
    ],
    "naturality": [
      840,
      841
    ],
    "naturality_id_hom_app": [
      840,
      841
    ],
    "fiber": [
      840
    ],
    "toloc": [
      840,
      841,
      1824,
      1825
    ],
    "dsimp": [
      840,
      1331,
      1879
    ],
    "naturality_comp_hom_app": [
      841
    ],
    "rightadj": [
      842
    ],
    "adjunction": [
      842
    ],
    "homequiv_naturality_left_symm": [
      842
    ],
    "mkofhomequiv": [
      842
    ],
    "homequiv": [
      842
    ],
    "curryingflipequiv": [
      842
    ],
    "homequiv_naturality_right": [
      842
    ],
    "comp_flip_uncurry_eq": [
      842
    ],
    "curry_obj_comp_flip": [
      842
    ],
    "analogous": [
      843
    ],
    "leftlim": [
      843
    ],
    "associates": [
      843
    ],
    "ofreal": [
      843,
      1527
    ],
    "giving": [
      843
    ],
    "measure_icc": [
      843
    ],
    "assertions": [
      843
    ],
    "measures": [
      843
    ],
    "asserts": [
      843
    ],
    "discrete": [
      844,
      1467,
      1468,
      1599,
      1600,
      1676,
      1896
    ],
    "countablecategorydiscreteofcountable": [
      844
    ],
    "countablecategory": [
      844
    ],
    "exists_eq_right": [
      845,
      1278
    ],
    "exists": [
      845,
      1278,
      1523,
      1818
    ],
    "sunion_eq_iunion": [
      845,
      1278
    ],
    "hts": [
      845,
      1278
    ],
    "exists_and_right": [
      845,
      1278
    ],
    "generatefrom": [
      845,
      1278
    ],
    "iscompact_generatefrom": [
      845,
      1278
    ],
    "cover": [
      845,
      1278,
      1412,
      1413
    ],
    "mem_image": [
      845,
      1278
    ],
    "le_nhds_lim": [
      846,
      1279
    ],
    "top_unique": [
      846,
      1279
    ],
    "nonrec": [
      846,
      956,
      1268,
      1279
    ],
    "iscompact_univ": [
      846,
      1279
    ],
    "clusterpt": [
      846,
      1279
    ],
    "elim_nhds_subcover": [
      846,
      1279
    ],
    "ultrafilter_le_nhds": [
      846,
      1279,
      1595
    ],
    "lim": [
      846,
      1279
    ],
    "ultrafilter": [
      846,
      1279
    ],
    "house": [
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282,
      1901
    ],
    "house_mul_le": [
      847,
      848,
      849,
      850,
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282,
      1901
    ],
    "cast_abs": [
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282,
      1799
    ],
    "intcast_def": [
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282
    ],
    "norm_intcast": [
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282
    ],
    "pi_norm_const": [
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282
    ],
    "house_intcast": [
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282
    ],
    "map_intcast": [
      851,
      852,
      853,
      854,
      855,
      1280,
      1281,
      1282
    ],
    "quadraticform": [
      856,
      857,
      858,
      1283,
      1284,
      1285,
      1902,
      1903
    ],
    "measuretheory": [
      860,
      861,
      1287,
      1599,
      1600,
      1629
    ],
    "length_append": [
      862,
      863,
      864,
      865,
      866
    ],
    "card_add": [
      862,
      863,
      864,
      865,
      866
    ],
    "multiset": [
      862,
      863,
      864,
      865,
      866
    ],
    "mapsto_image": [
      870
    ],
    "preimage_mono": [
      871,
      1563
    ],
    "interior_maximal": [
      871
    ],
    "isopen_interior": [
      871
    ],
    "interior_subset": [
      871,
      1886,
      1887
    ],
    "interior": [
      871
    ],
    "push": [
      888,
      1388,
      1568,
      1568,
      1569,
      1570,
      1834
    ],
    "arg": [
      889
    ],
    "morphism": [
      889,
      1222,
      1443
    ],
    "init": [
      889
    ],
    "mkappn": [
      889
    ],
    "bundled": [
      889,
      1890,
      1891
    ],
    "array": [
      889
    ],
    "foldl": [
      889
    ],
    "liesover_iff": [
      902
    ],
    "over_def": [
      902
    ],
    "eq_bot_of_comap_eq_bot": [
      902
    ],
    "eq_bot_of_liesover_bot": [
      902
    ],
    "ismaximal_comap_of_isintegral_of_ismaximal": [
      902
    ],
    "liesover": [
      902
    ],
    "sort": [
      904,
      905,
      1357,
      1358
    ],
    "elab_as_elim": [
      904,
      905,
      1357,
      1358
    ],
    "oflower": [
      904
    ],
    "cases_eliminator": [
      904,
      905,
      1357,
      1358
    ],
    "withlower": [
      904
    ],
    "recursor": [
      904,
      905,
      1357,
      1358
    ],
    "induction_eliminator": [
      904,
      905,
      1357,
      1358
    ],
    "tolower": [
      904,
      1659
    ],
    "withupper": [
      905
    ],
    "ofupper": [
      905
    ],
    "_eq_sup": [
      912
    ],
    "_eq_zero": [
      912
    ],
    "sub_pos": [
      917
    ],
    "continuousat_fst": [
      917
    ],
    "continuousat_snd": [
      917
    ],
    "mem_ioi": [
      919
    ],
    "posf": [
      919
    ],
    "continuouson": [
      919,
      919
    ],
    "aestronglymeasurable": [
      919,
      1624,
      1624
    ],
    "continuous_exp": [
      919
    ],
    "norm_of_nonneg": [
      919
    ],
    "continuousat_rpow_const": [
      919
    ],
    "continuouson_of_forall_continuousat": [
      919
    ],
    "measurableset_ioi": [
      919
    ],
    "posdef": [
      950
    ],
    "posdef_gram_of_linearindependent": [
      950
    ],
    "gram": [
      950
    ],
    "linearindependent_iff": [
      950
    ],
    "lt_of_ne": [
      950
    ],
    "linearindependent": [
      950
    ],
    "h_li": [
      950
    ],
    "possemidef_gram": [
      950
    ],
    "lapmatrix": [
      951
    ],
    "trivialstar": [
      951
    ],
    "possemidef_lapmatrix": [
      951
    ],
    "positive": [
      951
    ],
    "semidefinite": [
      951
    ],
    "laplacian": [
      951
    ],
    "starring": [
      951
    ],
    "ishermitian_zero": [
      952
    ],
    "conjtranspose": [
      952
    ],
    "mem_prod": [
      956
    ],
    "uniformcontinuous_const": [
      956
    ],
    "uniformcontinuous_of_const": [
      956
    ],
    "uniformcontinuous_def": [
      956
    ],
    "located": [
      956
    ],
    "uniformcontinuous_iff_eventually": [
      956
    ],
    "iterate": [
      956
    ],
    "inter_comm": [
      956,
      1881
    ],
    "matter": [
      956
    ],
    "close": [
      956
    ],
    "tohomeomorphoffinitedimensional": [
      961
    ],
    "forth": [
      991,
      1489
    ],
    "comm_comp_comul": [
      991,
      1489
    ],
    "back": [
      991,
      1489
    ],
    "map_comp_comm_eq": [
      991,
      1489
    ],
    "wouldn": [
      991,
      1489
    ],
    "iscocomm": [
      991,
      1489
    ],
    "need": [
      991,
      1489,
      1686
    ],
    "reassociate": [
      991,
      1489
    ],
    "comul_comp_lsingle": [
      991,
      1489
    ],
    "ici_top": [
      1009
    ],
    "ordertop": [
      1009
    ],
    "ismax_top": [
      1009
    ],
    "ici_eq": [
      1009
    ],
    "formula": [
      1019
    ],
    "typeof": [
      1019
    ],
    "realize": [
      1019
    ],
    "equivsentence": [
      1019
    ],
    "formula_mem_typeof": [
      1019
    ],
    "most": [
      1022,
      1402,
      1509
    ],
    "polynomials": [
      1022
    ],
    "cyclotomic_mahlermeasure_eq_one": [
      1022
    ],
    "bound": [
      1022
    ],
    "card_mahlermeasure_le_prod": [
      1022
    ],
    "cyclotomic": [
      1022
    ],
    "mahler": [
      1022
    ],
    "formallyetale": [
      1029
    ],
    "islocalizedmodule_iff_isbasechange": [
      1029
    ],
    "isbasechange_of_formallyetale": [
      1029
    ],
    "of_islocalization": [
      1029,
      1355
    ],
    "run": [
      1041,
      1512,
      1622,
      1657,
      1803,
      1803,
      1804,
      1804,
      1808,
      1813,
      1813,
      1814,
      1814
    ],
    "getlinteroptions": [
      1041
    ],
    "withsetoptionin": [
      1041
    ],
    "style": [
      1041,
      1043,
      1044,
      1045,
      1046
    ],
    "take": [
      1041,
      1481
    ],
    "stx": [
      1041,
      1834
    ],
    "takewhile": [
      1041
    ],
    "commandstart": [
      1041
    ],
    "iswhitespace": [
      1041
    ],
    "drop": [
      1041,
      1481
    ],
    "commandstartlinter": [
      1041
    ],
    "unless": [
      1041
    ],
    "middle": [
      1041
    ],
    "getlintervalue": [
      1041
    ],
    "whitespace": [
      1043,
      1044,
      1045,
      1046
    ],
    "these": [
      1043,
      1044,
      1045,
      1045,
      1596,
      1597,
      1772
    ],
    "instances": [
      1043,
      1044,
      1045,
      1888
    ],
    "computably": [
      1043,
      1044,
      1045
    ],
    "set_option": [
      1043,
      1044,
      1045,
      1046,
      1841
    ],
    "being": [
      1045,
      1553
    ],
    "prevent": [
      1045
    ],
    "computable": [
      1045
    ],
    "construct": [
      1045
    ],
    "galois": [
      1046
    ],
    "connection": [
      1046
    ],
    "map_gc": [
      1046
    ],
    "pullback": [
      1046,
      1877
    ],
    "sheaves": [
      1046
    ],
    "le_map_iff_comap_le": [
      1046
    ],
    "forms": [
      1046
    ],
    "contmdiffat_iff_contdiffat": [
      1048,
      1566
    ],
    "contdiffat_ringinverse": [
      1048,
      1566
    ],
    "congruent": [
      1050,
      1576
    ],
    "shown": [
      1050,
      1576
    ],
    "modeq": [
      1050,
      1576
    ],
    "modulo": [
      1050,
      1576,
      1587
    ],
    "toicodiv": [
      1050,
      1582,
      1583
    ],
    "does": [
      1050,
      1768
    ],
    "toiocdiv": [
      1050
    ],
    "toiocmod": [
      1050
    ],
    "lie": [
      1050
    ],
    "assert_not_exists": [
      1050
    ],
    "h_lt": [
      1056
    ],
    "edge": [
      1072,
      1073,
      1608,
      1609,
      1610
    ],
    "tensor": [
      1072,
      1073,
      1608,
      1609,
      1610
    ],
    "compstruct": [
      1072,
      1073,
      1608,
      1609,
      1610
    ],
    "idcomp": [
      1072,
      1073,
      1608,
      1609,
      1610
    ],
    "compid": [
      1072,
      1073,
      1608,
      1609,
      1610
    ],
    "hommk_comp_hommk": [
      1072,
      1073,
      1608,
      1609,
      1610
    ],
    "initialize": [
      1074
    ],
    "registertraceclass": [
      1074
    ],
    "self_mem_nhdswithin": [
      1077,
      1078,
      1079,
      1080
    ],
    "truncatedwittvector": [
      1108
    ],
    "liftfun": [
      1108
    ],
    "universal": [
      1108
    ],
    "div_div_eq_div_mul": [
      1127,
      1696,
      1697,
      1698,
      1699
    ],
    "div_lt_self": [
      1127,
      1696,
      1697,
      1698,
      1699
    ],
    "pow_succ": [
      1127,
      1696,
      1697,
      1698,
      1699
    ],
    "le_of_lt_succ": [
      1127,
      1696,
      1697,
      1698,
      1699
    ],
    "of_eq": [
      1133
    ],
    "option": [
      1133
    ],
    "option_iget": [
      1133
    ],
    "default": [
      1133
    ],
    "iget": [
      1133
    ],
    "primrec": [
      1133
    ],
    "option_caseson": [
      1133
    ],
    "option_map": [
      1133
    ],
    "induced": [
      1138,
      1443,
      1666
    ],
    "muldistribmulaction": [
      1138
    ],
    "coboundary": [
      1138
    ],
    "comp_contdiffon_iff": [
      1157
    ],
    "admits": [
      1157
    ],
    "whose": [
      1157
    ],
    "hasftaylorseriesuptoon": [
      1157,
      1655
    ],
    "series": [
      1157
    ],
    "compcontinuouslinearmap": [
      1157,
      1655
    ],
    "taylor": [
      1157
    ],
    "contdiffon_univ": [
      1157
    ],
    "linear": [
      1157,
      1228,
      1245,
      1272,
      1490,
      1491,
      1554,
      1565,
      1758,
      1759,
      1826
    ],
    "bairetheorem": [
      1161,
      1741
    ],
    "det": [
      1174
    ],
    "det_eq": [
      1174
    ],
    "sesqformofinner": [
      1192,
      1767,
      1768
    ],
    "adjoint": [
      1192
    ],
    "isadjointpair": [
      1192,
      1767
    ],
    "isadjointpair_inner": [
      1192,
      1767
    ],
    "deriv": [
      1196,
      1337
    ],
    "deriv_log": [
      1196
    ],
    "equation": [
      1222
    ],
    "postcompose": [
      1222
    ],
    "initialize_simps_projections": [
      1222
    ],
    "another": [
      1222
    ],
    "between": [
      1222,
      1245,
      1585,
      1666,
      1723
    ],
    "lipschitzwith": [
      1223,
      1584
    ],
    "lipschitzonwith_univ": [
      1223
    ],
    "isclosed_setof_lipschitzonwith": [
      1223
    ],
    "prereflection": [
      1228
    ],
    "associated": [
      1228,
      1526
    ],
    "comp_of_right_eq_apply": [
      1228,
      1463,
      1464,
      1465
    ],
    "of_left_eq_zero": [
      1228
    ],
    "length": [
      1230,
      1481
    ],
    "mk_congr": [
      1230
    ],
    "vectorequivfin": [
      1230
    ],
    "mk_list_eq_sum_pow": [
      1230
    ],
    "sigmafiberequiv": [
      1230
    ],
    "sum": [
      1230,
      1336,
      1425,
      1723,
      1768
    ],
    "mk_vector": [
      1230
    ],
    "connectedcomponentmk": [
      1232
    ],
    "component": [
      1232
    ],
    "homomorphisms": [
      1232
    ],
    "proofsinpublic": [
      1232
    ],
    "backward": [
      1232
    ],
    "homomorphism": [
      1232,
      1361
    ],
    "connectedcomponent": [
      1232
    ],
    "graph": [
      1232,
      1402,
      1403
    ],
    "tosimplegraph": [
      1232
    ],
    "bddabove": [
      1238
    ],
    "coe_sort_coe": [
      1238
    ],
    "notmem_support_iff": [
      1238
    ],
    "h_fin": [
      1238
    ],
    "of_fintype": [
      1238
    ],
    "finite_univ_iff": [
      1238
    ],
    "lt_succ_self": [
      1239
    ],
    "choose_eq_zero_of_lt": [
      1239
    ],
    "etastruct": [
      1241
    ],
    "call": [
      1241
    ],
    "heqtype": [
      1241
    ],
    "cont": [
      1241
    ],
    "reduction": [
      1241
    ],
    "neutralconfig": [
      1241
    ],
    "den": [
      1245,
      1246,
      1848
    ],
    "h_nz": [
      1245,
      1246,
      1848
    ],
    "equivnum": [
      1245
    ],
    "num": [
      1245
    ],
    "fractional": [
      1245
    ],
    "mapping": [
      1245,
      1403
    ],
    "integral": [
      1245
    ],
    "distribmulaction": [
      1246,
      1848
    ],
    "tolinearmap_apply": [
      1246,
      1848
    ],
    "algebramap_injective": [
      1246,
      1848
    ],
    "smul_right_inj": [
      1246,
      1848
    ],
    "smul_mem_pointwise_smul": [
      1246,
      1848
    ],
    "setcoe": [
      1246,
      1848
    ],
    "ofbijective": [
      1246,
      1848
    ],
    "law": [
      1250
    ],
    "hxm": [
      1250
    ],
    "gaussianreal": [
      1250
    ],
    "variance": [
      1250
    ],
    "gaussian": [
      1250
    ],
    "gaussianreal_map_const_add": [
      1250
    ],
    "gaussianreal_map_add_const": [
      1250
    ],
    "measurespace": [
      1250
    ],
    "sinh": [
      1268
    ],
    "tanh": [
      1268
    ],
    "cosh": [
      1268,
      1863
    ],
    "tanh_eq_sinh_div_cosh": [
      1268
    ],
    "ofreal_inj": [
      1268
    ],
    "smul_comp": [
      1272
    ],
    "comp_smul": [
      1272
    ],
    "hommodule": [
      1272
    ],
    "syntaxnodekind": [
      1289
    ],
    "grindreplacementwith": [
      1289
    ],
    "tacticname": [
      1289
    ],
    "tactickind": [
      1289
    ],
    "leangz": [
      1290,
      1295,
      1300,
      1305,
      1310
    ],
    "digama0": [
      1290,
      1295,
      1300,
      1305,
      1310
    ],
    "leantar": [
      1290,
      1295,
      1300,
      1305,
      1310
    ],
    "version": [
      1290,
      1295,
      1300,
      1305,
      1310,
      1758,
      1759
    ],
    "leantarversion": [
      1290,
      1295,
      1300,
      1305,
      1310
    ],
    "time": [
      1291,
      1296,
      1301,
      1306,
      1311,
      1467,
      1468,
      1596,
      1597,
      1599,
      1600
    ],
    "touched": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "roothashgeneration": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "cache": [
      1291,
      1296,
      1301,
      1306,
      1311,
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "existing": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "inputs": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "last": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "lake": [
      1291,
      1296,
      1301,
      1306,
      1311,
      1657,
      1801,
      1802,
      1803,
      1804,
      1805,
      1808,
      1811,
      1812,
      1813,
      1814
    ],
    "uint64": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "githash": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "long": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "counter": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "invalidate": [
      1291,
      1296,
      1301,
      1306,
      1311
    ],
    "git": [
      1292,
      1297,
      1302,
      1307,
      1312
    ],
    "dependencies": [
      1292,
      1297,
      1302,
      1307,
      1312
    ],
    "testing": [
      1292,
      1297,
      1302,
      1307,
      1312
    ],
    "nightly": [
      1292,
      1297,
      1302,
      1307,
      1312
    ],
    "batteries": [
      1292,
      1297,
      1302,
      1307,
      1312,
      1801,
      1802,
      1805,
      1811,
      1812
    ],
    "require": [
      1292,
      1297,
      1302,
      1307,
      1312
    ],
    "upstream": [
      1292,
      1297,
      1302,
      1307,
      1312
    ],
    "projects": [
      1292,
      1297,
      1302,
      1307,
      1312
    ],
    "title": [
      1293,
      1294,
      1298,
      1299,
      1303,
      1304,
      1308,
      1309,
      1313,
      1314,
      1417,
      1418
    ],
    "extension": [
      1293,
      1298,
      1303,
      1308,
      1313,
      1573
    ],
    "kolmogorov": [
      1293,
      1298,
      1303,
      1308,
      1313
    ],
    "q3526996": [
      1293,
      1298,
      1303,
      1308,
      1313
    ],
    "stopping": [
      1294,
      1299,
      1304,
      1309,
      1314,
      1599,
      1600
    ],
    "q2027347": [
      1294,
      1299,
      1304,
      1309,
      1314
    ],
    "optional": [
      1294,
      1299,
      1304,
      1309,
      1314
    ],
    "sum_eq_one_iff": [
      1319
    ],
    "mathlib4": [
      1320,
      1334
    ],
    "ubuntu": [
      1320,
      1323,
      1334,
      1335
    ],
    "latest": [
      1320,
      1323,
      1334,
      1335
    ],
    "repository": [
      1320,
      1334
    ],
    "steps": [
      1320,
      1321,
      1322,
      1323,
      1334,
      1335,
      1805,
      1806,
      1807,
      1808,
      1809,
      1810
    ],
    "format": [
      1321
    ],
    "delegate": [
      1321
    ],
    "contains": [
      1321,
      1510
    ],
    "comment": [
      1321
    ],
    "review": [
      1321
    ],
    "maintainer": [
      1321
    ],
    "event": [
      1321
    ],
    "body": [
      1321
    ],
    "grantbirki": [
      1322
    ],
    "merge": [
      1322,
      1335
    ],
    "secrets": [
      1322,
      1335
    ],
    "scope": [
      1322
    ],
    "bors": [
      1322
    ],
    "outputs": [
      1322,
      1806,
      1807,
      1809,
      1810
    ],
    "users": [
      1322
    ],
    "token": [
      1322
    ],
    "present": [
      1322
    ],
    "username": [
      1322
    ],
    "get": [
      1322,
      1659
    ],
    "label": [
      1322,
      1335
    ],
    "actor": [
      1322
    ],
    "org": [
      1322,
      1688,
      1889
    ],
    "mathlib_reviewers_team_key": [
      1322
    ],
    "post_steps": [
      1323
    ],
    "needs": [
      1323
    ],
    "build": [
      1323,
      1801,
      1802,
      1805,
      1811,
      1812
    ],
    "style_lint": [
      1323
    ],
    "b_mem": [
      1324
    ],
    "takeuntil": [
      1324
    ],
    "card_eq_zero": [
      1324
    ],
    "elim": [
      1324,
      1405,
      1407,
      1409,
      1410,
      1746
    ],
    "reverse": [
      1324
    ],
    "a_mem": [
      1324
    ],
    "ishamiltonian": [
      1324
    ],
    "append": [
      1324
    ],
    "of_card_eq_one": [
      1324
    ],
    "not_isempty_iff": [
      1324
    ],
    "picongrright": [
      1329,
      1330
    ],
    "homeomorph": [
      1329,
      1329,
      1330,
      1330
    ],
    "ishomeomorph": [
      1329,
      1329,
      1330,
      1330
    ],
    "continuoushom": [
      1331
    ],
    "tomono": [
      1331
    ],
    "doubly": [
      1332
    ],
    "stochastic": [
      1332,
      1596,
      1597
    ],
    "transpose_mem_colstochastic_iff_mem_rowstochastic": [
      1332
    ],
    "doublystochastic_eq_rowstochastic_inf_colstochastic": [
      1332
    ],
    "permmatrix_mem_colstochastic": [
      1332
    ],
    "doublystochastic": [
      1332
    ],
    "transpose_mem_rowstochastic_iff_mem_colstochastic": [
      1332
    ],
    "permmatrix_mem_rowstochastic": [
      1332
    ],
    "transpose_mem_doublystochastif_iff": [
      1332
    ],
    "mem_rowstochastic": [
      1332
    ],
    "mem_colstochastic": [
      1332
    ],
    "eps1lon": [
      1335
    ],
    "dirty": [
      1335
    ],
    "merge_conflicts_token": [
      1335
    ],
    "dirtylabel": [
      1335
    ],
    "conflict": [
      1335
    ],
    "request": [
      1335
    ],
    "commentondirty": [
      1335
    ],
    "tsum_eq_tsum_fourierintegral": [
      1336
    ],
    "following": [
      1336
    ],
    "fourier": [
      1336
    ],
    "convergent": [
      1336
    ],
    "formulation": [
      1336
    ],
    "hypotheses": [
      1336
    ],
    "transform": [
      1336
    ],
    "hasfpowerseriesonball": [
      1337
    ],
    "hasfpowerseriesat": [
      1337
    ],
    "cauchypowerseries_apply": [
      1337
    ],
    "zpow_neg": [
      1337
    ],
    "one_div": [
      1337
    ],
    "smul_smul": [
      1337
    ],
    "zpow_two": [
      1337
    ],
    "pow_one": [
      1337
    ],
    "cderiv": [
      1338
    ],
    "differentiablewithinat": [
      1339
    ],
    "notpx": [
      1340
    ],
    "hallnotpx": [
      1340
    ],
    "mkforallfvars": [
      1340
    ],
    "allnotpx": [
      1340
    ],
    "mem_coe_iff": [
      1341
    ],
    "submulaction": [
      1342,
      1342
    ],
    "val_smul": [
      1342
    ],
    "supportinterpreter": [
      1350
    ],
    "srcdir": [
      1350
    ],
    "scripts": [
      1350
    ],
    "algebramap_eq_map_map_submonoid": [
      1354
    ],
    "islocalization": [
      1354
    ],
    "isintegralclosure": [
      1355
    ],
    "absnorm_differentideal": [
      1356
    ],
    "discriminant": [
      1356
    ],
    "absolute": [
      1356
    ],
    "withupperset": [
      1357
    ],
    "ofupperset": [
      1357
    ],
    "toupperset": [
      1357
    ],
    "tolowerset": [
      1358
    ],
    "withlowerset": [
      1358
    ],
    "oflowerset": [
      1358
    ],
    "hrep": [
      1360
    ],
    "image_eq": [
      1360
    ],
    "ncard": [
      1360
    ],
    "exists_inter_eq_singleton": [
      1360
    ],
    "represents": [
      1360
    ],
    "ncard_eq": [
      1360
    ],
    "ncard_image_of_injon": [
      1360
    ],
    "splits_domain": [
      1361
    ],
    "isalgclosed": [
      1361
    ],
    "algebraically": [
      1361
    ],
    "splits": [
      1361
    ],
    "arbitrary": [
      1361
    ],
    "fields": [
      1361,
      1693
    ],
    "one_le_mulheight": [
      1363
    ],
    "zero_le_logheight": [
      1363
    ],
    "logheight": [
      1363
    ],
    "continuity": [
      1364,
      1606,
      1889
    ],
    "deducing": [
      1364
    ],
    "tendsto_nhds": [
      1364
    ],
    "hasfderivatfilter": [
      1364
    ],
    "differentiability": [
      1364
    ],
    "hlim": [
      1366
    ],
    "hseq": [
      1366
    ],
    "equals": [
      1366
    ],
    "hpm": [
      1366
    ],
    "div_self": [
      1366
    ],
    "tendsto_nhds_unique": [
      1366
    ],
    "above": [
      1369,
      1370,
      1371
    ],
    "bounded": [
      1369,
      1370,
      1371
    ],
    "tendsto_of_bddabove_monotone": [
      1370,
      1371,
      1372,
      1373,
      1374
    ],
    "tendsto_attop_islub": [
      1370,
      1371,
      1372,
      1373,
      1374
    ],
    "h_bdd": [
      1370
    ],
    "exists_isglb": [
      1372,
      1373,
      1374
    ],
    "smulleftclm_smul": [
      1377
    ],
    "real_smul_eq_coe_smul": [
      1377
    ],
    "continuous_snd": [
      1382
    ],
    "prodmap": [
      1382,
      1701
    ],
    "continuous_subtype_val": [
      1382
    ],
    "if_le": [
      1382
    ],
    "istopologicalgroup": [
      1383
    ],
    "measurable_smul_const": [
      1383
    ],
    "measurablesmul": [
      1383,
      1383
    ],
    "continuous_const_smul": [
      1383
    ],
    "borelspace": [
      1383,
      1467,
      1468
    ],
    "measurable_const_smul": [
      1383
    ],
    "asiso": [
      1388
    ],
    "eq_inv_of_hom_inv_id": [
      1388
    ],
    "mapiso": [
      1388,
      1875
    ],
    "isiso_hom": [
      1388
    ],
    "map_isiso": [
      1388
    ],
    "map_inv": [
      1388
    ],
    "reassoc": [
      1388
    ],
    "emod_two_eq": [
      1389
    ],
    "emod_two_eq_zero_or_one": [
      1389
    ],
    "mod": [
      1390,
      1666,
      1874
    ],
    "mod_eq_of_modeq": [
      1390
    ],
    "tounithom_eq": [
      1392
    ],
    "ofunithom_eq": [
      1392
    ],
    "changelevel_tounithom": [
      1392
    ],
    "one_mem_center": [
      1398
    ],
    "nonunitalsubsemiring": [
      1398
    ],
    "one_mem": [
      1398
    ],
    "tosubsemigroup": [
      1399,
      1400
    ],
    "subsemigroup": [
      1399,
      1400
    ],
    "center_tosubsemigroup": [
      1399,
      1400
    ],
    "name_poly_vars": [
      1401
    ],
    "namepolyvarsover": [
      1401
    ],
    "check": [
      1401,
      1801,
      1802,
      1805,
      1811,
      1812
    ],
    "command": [
      1401,
      1570
    ],
    "colored": [
      1402
    ],
    "decidablepred": [
      1402,
      1723
    ],
    "whether": [
      1402
    ],
    "colors": [
      1402
    ],
    "colorclass": [
      1402
    ],
    "produces": [
      1403
    ],
    "vertices": [
      1403
    ],
    "injective_of_subsingleton": [
      1405,
      1407,
      1409,
      1410
    ],
    "icc_union_ioo_eq_ico": [
      1411
    ],
    "ofreal_add": [
      1411
    ],
    "atbot": [
      1411
    ],
    "singleton_union": [
      1411
    ],
    "nominorder": [
      1411
    ],
    "measure_iic": [
      1411
    ],
    "le_leftlim": [
      1411
    ],
    "measure_union": [
      1411
    ],
    "measurableset_ioo": [
      1411
    ],
    "leftlim_le": [
      1411
    ],
    "weakly": [
      1412
    ],
    "modular": [
      1412,
      1413
    ],
    "covers": [
      1412,
      1413
    ],
    "lower": [
      1412,
      1413,
      1883
    ],
    "either": [
      1413,
      1427,
      1618
    ],
    "abs_nonneg": [
      1414
    ],
    "eq_of_le_of_forall_lt_imp_le_of_dense": [
      1414
    ],
    "mk_near_of_forall_near": [
      1414
    ],
    "sphere": [
      1415
    ],
    "model": [
      1415
    ],
    "frominnerproductspace": [
      1415
    ],
    "could": [
      1415
    ],
    "fromnormedfield": [
      1415
    ],
    "corners": [
      1415
    ],
    "fromsphere": [
      1415
    ],
    "some": [
      1415,
      1656
    ],
    "indep_of_indep_of_le_right": [
      1416
    ],
    "q574902": [
      1417,
      1418
    ],
    "indefinability": [
      1417,
      1418
    ],
    "tarski": [
      1417,
      1418
    ],
    "not_exists": [
      1419
    ],
    "greater": [
      1425
    ],
    "divisors": [
      1425
    ],
    "_abundant_": [
      1425
    ],
    "than": [
      1425,
      1688
    ],
    "proper": [
      1425
    ],
    "comp_tospansingleton": [
      1426
    ],
    "attempt": [
      1427
    ],
    "actually": [
      1427
    ],
    "transparency": [
      1427
    ],
    "infer": [
      1427
    ],
    "equal": [
      1427
    ],
    "match_expr": [
      1427
    ],
    "structure": [
      1427,
      1509,
      1658
    ],
    "maprange_apply": [
      1435
    ],
    "maprange_zero": [
      1435
    ],
    "maprange": [
      1435
    ],
    "ishermitian_intcast": [
      1436
    ],
    "dotproduct_smul": [
      1436
    ],
    "dotproduct_star_self_nonneg": [
      1436
    ],
    "natcast": [
      1436
    ],
    "possemidef_diagonal_iff": [
      1436
    ],
    "nsmul_nonneg": [
      1436
    ],
    "intcast": [
      1436,
      1894
    ],
    "possemidef_intcast_iff": [
      1436
    ],
    "natcast_mulvec": [
      1436
    ],
    "intcast_mulvec": [
      1436
    ],
    "star_mul_self_nonneg": [
      1436
    ],
    "val_mul": [
      1441
    ],
    "coe_mul": [
      1441
    ],
    "coe_unzero": [
      1441
    ],
    "res": [
      1443
    ],
    "map_injective": [
      1443
    ],
    "res_map_hom": [
      1443
    ],
    "ioo_mem_nhds": [
      1444,
      1445,
      1446
    ],
    "exists_isextron_ioo_of_tendsto": [
      1444,
      1445,
      1446
    ],
    "islocalextr": [
      1444,
      1444,
      1445,
      1445,
      1446,
      1446
    ],
    "hfc": [
      1444,
      1445,
      1446
    ],
    "cmem": [
      1444,
      1445,
      1446
    ],
    "count": [
      1447,
      1448
    ],
    "cond_apply": [
      1447
    ],
    "uniformon": [
      1447
    ],
    "count_apply_lt_top": [
      1448
    ],
    "isprobabilitymeasure": [
      1448
    ],
    "cond_isprobabilitymeasure_of_finite": [
      1448
    ],
    "count_ne_zero_iff": [
      1448
    ],
    "measurablesingletonclass": [
      1448
    ],
    "uniformon_isprobabilitymeasure": [
      1448
    ],
    "generalizations": [
      1450
    ],
    "normed": [
      1450,
      1693,
      1766
    ],
    "islittleotvs": [
      1450
    ],
    "topological": [
      1450,
      1450
    ],
    "spaces": [
      1450
    ],
    "isbigotvs": [
      1450
    ],
    "space": [
      1450,
      1510,
      1818
    ],
    "pairwisedisjoint": [
      1451
    ],
    "diff_eq_sunion": [
      1451
    ],
    "ispisystem": [
      1451,
      1451
    ],
    "inter_mem": [
      1451
    ],
    "exists_ne_map_eq_of_card_lt_of_maps_to": [
      1453
    ],
    "tsub_add_cancel_of_le": [
      1456
    ],
    "hfy": [
      1456
    ],
    "pdf": [
      1457,
      1458
    ],
    "files": [
      1457,
      1458
    ],
    "emilyriehl": [
      1457,
      1458
    ],
    "url": [
      1457,
      1458
    ],
    "isequivalent_iff_exists_eq_mul": [
      1459
    ],
    "div_mul_cancel_of_imp": [
      1459
    ],
    "isequivalent_of_tendsto_one": [
      1459
    ],
    "eventually": [
      1459
    ],
    "linearequiv": [
      1463,
      1464,
      1465,
      1759
    ],
    "symm_apply_eq": [
      1463,
      1464,
      1465
    ],
    "comp_of_left_eq_apply": [
      1465
    ],
    "symm_eq": [
      1465
    ],
    "dual": [
      1465,
      1490,
      1491,
      1826
    ],
    "inequalities": [
      1467,
      1468
    ],
    "measurableset": [
      1467,
      1468,
      1667,
      1668,
      1669,
      1670
    ],
    "hitting": [
      1467,
      1468,
      1599,
      1600
    ],
    "stronglyadapted": [
      1467,
      1468,
      1553
    ],
    "conditionallycompletelinearorder": [
      1467
    ],
    "hittingbtwn": [
      1467
    ],
    "hittingbtwn_isstoppingtime": [
      1467,
      1599,
      1600
    ],
    "pseudometrizablespace": [
      1467
    ],
    "isstoppingtime": [
      1467,
      1881,
      1882
    ],
    "wellfoundedlt": [
      1467
    ],
    "h_set_eq_union": [
      1468
    ],
    "linearequivfunonfinite_symm_coe": [
      1469
    ],
    "linearequivfunonfinite": [
      1469
    ],
    "iio": [
      1470
    ],
    "iio_castsucc": [
      1470
    ],
    "castsuccemb": [
      1470
    ],
    "castsucc": [
      1470,
      1700
    ],
    "le_antisymm_iff": [
      1471
    ],
    "isequiv": [
      1471,
      1472,
      1473,
      1474
    ],
    "ne_zero": [
      1471,
      1472,
      1473,
      1474
    ],
    "val_eq": [
      1471,
      1472
    ],
    "and_congr": [
      1471
    ],
    "not_congr": [
      1471
    ],
    "lt_iff_lt": [
      1472,
      1473,
      1474
    ],
    "zero_lt_iff": [
      1472
    ],
    "pos_iff": [
      1472
    ],
    "eq_one_iff_eq_one": [
      1472,
      1473
    ],
    "lt_one_iff_lt_one": [
      1472,
      1473
    ],
    "le_iff_le": [
      1473,
      1474
    ],
    "isequiv_of_map_strictmono": [
      1473,
      1474
    ],
    "linearorderedcommgroupwithzero": [
      1473,
      1474,
      1713,
      1714,
      1715
    ],
    "linearorderedcommmonoidwithzero": [
      1473,
      1474
    ],
    "isequiv_of_val_le_one": [
      1473,
      1474
    ],
    "forall_comm": [
      1473,
      1474
    ],
    "le_iff_le_iff_lt_iff_lt": [
      1473,
      1474
    ],
    "_iff": [
      1475
    ],
    "_top": [
      1475
    ],
    "localized": [
      1475,
      1883
    ],
    "copy": [
      1481
    ],
    "dropwhile": [
      1481
    ],
    "parallelscanaux": [
      1481
    ],
    "diff": [
      1481
    ],
    "newl": [
      1481
    ],
    "toslice": [
      1481
    ],
    "issimple": [
      1484,
      1485
    ],
    "lid_symm_apply": [
      1486
    ],
    "lid": [
      1486
    ],
    "hks": [
      1492
    ],
    "not_gt": [
      1492
    ],
    "exists_gt": [
      1492
    ],
    "coesubmodule_top": [
      1493
    ],
    "coe_one": [
      1493
    ],
    "coe_one_eq_coesubmodule_top": [
      1493
    ],
    "ne_rational": [
      1494
    ],
    "irrational": [
      1494
    ],
    "algebramap_ne_zero": [
      1499,
      1500,
      1501,
      1503,
      1504
    ],
    "denom_ne_zero": [
      1499,
      1500,
      1501
    ],
    "ismulindecomposable": [
      1502,
      1752,
      1753
    ],
    "isorderedmonoid": [
      1502
    ],
    "involutiveinv": [
      1502
    ],
    "commgroup": [
      1502,
      1650,
      1651,
      1652
    ],
    "baseof": [
      1502
    ],
    "apply_ne_one_iff_mem_closure": [
      1502
    ],
    "ratfunc": [
      1503,
      1504
    ],
    "x_ne_zero": [
      1503,
      1504
    ],
    "iff_finite_comap_preimage_singleton": [
      1506
    ],
    "spec": [
      1506,
      1685
    ],
    "fibers": [
      1506
    ],
    "artinian": [
      1506
    ],
    "quasi": [
      1506
    ],
    "those": [
      1509
    ],
    "submodules": [
      1509
    ],
    "notably": [
      1509
    ],
    "linearalgebra": [
      1509,
      1665,
      1666
    ],
    "breaking": [
      1510
    ],
    "character": [
      1510,
      1590
    ],
    "semicolon": [
      1510
    ],
    "nonbreakingspace": [
      1510
    ],
    "line": [
      1510
    ],
    "before": [
      1510
    ],
    "withapp": [
      1512
    ],
    "isreservedname": [
      1512
    ],
    "translate_detail": [
      1512
    ],
    "mapm": [
      1512
    ],
    "expand": [
      1512
    ],
    "dbg_trace": [
      1512
    ],
    "reorderfn": [
      1512
    ],
    "traversechildren": [
      1512
    ],
    "becomes": [
      1512
    ],
    "donttranslate": [
      1512
    ],
    "translatedata": [
      1512
    ],
    "fvarid": [
      1512
    ],
    "direction_altitude": [
      1515,
      1517
    ],
    "isortho_orthogonal_right": [
      1515,
      1517
    ],
    "mono_right": [
      1515,
      1517
    ],
    "inf_le_left": [
      1515,
      1517,
      1878,
      1882
    ],
    "sum_comp_equiv": [
      1516
    ],
    "property_index": [
      1518
    ],
    "index": [
      1518
    ],
    "mem_of_mem": [
      1518
    ],
    "set_index_subset": [
      1518
    ],
    "hconnected": [
      1518
    ],
    "hbasis": [
      1518
    ],
    "_hb": [
      1519,
      1520
    ],
    "confirms": [
      1519,
      1520
    ],
    "previous": [
      1519,
      1520
    ],
    "test": [
      1519,
      1520,
      1803,
      1804,
      1808,
      1810,
      1813,
      1814
    ],
    "removal": [
      1519,
      1520
    ],
    "confined": [
      1519,
      1520
    ],
    "algebra_adjoin_le_adjoin": [
      1522
    ],
    "adjoin_eq_top_of_algebra": [
      1522
    ],
    "top_le_iff": [
      1522
    ],
    "intermediatefield": [
      1523
    ],
    "generated": [
      1523
    ],
    "there": [
      1523,
      1568,
      1818,
      1883
    ],
    "finitely": [
      1523
    ],
    "intermediate": [
      1523
    ],
    "mem_ssup": [
      1525
    ],
    "gcdmonoid": [
      1526
    ],
    "bottom": [
      1526
    ],
    "facts": [
      1526,
      1553
    ],
    "lcm_zero_right": [
      1526
    ],
    "normalizedgcdmonoid": [
      1526
    ],
    "normalization": [
      1526
    ],
    "lcm": [
      1526
    ],
    "normalized": [
      1526
    ],
    "infimum": [
      1526
    ],
    "exact_and_mono_f_iff_f_is_kernel": [
      1528
    ],
    "fiskernel": [
      1528
    ],
    "mapislimit": [
      1528
    ],
    "tfae_finish": [
      1528,
      1529
    ],
    "kernelfork": [
      1528
    ],
    "guard_hyp": [
      1538,
      1539
    ],
    "hasfinitecoproducts_of_has_binary_and_initial": [
      1540
    ],
    "of_hasfiniteproducts": [
      1540
    ],
    "hasfiniteproducts_of_has_binary_and_terminal": [
      1540
    ],
    "hasfiniteproducts": [
      1540
    ],
    "hasfinitecoproducts": [
      1540
    ],
    "hasfinitebiproducts": [
      1540
    ],
    "le_order": [
      1542,
      1543,
      1544
    ],
    "order_mul_ge": [
      1542
    ],
    "coeff_zero_eq_constantcoeff": [
      1542
    ],
    "cast_lt_one": [
      1542,
      1543,
      1544
    ],
    "order_ne_zero_iff_constcoeff_eq_zero": [
      1542,
      1543,
      1544
    ],
    "powerseries": [
      1542
    ],
    "coeff_of_lt_order": [
      1542,
      1543,
      1544
    ],
    "le_order_mul": [
      1542
    ],
    "degree_eq_zero_iff": [
      1543,
      1544
    ],
    "le_weightedorder_prod": [
      1543,
      1544
    ],
    "mvpowerseries": [
      1543,
      1544
    ],
    "vlt_mul_right_iff": [
      1546,
      1547
    ],
    "srel_mul_right": [
      1546,
      1547
    ],
    "srel_mul_right_iff": [
      1546,
      1547
    ],
    "vle_mul_right": [
      1546,
      1547
    ],
    "vle_mul_right_iff": [
      1546,
      1547
    ],
    "vle_mul_cancel": [
      1546,
      1547
    ],
    "vlt_mul_right": [
      1546,
      1547
    ],
    "rel_mul_right_iff": [
      1546,
      1547
    ],
    "vlt": [
      1546,
      1547
    ],
    "srel": [
      1546,
      1547
    ],
    "rel_mul_left_iff": [
      1546
    ],
    "vle_mul_left_iff": [
      1546
    ],
    "srel_mul_left": [
      1547
    ],
    "vlt_mul_left_iff": [
      1547
    ],
    "srel_mul_left_iff": [
      1547
    ],
    "vlt_mul_left": [
      1547
    ],
    "composablearrows": [
      1550
    ],
    "leofhom": [
      1550
    ],
    "precomp": [
      1550,
      1550
    ],
    "homologicalcomplex": [
      1551,
      1552
    ],
    "iszero_single_obj_x": [
      1551,
      1552
    ],
    "said": [
      1553,
      1597,
      1727
    ],
    "notions": [
      1553
    ],
    "strongly": [
      1553
    ],
    "progmeasurable": [
      1553
    ],
    "processes": [
      1553,
      1596,
      1597
    ],
    "respect": [
      1553
    ],
    "related": [
      1553
    ],
    "proves": [
      1553
    ],
    "definitions": [
      1553,
      1596,
      1597,
      1666
    ],
    "progressively": [
      1553,
      1596,
      1597,
      1598
    ],
    "equicontinuous": [
      1554
    ],
    "family": [
      1554,
      1858,
      1886,
      1887
    ],
    "barrelled": [
      1554
    ],
    "von": [
      1554
    ],
    "principle": [
      1554
    ],
    "uniform": [
      1554
    ],
    "image_isvonnbounded_iff_seminorm_bounded": [
      1554
    ],
    "satisfying": [
      1554
    ],
    "withseminorms": [
      1554,
      1658
    ],
    "boundedness": [
      1554
    ],
    "fix": [
      1554
    ],
    "requiring": [
      1554
    ],
    "macro": [
      1555,
      1569
    ],
    "rest": [
      1555
    ],
    "setargsrest": [
      1555
    ],
    "rev": [
      1555
    ],
    "elab_rules": [
      1555
    ],
    "archimedeanclass": [
      1558
    ],
    "mem_ball_iff": [
      1558
    ],
    "colon_top": [
      1561
    ],
    "inter_subset_inter_right": [
      1563
    ],
    "iinf_nebot_of_directed": [
      1563
    ],
    "iic_subset_iic": [
      1563
    ],
    "directed": [
      1563,
      1563
    ],
    "principal_mono": [
      1563
    ],
    "mono_comp": [
      1563
    ],
    "aeval_eq_zero_of_mem_rootset": [
      1564
    ],
    "mulsemiringaction": [
      1564,
      1725
    ],
    "smul_mem_rootset": [
      1564
    ],
    "rootset": [
      1564
    ],
    "aeval_smul": [
      1564
    ],
    "coe_smul": [
      1564
    ],
    "mem_rootset": [
      1564
    ],
    "demonstrated": [
      1565
    ],
    "different": [
      1568
    ],
    "parts": [
      1568
    ],
    "typically": [
      1568
    ],
    "added": [
      1568
    ],
    "elabpushconfig": [
      1568
    ],
    "showing": [
      1568
    ],
    "neghygname": [
      1568
    ],
    "idiom": [
      1568
    ],
    "side": [
      1568,
      1618
    ],
    "claim": [
      1568
    ],
    "print": [
      1569,
      1570
    ],
    "optconfig": [
      1569
    ],
    "push_neg": [
      1569,
      1570
    ],
    "expression": [
      1569,
      1570
    ],
    "discharger": [
      1570
    ],
    "disch": [
      1570
    ],
    "stdpart_eq": [
      1571
    ],
    "mk_sub_stdpart_pos": [
      1571
    ],
    "mk_sub_pos_iff": [
      1571
    ],
    "preorders": [
      1572
    ],
    "isopen_inter": [
      1572
    ],
    "seen": [
      1572
    ],
    "isopen_univ": [
      1572
    ],
    "isopen_sunion": [
      1572
    ],
    "abv_nonneg": [
      1573
    ],
    "identifies": [
      1573
    ],
    "whnfr": [
      1573
    ],
    "expressions": [
      1573
    ],
    "evalabv": [
      1573
    ],
    "abv": [
      1573
    ],
    "modeq_zero": [
      1576
    ],
    "modeq_comm": [
      1576
    ],
    "modeq_rfl": [
      1576
    ],
    "istrans": [
      1576
    ],
    "modeq_sub": [
      1576
    ],
    "prod_le": [
      1578
    ],
    "prod_le_inf": [
      1578
    ],
    "inf_le": [
      1578
    ],
    "his": [
      1578
    ],
    "hip": [
      1578
    ],
    "subset_def": [
      1582,
      1583
    ],
    "sub_le_sub_right": [
      1582,
      1583
    ],
    "neg_le_neg": [
      1582,
      1583
    ],
    "iic": [
      1582,
      1583
    ],
    "toicomod_sub_zsmul": [
      1582,
      1583
    ],
    "sub_mem_ioo_iff_left": [
      1582,
      1583
    ],
    "hausdorffedist_union_le": [
      1584
    ],
    "isometry": [
      1584,
      1759
    ],
    "lipschitz_sup": [
      1584
    ],
    "isometry_singleton": [
      1584
    ],
    "nonemptycompacts": [
      1584
    ],
    "of_edist_le": [
      1584
    ],
    "hausdorffedist_singleton": [
      1584
    ],
    "secondcountable_of_separable": [
      1584
    ],
    "hausdorffedist_prod_le": [
      1584
    ],
    "lipschitz_prod": [
      1584
    ],
    "emetric": [
      1585,
      1586,
      1587
    ],
    "want": [
      1585,
      1586,
      1587
    ],
    "hausdorffedist": [
      1585,
      1586
    ],
    "coincide": [
      1585,
      1586
    ],
    "ofreal_ne_top": [
      1585,
      1586
    ],
    "hausdorffdist_comm": [
      1585,
      1586
    ],
    "more": [
      1585,
      1586,
      1587
    ],
    "hausdorffdist": [
      1585,
      1586
    ],
    "hausdorffdist_self_zero": [
      1585,
      1586
    ],
    "vanishes": [
      1585,
      1586
    ],
    "hausdorffedist_empty": [
      1586
    ],
    "toreal_nonneg": [
      1587
    ],
    "infdist_eq_iinf": [
      1587
    ],
    "infdist_nonneg": [
      1587
    ],
    "readily": [
      1587
    ],
    "pairs": [
      1588,
      1629
    ],
    "diag": [
      1588,
      1588
    ],
    "locations": [
      1590
    ],
    "server_rpc_method": [
      1590
    ],
    "select": [
      1590
    ],
    "map_sup": [
      1592
    ],
    "smul_sup": [
      1592
    ],
    "addgroup": [
      1593
    ],
    "not_issumsq_neg_one": [
      1593
    ],
    "issumsq": [
      1593
    ],
    "measure_preimage_smul": [
      1594
    ],
    "measure_smul": [
      1594
    ],
    "preimage_smul_inv": [
      1594
    ],
    "iscompact_iff_ultrafilter_le_nhds": [
      1595
    ],
    "specific": [
      1596,
      1597,
      1772
    ],
    "filtrations": [
      1596,
      1597
    ],
    "formalizing": [
      1596,
      1597
    ],
    "step": [
      1596,
      1597
    ],
    "times": [
      1596,
      1597
    ],
    "definition": [
      1596,
      1597
    ],
    "amount": [
      1596
    ],
    "adapted": [
      1598,
      1598,
      1599,
      1600,
      1601,
      1601
    ],
    "progmeasurable_of_continuous": [
      1598
    ],
    "process": [
      1598,
      1599,
      1600
    ],
    "hittingafter_isstoppingtime": [
      1599,
      1600
    ],
    "supermartingale": [
      1601
    ],
    "cfc_congr": [
      1604
    ],
    "map_sinf": [
      1605
    ],
    "completelatticehom": [
      1605
    ],
    "restrictscalarslatticehom": [
      1605
    ],
    "forgetting": [
      1605
    ],
    "toaddsubmonoid_ssup": [
      1605
    ],
    "map_ssup": [
      1605
    ],
    "compatibly": [
      1605
    ],
    "toaddsubmonoid_inj": [
      1605
    ],
    "into": [
      1605
    ],
    "image_comp": [
      1605
    ],
    "sqrt": [
      1606
    ],
    "continuous_coe": [
      1606
    ],
    "tonnreal_coe": [
      1606
    ],
    "continuous_sqrt": [
      1606
    ],
    "continuous_real_tonnreal": [
      1606
    ],
    "coe_sqrt": [
      1606
    ],
    "nnreal": [
      1606
    ],
    "ofcomponents": [
      1607
    ],
    "isomk": [
      1607
    ],
    "natiso": [
      1607
    ],
    "counitiso": [
      1607
    ],
    "unitiso": [
      1607
    ],
    "recall": [
      1618
    ],
    "multiplication": [
      1618
    ],
    "down_mul": [
      1618
    ],
    "span_union": [
      1618
    ],
    "subsets": [
      1618
    ],
    "span_empty": [
      1618
    ],
    "setsemiring": [
      1618
    ],
    "mem_radical_of_pow_mem": [
      1619,
      1620
    ],
    "own": [
      1622
    ],
    "srcdecl": [
      1622
    ],
    "withoutexporting": [
      1622
    ],
    "findauxdecls": [
      1622
    ],
    "transformdeclrec": [
      1622
    ],
    "translated": [
      1622
    ],
    "able": [
      1622
    ],
    "getconstinfo": [
      1622
    ],
    "uicc": [
      1623,
      1625
    ],
    "ae_differentiableat_of_mem_uicc": [
      1623,
      1625
    ],
    "boundedvariationon": [
      1623,
      1625
    ],
    "differentiableat": [
      1623,
      1625
    ],
    "says": [
      1629
    ],
    "separated": [
      1629
    ],
    "provided": [
      1629
    ],
    "required": [
      1629
    ],
    "ismetric": [
      1629
    ],
    "outermeasure": [
      1629
    ],
    "additive": [
      1629,
      1778
    ],
    "predicate": [
      1629
    ],
    "isnowheredense": [
      1641
    ],
    "isnowheredense_empty": [
      1641
    ],
    "closure_empty": [
      1641
    ],
    "interior_empty": [
      1641
    ],
    "maps": [
      1649,
      1888
    ],
    "image": [
      1649
    ],
    "pair": [
      1649
    ],
    "belongs": [
      1649
    ],
    "reflector": [
      1653
    ],
    "ofchosenfiniteproducts": [
      1653
    ],
    "ofreflective": [
      1653
    ],
    "reflective": [
      1653
    ],
    "cone": [
      1653,
      1877
    ],
    "asemptycone": [
      1653
    ],
    "cartesianmonoidalcategory": [
      1653
    ],
    "topmodulecat": [
      1654
    ],
    "contlinear": [
      1655
    ],
    "contractiblespace": [
      1656
    ],
    "ofcontractible": [
      1656
    ],
    "equiv_unit": [
      1656
    ],
    "hequiv": [
      1656
    ],
    "punit": [
      1656
    ],
    "simplyconnectedspace": [
      1656
    ],
    "runlinter": [
      1657
    ],
    "lean_abort_on_panic": [
      1657
    ],
    "lint": [
      1657
    ],
    "branch": [
      1657,
      1806,
      1807,
      1809,
      1810
    ],
    "exe": [
      1657,
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "modulefilterbasis": [
      1658
    ],
    "topology_eq_withseminorms": [
      1658
    ],
    "seminormfamily": [
      1658
    ],
    "examples": [
      1659,
      1660
    ],
    "capitalize": [
      1659,
      1660
    ],
    "leaves": [
      1659,
      1660
    ],
    "char": [
      1659,
      1660
    ],
    "islower": [
      1659,
      1660
    ],
    "hadd": [
      1659,
      1660
    ],
    "helper": [
      1659,
      1660
    ],
    "capitalizelike": [
      1659
    ],
    "input": [
      1660
    ],
    "therefore": [
      1660
    ],
    "capitalized": [
      1660
    ],
    "guessname": [
      1660
    ],
    "properly": [
      1660
    ],
    "autogenerate": [
      1660
    ],
    "morita": [
      1666
    ],
    "tomatrixmodcat": [
      1666
    ],
    "matrixmodule": [
      1666
    ],
    "equivalece": [
      1666
    ],
    "measurable_densityprocess": [
      1667,
      1668,
      1669,
      1670
    ],
    "measurable_densityprocess_left": [
      1667,
      1668,
      1669,
      1670
    ],
    "densityprocess": [
      1667,
      1668,
      1669,
      1670
    ],
    "measurable_id": [
      1667,
      1668,
      1669,
      1670
    ],
    "measurable_const": [
      1667,
      1668,
      1669,
      1670
    ],
    "measurable_densityprocess_right": [
      1668,
      1670
    ],
    "vertexcovernum_congr": [
      1673
    ],
    "discretetopology_of_codiscretewithin": [
      1676
    ],
    "codiscrete": [
      1676,
      1677
    ],
    "within": [
      1676
    ],
    "disjoint_iff": [
      1677
    ],
    "accpt": [
      1677
    ],
    "not_nebot": [
      1677
    ],
    "mem_codiscrete": [
      1677
    ],
    "incidence": [
      1683
    ],
    "app_eq_apple": [
      1685
    ],
    "map_apple": [
      1685
    ],
    "map_top": [
      1685
    ],
    "morphismrestrict_apple": [
      1685
    ],
    "apple_map": [
      1685
    ],
    "eqtohom_op": [
      1685
    ],
    "opens": [
      1685
    ],
    "zsmul_int_int": [
      1686
    ],
    "really": [
      1686
    ],
    "continuous_piecewise_of_specializes": [
      1687
    ],
    "hspec": [
      1687
    ],
    "isopen_compl": [
      1687
    ],
    "piecewise_compl": [
      1687
    ],
    "mk_lt_continuum": [
      1688
    ],
    "not_ge": [
      1688
    ],
    "to_subtype": [
      1688
    ],
    "wikipedia": [
      1688,
      1889
    ],
    "proof_that_the_moore_plane_is_not_normal": [
      1688
    ],
    "moore_plane": [
      1688
    ],
    "meromorphic": [
      1689
    ],
    "untop0": [
      1689
    ],
    "inv_pow": [
      1690
    ],
    "mul_pow": [
      1690
    ],
    "eventually_ne": [
      1690
    ],
    "han": [
      1690
    ],
    "hzne": [
      1690
    ],
    "reapplyinnerself_seminormed": [
      1691
    ],
    "algebramap_eq_ofreal": [
      1691
    ],
    "pi_pos": [
      1692
    ],
    "angle_eq_pi_div_three": [
      1692
    ],
    "map_exp": [
      1693,
      1725
    ],
    "tsum_congr": [
      1693
    ],
    "ofreal_exp": [
      1693
    ],
    "expseries_apply_eq": [
      1693
    ],
    "expseries": [
      1693
    ],
    "two": [
      1693,
      1747
    ],
    "expseries_eq_expseries": [
      1693
    ],
    "factorial": [
      1694
    ],
    "descfactorial_self": [
      1694
    ],
    "iterate_derivative_x_sub_pow": [
      1694
    ],
    "pow_zero": [
      1694
    ],
    "nsmul_one": [
      1694
    ],
    "ofdigits_neg_one": [
      1695
    ],
    "map_cons": [
      1695
    ],
    "alternatingsum": [
      1695
    ],
    "ofdigits": [
      1695
    ],
    "castsucc_ne_zero_of_lt": [
      1700
    ],
    "castsucc_ne_zero_iff": [
      1700
    ],
    "elim0": [
      1700
    ],
    "preimage_prod_map_prod": [
      1701
    ],
    "top_adj": [
      1702
    ],
    "eq_iff_iff": [
      1702
    ],
    "injeq": [
      1702
    ],
    "coeff_trunc": [
      1711,
      1712
    ],
    "coeff_map": [
      1711,
      1712
    ],
    "trunc": [
      1711,
      1712
    ],
    "apply_ite": [
      1711,
      1712,
      1723
    ],
    "exists_lt_one": [
      1713,
      1715
    ],
    "one_lt_val_iff": [
      1714,
      1715
    ],
    "isnontrivial_iff_exists_lt_one": [
      1714,
      1715
    ],
    "exists_one_lt": [
      1715
    ],
    "hx1": [
      1715
    ],
    "monoidalgebra": [
      1720,
      1721,
      1722
    ],
    "commmonoid": [
      1720,
      1721
    ],
    "additivise": [
      1720,
      1721
    ],
    "tensorequiv": [
      1722
    ],
    "singleonealghom": [
      1722
    ],
    "isomorphic": [
      1722
    ],
    "finsuppprodequiv": [
      1723
    ],
    "filter_apply": [
      1723
    ],
    "invfun": [
      1723
    ],
    "sum_uncurry_index": [
      1723
    ],
    "curry_uncurry": [
      1723
    ],
    "uncurrying": [
      1723
    ],
    "toringhom": [
      1725
    ],
    "not_rel_one_zero": [
      1726
    ],
    "arising": [
      1726
    ],
    "rel_total": [
      1726
    ],
    "relation": [
      1726
    ],
    "rel_trans": [
      1726
    ],
    "rel_mul_right": [
      1726
    ],
    "operator": [
      1726
    ],
    "rel": [
      1726
    ],
    "rel_add": [
      1726
    ],
    "rel_mul_cancel": [
      1726
    ],
    "valuativerel": [
      1726
    ],
    "valuative": [
      1727
    ],
    "rel_iff_le": [
      1727
    ],
    "compatible": [
      1727
    ],
    "nozerodivisors": [
      1728
    ],
    "count_tomultiset": [
      1728
    ],
    "monomial": [
      1728
    ],
    "degrees_monomial_eq": [
      1728
    ],
    "degreeof": [
      1728
    ],
    "degreeof_def": [
      1728
    ],
    "mem_nonzerodivisors": [
      1732
    ],
    "isunit_le_nonzerodivisors": [
      1732
    ],
    "add_zero": [
      1744,
      1745
    ],
    "orthogonalprojection_eq_linearprojofiscompl": [
      1744,
      1745
    ],
    "orthogonalprojection_mem_subspace_orthogonalcomplement_eq_zero": [
      1744,
      1745
    ],
    "orthogonalprojection_coe_eq_linearprojofiscompl": [
      1744,
      1745
    ],
    "hasorthogonalprojection": [
      1744,
      1745
    ],
    "coe_mem": [
      1744,
      1745
    ],
    "orthogonalprojection_eq_linear_proj": [
      1744,
      1745
    ],
    "iscompl_orthogonal_of_hasorthogonalprojection": [
      1745
    ],
    "orthogonalprojection_coe_linearmap_eq_linearproj": [
      1745
    ],
    "linearprojofiscompl": [
      1745
    ],
    "starprojection_coe_eq_iscompl_projection": [
      1745
    ],
    "cons": [
      1746
    ],
    "mapdomain": [
      1747
    ],
    "mapdomain_smul": [
      1747
    ],
    "addmonoidhom": [
      1747
    ],
    "mapdomain_mul": [
      1747
    ],
    "mulhomclass": [
      1747
    ],
    "dont_translate": [
      1747
    ],
    "magma": [
      1747
    ],
    "compact": [
      1751,
      1820
    ],
    "ismulindecomposable_id_univ": [
      1752,
      1753
    ],
    "isunit_or_isunit": [
      1752,
      1753
    ],
    "hker": [
      1755
    ],
    "implicittoopenpartialhomeomorphofcomplemented_self": [
      1755
    ],
    "hasstrictfderivat": [
      1755,
      1820
    ],
    "closedcomplemented": [
      1755
    ],
    "adjoint_subtypel": [
      1756,
      1757
    ],
    "adjoint_adjoint": [
      1756,
      1757
    ],
    "topologicalclosure": [
      1756,
      1757
    ],
    "orthogonal_ker": [
      1756,
      1757
    ],
    "ext_inner_left": [
      1757
    ],
    "orthogonal_le": [
      1757
    ],
    "orthogonal_orthogonal_eq_closure": [
      1757
    ],
    "orthogonal_range": [
      1757
    ],
    "mem_range_self": [
      1757
    ],
    "extended": [
      1758,
      1759
    ],
    "isometries": [
      1758
    ],
    "submodulemap": [
      1758,
      1759
    ],
    "equivalences": [
      1759
    ],
    "invariant": [
      1760
    ],
    "invtsubmodule": [
      1760
    ],
    "commute_iff": [
      1760
    ],
    "commute": [
      1760
    ],
    "arithmeticfunction": [
      1766
    ],
    "specificlimits": [
      1766
    ],
    "misc": [
      1766
    ],
    "numbertheory": [
      1766
    ],
    "norm_mul_self_le": [
      1767
    ],
    "le_of_eq": [
      1767
    ],
    "norm_adjoint_comp_self": [
      1767
    ],
    "inner_add_right": [
      1768
    ],
    "inner_add_left": [
      1768
    ],
    "sesquilinear": [
      1768
    ],
    "inner_smul_left": [
      1768
    ],
    "inner_smul_right": [
      1768
    ],
    "bilinear": [
      1768
    ],
    "shapes": [
      1772
    ],
    "preserve": [
      1772
    ],
    "functors": [
      1772
    ],
    "duals": [
      1772
    ],
    "cof_eq": [
      1775
    ],
    "ord": [
      1775
    ],
    "isnormal": [
      1775,
      1776
    ],
    "exists_fundamental_sequence": [
      1775
    ],
    "cof": [
      1775
    ],
    "isfundamentalsequence": [
      1775
    ],
    "ord_injective": [
      1775
    ],
    "enumordorderiso": [
      1776
    ],
    "enumord_strictmono": [
      1776
    ],
    "enumord_mem": [
      1776
    ],
    "isnormal_iff_strictmono_limit": [
      1776
    ],
    "isclosed_iff_isup": [
      1776
    ],
    "enumord": [
      1776
    ],
    "map_isup": [
      1776
    ],
    "shift": [
      1778
    ],
    "preadditive": [
      1778
    ],
    "shiftedhom": [
      1778
    ],
    "equipped": [
      1778
    ],
    "mk_inv": [
      1781
    ],
    "neg_ne_zero": [
      1781
    ],
    "stdpart_sub": [
      1781
    ],
    "stdpart_of_mk_ne_zero": [
      1781
    ],
    "stdpart_add": [
      1781
    ],
    "or_iff_left": [
      1799
    ],
    "cast_lt": [
      1799
    ],
    "norm_pos_iff": [
      1799
    ],
    "norm_eq_abs": [
      1799
    ],
    "abs_lt_one_iff": [
      1799
    ],
    "smul_eq_zero": [
      1799
    ],
    "mul_lt_iff_lt_one_left": [
      1799
    ],
    "seminormedaddcommgroup": [
      1800
    ],
    "explicitly": [
      1801,
      1802,
      1805,
      1811,
      1812
    ],
    "well": [
      1801,
      1802,
      1805,
      1811,
      1812
    ],
    "lean4checker": [
      1801,
      1802,
      1805,
      1806,
      1807,
      1811,
      1812
    ],
    "bin": [
      1801,
      1802,
      1805,
      1811,
      1812
    ],
    "mathlib_test_executable": [
      1803,
      1804,
      1808,
      1809,
      1810,
      1813,
      1814
    ],
    "reinstall": [
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "consistent": [
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "toolchain": [
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "sure": [
      1803,
      1804,
      1808,
      1813,
      1814
    ],
    "error": [
      1803,
      1804,
      1813,
      1814
    ],
    "transient": [
      1803,
      1804,
      1813,
      1814
    ],
    "success": [
      1805,
      1808
    ],
    "zulip": [
      1805,
      1806,
      1808,
      1809
    ],
    "message": [
      1805,
      1806,
      1808,
      1809
    ],
    "outcome": [
      1805,
      1807,
      1810
    ],
    "content": [
      1806,
      1807,
      1809,
      1810
    ],
    "lean4checker_url": [
      1806,
      1807
    ],
    "succeeded": [
      1806,
      1809
    ],
    "urls": [
      1806,
      1807,
      1809,
      1810
    ],
    "stream": [
      1806,
      1807,
      1809,
      1810
    ],
    "branch_ref": [
      1806,
      1807,
      1809,
      1810
    ],
    "failure": [
      1806,
      1807,
      1809,
      1810,
      1830
    ],
    "sha": [
      1806,
      1807,
      1809,
      1810
    ],
    "cancelled": [
      1806,
      1809
    ],
    "topic": [
      1807,
      1810
    ],
    "executable": [
      1809,
      1810
    ],
    "mathlib_test_executable_url": [
      1810
    ],
    "coedep": [
      1815
    ],
    "totempereddistribution": [
      1815
    ],
    "yonedafullyfaithful": [
      1816
    ],
    "fun_comp": [
      1817
    ],
    "schwartz": [
      1818
    ],
    "multiindices": [
      1818
    ],
    "usually": [
      1818
    ],
    "smooth": [
      1818
    ],
    "lipschitzonwith": [
      1820
    ],
    "contdiffat": [
      1820
    ],
    "locally": [
      1820
    ],
    "locallylipschitz": [
      1820,
      1820
    ],
    "lipschitz": [
      1820
    ],
    "exists_lipschitzonwith": [
      1820
    ],
    "coetc": [
      1821,
      1822
    ],
    "instcoetccontinuouslinearmap": [
      1821,
      1822
    ],
    "linearisometryequiv": [
      1822
    ],
    "instcoetccontinuouslinearequiv": [
      1822
    ],
    "reinterpret": [
      1822
    ],
    "coe_coe": [
      1822
    ],
    "toisometryequiv": [
      1822
    ],
    "properlydiscontinuoussmul": [
      1823
    ],
    "properlydiscontinuousvadd": [
      1823
    ],
    "finite_disjoint_inter_image": [
      1823
    ],
    "export": [
      1823
    ],
    "ofobj": [
      1824,
      1825
    ],
    "todescentdata": [
      1824,
      1825
    ],
    "descentdata": [
      1824,
      1825
    ],
    "getppfunbindertypes": [
      1830
    ],
    "ppdomain": [
      1830
    ],
    "whenppoption": [
      1830
    ],
    "getappargs": [
      1830
    ],
    "guard": [
      1830
    ],
    "getexpr": [
      1830
    ],
    "islambda": [
      1830
    ],
    "getppoption": [
      1830
    ],
    "getppnotation": [
      1830
    ],
    "withoverapp": [
      1830
    ],
    "levels": [
      1834
    ],
    "eta": [
      1834
    ],
    "pullcore": [
      1834
    ],
    "infertype": [
      1834
    ],
    "to_fun": [
      1834
    ],
    "lambda": [
      1834
    ],
    "addrelateddecl": [
      1834
    ],
    "expanded": [
      1834
    ],
    "global": [
      1834
    ],
    "src": [
      1834
    ],
    "docstringprefix": [
      1834
    ],
    "real_inner_comm": [
      1836
    ],
    "sin_sq": [
      1836
    ],
    "real_inner_self_eq_norm_sq": [
      1836
    ],
    "inner_ortho_right_eq_sin_angle": [
      1836
    ],
    "inner_eq_one_iff_of_norm_eq_one": [
      1836
    ],
    "sq_ne_one_iff": [
      1836
    ],
    "inner_ortho_nonneg_of_norm_eq_one": [
      1836
    ],
    "normalize": [
      1836
    ],
    "inner_eq_neg_one_iff_of_norm_eq_one": [
      1836
    ],
    "sin": [
      1836
    ],
    "inner_sub_right": [
      1836
    ],
    "cos": [
      1836
    ],
    "realize_not": [
      1839,
      1840
    ],
    "iff_of_false": [
      1839,
      1840
    ],
    "realize_sentence": [
      1839,
      1840
    ],
    "models_not_iff": [
      1839,
      1840
    ],
    "sentence": [
      1839,
      1840
    ],
    "unusedarguments": [
      1841
    ],
    "lie_f_pow_toend_f": [
      1841
    ],
    "nolint": [
      1841
    ],
    "unusedvariables": [
      1841
    ],
    "lie_e_pow_succ_toend_f": [
      1842
    ],
    "cyclic": [
      1844
    ],
    "resolution": [
      1844
    ],
    "grouphomology": [
      1844
    ],
    "representations": [
      1844,
      1875
    ],
    "projective": [
      1844
    ],
    "finitecyclic": [
      1844
    ],
    "groups": [
      1844
    ],
    "homology": [
      1844
    ],
    "isopencover": [
      1849,
      1850
    ],
    "subpresheaf": [
      1852,
      1852,
      1853,
      1853,
      1854
    ],
    "presheaf": [
      1852,
      1853,
      1854
    ],
    "types": [
      1852,
      1853
    ],
    "valued": [
      1852,
      1853
    ],
    "ssup": [
      1854
    ],
    "min_obj": [
      1854
    ],
    "max_obj": [
      1854
    ],
    "isup_min": [
      1854
    ],
    "sinf": [
      1854
    ],
    "max_min": [
      1854
    ],
    "ssup_obj": [
      1854
    ],
    "isup_obj": [
      1854
    ],
    "sinf_obj": [
      1854
    ],
    "topresheaf": [
      1854
    ],
    "functorpushforward_mem_iff": [
      1855
    ],
    "finrank_le_finrank_of_rank_le_rank": [
      1856,
      1857
    ],
    "rank_lt_aleph0": [
      1856,
      1857
    ],
    "lift_rank_bot_le_lift_rank_of_isscalartower": [
      1856,
      1857
    ],
    "isupindep": [
      1858
    ],
    "noetherian": [
      1858
    ],
    "vectors": [
      1858
    ],
    "mem_span_singleton_self": [
      1858
    ],
    "extend_injective": [
      1859
    ],
    "le_of_fin_injective": [
      1859
    ],
    "strongrankcondition": [
      1859
    ],
    "extendbyzero": [
      1859
    ],
    "castle": [
      1859
    ],
    "strictmono_castle": [
      1859
    ],
    "not_succ_le_self": [
      1859
    ],
    "forgettotop": [
      1860
    ],
    "forgetful": [
      1860
    ],
    "scheme": [
      1860
    ],
    "coercion": [
      1860
    ],
    "carrier": [
      1860
    ],
    "forgettotop_obj_eq_coe": [
      1860
    ],
    "unif_hint": [
      1860
    ],
    "istightmeasureset_singleton_of_innerregularwrt": [
      1861
    ],
    "statements": [
      1861
    ],
    "tight": [
      1861
    ],
    "partialequiv": [
      1863
    ],
    "coshpartialequiv": [
      1863
    ],
    "arcosh": [
      1863
    ],
    "motive": [
      1871
    ],
    "neg_add": [
      1871
    ],
    "neg_add_one": [
      1871
    ],
    "hnm": [
      1871
    ],
    "add_two": [
      1871
    ],
    "negsucc_eq": [
      1871
    ],
    "induct": [
      1871
    ],
    "add_modeq_right": [
      1874
    ],
    "isotolinearequiv": [
      1875
    ],
    "hom_ofhom": [
      1875
    ],
    "conj_hom_eq_conj": [
      1875
    ],
    "fdrep": [
      1875
    ],
    "haslimit": [
      1877
    ],
    "cospan": [
      1877
    ],
    "exists_limit": [
      1877
    ],
    "homofle": [
      1878
    ],
    "id_single": [
      1878
    ],
    "id_pair": [
      1878
    ],
    "pairwisetoopenslecoverobj": [
      1878
    ],
    "lowercone_pt": [
      1879,
      1880
    ],
    "pointwiserightkanextension_obj": [
      1879,
      1880
    ],
    "proj_obj": [
      1879,
      1880
    ],
    "structuredarrow": [
      1879,
      1880
    ],
    "objectproperty": [
      1879,
      1880
    ],
    "map_obj_right": [
      1879,
      1880
    ],
    "openslecovercocone": [
      1879,
      1880
    ],
    "projsup_obj": [
      1879
    ],
    "op_obj": [
      1879
    ],
    "const_obj_obj": [
      1879
    ],
    "quiver": [
      1880
    ],
    "exists_le_of_le_sup": [
      1880
    ],
    "unop": [
      1880
    ],
    "condexp_ae_eq_restrict_of_measurablespace_eq_on": [
      1881
    ],
    "measurablespace_le": [
      1881,
      1882
    ],
    "trim": [
      1881,
      1882
    ],
    "sigmafinite": [
      1881,
      1882
    ],
    "measurablespace_min": [
      1881,
      1882
    ],
    "h_le": [
      1881,
      1882
    ],
    "sigmafinitetrim_mono": [
      1881,
      1882
    ],
    "measurableset_le_stopping_time": [
      1881
    ],
    "min": [
      1881,
      1882
    ],
    "havei": [
      1882,
      1885,
      1895
    ],
    "essentially": [
      1883
    ],
    "happen": [
      1883
    ],
    "objects": [
      1883
    ],
    "localization": [
      1883
    ],
    "constructed": [
      1883
    ],
    "situations": [
      1883
    ],
    "ae_eq_zero_of_integral_smooth_smul_eq_zero": [
      1885
    ],
    "secondcountable_of_sigmacompact": [
      1885
    ],
    "issigmacompact_iff_sigmacompactspace": [
      1885
    ],
    "chartedspace": [
      1885
    ],
    "locallycompactspace": [
      1885
    ],
    "exists_smooth_forall_closedball_subset": [
      1886,
      1887
    ],
    "exists_smooth_forall_mem_convex_of_local": [
      1886,
      1887
    ],
    "s_loc": [
      1886,
      1887
    ],
    "f_fiber": [
      1886,
      1887
    ],
    "forall_and": [
      1886,
      1887
    ],
    "exists_smooth_section_forall_mem_convex_of_local": [
      1886,
      1887
    ],
    "h_x_in_umap_j": [
      1886
    ],
    "emetric_closedball": [
      1887
    ],
    "semicontinuous": [
      1888
    ],
    "groupwithzero": [
      1888
    ],
    "closed_convex_function": [
      1889
    ],
    "semi": [
      1889
    ],
    "wiki": [
      1889
    ],
    "offunction_le": [
      1892
    ],
    "offunction": [
      1892
    ],
    "tonnreal_le_tonnreal": [
      1892
    ],
    "iinf_mono": [
      1892
    ],
    "reduce": [
      1892
    ],
    "mem_nhds_iff_exists_ioo_subset": [
      1892
    ],
    "stieltjesfunction_eq": [
      1892
    ],
    "tendsto_leftlim": [
      1892
    ],
    "argue": [
      1892
    ],
    "length_ioc": [
      1892
    ],
    "precompequivalence": [
      1893
    ],
    "costructuredarrow": [
      1893
    ],
    "isequivalence": [
      1893
    ],
    "denseat": [
      1893
    ],
    "whiskerequivalence": [
      1893
    ],
    "cocones": [
      1893
    ],
    "mapnatiso": [
      1893
    ],
    "algebras": [
      1894
    ],
    "quot": [
      1894
    ],
    "diamonds": [
      1894
    ],
    "instmonoidwithzero": [
      1894
    ],
    "ringquot": [
      1894
    ],
    "instaddcommmonoid": [
      1894
    ],
    "onfinset_support": [
      1895
    ],
    "irreducible_def": [
      1895
    ],
    "deceq": [
      1895
    ],
    "fincategory": [
      1896
    ],
    "fincategorydiscreteoffintype": [
      1896
    ],
    "reflgen": [
      1897
    ],
    "eqvgen": [
      1898
    ],
    "transgen": [
      1899
    ],
    "mk_map_of_archimedean": [
      1900
    ],
    "toorderaddmonoidhom": [
      1900
    ],
    "cauchy": [
      1904
    ]
  },
  "all_examples": [
    {
      "id": 0,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 9,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 18,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 27,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 36,
      "before_code": "cons_head?_tail (head!_mem_head? h)\n\ntheorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'",
      "suggestion": "\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n",
      "body": "```suggestion\r\n  simpa [cons_head!_tail h] using l.tail.mem_cons_self (a := l.head!)\r\n```\r\nmaybe?",
      "path": "Mathlib/Data/List/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "cons_head",
          "rwa",
          "theorem",
          "Inhabited",
          "head",
          "have",
          "nil",
          "_mem_head",
          "List",
          "mem_cons_self",
          "tail",
          "_mem_self",
          "_tail"
        ]
      }
    },
    {
      "id": 52,
      "before_code": "attribute will add a `to_dual none` tag to an `_assoc` theorem if the original theorem was\nalready tagged with `to_dual`. This also works with `to_dual (attr := reassoc)`.\n\nWhen troubleshooting, you can see what `to_dual` is doing by replacing it with `to_dual?` and/or",
      "suggestion": "\r\n",
      "body": "A copy of the paragraph above seems to have crept in during a merge.\r\n\r\n```suggestion\r\n```",
      "path": "Mathlib/Tactic/Translate/ToDual.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "was",
          "tagged",
          "to_dual",
          "already",
          "troubleshooting",
          "When",
          "add",
          "replacing",
          "This",
          "original",
          "works",
          "tag",
          "see",
          "also",
          "can",
          "attr",
          "none",
          "_assoc",
          "you",
          "will",
          "attribute",
          "theorem",
          "what",
          "reassoc",
          "doing"
        ]
      }
    },
    {
      "id": 57,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  \u00b7 exact Subsingleton.allEq ..\r\n",
      "body": "```suggestion\r\n  \u00b7 exact Subsingleton.allEq ..\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 62,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  simp [\u2190 degree_preimage_nsmul, hn]\r\n",
      "body": "You are missing the following lemmas\r\n```lean\r\nopen scoped Pointwise in\r\nlemma exists_le_degree_eq {\u03c3 : Type*} (f : \u03c3 \u2192\u2080 \u2115) (n : \u2115) (hn : n \u2264 f.degree) :\r\n    \u2203 g \u2264 f, g.degree = n := by\r\n  induction n with\r\n  | zero => simp [degree_eq_zero_iff]\r\n  | succ n IH =>\r\n    obtain \u27e8g, hgf, rfl\u27e9 := IH (by lia)\r\n    obtain \u27e8f, rfl\u27e9 := le_iff_exists_add.mp hgf\r\n    obtain \u27e8i, hi\u27e9 : f.support.Nonempty := by aesop\r\n    exact \u27e8g + .single i 1, add_le_add_right (by simp; grind) _, by simp\u27e9\r\n\r\nopen scoped Poi",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "exact",
          "grind",
          "obtain",
          "induction",
          "simp_all",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 63,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  \u00b7 simp [hn]\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [hn]\r\n```\r\nIf you add this as a simp lemma\r\n```lean\r\n@[simp]\r\nlemma Set.Ici_zero {\u03b1 : Type*} [AddZeroClass \u03b1] [Preorder \u03b1] [CanonicallyOrderedAdd \u03b1] :\r\n    Set.Ici (0 : \u03b1) = Set.univ := by aesop\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 70,
      "before_code": "hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\nend Dense",
      "suggestion": "  \u27e8fun h \u21a6 by simpa using congr($h\u15ee), fun h \u21a6 congr($h\u15ee)\u27e9\n",
      "body": "```suggestion\n  \u27e8fun h \u21a6 by simpa using congr($h\u15ee), fun h \u21a6 congr($h\u15ee)\u27e9\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "congr"
        ],
        "new_tactics": [
          "simpa",
          "congr"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "inner_zero_right",
          "end",
          "Dense",
          "eq_of_inner_right"
        ]
      }
    },
    {
      "id": 71,
      "before_code": "hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\nend Dense",
      "suggestion": "theorem orthogonal_injective [CompleteSpace E] :\n    Function.Injective (fun K : ClosedSubmodule \ud835\udd5c E \u21a6 K\u15ee) :=\n  (orthogonal_eq_orthogonal_iff \u00b7 \u00b7 |>.mp)\n\n/-- The sup of two orthogonal subspaces equals the subspace orthogonal\nto the inf. -/\ntheorem sup_orthogonal [CompleteSpace E] (K\u2081 K\u2082 : ClosedSubmodule \ud835\udd5c E) :\n    K\u2081\u15ee \u2294 K\u2082\u15ee = (K\u2081 \u2293 K\u2082)\u15ee := by\n  simpa using congr($(inf_orthogonal K\u2081\u15ee K\u2082\u15ee)\u15ee).symm\n",
      "body": "Here's a another `simpa` proof, and let's have this `orthogonal_injective` lemma too.\n```suggestion\ntheorem orthogonal_injective [CompleteSpace E] :\n    Function.Injective (fun K : ClosedSubmodule \ud835\udd5c E \u21a6 K\u15ee) :=\n  (orthogonal_eq_orthogonal_iff \u00b7 \u00b7 |>.mp)\n\n/-- The sup of two orthogonal subspaces equals the subspace orthogonal\nto the inf. -/\ntheorem sup_orthogonal [CompleteSpace E] (K\u2081 K\u2082 : ClosedSubmodule \ud835\udd5c E) :\n    K\u2081\u15ee \u2294 K\u2082\u15ee = (K\u2081 \u2293 K\u2082)\u15ee := by\n  simpa using congr($(inf_orthogonal K\u2081\u15ee K\u2082\u15ee)\u15ee).symm\n`",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "congr",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "congr"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "inner_zero_right",
          "end",
          "Dense",
          "eq_of_inner_right"
        ]
      }
    },
    {
      "id": 72,
      "before_code": "theorem continuous_closure : Continuous (Closeds.closure (\u03b1 := \u03b1)) :=\n  uniformContinuous_closure.continuous",
      "suggestion": "instance [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) where\n  isCompact_univ := by simpa [gi.l_surjective.range_eq]\n    using isCompact_univ.image continuous_closure\n",
      "body": "```suggestion\ninstance [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) where\n  isCompact_univ := by simpa [gi.l_surjective.range_eq]\n    using isCompact_univ.image continuous_closure\n```",
      "path": "Mathlib/Topology/UniformSpace/Closeds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "theorem",
          "closure",
          "continuous_closure",
          "continuous",
          "Closeds",
          "Continuous",
          "uniformContinuous_closure"
        ]
      }
    },
    {
      "id": 75,
      "before_code": "apply ext_support\n    simp only [\u2190 h, support_append, support_copy, take_support_eq_support_take_succ,\n      List.take_append, drop_support_eq_support_drop_min, List.tail_drop]\n    rw [Nat.min_eq_left (by grind [length_support]), List.drop_append, List.drop_append,\n      List.drop_eq_nil_of_le (by lia), List.drop_eq_nil_of_le (by grind [length_support]),\n      p\u2081.support_eq_cons]\n    simp +arith",
      "suggestion": "@[simp] theorem isSubwalk_nil_iff_mem_support {u v v'} (p : G.Walk u v) :\n",
      "body": "```suggestion\n@[simp] theorem isSubwalk_nil_iff_mem_support {u v v'} (p : G.Walk u v) :\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Walks/Subwalks.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "grind",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "grind",
          "rw"
        ],
        "topics": [
          "list",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "support_eq_cons",
          "apply",
          "take_append",
          "grind",
          "Nat",
          "support_copy",
          "drop_support_eq_support_drop_min",
          "length_support",
          "lia",
          "drop_eq_nil_of_le",
          "support_append",
          "tail_drop",
          "arith",
          "simp",
          "only",
          "take_support_eq_support_take_succ",
          "min_eq_left",
          "List",
          "drop_append",
          "ext_support"
        ]
      }
    },
    {
      "id": 78,
      "before_code": "instance isRegularEpi_of_extremalEpi (f : X \u27f6 Y) [ExtremalEpi f] : IsRegularEpi f :=\n  \u27e8\u27e8regularEpiOfExtremalEpi f\u27e9\u27e9",
      "suggestion": "noncomputable def frobeniusMorphism :\n  underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n  (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip.lift\n    ((ofLE _ _ (inf_le_right A' ((Subobject.pullback f).obj B'))) \u226b (pullback\u03c0 _ _))\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))) \u226b (imageFactorisation f A').F.e)\n    (by simp [\u2190 imageFactorisation_F_m, (isPullback _ _).w])\n\nlemma frobeniusMorphism_isPullback :\n  IsPullback (frobeniusMorphism f A' B')\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))))\n    ((ofLE _ _ (inf_le_left ((\u00abexists\u00bb f).obj A') B')))\n    (imageFactorisation _ _).F.e := by\n  apply IsPullback.of_right (t := (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip)\n    (p := by simp [frobeniusMorphism])\n  simpa [frobeniusMorphism, IsPullback.lift_fst, \u2190 imageFactorisation_F_m,\n    (isPullback f B').paste_horiz_iff ] using\n    (inf_isPullback A' ((Subobject.pullback f).obj B')).flip\n\ninstance : IsRegula",
      "body": "```suggestion\nnoncomputable def frobeniusMorphism :\n  underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n  (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip.lift\n    ((ofLE _ _ (inf_le_right A' ((Subobject.pullback f).obj B'))) \u226b (pullback\u03c0 _ _))\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))) \u226b (imageFactorisation f A').F.e)\n    (by simp [\u2190 imageFactorisation_F_m, (isPullback _ _).w])\n\nlemma frobeniusMorphism_isPullback :\n  IsPullbac",
      "path": "Mathlib/CategoryTheory/RegularCategory/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "rw",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "IsRegularEpi",
          "regularEpiOfExtremalEpi",
          "isRegularEpi_of_extremalEpi",
          "instance",
          "ExtremalEpi"
        ]
      }
    },
    {
      "id": 81,
      "before_code": "p.darts[i].snd = p.support.tail[i]'(by grind) := by\n  grind [map_snd_darts]",
      "suggestion": "lemma support_getElem_zero (p : G.Walk u v) : p.support[0] = u := by cases p <;> simp\n",
      "body": "```suggestion\nlemma support_getElem_zero (p : G.Walk u v) : p.support[0] = u := by cases p <;> simp\n```\nThis seems to work for me",
      "path": "Mathlib/Combinatorics/SimpleGraph/Walks/Basic.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "grind"
        ],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support",
          "map_snd_darts",
          "grind",
          "tail",
          "snd",
          "darts"
        ]
      }
    },
    {
      "id": 82,
      "before_code": "Sbtw R w x y :=\n  \u27e8h\u2081.wbtw.trans_right_left h\u2082.wbtw, h\u2081.ne_left, h\u2082.left_ne\u27e9",
      "suggestion": "\r\n    \u00b7 constructor\r\n      \u00b7 apply div_nonneg (mul_nonneg ht\u2081.1 ht\u2082.1)\r\n        nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n      \u00b7 apply div_le_one_of_le\u2080\r\n        \u00b7 grind\r\n        \u00b7 nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n",
      "body": "```suggestion\r\n    \u00b7 constructor\r\n      \u00b7 apply div_nonneg (mul_nonneg ht\u2081.1 ht\u2082.1)\r\n        nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n      \u00b7 apply div_le_one_of_le\u2080\r\n        \u00b7 grind\r\n        \u00b7 nlinarith [ht\u2081.1, ht\u2081.2, ht\u2082.1, ht\u2082.2]\r\n```",
      "path": "Mathlib/Analysis/Convex/Between.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "nlinarith",
          "apply",
          "grind",
          "constructor"
        ],
        "body_tactics": [
          "nlinarith",
          "apply",
          "grind",
          "constructor"
        ],
        "new_tactics": [
          "nlinarith",
          "apply",
          "grind",
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "wbtw",
          "trans_right_left",
          "Sbtw",
          "ne_left",
          "left_ne"
        ]
      }
    },
    {
      "id": 91,
      "before_code": "\u03c9ScottContinuous.of_monotone_map_\u03c9Sup\n    \u27e8fun _ _ h \u21a6 hf.monotone h a, fun c \u21a6 congr_fun (hf.map_\u03c9Sup c) a\u27e9",
      "suggestion": "\r\nlemma \u03c9ScottContinuous.apply (x : \u03b1) : \u03c9ScottContinuous (fun f : \u2200 x, \u03b2 x \u21a6 f x) :=\r\n",
      "body": "```suggestion\r\nlemma \u03c9ScottContinuous.apply (x : \u03b1) : \u03c9ScottContinuous (fun f : \u2200 x, \u03b2 x \u21a6 f x) :=\r\n```",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "monotone",
          "congr_fun"
        ]
      }
    },
    {
      "id": 94,
      "before_code": "simpa [map_coe, OrderHom.coe_mk, Set.range_comp]\n    using hf (by simp) (Set.range_nonempty _) (isChain_range c).directedOn (isLUB_range_\u03c9Sup c)",
      "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```\r\nThis way, the `fun_id` lemma is also tagged with fun_prop.",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "OrderHom",
          "range_comp",
          "map_coe",
          "coe_mk",
          "Set",
          "directedOn",
          "simpa",
          "simp",
          "range_nonempty",
          "isChain_range",
          "using"
        ]
      }
    },
    {
      "id": 95,
      "before_code": "inter_eq_self_of_subset_right (Ici_subset_Ici.2 hab)]\n  exact isLeast_Ici\n\n@[simp] lemma ScottContinuousOn.id : ScottContinuousOn D (id : \u03b1 \u2192 \u03b1) := by simp [ScottContinuousOn]\n\nvariable {g : \u03b1 \u2192 \u03b2}\n\nlemma ScottContinuousOn.prodMk (hD : \u2200 a b : \u03b1, a \u2264 b \u2192 {a, b} \u2208 D)",
      "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```",
      "path": "Mathlib/Order/ScottContinuity.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "continuity",
          "set_theory"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "Ici_subset_Ici",
          "inter_eq_self_of_subset_right",
          "lemma",
          "variable",
          "exact",
          "ScottContinuousOn",
          "hab",
          "isLeast_Ici",
          "simp",
          "prodMk"
        ]
      }
    },
    {
      "id": 97,
      "before_code": "theorem \u03c9Sup_zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : \u03c9Sup (c\u2080.zip c\u2081) = (\u03c9Sup c\u2080, \u03c9Sup c\u2081) := rfl",
      "suggestion": "    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n",
      "body": "Something like\n```suggestion\n    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n```\nshould work, and then you can remove the `by exact` and (probably) format everything on one line.",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "rfl",
          "Chain",
          "zip",
          "theorem"
        ]
      }
    },
    {
      "id": 99,
      "before_code": "OmegaCompletePartialOrder.lift ContinuousHom.toMono ContinuousHom.\u03c9Sup\n    (fun _ _ h => h) (fun _ => rfl)\n\nnamespace Prod\n\n/-- The application of continuous functions as a continuous function. -/\n@[simps]\ndef apply : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1 \u2192\ud835\udc84 \u03b2 where\n  toFun f := f.1 f.2\n  monotone' x y h := by\n    dsimp\n    trans y.fst x.snd <;> [apply h.1; apply y.1.monotone h.2]\n  map_\u03c9Sup' c := by\n    apply le_antisymm\n    \u00b7 apply \u03c9Sup_le\n      intro i\n      dsimp\n      rw [(c _).fst.continuous]\n      apply \u03c9Sup_le\n      intro j\n      apply le_\u03c9Sup_of_le (max i j)\n      apply apply_mono\n      \u00b7 exact monotone_fst (OrderHom.mono _ (le_max_left _ _))\n      \u00b7 exact monotone_snd (OrderHom.mono _ (le_max_right _ _))\n    \u00b7 apply \u03c9Sup_le\n      intro i\n      apply le_\u03c9Sup_of_le i\n      dsimp\n      apply OrderHom.mono _\n      apply le_\u03c9Sup_of_le i\n      rfl",
      "suggestion": "def apply : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1 \u2192\ud835\udc84 \u03b2 := ofFun (fun f \u21a6 f.1 f.2)\n",
      "body": "```suggestion\ndef apply : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1 \u2192\ud835\udc84 \u03b2 := ofFun (fun f \u21a6 f.1 f.2)\n```",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw",
          "intro"
        ],
        "topics": [
          "continuity",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "OrderHom",
          "monotone_fst",
          "le_antisymm",
          "le_max_left",
          "lift",
          "snd",
          "apply_mono",
          "apply",
          "mono",
          "monotone",
          "fst",
          "OmegaCompletePartialOrder",
          "max",
          "intro",
          "Prod",
          "def",
          "toFun",
          "simps",
          "rfl",
          "application",
          "dsimp",
          "namespace",
          "function",
          "ContinuousHom",
          "exact",
          "continuous",
          "trans",
          "toMono",
          "le_max_right",
          "functions",
          "monotone_snd"
        ]
      }
    },
    {
      "id": 100,
      "before_code": "pure (.done r)\n      catch _ => pure <| .continue\n    let post := Simp.postDefault #[]\n    (\u00b7.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })",
      "suggestion": "\r\n      (methods := { pre, post, wellBehavedDischarge })\r\n",
      "body": "```suggestion\r\n      (methods := { pre, post, wellBehavedDischarge })\r\n```",
      "path": "Mathlib/Util/AtomM/Recurse.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "done",
          "continue",
          "post",
          "nctx",
          "parent",
          "pre",
          "catch",
          "ctx",
          "pure",
          "methods",
          "main",
          "postDefault",
          "Simp"
        ]
      }
    },
    {
      "id": 113,
      "before_code": "pure (.done r)\n      catch _ => pure <| .continue\n    let post := Simp.postDefault #[]\n    (\u00b7.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\n/--\nRuns a tactic in the `AtomM.RecurseM` monad, given initial data:\n\n* `s`: a reference to the mutable `AtomM` state, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options",
      "suggestion": "\r\n  Reason: it would cause `simp` to cache results too aggressively.\r\n",
      "body": "```suggestion\r\n  Reason: it would cause `simp` to cache results too aggressively.\r\n```",
      "path": "Mathlib/Util/AtomM/Recurse.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "done",
          "nctx",
          "consistently",
          "main",
          "reference",
          "persisting",
          "ordering",
          "This",
          "configuration",
          "catch",
          "initial",
          "ctx",
          "across",
          "methods",
          "continue",
          "Simp",
          "Runs",
          "monad",
          "RecurseM",
          "for",
          "pre",
          "used",
          "mutable",
          "that",
          "pure",
          "state",
          "tactic",
          "AtomM",
          "given",
          "postDefault",
          "data",
          "cfg",
          "post",
          "parent",
          "options",
          "ensures",
          "calls",
          "atom"
        ]
      }
    },
    {
      "id": 114,
      "before_code": "* `s`: a reference to the mutable `AtomM` state, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options",
      "suggestion": "\r\n  Reason: it would cause `simp` to cache results too aggressively.\r\n",
      "body": "```suggestion\r\n  Reason: it would cause `simp` to cache results too aggressively.\r\n```",
      "path": "Mathlib/Util/AtomM/Recurse.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "persisting",
          "ordering",
          "This",
          "cfg",
          "options",
          "consistently",
          "used",
          "configuration",
          "mutable",
          "ensures",
          "that",
          "across",
          "for",
          "state",
          "AtomM",
          "calls",
          "atom",
          "reference"
        ]
      }
    },
    {
      "id": 116,
      "before_code": "obtain \u27e8s, rfl\u27e9 := hN\n    induction s using Finset.induction with\n    | empty =>\n      rw [Finset.coe_empty, Submodule.span_empty, \u2190 Submodule.span_zero_singleton]\n      exact h\u2081 _\n    | insert _ _ _ ih =>\n      rw [Finset.coe_insert, Submodule.span_insert]\n      exact h\u2082 _ _ (h\u2081 _) ih\n\ntheorem fg_restrictScalars {R S M : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommMonoid M] [Module S M] [Module R M] [IsScalarTower R S M] (N : Submodule S M)\n    (hfin : N.FG) (h : Function.Surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).FG := by\n  obtain \u27e8X, rfl\u27e9 := hfin\n  use X\n  exact (Submodule.restrictScalars_span R S h (X : Set M)).symm\n\nlemma FG.of_restrictScalars (R) {A M} [Semiring R] [Semiring A] [AddCommMonoid M]\n    [SMul R A] [Module R M] [Module A M] [IsScalarTower R A M] (S : Submodule A M)\n    (hS : (S.restrictScalars R).FG) : S.FG := by\n  obtain \u27e8s, e\u27e9 := hS\n  refine \u27e8s, Submodule.restrictScalars_injective R _ _ (le_antisymm ?_ ?_)\u27e9\n  \u00b7 change Submodule.span A s \u2264 S\n    have := Submodule.span_le.mp e.le\n    rwa [Submodule.span_le]\n  \u00b7 rw [\u2190 e]\n    exact Submodule.span_le_restrictScalars _ _ _\n\ntheorem FG.stabilizes_of_iSup_eq {M' : Submodule R M} (hM' : M'.FG) (N : \u2115 \u2192o Submodule R M)\n    (H : iSup N = M') : \u2203 n, M' = N n := by\n  obtain \u27e8S, hS\u27e9 := hM'\n  have : \u2200 s : S, \u2203 n, (s : M) \u2208 N n := fun s =>\n    (Submodule.mem_iSup_of_chain N s).mp\n      (by\n        rw [H, \u2190 hS]\n        exact Submodule.subset_span s.2)",
      "suggestion": "\r\n  have (s : S) : \u2203 n, (s : M) \u2208 N n :=\r\n    (mem_iSup_of_chain N s).mp (by simpa [H, \u2190 hS] using subset_span s.prop)\r\n",
      "body": "```suggestion\r\n  have (s : S) : \u2203 n, (s : M) \u2208 N n :=\r\n    (mem_iSup_of_chain N s).mp (by simpa [H, \u2190 hS] using subset_span s.prop)\r\n```",
      "path": "Mathlib/RingTheory/Finiteness/Basic.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "induction"
        ],
        "suggestion_tactics": [
          "simpa",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "have"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "refine",
          "exact",
          "obtain",
          "induction",
          "rw"
        ],
        "topics": [
          "function",
          "nat",
          "algebra",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Module",
          "lemma",
          "rwa",
          "fg_restrictScalars",
          "le_antisymm",
          "Type",
          "change",
          "obtain",
          "of_restrictScalars",
          "Function",
          "span_zero_singleton",
          "coe_empty",
          "empty",
          "insert",
          "restrictScalars",
          "symm",
          "refine",
          "span_insert",
          "Finset",
          "have",
          "Submodule",
          "span_empty",
          "mem_iSup_of_chain",
          "span_le_restrictScalars",
          "CommSemiring",
          "restrictScalars_injective",
          "hfin",
          "span",
          "stabilizes_of_iSup_eq",
          "Semiring",
          "induction",
          "rfl",
          "use",
          "subset_span",
          "AddCommMonoid",
          "theorem",
          "IsScalarTower",
          "exact",
          "Set",
          "iSup",
          "coe_insert",
          "restrictScalars_span",
          "SMul",
          "algebraMap",
          "Algebra",
          "Surjective",
          "span_le",
          "using"
        ]
      }
    },
    {
      "id": 124,
      "before_code": "namespace Complex\n\n/-- If `f` is complex differentiable on an open disc with center `c` and radius `R > 0` and is\ncontinuous on its closure, then `f' c` can be represented as an integral over the corresponding\ncircle.\n\nTODO: add a version for `w \u2208 Metric.ball c R`.\n\nTODO: add a version for higher derivatives. -/\ntheorem deriv_eq_smul_circleIntegral [CompleteSpace F] {R : \u211d} {c : \u2102} {f : \u2102 \u2192 F} (hR : 0 < R)\n    (hf : DiffContOnCl \u2102 f (ball c R)) :\n    deriv f c = (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e z in C(c, R), (z - c) ^ (-2 : \u2124) \u2022 f z := by\n  lift R to \u211d\u22650 using hR.le\n  refine (hf.hasFPowerSeriesOnBall hR).hasFPowerSeriesAt.deriv.trans ?_\n  simp only [cauchyPowerSeries_apply, one_div, zpow_neg, pow_one, smul_smul, zpow_two, mul_inv]\n\ntheorem norm_deriv_le_aux [CompleteSpace F] {c : \u2102} {R C : \u211d} {f : \u2102 \u2192 F} (hR : 0 < R)\n    (hf : DiffContOnCl \u2102 f (ball c R)) (hC : \u2200 z \u2208 sphere c R, \u2016f z\u2016 \u2264 C) :\n    \u2016deriv f c\u2016 \u2264 C / R := by\n  have : \u2200 z \u2208 sphere c R, \u2016(z - c) ^ (-2 : \u2124) \u2022 f z\u2016 \u2264 C / (R * R) :=\n    fun z (hz : \u2016z - c\u2016 = R) => by\n    simpa [-mul_inv_rev, norm_smul, hz, zpow_two, \u2190 div_eq_inv_mul] using\n      (div_le_div_iff_of_pos_right (mul_pos hR hR)).2 (hC z hz)",
      "suggestion": "\r\n    rw [\u2190 inv_smul_smul\u2080 two_pi_I_ne_zero (deriv f c)]\r\n    simp [\u2190 (DiffContOnCl.deriv_eq_smul_circleIntegral hR hf), zpow_ofNat]\r\n",
      "body": "alternative proof (matter of taste really):\r\n```suggestion\r\n    rw [\u2190 inv_smul_smul\u2080 two_pi_I_ne_zero (deriv f c)]\r\n    simp [\u2190 (DiffContOnCl.deriv_eq_smul_circleIntegral hR hf), zpow_ofNat]\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "refine",
          "have",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simpa",
          "have",
          "refine"
        ],
        "topics": [
          "continuity",
          "real",
          "complex",
          "norm",
          "differentiability",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "CompleteSpace",
          "norm_deriv_le_aux",
          "its",
          "closure",
          "complex",
          "deriv_eq_smul_circleIntegral",
          "Metric",
          "lift",
          "represented",
          "open",
          "center",
          "TODO",
          "circle",
          "add",
          "derivatives",
          "mul_inv",
          "refine",
          "Complex",
          "div_eq_inv_mul",
          "norm_smul",
          "corresponding",
          "have",
          "mul_inv_rev",
          "differentiable",
          "zpow_neg",
          "smul_smul",
          "pow_one",
          "for",
          "hasFPowerSeriesOnBall",
          "can",
          "radius",
          "hasFPowerSeriesAt",
          "then",
          "deriv",
          "over",
          "simp",
          "cauchyPowerSeries_apply",
          "zpow_two",
          "version",
          "disc",
          "namespace",
          "only",
          "div_le_div_iff_of_pos_right",
          "mul_pos",
          "DiffContOnCl",
          "theorem",
          "sphere",
          "higher",
          "continuous",
          "simpa"
        ]
      }
    },
    {
      "id": 125,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n        rw [\u2190 (DiffContOnCl.circleIntegral_one_div_sub_center_pow_smul hR n hf)]\r\n",
      "body": "Please keep indentation consistent inside `calc` blocks, it aids readability. \r\n\r\nIf you're using `congr` followed by `exact`, it's worth trying whether `rw` (or `simp_rw`, `simp only` etc) can do it in one line:\r\n```suggestion\r\n        rw [\u2190 (DiffContOnCl.circleIntegral_one_div_sub_center_pow_smul hR n hf)]\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 126,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n      rw [RCLike.norm_nsmul (K := \u2102), nsmul_eq_mul, mul_le_mul_iff_right\u2080 (by positivity)]\r\n      exact circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const hR.le hp\r\n",
      "body": "```suggestion\r\n      rw [RCLike.norm_nsmul (K := \u2102), nsmul_eq_mul, mul_le_mul_iff_right\u2080 (by positivity)]\r\n      exact circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const hR.le hp\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 127,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n  have hp (z) (hz : \u2016z - c\u2016 = R) : \u2016(z - c)\u207b\u00b9 ^ (n + 1) \u2022 f z\u2016 \u2264 C / (R ^ n  * R) := by\r\n    simpa [norm_smul, hz, \u2190 div_eq_inv_mul]\r\n      using (div_le_div_iff_of_pos_right (mul_pos (pow_pos hR n) hR)).2 (hC z hz)\r\n",
      "body": "You can introduce variables in a `have` statement, just like you can for theorems; then you don't need to intro them manually in the proof. Also, technically the `simp` here is non-terminal, which is against mathlib rules; but you can combine the `simp` and the following `exact` into a single statement with `simpa using`:\r\n```suggestion\r\n  have hp (z) (hz : \u2016z - c\u2016 = R) : \u2016(z - c)\u207b\u00b9 ^ (n + 1) \u2022 f z\u2016 \u2264 C / (R ^ n  * R) := by\r\n    simpa [norm_smul, hz, \u2190 div_eq_inv_mul]\r\n      using (div_le_div_if",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 137,
      "before_code": "case g2 => simp [Equiv.toPEquiv_apply]\n  case g3 => simp [Equiv.toPEquiv_apply, \u2190 Equiv.eq_symm_apply]",
      "suggestion": "\r\nlemma rowStochastic_inf_colStochastic :\r\n    rowStochastic R n \u2293 colStochastic R n = doublyStochastic R n := by\r\n  ext M\r\n  simp only [rowStochastic, colStochastic, Submonoid.mem_inf, Submonoid.mem_mk, Subsemigroup.mem_mk,\r\n    Set.mem_setOf_eq, doublyStochastic]\r\n  grind\r\n",
      "body": "I would phrase this as an equality of submonoids. Also, `grind` is a pretty nice tactic. I suggest that you try to play around with it and read about it to learn its power.\r\n\r\nCan you also move this much closer to the top of the file and use it to golf some of the other results in this file? (e.g., `convex_doublyStochastic` and `permMatrix_mem_doublyStochastic`)\r\n```suggestion\r\nlemma rowStochastic_inf_colStochastic :\r\n    rowStochastic R n \u2293 colStochastic R n = doublyStochastic R n := by\r\n  ext ",
      "path": "Mathlib/Data/Matrix/DoublyStochastic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "grind",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "grind",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "eq_symm_apply",
          "Equiv",
          "case",
          "simp",
          "toPEquiv_apply"
        ]
      }
    },
    {
      "id": 141,
      "before_code": "end Algebra\n\nend MvPolynomial",
      "suggestion": "\r\n    (\u2200 x \u2208 adjoin R S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) :=\r\n  AlgHom.eqOn_adjoin_iff (\u03c6 := MulSemiringAction.toAlgHom R A m) (\u03c8 := .id R A)\r\n",
      "body": "```suggestion\r\n    (\u2200 x \u2208 adjoin R S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) :=\r\n  AlgHom.eqOn_adjoin_iff (\u03c6 := MulSemiringAction.toAlgHom R A m) (\u03c8 := .id R A)\r\n```\r\nI think this can go in the same section as `AlgHom.eqOn_adjoin_iff`",
      "path": "Mathlib/Algebra/MvPolynomial/Eval.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Algebra",
          "MvPolynomial",
          "end"
        ]
      }
    },
    {
      "id": 142,
      "before_code": "simp only [mem_adjoin_iff_div, Algebra.adjoin_singleton_eq_range_aeval,\n    AlgHom.mem_range, exists_exists_eq_and]",
      "suggestion": "\r\ntheorem forall_mem_adjoin_smul_eq_self_iff {M : Type*} [Group M] [MulSemiringAction M E]\r\n    [SMulCommClass M F E] (m : M) :\r\n    (\u2200 x \u2208 adjoin F S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) := by\r\n  refine \u27e8fun h x hx \u21a6 h _ <| mem_adjoin_of_mem F hx, fun h x hx \u21a6 ?_\u27e9\r\n  induction hx using adjoin_induction F <;> simp_all [smul_inv\u2080']\r\n",
      "body": "Here is an almost working suggestion:\r\n```suggestion\r\ntheorem forall_mem_adjoin_smul_eq_self_iff {M : Type*} [Group M] [MulSemiringAction M E]\r\n    [SMulCommClass M F E] (m : M) :\r\n    (\u2200 x \u2208 adjoin F S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) := by\r\n  refine \u27e8fun h x hx \u21a6 h _ <| mem_adjoin_of_mem F hx, fun h x hx \u21a6 ?_\u27e9\r\n  induction hx using adjoin_induction F <;> simp_all [smul_inv\u2080']\r\n```\r\nThe problem is that this requires `M` to be a group because [smul_inv\u2080'](https://leanprover-community.github.io",
      "path": "Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "induction",
          "simp_all"
        ],
        "body_tactics": [
          "refine",
          "induction",
          "simp_all"
        ],
        "new_tactics": [
          "simp_all",
          "induction",
          "refine"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "mem_adjoin_iff_div",
          "mem_range",
          "exists_exists_eq_and",
          "simp",
          "AlgHom",
          "adjoin_singleton_eq_range_aeval",
          "Algebra",
          "only"
        ]
      }
    },
    {
      "id": 161,
      "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
      "suggestion": "  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n",
      "body": "```suggestion\n  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n```",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "nullMeasurable",
          "g_mble",
          "Set",
          "Countable",
          "Measurable"
        ]
      }
    },
    {
      "id": 162,
      "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
      "suggestion": "  apply ae_sum_iff.2 (fun n \u21a6 (hD n s hs).trans ?_)\n",
      "body": "```suggestion\n  apply ae_sum_iff.2 (fun n \u21a6 (hD n s hs).trans ?_)\n```",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "nullMeasurable",
          "g_mble",
          "Set",
          "Countable",
          "Measurable"
        ]
      }
    },
    {
      "id": 165,
      "before_code": "section map\n\nuniverse u\nsection Submodule\n\nvariable {R : Type*} {M N : Type u} [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N]\n  [Module R N] (f : M \u2192\u2097[R] N) (p : Submodule R M)\n\nlemma Submodule.spanRank_map_le : (p.map f).spanRank \u2264 p.spanRank := by\n  rw [\u2190 generators_card p, FG.spanRank_le_iff_exists_span_set_card_le]\n  exact \u27e8f '' p.generators, Cardinal.mk_image_le, le_antisymm (span_le.2 (fun n \u27e8m, hm, h\u27e9 \u21a6\n    \u27e8m, span_generators p \u25b8 subset_span hm, h\u27e9)) (by simp [span_generators])\u27e9\n\nvariable {p} in\nlemma Submodule.spanFinrank_map_le_of_fg (hp : p.FG) : (p.map f).spanFinrank \u2264 p.spanFinrank :=\n  (Cardinal.toNat_le_iff_le_of_lt_aleph0 (spanRank_finite_iff_fg.mpr (FG.map f hp))\n    (spanRank_finite_iff_fg.mpr hp)).2 (p.spanRank_map_le f)",
      "suggestion": "lemma spanRank_map_eq_of_injective {\u03c3 : R \u2192+* S} [RingHomSurjective \u03c3]\n",
      "body": "```suggestion\nlemma spanRank_map_eq_of_injective {\u03c3 : R \u2192+* S} [RingHomSurjective \u03c3]\n```",
      "path": "Mathlib/Algebra/Module/SpanRank.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "finset",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "generators_card",
          "Module",
          "spanFinrank_map_le_of_fg",
          "mpr",
          "lemma",
          "le_antisymm",
          "Type",
          "mk_image_le",
          "spanFinrank",
          "section",
          "spanRank_finite_iff_fg",
          "spanRank_le_iff_exists_span_set_card_le",
          "universe",
          "toNat_le_iff_le_of_lt_aleph0",
          "Submodule",
          "map",
          "Cardinal",
          "variable",
          "generators",
          "Semiring",
          "spanRank",
          "simp",
          "subset_span",
          "AddCommMonoid",
          "span_generators",
          "exact",
          "spanRank_map_le",
          "span_le"
        ]
      }
    },
    {
      "id": 166,
      "before_code": "section map\n\nuniverse u\nsection Submodule\n\nvariable {R : Type*} {M N : Type u} [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N]\n  [Module R N] (f : M \u2192\u2097[R] N) (p : Submodule R M)\n\nlemma Submodule.spanRank_map_le : (p.map f).spanRank \u2264 p.spanRank := by\n  rw [\u2190 generators_card p, FG.spanRank_le_iff_exists_span_set_card_le]\n  exact \u27e8f '' p.generators, Cardinal.mk_image_le, le_antisymm (span_le.2 (fun n \u27e8m, hm, h\u27e9 \u21a6\n    \u27e8m, span_generators p \u25b8 subset_span hm, h\u27e9)) (by simp [span_generators])\u27e9\n\nvariable {p} in\nlemma Submodule.spanFinrank_map_le_of_fg (hp : p.FG) : (p.map f).spanFinrank \u2264 p.spanFinrank :=\n  (Cardinal.toNat_le_iff_le_of_lt_aleph0 (spanRank_finite_iff_fg.mpr (FG.map f hp))\n    (spanRank_finite_iff_fg.mpr hp)).2 (p.spanRank_map_le f)",
      "suggestion": "lemma spanRank_range_le {\u03c3 : R \u2192+* S} [RingHomSurjective \u03c3] (f : M \u2192\u209b\u2097[\u03c3] N) :\n    (LinearMap.range f).spanRank \u2264 (\u22a4 : Submodule R M).spanRank := by\n",
      "body": "```suggestion\nlemma spanRank_range_le {\u03c3 : R \u2192+* S} [RingHomSurjective \u03c3] (f : M \u2192\u209b\u2097[\u03c3] N) :\n    (LinearMap.range f).spanRank \u2264 (\u22a4 : Submodule R M).spanRank := by\n```",
      "path": "Mathlib/Algebra/Module/SpanRank.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "finset",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "generators_card",
          "Module",
          "spanFinrank_map_le_of_fg",
          "mpr",
          "lemma",
          "le_antisymm",
          "Type",
          "mk_image_le",
          "spanFinrank",
          "section",
          "spanRank_finite_iff_fg",
          "spanRank_le_iff_exists_span_set_card_le",
          "universe",
          "toNat_le_iff_le_of_lt_aleph0",
          "Submodule",
          "map",
          "Cardinal",
          "variable",
          "generators",
          "Semiring",
          "spanRank",
          "simp",
          "subset_span",
          "AddCommMonoid",
          "span_generators",
          "exact",
          "spanRank_map_le",
          "span_le"
        ]
      }
    },
    {
      "id": 181,
      "before_code": "apply nontrivial h1\n  simp [ENat.card_eq_coe_natCard \u03b1, h2]",
      "suggestion": "\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Set.ncard_eq_zero, \u2190 card_coe_set_eq, Combination.card, Nat.choose_eq_zero_iff]\r\n",
      "body": "We just seem to be missing an instance `Finite (Combination \u03b1 n)`. Can you add it?\r\n```suggestion\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Set.ncard_eq_zero, \u2190 card_coe_set_eq, Combination.card, Nat.choose_eq_zero_iff]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "have"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "card_eq_coe_natCard",
          "simp",
          "nontrivial",
          "ENat"
        ]
      }
    },
    {
      "id": 182,
      "before_code": "apply nontrivial h1\n  simp [ENat.card_eq_coe_natCard \u03b1, h2]",
      "suggestion": "\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Finite.one_lt_card_iff_nontrivial, Combination.card, Nat.one_lt_iff_ne_zero_and_ne_one,\r\n    ne_eq, Nat.choose_eq_zero_iff, ne_eq, Nat.choose_eq_one_iff]\r\n  grind\r\n",
      "body": "```suggestion\r\n  have : Finite (Combination \u03b1 n) := sorry\r\n  rw [\u2190 Finite.one_lt_card_iff_nontrivial, Combination.card, Nat.one_lt_iff_ne_zero_and_ne_one,\r\n    ne_eq, Nat.choose_eq_zero_iff, ne_eq, Nat.choose_eq_one_iff]\r\n  grind\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "rw",
          "have"
        ],
        "body_tactics": [
          "grind",
          "rw",
          "have"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "apply",
          "card_eq_coe_natCard",
          "simp",
          "nontrivial",
          "ENat"
        ]
      }
    },
    {
      "id": 184,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  have : Finite \u03b1 := Nat.finite_of_card_ne_zero (Nat.ne_zero_of_lt hn)\r\n",
      "body": "I think it's slightly cleaner to inline here.\r\n```suggestion\r\n  have : Finite \u03b1 := Nat.finite_of_card_ne_zero (Nat.ne_zero_of_lt hn)\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 185,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  have : IsPretransitive (Equiv.Perm \u03b1) (n.Combination \u03b1) := Combination.isPretransitive \u03b1\r\n  -- The type on which the group acts is nontrivial.\r\n  have : Nontrivial (n.Combination \u03b1) := Combination.nontrivial' h_one_le hn\r\n",
      "body": "```suggestion\r\n  have : IsPretransitive (Equiv.Perm \u03b1) (n.Combination \u03b1) := Combination.isPretransitive \u03b1\r\n  -- The type on which the group acts is nontrivial.\r\n  have : Nontrivial (n.Combination \u03b1) := Combination.nontrivial' h_one_le hn\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 186,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  \u00b7 rw [Set.nonempty_compl, ne_eq, Set.eq_univ_iff_ncard, ncard_eq]\r\n    exact hn.ne\r\n",
      "body": "```suggestion\r\n  \u00b7 rw [Set.nonempty_compl, ne_eq, Set.eq_univ_iff_ncard, ncard_eq]\r\n    exact hn.ne\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 187,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  apply isPretransitive_of_isMultiplyPretransitive\r\n  rcases eq_or_ne n 0 with rfl | hn0\r\n  \u00b7 infer_instance\r\n  rcases eq_or_ne n 1 with rfl | hn1\r\n  \u00b7 rw [is_one_pretransitive_iff]\r\n    exact alternatingGroup.isPretransitive_of_three_le_card \u03b1 h\u03b1\r\n  have := alternatingGroup.isMultiplyPretransitive \u03b1\r\n  apply isMultiplyPretransitive_of_le (n := Nat.card \u03b1 - 2) <;> grind\r\n",
      "body": "```suggestion\r\n  apply isPretransitive_of_isMultiplyPretransitive\r\n  rcases eq_or_ne n 0 with rfl | hn0\r\n  \u00b7 infer_instance\r\n  rcases eq_or_ne n 1 with rfl | hn1\r\n  \u00b7 rw [is_one_pretransitive_iff]\r\n    exact alternatingGroup.isPretransitive_of_three_le_card \u03b1 h\u03b1\r\n  have := alternatingGroup.isMultiplyPretransitive \u03b1\r\n  apply isMultiplyPretransitive_of_le (n := Nat.card \u03b1 - 2) <;> grind\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "apply",
          "exact",
          "grind",
          "cases",
          "have",
          "rw"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "grind",
          "cases",
          "have",
          "rw"
        ],
        "new_tactics": [
          "apply",
          "grind",
          "cases",
          "have",
          "rw"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 188,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n    by_cases hn' : n \u2264 Nat.card \u03b1\r\n    \u00b7 apply IsPretransitive.of_surjective_map\r\n        (compl_bijective (alternatingGroup \u03b1) \u03b1 _).surjective this\r\n      aesop\r\n",
      "body": "I think `by_cases` makes more sense than `wlog` here.\r\n```suggestion\r\n    by_cases hn' : n \u2264 Nat.card \u03b1\r\n    \u00b7 apply IsPretransitive.of_surjective_map\r\n        (compl_bijective (alternatingGroup \u03b1) \u03b1 _).surjective this\r\n      aesop\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop"
        ],
        "body_tactics": [
          "apply",
          "aesop"
        ],
        "new_tactics": [
          "apply",
          "aesop"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 190,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  rw [\u2190 isCoatom_stabilizer_iff_preprimitive _ s, stabilizer_coe]\r\n  apply alternatingGroup.isCoatom_stabilizer\r\n  \u00b7 rw [Combination.coe_nonempty_iff]\r\n    exact le_trans (by norm_num) h_three_le\r\n  \u00b7 simp [Set.nonempty_compl, Set.eq_univ_iff_ncard, ncard_eq, hn.ne]\r\n  \u00b7 simpa [ncard_eq]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 isCoatom_stabilizer_iff_preprimitive _ s, stabilizer_coe]\r\n  apply alternatingGroup.isCoatom_stabilizer\r\n  \u00b7 rw [Combination.coe_nonempty_iff]\r\n    exact le_trans (by norm_num) h_three_le\r\n  \u00b7 simp [Set.nonempty_compl, Set.eq_univ_iff_ncard, ncard_eq, hn.ne]\r\n  \u00b7 simpa [ncard_eq]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "norm_num",
          "apply",
          "exact",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "norm_num",
          "apply",
          "exact",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "norm_num",
          "apply",
          "simpa",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 196,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j :=\n  \u27e8fun hsum i j \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mp (by simpa using hsum) i j,\n    fun heq \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mpr (by simpa using heq)\u27e9\n",
      "body": "```suggestion\n    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j :=\n  \u27e8fun hsum i j \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mp (by simpa using hsum) i j,\n    fun heq \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mpr (by simpa using heq)\u27e9\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 197,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    simp_rw [\u2190 heq 0]\n    simp [\u2190 Finset.mul_sum, Fin.sum_univ_eq_sum_range, h\u03b6.geom_sum_eq_zero hprime.one_lt]\n",
      "body": "```suggestion\n    simp_rw [\u2190 heq 0]\n    simp [\u2190 Finset.mul_sum, Fin.sum_univ_eq_sum_range, h\u03b6.geom_sum_eq_zero hprime.one_lt]\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 198,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pred_eq_of_pos hprime.pos\n    -- Derive a vanishing relation with coefficients `\u03b1\u1d62 - \u03b1_{p-1}` and exponents `< n`.\n    have : \u2211 i \u2208 Finset.range (n + 1), \u03b1Nat i * \u03b6 ^ i = 0 := by\n      simpa [show n + 1 = p by omega, \u2190 Fin.sum_univ_eq_sum_range, h\u03b1Nat_val]\n    have : \u2211 i \u2208 Finset.range n, \u03b1Nat i * \u03b6 ^ i - \u03b1Nat n * \u2211 i \u2208 Finset.range n, \u03b6 ^ i = 0 := by\n      rw [Finset.sum_range_succ] at this\n      -- Use the standard relation for primitive roots: `\u03b6^{p-1} = -\u2211_{i<p-1} \u03b6^i`.\n      grind [h\u03b6.pow_sub_one_eq hprime.one_lt]\n    have h",
      "body": "Attempted golfing\n\n```suggestion\n  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pr",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "body_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "new_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_omega",
          "cleanup_simp",
          "use_simpa",
          "use_grind",
          "use_ring"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 200,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j := by\n  simpa using sum_eq_zero_iff_eq_coeff h\u03b6 (Int.cast \u2218 \u03b1)\n",
      "body": "```suggestion\n    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j := by\n  simpa using sum_eq_zero_iff_eq_coeff h\u03b6 (Int.cast \u2218 \u03b1)\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 203,
      "before_code": "lemma MeasuredSets.edist_def (s t : MeasuredSets \u03bc) : edist s t = \u03bc ((s : Set \u03b1) \u2206 t) := rfl\n\nlemma MeasuredSets.continuous_measure : Continuous (fun (s : MeasuredSets \u03bc) \u21a6 \u03bc s) := by\n  apply continuous_iff_continuousAt.2 (fun x \u21a6 ?_)\n  simp only [ContinuousAt]\n  rcases eq_top_or_lt_top (\u03bc x) with hx | hx\n  \u00b7 simp only [hx]\n    apply tendsto_const_nhds.congr'\n    filter_upwards [Metric.eball_mem_nhds _ zero_lt_one] with y hy\n    simp only [Metric.mem_eball, edist_def] at hy\n    contrapose! hy\n    simp [measure_symmDiff_eq_top hy.symm hx]\n  \u00b7 apply (ENNReal.hasBasis_nhds_of_ne_top hx.ne).tendsto_right_iff.2 (fun \u03b5 \u03b5pos \u21a6 ?_)\n    filter_upwards [Metric.eball_mem_nhds _ \u03b5pos] with a ha\n    simp only [Metric.mem_eball, edist_def] at ha\n    refine \u27e8?_, ?_\u27e9\n    \u00b7 apply tsub_le_iff_right.mpr\n      calc \u03bc x\n      _ \u2264 \u03bc a + \u03bc (x \\ a) := by\n        rw [\u2190 measure_union Set.disjoint_sdiff_right (by exact x.2.diff a.2)]\n        apply measure_mono\n        exact Set.diff_subset_iff.mp fun \u2983a_1\u2984 a \u21a6 a\n      _ \u2264 \u03bc a + \u03bc (a \u2206 x) := by\n        gcongr\n        simp [symmDiff]\n      _ \u2264 \u03bc a + \u03b5 := by\n        gcongr\n    \u00b7 calc \u03bc a\n      _ \u2264 \u03bc x + \u03bc (a \\ x) := by\n        rw [\u2190 measure_union Set.disjoint_sdiff_right (by exact a.2.diff x.2)]\n        apply measure_mono\n        exact Set.diff_subset_iff.mp fun \u2983a_1\u2984 a \u21a6 a\n      _ \u2264 \u03bc x + \u03bc (a \u2206 x) := by\n        gcongr\n        simp [symmDiff]\n      _ \u2264 \u03bc x + \u03b5 := by\n        gcongr",
      "suggestion": "  exact sub_le_edist s t\n",
      "body": "```suggestion\n  exact sub_le_edist s t\n```",
      "path": "Mathlib/MeasureTheory/Measure/MeasuredSets.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "cases",
          "rw",
          "simp",
          "congr"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "gcongr",
          "refine",
          "cases",
          "rw",
          "simp",
          "congr"
        ],
        "topics": [
          "continuity",
          "list",
          "topology",
          "set_theory",
          "order",
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "tendsto_right_iff",
          "mpr",
          "lemma",
          "edist_def",
          "calc",
          "hasBasis_nhds_of_ne_top",
          "Metric",
          "rcases",
          "a_1",
          "symmDiff",
          "continuous_measure",
          "apply",
          "mem_eball",
          "contrapose",
          "symm",
          "refine",
          "gcongr",
          "filter_upwards",
          "tendsto_const_nhds",
          "Continuous",
          "measure_symmDiff_eq_top",
          "MeasuredSets",
          "tsub_le_iff_right",
          "eq_top_or_lt_top",
          "simp",
          "measure_union",
          "rfl",
          "congr",
          "only",
          "continuous_iff_continuousAt",
          "ENNReal",
          "disjoint_sdiff_right",
          "measure_mono",
          "zero_lt_one",
          "exact",
          "ContinuousAt",
          "Set",
          "diff",
          "eball_mem_nhds",
          "edist",
          "diff_subset_iff"
        ]
      }
    },
    {
      "id": 206,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    (hs : IndexedPartition s) [MeasurableSpace \u03b1] (hm : \u2200 i, MeasurableSet (s i))\n",
      "body": "I don't think the measurable space structure can be inferred here?\n```suggestion\n    (hs : IndexedPartition s) [MeasurableSpace \u03b1] (hm : \u2200 i, MeasurableSet (s i))\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 210,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "  \u00b7 rw [mem_preimage, piecewise_apply, \u2190 mem_preimage] at hx\n    exact mem_iUnion_of_mem (hs.index x) (mem_inter (hs.mem_index x) hx)\n  \u00b7 rw [\u2190 hi, \u2190 (mem_iff_index_eq hs).mp ha.1] at ha\n    simp_all [piecewise_apply]\n",
      "body": "You can drop some stuff here:\n\n```suggestion\n  \u00b7 rw [mem_preimage, piecewise_apply, \u2190 mem_preimage] at hx\n    exact mem_iUnion_of_mem (hs.index x) (mem_inter (hs.mem_index x) hx)\n  \u00b7 rw [\u2190 hi, \u2190 (mem_iff_index_eq hs).mp ha.1] at ha\n    simp_all [piecewise_apply]\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp_all"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 211,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "    simp only [hs.mem_iff_index_eq] at ha1\n",
      "body": "```suggestion\n    simp only [hs.mem_iff_index_eq] at ha1\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 212,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    obtain \u27e8e, -\u27e9 := exists_true_iff_nonempty.mpr (nonempty_equiv_of_countable (\u03b1 := \u2115) (\u03b2 := \u03b9))\n",
      "body": "```suggestion\n    obtain \u27e8e, -\u27e9 := exists_true_iff_nonempty.mpr (nonempty_equiv_of_countable (\u03b1 := \u2115) (\u03b2 := \u03b9))\n```\nThis removes the `True` hypothesis from the context.",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 213,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    have he := e.bijective\n",
      "body": "```suggestion\n    have he := e.bijective\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 215,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    \u00b7 exact .biUnion (to_countable _) fun _ _ \u21a6 hm _\n",
      "body": "`measurability` tends to be a bit slow so I suggest you replace it with this.\n```suggestion\n    \u00b7 exact .biUnion (to_countable _) fun _ _ \u21a6 hm _\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "measurability"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 216,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "  \u00b7 refine \u27e8fun n => SimpleFunc.indexedPartitionPiecewise hs hm (fun i => (hf i).approx n),\n      fun x => ?_\u27e9\n    simp [SimpleFunc.indexedPartitionPiecewise, IndexedPartition.piecewise_apply,\n      StronglyMeasurable.tendsto_approx]\n  simp only [not_finite_iff_infinite] at Fi\n",
      "body": "When you have small subgoals followed a main one, it's ok to not put a dot before the last one, so as to avoid too much indentation.\n```suggestion\n  \u00b7 refine \u27e8fun n => SimpleFunc.indexedPartitionPiecewise hs hm (fun i => (hf i).approx n),\n      fun x => ?_\u27e9\n    simp [SimpleFunc.indexedPartitionPiecewise, IndexedPartition.piecewise_apply,\n      StronglyMeasurable.tendsto_approx]\n  simp only [not_finite_iff_infinite] at Fi\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 217,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    simp only [SimpleFunc.indexedPartitionPiecewise, SimpleFunc.coe_mk,\n",
      "body": "Again here no need for the dot.\n```suggestion\n    simp only [SimpleFunc.indexedPartitionPiecewise, SimpleFunc.coe_mk,\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 218,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "        have : y = (\u27e8y, by lia\u27e9 : Fin (b + 1)).1 := rfl\n",
      "body": "`linarith` should also be replaced by `lia`, can you do so in the rest of the proof as well?\n```suggestion\n        have : y = (\u27e8y, by lia\u27e9 : Fin (b + 1)).1 := rfl\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have",
          "linarith"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 219,
      "before_code": "@SeparatesPoints _ m' := @SeparatesPoints.mk _ m' fun _ _ hxy \u21a6\n    @SeparatesPoints.separates _ m hsep _ _ fun _ hs \u21a6 hxy _ (h _ hs)",
      "suggestion": "    \u00b7 absurd hx\n      simp [\u2190 mem_preimage, h']\n    \u00b7 absurd hy\n      simp [\u2190 mem_preimage, h']\n  obtain h' | h' := isEmpty_or_nonempty \u03b1\n  \u00b7 use (Classical.ofNonempty : \u03b2), funext (by simp)\n  \u00b7 use f (Classical.ofNonempty : \u03b1), funext (fun x \u21a6 h _ _)\n",
      "body": "I think it's better not to use semicolons here. Also you can avoid `swap` by doing the following (or doing ` by_cases! h' : IsEmpty \u03b1` instead, or just not using `swap` because both proofs are one-liners):\n```suggestion\n    \u00b7 absurd hx\n      simp [\u2190 mem_preimage, h']\n    \u00b7 absurd hy\n      simp [\u2190 mem_preimage, h']\n  obtain h' | h' := isEmpty_or_nonempty \u03b1\n  \u00b7 use (Classical.ofNonempty : \u03b2), funext (by simp)\n  \u00b7 use f (Classical.ofNonempty : \u03b1), funext (fun x \u21a6 h _ _)\n```",
      "path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "SeparatesPoints",
          "hxy",
          "separates",
          "hsep"
        ]
      }
    },
    {
      "id": 234,
      "before_code": "-- Porting note: in Lean3, introducing `x` would just give `x \u2208 J\u207b\u00b9 \u2192 x \u2208 I\u207b\u00b9`, but\n  --  in Lean4, it goes all the way down to the subtypes",
      "suggestion": "\r\n",
      "body": "We can delete the porting note now, since [the regression](https://github.com/[user]y/mathlib3/blob/65a1391a0106c9204fe45bc73a039f056558cb83/src/ring_theory/dedekind_domain/ideal.lean#L87C1-L87C85) is fixed.\r\n```suggestion\r\n```",
      "path": "Mathlib/RingTheory/FractionalIdeal/Inverse.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "introducing",
          "Lean3",
          "would",
          "down",
          "Lean4",
          "give",
          "just",
          "note",
          "subtypes",
          "way",
          "Porting",
          "but",
          "goes",
          "all"
        ]
      }
    },
    {
      "id": 237,
      "before_code": "@[simp] lemma setOf_mem_eq (a : A) : {b | b \u2208 a} = a := rfl\n\ninstance (priority := 100) instPartialOrder : PartialOrder A :=\n  { PartialOrder.lift (SetLike.coe : A \u2192 Set B) coe_injective with\n    le := fun H K => \u2200 \u2983x\u2984, x \u2208 H \u2192 x \u2208 K }\n\ntheorem le_def {S T : A} : S \u2264 T \u2194 \u2200 \u2983x : B\u2984, x \u2208 S \u2192 x \u2208 T :=\n  Iff.rfl",
      "suggestion": "\r\nclass IsConcreteLE (A : Type*) (B : outParam Type*) [SetLike A B] [LE A] where\r\n",
      "body": "I noticed a few places where `B` has to be made explicit. Would it not work better if `B` is an `outParam`, like we already have for `SetLike`?\r\n```suggestion\r\nclass IsConcreteLE (A : Type*) (B : outParam Type*) [SetLike A B] [LE A] where\r\n```",
      "path": "Mathlib/Data/SetLike/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "theorem",
          "SetLike",
          "le_def",
          "setOf_mem_eq",
          "coe",
          "Set",
          "PartialOrder",
          "Iff",
          "instPartialOrder",
          "lift",
          "priority",
          "simp",
          "rfl",
          "instance",
          "coe_injective"
        ]
      }
    },
    {
      "id": 242,
      "before_code": "In general, a type `A` is `SetLike` with elements of type `B` if it\nhas an injective map to `Set B`.  This module provides standard\nboilerplate for every `SetLike`: a `coe_sort`, a `coe` to set, a\n`PartialOrder`, and various extensionality and simp lemmas.",
      "suggestion": "\r\nand various extensionality and simp lemmas. The order induced by set inclusion is\r\ncalled `PartialOrder.ofSetlike`: this is not an instance for better defeqs.\r\nThe class `IsConcreteLE` abstractly states the order is equal to that induced by set inclusion;\r\nan instance is automatically available when defining a `PartialOrder` as\r\n`.ofSetLike (MySubobject X) X`.\r\n",
      "body": "How about:\r\n```suggestion\r\nand various extensionality and simp lemmas. The order induced by set inclusion is\r\ncalled `PartialOrder.ofSetlike`: this is not an instance for better defeqs.\r\nThe class `IsConcreteLE` abstractly states the order is equal to that induced by set inclusion;\r\nan instance is automatically available when defining a `PartialOrder` as\r\n`.ofSetLike (MySubobject X) X`.\r\n```",
      "path": "Mathlib/Data/SetLike/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "boilerplate",
          "type",
          "has",
          "elements",
          "This",
          "standard",
          "set",
          "map",
          "injective",
          "various",
          "for",
          "SetLike",
          "extensionality",
          "coe_sort",
          "module",
          "simp",
          "general",
          "lemmas",
          "every",
          "Set",
          "PartialOrder",
          "coe",
          "provides"
        ]
      }
    },
    {
      "id": 247,
      "before_code": "I.map (algebraMap R' R) ^ Module.finrank (FractionRing R) (FractionRing S) := by\n  rw [\u2190 relNorm_algebraMap, Ideal.map_map, IsScalarTower.algebraMap_eq R' R S]",
      "suggestion": "  have h\u2080 : \u2200 Q \u2208 (p.primesOver S).toFinset,\n      relNorm R Q ^ ramificationIdx (algebraMap R S) p Q = p ^ ((p.ramificationIdxIn S) * s) := by\n    intro Q hQ\n",
      "body": "```suggestion\n  have h\u2080 : \u2200 Q \u2208 (p.primesOver S).toFinset,\n      relNorm R Q ^ ramificationIdx (algebraMap R S) p Q = p ^ ((p.ramificationIdxIn S) * s) := by\n    intro Q hQ\n```\nseems closer to standard mathematical notation",
      "path": "Mathlib/RingTheory/Ideal/Norm/RelNorm.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have",
          "intro"
        ],
        "body_tactics": [
          "have",
          "intro"
        ],
        "new_tactics": [
          "have",
          "intro"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "Ideal",
          "IsScalarTower",
          "map_map",
          "finrank",
          "relNorm_algebraMap",
          "FractionRing",
          "map",
          "algebraMap",
          "algebraMap_eq"
        ]
      }
    },
    {
      "id": 250,
      "before_code": "(FractionalIdeal.coeIdeal_le_coeIdeal _).symm.trans\n    (differentialIdeal_le_fractionalIdeal_iff (I := (I : FractionalIdeal B\u2070 L)) (by simpa))\n\nvariable (A K)",
      "suggestion": "\r\n    differentIdeal A C = differentIdeal B C * (differentIdeal A B).map (algebraMap B C) := by\r\n",
      "body": "```suggestion\r\n    differentIdeal A C = differentIdeal B C * (differentIdeal A B).map (algebraMap B C) := by\r\n```\r\nAnd for statements that doesn't mention the fraction fields, type classes should be on `FractionRing` instead (because typeclass inference cannot find it).\r\nIn particular `IsIntegralClosure C A M` should be `Module.Finite A C` (because you already have `C` is integrally closed and `NoZeroSMulDivisors A C`) and `Algebra.IsSeparable K M` should be `Algebra.IsSeparable (FractionRing A)",
      "path": "Mathlib/RingTheory/DedekindDomain/Different.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "differentialIdeal_le_fractionalIdeal_iff",
          "symm",
          "variable",
          "FractionalIdeal",
          "coeIdeal_le_coeIdeal",
          "simpa",
          "trans"
        ]
      }
    },
    {
      "id": 262,
      "before_code": "simp [b', Module.Basis.toMatrix_apply, mul_comm (RingOfIntegers.basis K i),\n      b, integralBasis_apply, \u2190 map_mul, Algebra.trace_localization \u2124 \u2124\u2070]\n\nlemma NumberField.discr_mem_differentIdeal : \u2191(discr K) \u2208 differentIdeal \u2124 \ud835\udcaa := by\n  have := (differentIdeal \u2124 \ud835\udcaa).absNorm_mem\n  cases (discr K).natAbs_eq with\n  | inl h =>\n    rwa [absNorm_differentIdeal (K := K), \u2190 Int.cast_natCast, \u2190 h] at this\n  | inr h =>\n    rwa [absNorm_differentIdeal (K := K), \u2190 Int.cast_natCast, Int.eq_neg_comm.mp h,\n      Int.cast_neg, neg_mem_iff] at this",
      "suggestion": "    [IsScalarTower \ud835\udcaa K L] [IsScalarTower \ud835\udcaa \ud835\udcaa' L] [Module.Free \u2124 \ud835\udcaa']\n",
      "body": "```suggestion\n    [IsScalarTower \ud835\udcaa K L] [IsScalarTower \ud835\udcaa \ud835\udcaa' L] [Module.Free \u2124 \ud835\udcaa']\n```\nAlso this I think.\n\nIf you need those in the proof it is surely worth to remove them, if they are needed in the statement then it depends on how painful is removing them.",
      "path": "Mathlib/NumberTheory/NumberField/Discriminant/Different.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "simp",
          "have"
        ],
        "topics": [
          "norm",
          "int",
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "lemma",
          "rwa",
          "discr_mem_differentIdeal",
          "cast_natCast",
          "eq_neg_comm",
          "inl",
          "neg_mem_iff",
          "absNorm_mem",
          "cases",
          "RingOfIntegers",
          "have",
          "discr",
          "map_mul",
          "NumberField",
          "natAbs_eq",
          "differentIdeal",
          "integralBasis_apply",
          "Int",
          "mul_comm",
          "simp",
          "basis",
          "cast_neg",
          "trace_localization",
          "Basis",
          "this",
          "toMatrix_apply",
          "absNorm_differentIdeal",
          "Algebra",
          "inr"
        ]
      }
    },
    {
      "id": 270,
      "before_code": "@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimit {J : Type w} [Category.{w'} J]\n    (K : J \u2964 GrpCat.{u}) : PreservesLimit K uliftFunctor.{v, u} where\n  preserves lc := \u27e8isLimitOfReflects (forget GrpCat.{max u v})\n    (isLimitOfPreserves CategoryTheory.uliftFunctor (isLimitOfPreserves (forget GrpCat) lc))\u27e9",
      "suggestion": "\r\n    isLimitOfPreserves CategoryTheory.uliftFunctor.{v} (isLimitOfPreserves (forget GrpCat) lc)\u27e9\r\n",
      "body": "```suggestion\r\n    isLimitOfPreserves CategoryTheory.uliftFunctor.{v} (isLimitOfPreserves (forget GrpCat) lc)\u27e9\r\n```\r\nSince you're adding `<|`, might as well remove the useless parens.\r\n\r\nAlso, why did you remove the `.{max u v}` annotation here but not in the similar chunk line 157?",
      "path": "Mathlib/Algebra/Category/Grp/Ulift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "to_additive",
          "GrpCat",
          "preserves",
          "noncomputable",
          "Category",
          "isLimitOfReflects",
          "isLimitOfPreserves",
          "Type",
          "CategoryTheory",
          "forget",
          "uliftFunctor_preservesLimit",
          "max",
          "uliftFunctor",
          "instance",
          "PreservesLimit"
        ]
      }
    },
    {
      "id": 273,
      "before_code": "intro S\u2081 hS\u2081 S\u2082 hS\u2082\n  exact Submodule.finite_sup S\u2081 S\u2082",
      "suggestion": "theorem span_submodule_fg_of_fg {S : Submodule R M} (hS : S.FG) :\n    (span A S : Submodule A M).FG := by\n  obtain \u27e8t, ht\u27e9 := hS\n  use t\n  rw [\u2190 ht, span_span_of_tower]\n",
      "body": "```suggestion\ntheorem span_submodule_fg_of_fg {S : Submodule R M} (hS : S.FG) :\n    (span A S : Submodule A M).FG := by\n  obtain \u27e8t, ht\u27e9 := hS\n  use t\n  rw [\u2190 ht, span_span_of_tower]\n```",
      "path": "Mathlib/RingTheory/Finiteness/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "obtain",
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Submodule",
          "intro",
          "finite_sup"
        ]
      }
    },
    {
      "id": 274,
      "before_code": "rw [Finset.coe_insert, Submodule.span_insert]\n      exact h\u2082 _ _ (h\u2081 _) ih\n\ntheorem fg_restrictScalars {R S M : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommMonoid M] [Module S M] [Module R M] [IsScalarTower R S M] (N : Submodule S M)\n    (hfin : N.FG) (h : Function.Surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).FG := by\n  obtain \u27e8X, rfl\u27e9 := hfin\n  use X\n  exact (Submodule.restrictScalars_span R S h (X : Set M)).symm",
      "suggestion": "  exact \u27e8X, (restrictScalars_span R A h _).symm\u27e9\n",
      "body": "```suggestion\n  exact \u27e8X, (restrictScalars_span R A h _).symm\u27e9\n```",
      "path": "Mathlib/RingTheory/Finiteness/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "obtain",
          "rw"
        ],
        "topics": [
          "finset",
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "fg_restrictScalars",
          "Type",
          "obtain",
          "Function",
          "symm",
          "restrictScalars",
          "span_insert",
          "Finset",
          "Submodule",
          "CommSemiring",
          "hfin",
          "Semiring",
          "rfl",
          "use",
          "AddCommMonoid",
          "theorem",
          "IsScalarTower",
          "exact",
          "Set",
          "coe_insert",
          "restrictScalars_span",
          "algebraMap",
          "Algebra",
          "Surjective"
        ]
      }
    },
    {
      "id": 276,
      "before_code": "intro S\u2081 hS\u2081 S\u2082 hS\u2082\n  exact Submodule.finite_sup S\u2081 S\u2082",
      "suggestion": "theorem FG.span (hS : S.FG) : (span A (S : Set M)).FG := by\n",
      "body": "```suggestion\ntheorem FG.span (hS : S.FG) : (span A (S : Set M)).FG := by\n```\nI think `span` is enough for a name? If you want to disambiguate then this should be called `submoduleSpan` (as the declaration you are referring is called `Submodule.span`)",
      "path": "Mathlib/RingTheory/Finiteness/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Submodule",
          "intro",
          "finite_sup"
        ]
      }
    },
    {
      "id": 307,
      "before_code": "end",
      "suggestion": "\r\n",
      "body": "This theorem is syntactically identical to `sum_eq_one`, so you should just drop it.\r\n```suggestion\r\n```",
      "path": "Mathlib/Analysis/Convex/StdSimplex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 309,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "\r\n  have ha : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\r\n",
      "body": "I'd be inclined to inline this\r\n```suggestion\r\n  have ha : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 310,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "\r\n  \u00b7 rw [Finset.coe_image]\r\n    exact h_dis.image\r\n",
      "body": "```suggestion\r\n  \u00b7 rw [Finset.coe_image]\r\n    exact h_dis.image\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 313,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "\r\n    \u00b7 simp only [K, coe_biUnion]\r\n      refine (h'I.mono_on ?_).biUnion hJdisj\r\n      simp\r\n      grind\r\n",
      "body": "```suggestion\r\n    \u00b7 simp only [K, coe_biUnion]\r\n      refine (h'I.mono_on ?_).biUnion hJdisj\r\n      simp\r\n      grind\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "grind",
          "refine",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "simp",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 315,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n",
      "body": "```suggestion\n  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n```\na little golf",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "refine",
          "simp",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 316,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    have : s = \u22c3 t \u2208 J', s \u2229 t := by\n      simp_rw [\u2190 Finset.set_biUnion_coe, \u2190 inter_iUnion, left_eq_inter, \u2190 sUnion_eq_biUnion, \u2190 h]\n      exact subset_sUnion_of_mem hs\n",
      "body": "```suggestion\n    have : s = \u22c3 t \u2208 J', s \u2229 t := by\n      simp_rw [\u2190 Finset.set_biUnion_coe, \u2190 inter_iUnion, left_eq_inter, \u2190 sUnion_eq_biUnion, \u2190 h]\n      exact subset_sUnion_of_mem hs\n```\nI still think this is longer than it should be :(",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "exact",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 317,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "      simp_rw [\u2190 Finset.set_biUnion_coe, \u2190 iUnion_inter, right_eq_inter, \u2190 sUnion_eq_biUnion, h]\n      exact subset_sUnion_of_mem ht\n",
      "body": "```suggestion\n      simp_rw [\u2190 Finset.set_biUnion_coe, \u2190 iUnion_inter, right_eq_inter, \u2190 sUnion_eq_biUnion, h]\n      exact subset_sUnion_of_mem ht\n```\nas before",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 318,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    \u00b7 exact hJ'disj.mono fun _ \u21a6 by simp\n",
      "body": "```suggestion\n    \u00b7 exact hJ'disj.mono fun _ \u21a6 by simp\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 319,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    \u00b7 exact hJdisj.mono fun _ \u21a6 by simp\n",
      "body": "```suggestion\n    \u00b7 exact hJdisj.mono fun _ \u21a6 by simp\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 320,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "      exact subset_sUnion_of_mem ha\n",
      "body": "```suggestion\n      exact subset_sUnion_of_mem ha\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 321,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "      exact subset_sUnion_of_mem ha\n",
      "body": "```suggestion\n      exact subset_sUnion_of_mem ha\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 323,
      "before_code": "lemma zero_le_logHeight\u2081 (x : K) : 0 \u2264 logHeight\u2081 x :=\n  Real.log_nonneg <| one_le_mulHeight\u2081 x",
      "suggestion": "\r\n    pure (.positive q(mulHeight\u2081_pos $a))\r\n",
      "body": "You can actually let Qq figure out the implicit variables here (and this will be done statically, so the tactic runs just as fast as if you'd done so manually):\r\n```suggestion\r\n    pure (.positive q(mulHeight\u2081_pos $a))\r\n```",
      "path": "Mathlib/NumberTheory/Height/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "log_nonneg",
          "Real"
        ]
      }
    },
    {
      "id": 324,
      "before_code": "module\n\npublic import Mathlib.Analysis.SpecialFunctions.Log.Basic",
      "suggestion": "\r\n",
      "body": "This import is redundant, let's not annoy Sebastian by making him do even more `shake` work :)\r\n```suggestion\r\n```",
      "path": "Mathlib/NumberTheory/Height/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "Basic",
          "import",
          "Mathlib",
          "public",
          "module",
          "Log",
          "Analysis",
          "SpecialFunctions"
        ]
      }
    },
    {
      "id": 328,
      "before_code": "\u2190 mul_assoc (f c ^ n), mul_inv_cancel\u2080 (pow_ne_zero n hc), one_mul, div_eq_mul_inv]\n\n/-- The real-valued function sending `x \u2208 R` to the limit of `(f (x * c^n))/((f c)^n)`. -/\ndef seminormFromConst' (x : R) : \u211d :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n    (seminormFromConst_seq_antitone hf1 hc hpm x)).choose\n\n/-- We prove that `seminormFromConst' hf1 hc hpm x` is the limit of the sequence\n  `seminormFromConst_seq c f x` as `n` tends to infinity. -/\ntheorem seminormFromConst_isLimit (x : R) :\n    Tendsto (seminormFromConst_seq c f x) atTop (\ud835\udcdd (seminormFromConst' hf1 hc hpm x)) :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n      (seminormFromConst_seq_antitone hf1 hc hpm x)).choose_spec\n\n/-- `seminormFromConst' hf1 hc hpm 1 = 1`. -/\ntheorem seminormFromConst_one : seminormFromConst' hf1 hc hpm 1 = 1 := by",
      "suggestion": "\r\n",
      "body": "This feels like a very silly docstring, considering it's literally just the type signature.\r\n```suggestion\r\n```\r\nThis applies to most docstrings in this file, frankly. Let's keep only the useful docstrings like `seminormFromConst_isLimit`, which clarify the type signature rather than repeating it verbatim.",
      "path": "Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "real",
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "div_eq_mul_inv",
          "infinity",
          "real",
          "tends",
          "seminormFromConst",
          "hf1",
          "atTop",
          "seminormFromConst_seq",
          "one_mul",
          "limit",
          "seminormFromConst_isLimit",
          "prove",
          "pow_ne_zero",
          "choose_spec",
          "seminormFromConst_seq_antitone",
          "def",
          "Real",
          "sending",
          "Tendsto",
          "sequence",
          "seminormFromConst_one",
          "hpm",
          "that",
          "choose",
          "mul_assoc",
          "function",
          "theorem",
          "valued",
          "seminormFromConst_bddBelow",
          "tendsto_of_bddBelow_antitone"
        ]
      }
    },
    {
      "id": 329,
      "before_code": "\u2190 mul_assoc (f c ^ n), mul_inv_cancel\u2080 (pow_ne_zero n hc), one_mul, div_eq_mul_inv]\n\n/-- The real-valued function sending `x \u2208 R` to the limit of `(f (x * c^n))/((f c)^n)`. -/\ndef seminormFromConst' (x : R) : \u211d :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n    (seminormFromConst_seq_antitone hf1 hc hpm x)).choose\n\n/-- We prove that `seminormFromConst' hf1 hc hpm x` is the limit of the sequence\n  `seminormFromConst_seq c f x` as `n` tends to infinity. -/\ntheorem seminormFromConst_isLimit (x : R) :\n    Tendsto (seminormFromConst_seq c f x) atTop (\ud835\udcdd (seminormFromConst' hf1 hc hpm x)) :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n      (seminormFromConst_seq_antitone hf1 hc hpm x)).choose_spec\n\n/-- `seminormFromConst' hf1 hc hpm 1 = 1`. -/\ntheorem seminormFromConst_one : seminormFromConst' hf1 hc hpm 1 = 1 := by\n  apply tendsto_nhds_unique_of_eventuallyEq (seminormFromConst_isLimit hf1 hc hpm 1)\n    tendsto_const_nhds\n  simp only [EventuallyEq, eventually_atTop, ge_iff_le]\n  exact \u27e81, seminormFromConst_seq_one hc hpm\u27e9\n\n/-- The function `seminormFromConst` is a `RingSeminorm` on `R`. -/\ndef seminormFromConst : RingSeminorm R where\n  toFun     := seminormFromConst' hf1 hc hpm\n  map_zero' := tendsto_nhds_unique (seminormFromConst_isLimit hf1 hc hpm 0)\n    (by simpa [seminormFromConst_seq_zero c (map_zero _)] using tendsto_const_nhds)\n  add_le' x y := by\n    apply le_of_tendsto_of_tendsto' (seminormFromConst_isLimit hf1 hc hpm (x + y))\n      ((seminormFromConst_isLimit hf1 hc hpm x).add (seminormFromConst_isLimit hf1 hc hpm y))\n    intro n\n    have h_add : f ((x + y) * c ^ n) \u2264 f (x * c ^ n) + f (y * c ^ n) := by\n      simp only [add_mul, map_add_le_add f _ _]\n    simp only [seminormFromConst_seq, \u2190 add_div]\n    gcongr\n  neg' x := by\n    apply tendsto_nhds_unique_of_eventuallyEq (seminormFromConst_isLimit hf1 hc hpm (-x))\n      (seminormFromConst_isLimit hf1 hc hpm x)\n    simp only [EventuallyEq, eventually_atTop]\n  ",
      "suggestion": "\r\n",
      "body": "I'd personally do away with this docstring too, for the same reason of \"just repeats the type signature\".\r\n```suggestion\r\n```",
      "path": "Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "nat",
          "algebra",
          "list",
          "real",
          "topology",
          "norm",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "map_zero",
          "infinity",
          "tends",
          "seminormFromConst",
          "seminormFromConst_seq_one",
          "hf1",
          "div_mul_div_comm",
          "using",
          "mul",
          "seminormFromConst_seq",
          "add",
          "limit",
          "have",
          "intro",
          "ge_iff_le",
          "def",
          "Tendsto",
          "that",
          "mul_comm",
          "simp",
          "choose",
          "rfl",
          "tendsto_nhds_unique_of_eventuallyEq",
          "theorem",
          "hlim",
          "tendsto_nhds_unique",
          "apply_nonneg",
          "map_neg_eq_map",
          "eventually_atTop",
          "add_le",
          "RingSeminorm",
          "nonarchimedean",
          "le_of_tendsto_of_tendsto",
          "apply",
          "seminormFromConst_one_le",
          "Nat",
          "seminormFromConst_isLimit",
          "tendsto_const_nhds",
          "prove",
          "choose_spec",
          "le_of_eq",
          "toFun",
          "hnm",
          "sending",
          "seminormFromConst_one",
          "div_le_div_iff_of_pos_right",
          "mul_assoc",
          "neg_mul",
          "lt_of_le_of_ne"
        ]
      }
    },
    {
      "id": 330,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n\n/-- An antitone, bounded below sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddBelow_antitone {f : \u2115 \u2192 \u211d} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9\n\n/-- An antitone sequence `f : \u2115 \u2192 \u211d\u22650` has a finite limit. -/\ntheorem tendsto_of_antitone {f : \u2115 \u2192 \u211d\u22650} (h_ant : Antitone f) :\n    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := by\n  have h_bdd_0 : (0 : \u211d) \u2208 lowerBounds (Set.range fun n : \u2115 => (f n : \u211d)) := by\n    rintro r \u27e8n, hn\u27e9\n    simp_rw [\u2190 hn]\n    exact NNReal.coe_nonneg _\n  obtain \u27e8L, hL\u27e9 := Real.tendsto_of_bddBelow_antitone \u27e80, h_bdd_0\u27e9 h_ant\n  have hL0 : 0 \u2264 L :=\n    haveI h_glb : IsGLB (Set.range fun n => (f n : \u211d)) L := isGLB_of_tendsto_atTop h_ant hL\n    (le_isGLB_iff h_glb).mpr h_bdd_0\n  exact \u27e8\u27e8L, hL0\u27e9, NNReal.tendsto_coe.mp hL\u27e9",
      "suggestion": "    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := \u27e8iInf f, tendsto_atTop_ciInf h_ant (by simp)\u27e9\n",
      "body": "```suggestion\n    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := \u27e8iInf f, tendsto_atTop_ciInf h_ant (by simp)\u27e9\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "lowerBounds",
          "mpr",
          "antitone",
          "rintro",
          "obtain",
          "hL0",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "have",
          "isGLB_of_tendsto_atTop",
          "exists_isLUB",
          "Antitone",
          "simp_rw",
          "h_mon",
          "range",
          "Real",
          "exists_isGLB",
          "Tendsto",
          "sequence",
          "IsGLB",
          "tendsto_of_bddAbove_monotone",
          "le_isGLB_iff",
          "tendsto_atTop_isLUB",
          "BddBelow",
          "tendsto_coe",
          "above",
          "bounded",
          "NNReal",
          "h_bdd",
          "below",
          "tendsto_atTop_isGLB",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set",
          "coe_nonneg",
          "h_bdd_0",
          "tendsto_of_bddBelow_antitone",
          "h_glb",
          "tendsto_of_antitone",
          "h_ant",
          "haveI"
        ]
      }
    },
    {
      "id": 332,
      "before_code": "\u2190 mul_assoc (f c ^ n), mul_inv_cancel\u2080 (pow_ne_zero n hc), one_mul, div_eq_mul_inv]\n\n/-- The real-valued function sending `x \u2208 R` to the limit of `(f (x * c^n))/((f c)^n)`. -/\ndef seminormFromConst' (x : R) : \u211d :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n    (seminormFromConst_seq_antitone hf1 hc hpm x)).choose\n\n/-- We prove that `seminormFromConst' hf1 hc hpm x` is the limit of the sequence\n  `seminormFromConst_seq c f x` as `n` tends to infinity. -/\ntheorem seminormFromConst_isLimit (x : R) :\n    Tendsto (seminormFromConst_seq c f x) atTop (\ud835\udcdd (seminormFromConst' hf1 hc hpm x)) :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n      (seminormFromConst_seq_antitone hf1 hc hpm x)).choose_spec\n\n/-- `seminormFromConst' hf1 hc hpm 1 = 1`. -/\ntheorem seminormFromConst_one : seminormFromConst' hf1 hc hpm 1 = 1 := by\n  apply tendsto_nhds_unique_of_eventuallyEq (seminormFromConst_isLimit hf1 hc hpm 1)",
      "suggestion": "theorem tendsto_seminormFromConst_seq_atTop (x : R) :\n",
      "body": "I would have sworn I already made this comment, but maybe not:\n```suggestion\ntheorem tendsto_seminormFromConst_seq_atTop (x : R) :\n```",
      "path": "Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "list",
          "real",
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "div_eq_mul_inv",
          "infinity",
          "real",
          "tends",
          "seminormFromConst",
          "hf1",
          "atTop",
          "seminormFromConst_seq",
          "one_mul",
          "apply",
          "limit",
          "seminormFromConst_isLimit",
          "prove",
          "pow_ne_zero",
          "choose_spec",
          "seminormFromConst_seq_antitone",
          "def",
          "Real",
          "sending",
          "Tendsto",
          "sequence",
          "seminormFromConst_one",
          "hpm",
          "that",
          "choose",
          "mul_assoc",
          "function",
          "theorem",
          "tendsto_nhds_unique_of_eventuallyEq",
          "valued",
          "seminormFromConst_bddBelow",
          "tendsto_of_bddBelow_antitone"
        ]
      }
    },
    {
      "id": 334,
      "before_code": "section Monotone",
      "suggestion": "  obtain rfl : iSup f = B := h_lub.csSup_eq (range_nonempty f)\n",
      "body": "This is a fun trick:\n```suggestion\n  obtain rfl : iSup f = B := h_lub.csSup_eq (range_nonempty f)\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Monotone",
          "section"
        ]
      }
    },
    {
      "id": 335,
      "before_code": "section Monotone",
      "suggestion": "    Tendsto f atTop (\ud835\udcdd (iSup f)) :=\n  tendsto_atTop_isLUB h_mon <| Real.isLUB_iSup ...\n",
      "body": "The proof should rather be\n```suggestion\n    Tendsto f atTop (\ud835\udcdd (iSup f)) :=\n  tendsto_atTop_isLUB h_mon <| Real.isLUB_iSup ...\n```\nbut we don't have `Real.isLUB_iSup`, only `Real.isLUB_sSup`. Mind adding it?",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Monotone",
          "section"
        ]
      }
    },
    {
      "id": 336,
      "before_code": "section Monotone",
      "suggestion": "\r\n/-- A monotone, bounded above sequence `f : \u03b9 \u2192 \u211d` on `s` has the finite\r\nlimit `sSup (f '' s)`. -/\r\ntheorem _root_.Real.tendsto_csSup_of_bddAbove_monotoneOn_Ici {f : \u03b9 \u2192 \u211d} {k : \u2115}\r\n    (h_bdd : BddAbove (f '' s)) (h_mon : MonotoneOn f s) :\r\n    Tendsto f atTop (\ud835\udcdd (sSup (f '' s))) := by\r\n  rw [\u2190 range_add_eq_image_Ici] at h_bdd\r\n  rw [Ici, \u2190 monotone_add_nat_iff_monotoneOn_nat_Ici] at h_mon\r\n  rw [\u2190 tendsto_add_atTop_iff_nat k, \u2190 range_add_eq_image_Ici, sSup_range]\r\n  exact Real.tendsto_ciSup_of_bddAbove_monotone h_bdd h_mon\r\n\r\n/-- An antitone, bounded below sequence `f : \u03b9 \u2192 \u211d` on `s` has the finite\r\nlimit `sInf (f '' s)`. -/\r\ntheorem _root_.Real.tendsto_csInf_of_bddBelow_antitoneOn_Ici {f : \u03b9 \u2192 \u211d} {k : \u2115}\r\n    (h_bdd : BddBelow (f '' s)) (h_ant : AntitoneOn f s) :\r\n    Tendsto f atTop (\ud835\udcdd (sInf (f '' s))) := by\r\n  rw [\u2190 range_add_eq_image_Ici] at h_bdd\r\n  rw [Ici, \u2190 antitone_add_nat_iff_antitoneOn_nat_Ici] at h_ant\r\n  rw [\u2190 tendsto_add_atTop_iff_nat k, \u2190 range_add_eq_image_Ici, sIn",
      "body": "but you can generalise to\r\n```suggestion\r\n/-- A monotone, bounded above sequence `f : \u03b9 \u2192 \u211d` on `s` has the finite\r\nlimit `sSup (f '' s)`. -/\r\ntheorem _root_.Real.tendsto_csSup_of_bddAbove_monotoneOn_Ici {f : \u03b9 \u2192 \u211d} {k : \u2115}\r\n    (h_bdd : BddAbove (f '' s)) (h_mon : MonotoneOn f s) :\r\n    Tendsto f atTop (\ud835\udcdd (sSup (f '' s))) := by\r\n  rw [\u2190 range_add_eq_image_Ici] at h_bdd\r\n  rw [Ici, \u2190 monotone_add_nat_iff_monotoneOn_nat_Ici] at h_mon\r\n  rw [\u2190 tendsto_add_atTop_iff_nat k, \u2190 range_add_eq_image_Ici,",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Monotone",
          "section"
        ]
      }
    },
    {
      "id": 340,
      "before_code": "SchwartzMap.bilinLeftCLM (ContinuousLinearMap.lsmul \ud835\udd5c \ud835\udd5c).flip hg\n  else 0",
      "suggestion": "@[simp]\ntheorem smulLeftCLM_apply {g : E \u2192 \ud835\udd5c} (hg : g.HasTemperateGrowth) (f : \ud835\udce2(E, F)) :\n",
      "body": "Can we give this lemma the `simp` instead of `smulLeftCLM_apply_apply`:\n```suggestion\n@[simp]\ntheorem smulLeftCLM_apply {g : E \u2192 \ud835\udd5c} (hg : g.HasTemperateGrowth) (f : \ud835\udce2(E, F)) :\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simp"
        ],
        "keywords": [
          "SchwartzMap",
          "else",
          "ContinuousLinearMap",
          "lsmul",
          "flip",
          "bilinLeftCLM"
        ]
      }
    },
    {
      "id": 342,
      "before_code": "end Zero\n\nsection One\n\nvariable [DecidableEq n] [MulZeroOneClass \u03b1]\nvariable (M : Matrix n n \u03b1)\n\ntheorem hadamard_one : M \u2299 (1 : Matrix n n \u03b1) = diagonal fun i => M i i := by\n  ext i j\n  by_cases h : i = j <;> simp [h]\n\ntheorem one_hadamard : (1 : Matrix n n \u03b1) \u2299 M = diagonal fun i => M i i := by\n  ext i j\n  by_cases h : i = j <;> simp [h]\n\nend One",
      "suggestion": "    A \u2299 of 1 = A := by ext; simp\n\n@[simp] theorem of_one_hadamard [MulOneClass \u03b1] (A : Matrix m n \u03b1) :\n    of 1 \u2299 A = A := by ext; simp\n",
      "body": "```suggestion\n    A \u2299 of 1 = A := by ext; simp\n\n@[simp] theorem of_one_hadamard [MulOneClass \u03b1] (A : Matrix m n \u03b1) :\n    of 1 \u2299 A = A := by ext; simp\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/Hadamard.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "ext",
          "variable",
          "by_cases",
          "theorem",
          "Matrix",
          "diagonal",
          "hadamard_one",
          "One",
          "DecidableEq",
          "simp",
          "MulZeroOneClass",
          "Zero",
          "one_hadamard",
          "section"
        ]
      }
    },
    {
      "id": 346,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "/-- Composition of intertwining maps. -/\ndef llcomp : IntertwiningMap \u03c3 \u03c4 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c3 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c4 where\n  toFun f :=\n    { toFun g :=\n      { toLinearMap := f.toLinearMap.comp g.toLinearMap\n        isIntertwining' := by simp [f.isIntertwining, g.isIntertwining] }\n      map_add' _ _ := by ext; simp [map_add]\n      map_smul' _ _ := by ext; simp }\n  map_add' _ _ := by ext; simp\n  map_smul' _ _ := by ext; simp\n\nvariable {\u03c1 \u03c3 \u03c4} in\n/-- Composition of intertwining maps.\n\nA convenience variant of `IntertwiningMap.llcomp` for use in dot notation. -/\ndef comp (f : IntertwiningMap \u03c3 \u03c4) (g : IntertwiningMap \u03c1 \u03c3) : IntertwiningMap \u03c1 \u03c4 :=\n  llcomp _ _ _ f g\n",
      "body": "How about we also capture the fact that this operation is bilinear as follows:\n```suggestion\n/-- Composition of intertwining maps. -/\ndef llcomp : IntertwiningMap \u03c3 \u03c4 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c3 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c4 where\n  toFun f :=\n    { toFun g :=\n      { toLinearMap := f.toLinearMap.comp g.toLinearMap\n        isIntertwining' := by simp [f.isIntertwining, g.isIntertwining] }\n      map_add' _ _ := by ext; simp [map_add]\n      map_smul' _ _ := by ext; simp }\n  map_add' _ _ := by ext; simp\n ",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 347,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "      | succ n ih => simp [pow_succ, ih, show f ^ (n + 1) = f ^ n * f from rfl])\n",
      "body": "After dropping the lemma above this can be just:\n```suggestion\n      | succ n ih => simp [pow_succ, ih, show f ^ (n + 1) = f ^ n * f from rfl])\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 348,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "      | succ n ih => simp [ih, pow_succ])\n",
      "body": "After dropping the lemma above, there's no longer ambiguity:\n```suggestion\n      | succ n ih => simp [ih, pow_succ])\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 349,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "\n@[simp] lemma mul_apply (f g : IntertwiningMap \u03c1 \u03c1) (v : V) : (f * g) v = f (g v) := rfl\n\n",
      "body": "This will help below:\n```suggestion\n\n@[simp] lemma mul_apply (f g : IntertwiningMap \u03c1 \u03c1) (v : V) : (f * g) v = f (g v) := rfl\n\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 350,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "  Algebra.ofModule (fun a f g => rfl) (fun a f g => by ext; simp)\n",
      "body": "If we add `mul_apply` above, this can be just:\n```suggestion\n  Algebra.ofModule (fun a f g => rfl) (fun a f g => by ext; simp)\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 351,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "\n@[simp] lemma algebraMap_apply (a : A) : algebraMap A (IntertwiningMap \u03c1 \u03c1) a = a \u2022 1 := rfl\n\n",
      "body": "An `Algebra` structure includes the data of `algebraMap` so we should characterise it:\n```suggestion\n\n@[simp] lemma algebraMap_apply (a : A) : algebraMap A (IntertwiningMap \u03c1 \u03c1) a = a \u2022 1 := rfl\n\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 353,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "  have : IsSimpleModule k[G] \u03c1.asModule :=\n    (irreducible_iff_isSimpleModule_asModule \u03c1).mp inferInstance\n",
      "body": "The `I` in `haveI` is for \"inline\" and we don't need this.\n```suggestion\n  have : IsSimpleModule k[G] \u03c1.asModule :=\n    (irreducible_iff_isSimpleModule_asModule \u03c1).mp inferInstance\n```\nsimilarly several times below",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 355,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "      | succ n ih => simp only [pow_succ, coe_mul, show f ^ (n + 1) = f ^ n * f from rfl, ih])\n",
      "body": "```suggestion\n      | succ n ih => simp only [pow_succ, coe_mul, show f ^ (n + 1) = f ^ n * f from rfl, ih])\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 357,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "\ninstance : IsSimpleModule k[G] \u03c1.asModule :=\n  (irreducible_iff_isSimpleModule_asModule \u03c1).mp inferInstance\n\n",
      "body": "If we add this:\n```suggestion\n\ninstance : IsSimpleModule k[G] \u03c1.asModule :=\n  (irreducible_iff_isSimpleModule_asModule \u03c1).mp inferInstance\n\n```\nthen you can drop all the `have _ : IsSimpleModule k[G] \u03c1.asModule :=` within the proofs.",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 358,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "theorem algebraMap_intertwiningMap_bijective_of_isAlgClosed :\n    Bijective (algebraMap k (IntertwiningMap \u03c1 \u03c1)) := by\n  have : Bijective (algebraMap k (Module.End k[G] \u03c1.asModule)) :=\n    IsSimpleModule.algebraMap_end_bijective_of_isAlgClosed k\n  exact (Bijective.of_comp_iff' (IntertwiningMap.equivAlgEnd \u03c1).bijective _).1 this\n",
      "body": "```suggestion\ntheorem algebraMap_intertwiningMap_bijective_of_isAlgClosed :\n    Bijective (algebraMap k (IntertwiningMap \u03c1 \u03c1)) := by\n  have : Bijective (algebraMap k (Module.End k[G] \u03c1.asModule)) :=\n    IsSimpleModule.algebraMap_end_bijective_of_isAlgClosed k\n  exact (Bijective.of_comp_iff' (IntertwiningMap.equivAlgEnd \u03c1).bijective _).1 this\n```",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 359,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "include \u03c1 in\nvariable (\u03c1) in\ntheorem finrank_eq_one_of_isMulCommutative [IsMulCommutative G] :\n    Module.finrank k V = 1 := by\n  have : IsMulCommutative k[G] := \u27e8\u27e8mul_comm\u27e9\u27e9\n",
      "body": "```suggestion\ninclude \u03c1 in\nvariable (\u03c1) in\ntheorem finrank_eq_one_of_isMulCommutative [IsMulCommutative G] :\n    Module.finrank k V = 1 := by\n  have : IsMulCommutative k[G] := \u27e8\u27e8mul_comm\u27e9\u27e9\n```",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 360,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso\n\nend",
      "suggestion": "",
      "body": "This can be dropped now that you've added the instance above:\n```suggestion\n```",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "end",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 373,
      "before_code": "g_an.continuousAt.continuousWithinAt.tendsto.norm\n    have : Tendsto (fun z \u21a6 z - x) (\ud835\udcdd[\u2260] x) (\ud835\udcdd[\u2260] 0) := by\n      refine tendsto_nhdsWithin_iff.2 \u27e8?_, ?_\u27e9\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) ({x}\u1d9c) x :=\n          ContinuousAt.continuousWithinAt (by fun_prop)",
      "suggestion": "\r\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) {x}\u1d9c x := by fun_prop\r\n",
      "body": "```suggestion\r\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) {x}\u1d9c x := by fun_prop\r\n```\r\nWhy the brackets?",
      "path": "Mathlib/Analysis/Meromorphic/Order.lean",
      "tags": {
        "before_tactics": [
          "fun_prop",
          "refine",
          "have"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "have"
        ],
        "body_tactics": [
          "fun_prop",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "continuity",
          "norm"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "ContinuousWithinAt",
          "tendsto",
          "refine",
          "tendsto_nhdsWithin_iff",
          "continuousAt",
          "ContinuousAt",
          "have",
          "Tendsto",
          "norm",
          "continuousWithinAt",
          "g_an",
          "fun_prop"
        ]
      }
    },
    {
      "id": 374,
      "before_code": "have : x = (fun \u03b5 : \u211d => mulExpNegMulSq \u03b5 x) 0 := by\n    simp only [mulExpNegMulSq, zero_mul, neg_zero, exp_zero, mul_one]\n  nth_rw 2 [this]\n  apply Continuous.tendsto (Continuous.mul continuous_const (by fun_prop))",
      "suggestion": "\r\n  apply Continuous.tendsto (by fun_prop)\r\n",
      "body": "Unnecessary diff? or maybe\r\n```suggestion\r\n  apply Continuous.tendsto (by fun_prop)\r\n```\r\nworks?",
      "path": "Mathlib/Analysis/SpecialFunctions/MulExpNegMulSq.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "have",
          "simp",
          "fun_prop"
        ],
        "suggestion_tactics": [
          "apply",
          "fun_prop"
        ],
        "body_tactics": [
          "apply",
          "fun_prop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "have"
        ],
        "topics": [
          "continuity",
          "real",
          "list"
        ],
        "transforms": [
          "remove_redundant",
          "use_fun_prop"
        ],
        "keywords": [
          "apply",
          "nth_rw",
          "tendsto",
          "have",
          "this",
          "exp_zero",
          "mulExpNegMulSq",
          "continuous_const",
          "mul_one",
          "neg_zero",
          "simp",
          "Continuous",
          "fun_prop",
          "zero_mul",
          "mul",
          "only"
        ]
      }
    },
    {
      "id": 375,
      "before_code": "apply ((continuous_sub_right _).smul P.differentiable_\u039b\u2080.continuous).tendsto\n  \u00b7 rw [(by rw [sub_self, zero_smul] : \ud835\udcdd 0 = \ud835\udcdd ((P.k - P.k : \u2102) \u2022 (1 / P.k : \u2102) \u2022 P.f\u2080))]\n    refine (continuous_sub_right _).continuousAt.smul (ContinuousAt.smul ?_ continuousAt_const)\n    exact continuousAt_const.div continuousAt_id (ofReal_ne_zero.mpr P.hk.ne')",
      "suggestion": "\r\n    have := ofReal_ne_zero.mpr P.hk.ne'\r\n",
      "body": "```suggestion\r\n    have := ofReal_ne_zero.mpr P.hk.ne'\r\n```",
      "path": "Mathlib/NumberTheory/LSeries/AbstractFuncEq.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "apply",
          "rw",
          "refine"
        ],
        "topics": [
          "continuity",
          "complex",
          "differentiability",
          "list"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "smul",
          "mpr",
          "tendsto",
          "refine",
          "ofReal_ne_zero",
          "exact",
          "zero_smul",
          "sub_self",
          "continuousAt",
          "ContinuousAt",
          "continuous",
          "div",
          "continuousAt_id",
          "continuous_sub_right",
          "continuousAt_const"
        ]
      }
    },
    {
      "id": 378,
      "before_code": "prime_factors_unique (fun x hx => UniqueFactorizationMonoid.irreducible_iff_prime.mp (hf x hx))\n    (fun x hx => UniqueFactorizationMonoid.irreducible_iff_prime.mp (hg x hx)) h",
      "suggestion": "  \u00b7 simp_all\n",
      "body": "```suggestion\n  \u00b7 simp_all\n```",
      "path": "Mathlib/RingTheory/UniqueFactorizationDomain/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "irreducible_iff_prime",
          "UniqueFactorizationMonoid",
          "prime_factors_unique"
        ]
      }
    },
    {
      "id": 381,
      "before_code": "theorem self_symm_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : X \u2245 Z) : \u03b1 \u226a\u226b \u03b1.symm \u226a\u226b \u03b2 = \u03b2 := by\n  rw [\u2190 trans_assoc, self_symm_id, refl_trans]\n\ntheorem inv_comp_eq (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_inv_comp (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f :=\n  (inv_comp_eq \u03b1.symm).symm\n\ntheorem comp_inv_eq (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b \u03b1.inv = g \u2194 f = g \u226b \u03b1.hom :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_comp_inv (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b \u03b1.inv \u2194 g \u226b \u03b1.hom = f :=\n  (comp_inv_eq \u03b1.symm).symm\n\ntheorem inv_eq_inv (f g : X \u2245 Y) : f.inv = g.inv \u2194 f.hom = g.hom :=\n  have : \u2200 {X Y : C} (f g : X \u2245 Y), f.hom = g.hom \u2192 f.inv = g.inv := fun f g h => by rw [ext h]\n  \u27e8this f.symm g.symm, this f g\u27e9\n\ntheorem hom_comp_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : \u03b1.hom \u226b f = \ud835\udfd9 X \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_inv_comp, comp_id]\n\ntheorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_comp_inv, id_comp]\n\ntheorem inv_comp_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : \u03b1.inv \u226b f = \ud835\udfd9 Y \u2194 f = \u03b1.hom :=\n  hom_comp_eq_id \u03b1.symm\n\ntheorem comp_inv_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : f \u226b \u03b1.inv = \ud835\udfd9 X \u2194 f = \u03b1.hom :=\n  comp_hom_eq_id \u03b1.symm\n\ntheorem hom_eq_inv (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 X) : \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv := by\n  rw [\u2190 symm_inv, inv_eq_inv \u03b1.symm \u03b2, eq_comm]\n  rfl\n\nattribute [local grind] Function.LeftInverse Function.RightInverse\n\n/-- The bijection `(Z \u27f6 X) \u2243 (Z \u27f6 Y)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homToEquiv (\u03b1 : X \u2245 Y) {Z : C} : (Z \u27f6 X) \u2243 (Z \u27f6 Y) where\n  toFun f := f \u226b \u03b1.hom\n  invFun g := g \u226b \u03b1.inv\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\n/-- The bijection `(X \u27f6 Z) \u2243 (Y \u27f6 Z)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homFromEquiv (\u03b1 : X \u2245 Y) {Z : C} : (X \u27f6 Z) \u2243 (Y \u27f6 Z) where\n  toFun f := \u03b1.inv \u226b f\n  invFun g := \u03b1.hom \u226b g\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\nend Iso\n\n/-- The `IsIso` t",
      "suggestion": "\r\n@[aesop apply safe (rule_sets := [CategoryTheory]), to_dual (reorder := X Y) eq_inv_of_inv_hom_id]\r\n",
      "body": "```suggestion\r\n@[aesop apply safe (rule_sets := [CategoryTheory]), to_dual (reorder := X Y) eq_inv_of_inv_hom_id]\r\n```",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "aesop",
          "ext",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop"
        ],
        "body_tactics": [
          "apply",
          "aesop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory",
          "function"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "symm_inv",
          "IsIso",
          "note",
          "lean",
          "typeclass",
          "open",
          "epi_of_iso",
          "eq_comm",
          "been",
          "trans_assoc",
          "have",
          "inv_hom_id",
          "Prop",
          "failing",
          "priority",
          "Epi",
          "Iso",
          "inv_comp_eq_id",
          "Mono",
          "inverse",
          "out",
          "def",
          "comp_inv_eq",
          "right_inv",
          "simps",
          "that",
          "had",
          "right_cancellation",
          "simp",
          "choose",
          "rfl",
          "theorem",
          "Category",
          "left",
          "Reinterpret",
          "reassoc",
          "left_inv",
          "inv_hom_id_assoc",
          "eq_inv_comp",
          "end",
          "existence",
          "comp_id",
          "safe",
          "self_symm_id_assoc",
          "isomorphism",
          "CategoryTheory",
          "when",
          "asIso",
          "Function",
          "homFromEquiv"
        ]
      }
    },
    {
      "id": 382,
      "before_code": "theorem self_symm_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : X \u2245 Z) : \u03b1 \u226a\u226b \u03b1.symm \u226a\u226b \u03b2 = \u03b2 := by\n  rw [\u2190 trans_assoc, self_symm_id, refl_trans]\n\ntheorem inv_comp_eq (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_inv_comp (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f :=\n  (inv_comp_eq \u03b1.symm).symm\n\ntheorem comp_inv_eq (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b \u03b1.inv = g \u2194 f = g \u226b \u03b1.hom :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_comp_inv (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b \u03b1.inv \u2194 g \u226b \u03b1.hom = f :=\n  (comp_inv_eq \u03b1.symm).symm\n\ntheorem inv_eq_inv (f g : X \u2245 Y) : f.inv = g.inv \u2194 f.hom = g.hom :=\n  have : \u2200 {X Y : C} (f g : X \u2245 Y), f.hom = g.hom \u2192 f.inv = g.inv := fun f g h => by rw [ext h]\n  \u27e8this f.symm g.symm, this f g\u27e9\n\ntheorem hom_comp_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : \u03b1.hom \u226b f = \ud835\udfd9 X \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_inv_comp, comp_id]\n\ntheorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_comp_inv, id_comp]\n\ntheorem inv_comp_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : \u03b1.inv \u226b f = \ud835\udfd9 Y \u2194 f = \u03b1.hom :=\n  hom_comp_eq_id \u03b1.symm\n\ntheorem comp_inv_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : f \u226b \u03b1.inv = \ud835\udfd9 X \u2194 f = \u03b1.hom :=\n  comp_hom_eq_id \u03b1.symm\n\ntheorem hom_eq_inv (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 X) : \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv := by\n  rw [\u2190 symm_inv, inv_eq_inv \u03b1.symm \u03b2, eq_comm]\n  rfl\n\nattribute [local grind] Function.LeftInverse Function.RightInverse\n\n/-- The bijection `(Z \u27f6 X) \u2243 (Z \u27f6 Y)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homToEquiv (\u03b1 : X \u2245 Y) {Z : C} : (Z \u27f6 X) \u2243 (Z \u27f6 Y) where\n  toFun f := f \u226b \u03b1.hom\n  invFun g := g \u226b \u03b1.inv\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\n/-- The bijection `(X \u27f6 Z) \u2243 (Y \u27f6 Z)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homFromEquiv (\u03b1 : X \u2245 Y) {Z : C} : (X \u27f6 Z) \u2243 (Y \u27f6 Z) where\n  toFun f := \u03b1.inv \u226b f\n  invFun g := \u03b1.hom \u226b g\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\nend Iso\n\n/-- The `IsIso` t",
      "suggestion": "\r\n@[to_dual (attr := simp) (reorder := X Y) comp_inv_eq]\r\n",
      "body": "```suggestion\r\n@[to_dual (attr := simp) (reorder := X Y) comp_inv_eq]\r\n```",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "grind",
          "have",
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "symm_inv",
          "inferInstance",
          "IsIso",
          "loop",
          "note",
          "lean",
          "Type",
          "make",
          "typeclass",
          "easier",
          "open",
          "epi_of_iso",
          "eq_comm",
          "been",
          "trans_assoc",
          "have",
          "inv_hom_id",
          "Prop",
          "failing",
          "priority",
          "reason",
          "Epi",
          "Iso",
          "cannot",
          "inv_comp_eq_id",
          "Mono",
          "inverse",
          "out",
          "arguments",
          "def",
          "Here",
          "comp_inv_eq",
          "right_inv",
          "simps",
          "that",
          "had",
          "right_cancellation",
          "simp",
          "choose",
          "rfl",
          "theorem",
          "Without",
          "Category",
          "left",
          "Reinterpret",
          "reassoc",
          "left_inv",
          "isomorphisms",
          "inv_hom_id_assoc",
          "eq_inv_comp"
        ]
      }
    },
    {
      "id": 383,
      "before_code": "theorem self_symm_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : X \u2245 Z) : \u03b1 \u226a\u226b \u03b1.symm \u226a\u226b \u03b2 = \u03b2 := by\n  rw [\u2190 trans_assoc, self_symm_id, refl_trans]\n\ntheorem inv_comp_eq (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_inv_comp (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f :=\n  (inv_comp_eq \u03b1.symm).symm\n\ntheorem comp_inv_eq (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b \u03b1.inv = g \u2194 f = g \u226b \u03b1.hom :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_comp_inv (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b \u03b1.inv \u2194 g \u226b \u03b1.hom = f :=\n  (comp_inv_eq \u03b1.symm).symm\n\ntheorem inv_eq_inv (f g : X \u2245 Y) : f.inv = g.inv \u2194 f.hom = g.hom :=\n  have : \u2200 {X Y : C} (f g : X \u2245 Y), f.hom = g.hom \u2192 f.inv = g.inv := fun f g h => by rw [ext h]\n  \u27e8this f.symm g.symm, this f g\u27e9\n\ntheorem hom_comp_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : \u03b1.hom \u226b f = \ud835\udfd9 X \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_inv_comp, comp_id]\n\ntheorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_comp_inv, id_comp]\n\ntheorem inv_comp_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : \u03b1.inv \u226b f = \ud835\udfd9 Y \u2194 f = \u03b1.hom :=\n  hom_comp_eq_id \u03b1.symm\n\ntheorem comp_inv_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : f \u226b \u03b1.inv = \ud835\udfd9 X \u2194 f = \u03b1.hom :=\n  comp_hom_eq_id \u03b1.symm\n\ntheorem hom_eq_inv (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 X) : \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv := by\n  rw [\u2190 symm_inv, inv_eq_inv \u03b1.symm \u03b2, eq_comm]\n  rfl\n\nattribute [local grind] Function.LeftInverse Function.RightInverse\n\n/-- The bijection `(Z \u27f6 X) \u2243 (Z \u27f6 Y)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homToEquiv (\u03b1 : X \u2245 Y) {Z : C} : (Z \u27f6 X) \u2243 (Z \u27f6 Y) where\n  toFun f := f \u226b \u03b1.hom\n  invFun g := g \u226b \u03b1.inv\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\n/-- The bijection `(X \u27f6 Z) \u2243 (Y \u27f6 Z)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homFromEquiv (\u03b1 : X \u2245 Y) {Z : C} : (X \u27f6 Z) \u2243 (Y \u27f6 Z) where\n  toFun f := \u03b1.inv \u226b f\n  invFun g := \u03b1.hom \u226b g\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\nend Iso\n\n/-- The `IsIso` t",
      "suggestion": "\r\n@[to_dual (attr := simp) (reorder := X Y) eq_comp_inv]\r\n",
      "body": "```suggestion\r\n@[to_dual (attr := simp) (reorder := X Y) eq_comp_inv]\r\n```",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "grind",
          "have",
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "symm_inv",
          "inferInstance",
          "IsIso",
          "loop",
          "note",
          "lean",
          "Type",
          "make",
          "typeclass",
          "easier",
          "open",
          "epi_of_iso",
          "eq_comm",
          "been",
          "trans_assoc",
          "have",
          "inv_hom_id",
          "Prop",
          "failing",
          "priority",
          "reason",
          "Epi",
          "Iso",
          "cannot",
          "inv_comp_eq_id",
          "Mono",
          "inverse",
          "out",
          "arguments",
          "def",
          "Here",
          "comp_inv_eq",
          "right_inv",
          "simps",
          "that",
          "had",
          "right_cancellation",
          "simp",
          "choose",
          "rfl",
          "theorem",
          "Without",
          "Category",
          "left",
          "Reinterpret",
          "reassoc",
          "left_inv",
          "isomorphisms",
          "inv_hom_id_assoc",
          "eq_inv_comp"
        ]
      }
    },
    {
      "id": 384,
      "before_code": "-/\n\n\n@[simp]",
      "suggestion": "\r\n@[to_dual (attr := simp) (reorder := f g, g g', Z X) cancel_iso_inv_right]\r\n",
      "body": "```suggestion\r\n@[to_dual (attr := simp) (reorder := f g, g g', Z X) cancel_iso_inv_right]\r\n```\r\nyou might want to double-check this one, a similar one is needed for the one below",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp"
        ]
      }
    },
    {
      "id": 387,
      "before_code": "theorem mod_mul_left_mod (a b c : \u2124) : a % (b * c) % c = a % c :=\n  (mod_modEq _ _).of_mul_left _",
      "suggestion": "\r\ntheorem ext_ediv_modEq {n a b : \u2124} (h0 : a / n = b / n) (h1 : a \u2261 b [ZMOD n]) : a = b :=\r\n",
      "body": "```suggestion\r\ntheorem ext_ediv_modEq {n a b : \u2124} (h0 : a / n = b / n) (h1 : a \u2261 b [ZMOD n]) : a = b :=\r\n```\r\ngenerally mathlib prefers hyps over implications in the statement. Exactly analog to how you have it in the file above.",
      "path": "Mathlib/Data/Int/ModEq.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "of_mul_left",
          "mod_mul_left_mod",
          "mod_modEq",
          "theorem"
        ]
      }
    },
    {
      "id": 392,
      "before_code": "obtain \u27e8y, rfl, hcodisjoint\u27e9 := exists_inf_eq_and_codisjoint hx\n    exact \u27e8\u27e8y, inf_le_right\u27e9, rfl, hcodisjoint\u27e9",
      "suggestion": "\r\n  exact \u27e8u \u2294 a, le_sup_right, hab.isCompl_sup_left_of_isCompl_sup_right hu.symm\u27e9\r\n",
      "body": "```suggestion\r\n  exact \u27e8u \u2294 a, le_sup_right, hab.isCompl_sup_left_of_isCompl_sup_right hu.symm\u27e9\r\n```",
      "path": "Mathlib/Order/ModularLattice.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hcodisjoint",
          "exact",
          "inf_le_right",
          "exists_inf_eq_and_codisjoint",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 393,
      "before_code": "obtain \u27e8y, rfl, hcodisjoint\u27e9 := exists_inf_eq_and_codisjoint hx\n    exact \u27e8\u27e8y, inf_le_right\u27e9, rfl, hcodisjoint\u27e9",
      "suggestion": "\r\n@[to_dual /-- A codisjoint element can be shrunk to a complementary element. -/]\r\n",
      "body": "The name can be generated automatically.\r\n```suggestion\r\n@[to_dual /-- A codisjoint element can be shrunk to a complementary element. -/]\r\n```",
      "path": "Mathlib/Order/ModularLattice.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hcodisjoint",
          "exact",
          "inf_le_right",
          "exists_inf_eq_and_codisjoint",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 397,
      "before_code": "(isPrimitive_def _).1 (1 : DirichletCharacter R n).primitiveCharacter_isPrimitive,\n      conductor_one hn]",
      "suggestion": "    obtain \u27e8_, \u03c7\u2081, h\u03c7\u2081\u27e9 := factorsThrough_gcd \u03c7\u2080 \u03c7.primitiveCharacter this\n",
      "body": "```suggestion\n    obtain \u27e8_, \u03c7\u2081, h\u03c7\u2081\u27e9 := factorsThrough_gcd \u03c7\u2080 \u03c7.primitiveCharacter this\n```",
      "path": "Mathlib/NumberTheory/DirichletCharacter/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isPrimitive_def",
          "DirichletCharacter",
          "primitiveCharacter_isPrimitive",
          "conductor_one"
        ]
      }
    },
    {
      "id": 413,
      "before_code": "This procedure is mostly intended as a post-procedure: it will work better if `f` and `g`\nhave already been traversed beforehand. -/\ndef cancelIsoSimproc : Simp.Simproc := fun e => withReducible do -- is withReducible necessary here?\n  let e_whnf \u2190 whnf e\n  let_expr CategoryStruct.comp C instCat x y t f g := e_whnf | return .continue",
      "suggestion": "\r\ndef cancelIsoSimproc : Simp.Simproc := fun e => do\r\n",
      "body": "```suggestion\r\ndef cancelIsoSimproc : Simp.Simproc := fun e => do\r\n```",
      "path": "Mathlib/Tactic/CategoryTheory/CancelIso.lean",
      "tags": {
        "before_tactics": [
          "have",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "have"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "let_expr",
          "traversed",
          "necessary",
          "already",
          "mostly",
          "better",
          "work",
          "This",
          "been",
          "Simproc",
          "here",
          "have",
          "instCat",
          "withReducible",
          "continue",
          "Simp",
          "procedure",
          "def",
          "return",
          "comp",
          "will",
          "cancelIsoSimproc",
          "whnf",
          "intended",
          "post",
          "e_whnf",
          "CategoryStruct",
          "beforehand"
        ]
      }
    },
    {
      "id": 414,
      "before_code": "rw [\u2190 h]\n  exact IsIso.hom_inv_id_assoc f k",
      "suggestion": "\r\n    (\u2190 (\u2190 pushed_g.proof?.mapM mkEqSymm).getDM (mkEqRefl g))\r\n",
      "body": "```suggestion\r\n    (\u2190 (\u2190 pushed_g.proof?.mapM mkEqSymm).getDM (mkEqRefl g))\r\n```\r\nThis way, we avoid running `mkEqSymm` on the `rfl` proof.",
      "path": "Mathlib/Tactic/CategoryTheory/CancelIso.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "hom_inv_id_assoc",
          "IsIso"
        ]
      }
    },
    {
      "id": 415,
      "before_code": "public import Mathlib.CategoryTheory.Functor.Category\npublic import Mathlib.CategoryTheory.Iso",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis import should now be redundant",
      "path": "Mathlib/CategoryTheory/NatIso.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "import",
          "Mathlib",
          "public",
          "Functor",
          "Category",
          "CategoryTheory",
          "Iso"
        ]
      }
    },
    {
      "id": 420,
      "before_code": "SMulCommClass \u03b1 S \u03b2 :=\n  inferInstance",
      "suggestion": "\r\n    SMulCommClass R \u21a5(Subsemiring.center R) M :=\r\n  inferInstanceAs <| SMulCommClass R \u21a5(Submonoid.center R)\r\n",
      "body": "```suggestion\r\n    SMulCommClass R \u21a5(Subsemiring.center R) M :=\r\n  inferInstanceAs <| SMulCommClass R \u21a5(Submonoid.center R)\r\n```",
      "path": "Mathlib/Algebra/Ring/Subsemiring/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "SMulCommClass",
          "inferInstance"
        ]
      }
    },
    {
      "id": 421,
      "before_code": "SMulCommClass \u03b1 S \u03b2 :=\n  inferInstance",
      "suggestion": "\r\ninstance {R M : Type*} [Semiring R] [MulAction R M] :\r\n",
      "body": "```suggestion\r\ninstance {R M : Type*} [Semiring R] [MulAction R M] :\r\n```\r\nand below",
      "path": "Mathlib/Algebra/Ring/Subsemiring/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "SMulCommClass",
          "inferInstance"
        ]
      }
    },
    {
      "id": 422,
      "before_code": "instance center.smulCommClass_right : SMulCommClass R (center R) R :=\n  Subsemiring.center.smulCommClass_right",
      "suggestion": "\r\n/-- The center of a semiring acts commutatively on any `R`-module -/\r\ninstance {M : Type*} [MulAction R M] :\r\n    SMulCommClass R (Subring.center R) M :=\r\n  inferInstanceAs <| SMulCommClass R \u21a5(Submonoid.center R) M\r\n\r\n/-- The center of a semiring acts commutatively on any `R`-module -/\r\ninstance {M : Type*} [MulAction R M] :\r\n    SMulCommClass (Subring.center R) R M :=\r\n  inferInstanceAs <| SMulCommClass \u21a5(Submonoid.center R) R M\r\n",
      "body": "```suggestion\r\n/-- The center of a semiring acts commutatively on any `R`-module -/\r\ninstance {M : Type*} [MulAction R M] :\r\n    SMulCommClass R (Subring.center R) M :=\r\n  inferInstanceAs <| SMulCommClass R \u21a5(Submonoid.center R) M\r\n\r\n/-- The center of a semiring acts commutatively on any `R`-module -/\r\ninstance {M : Type*} [MulAction R M] :\r\n    SMulCommClass (Subring.center R) R M :=\r\n  inferInstanceAs <| SMulCommClass \u21a5(Submonoid.center R) R M\r\n```",
      "path": "Mathlib/Algebra/Ring/Subring/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "center",
          "SMulCommClass",
          "smulCommClass_right",
          "Subsemiring",
          "instance"
        ]
      }
    },
    {
      "id": 424,
      "before_code": "SMulCommClass \u03b1 S \u03b2 :=\n  inferInstance",
      "suggestion": "instance {R M : Type*} [Semiring R] [MulAction R M] :\n    SMulCommClass R (Subsemiring.center R) M :=\n  inferInstanceAs <| SMulCommClass R (Submonoid.center R) M\n\ninstance {R M : Type*} [Semiring R] [MulAction R M] :\n    SMulCommClass (Subsemiring.center R) R M :=\n  inferInstanceAs <| SMulCommClass (Submonoid.center R) R M\n",
      "body": "```suggestion\ninstance {R M : Type*} [Semiring R] [MulAction R M] :\n    SMulCommClass R (Subsemiring.center R) M :=\n  inferInstanceAs <| SMulCommClass R (Submonoid.center R) M\n\ninstance {R M : Type*} [Semiring R] [MulAction R M] :\n    SMulCommClass (Subsemiring.center R) R M :=\n  inferInstanceAs <| SMulCommClass (Submonoid.center R) R M\n```",
      "path": "Mathlib/Algebra/Ring/Subsemiring/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "SMulCommClass",
          "inferInstance"
        ]
      }
    },
    {
      "id": 430,
      "before_code": "abbrev Coloring (\u03b1 : Type v) := G \u2192g completeGraph \u03b1\n\nvariable {G}\nvariable {\u03b1 \u03b2 : Type*} (C : G.Coloring \u03b1)\n\ntheorem Coloring.valid {v w : V} (h : G.Adj v w) : C v \u2260 C w :=\n  C.map_rel h",
      "suggestion": "\r\nlemma Coloring.comp_injective_of_pairwise_adj (C : G.Coloring \u03b1) (f : \u03b9 \u2192 V)\r\n    (hf : Pairwise (G.Adj on f)) : (C \u2218 f).Injective :=\r\n  Function.injective_iff_pairwise_ne.2 <| hf.mono fun _ _ \u21a6 C.valid\r\n",
      "body": "```suggestion\r\nlemma Coloring.comp_injective_of_pairwise_adj (C : G.Coloring \u03b1) (f : \u03b9 \u2192 V)\r\n    (hf : Pairwise (G.Adj on f)) : (C \u2218 f).Injective :=\r\n  Function.injective_iff_pairwise_ne.2 <| hf.mono fun _ _ \u21a6 C.valid\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Adj",
          "map_rel",
          "variable",
          "abbrev",
          "theorem",
          "Coloring",
          "Type",
          "valid",
          "completeGraph"
        ]
      }
    },
    {
      "id": 431,
      "before_code": "/-- If `G` is `n`-colorable, then mapping the vertices of `G` produces an `n`-colorable simple\ngraph. -/\ntheorem Colorable.map {\u03b2 : Type*} (f : V \u21aa \u03b2) [NeZero n] {G : SimpleGraph V} (hc : G.Colorable n) :\n    (G.map f).Colorable n := by\n  obtain \u27e8C\u27e9 := hc\n  use extend f C (const \u03b2 default)\n  intro a b \u27e8_, _, hadj, ha, hb\u27e9\n  rw [\u2190 ha, f.injective.extend_apply, \u2190 hb, f.injective.extend_apply]\n  exact C.valid hadj\n\n/-- The \"tautological\" coloring of a graph, using the vertices of the graph as colors. -/\ndef selfColoring : G.Coloring V := Coloring.mk id fun {_ _} => G.ne_of_adj\n\n/-- The chromatic number of a graph is the minimal number of colors needed to color it.\nThis is `\u22a4` (infinity) iff `G` isn't colorable with finitely many colors.\n\nIf `G` is colorable, then `ENat.toNat G.chromaticNumber` is the `\u2115`-valued chromatic number. -/\nnoncomputable def chromaticNumber : \u2115\u221e := \u2a05 n \u2208 setOf G.Colorable, (n : \u2115\u221e)\n\nlemma chromaticNumber_eq_biInf {G : SimpleGraph V} :\n    G.chromaticNumber = \u2a05 n \u2208 setOf G.Colorable, (n : \u2115\u221e) := rfl\n\nlemma chromaticNumber_eq_iInf {G : SimpleGraph V} :\n    G.chromaticNumber = \u2a05 n : {m | G.Colorable m}, (n : \u2115\u221e) := by",
      "suggestion": "\r\nvariable (G) in\r\nlemma chromaticNumber_eq_biInf : G.chromaticNumber = \u2a05 n \u2208 setOf G.Colorable, (n : \u2115\u221e) := rfl\r\n",
      "body": "```suggestion\r\nvariable (G) in\r\nlemma chromaticNumber_eq_biInf : G.chromaticNumber = \u2a05 n \u2208 setOf G.Colorable, (n : \u2115\u221e) := rfl\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "list",
          "order",
          "function",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "selfColoring",
          "simple",
          "lemma",
          "infinity",
          "Type",
          "chromaticNumber",
          "const",
          "many",
          "chromatic",
          "tautological",
          "obtain",
          "Colorable",
          "colorable",
          "coloring",
          "This",
          "noncomputable",
          "extend",
          "Coloring",
          "setOf",
          "iff",
          "produces",
          "map",
          "vertices",
          "hadj",
          "intro",
          "minimal",
          "chromaticNumber_eq_iInf",
          "injective",
          "SimpleGraph",
          "toNat",
          "colors",
          "ne_of_adj",
          "def",
          "extend_apply",
          "then",
          "number",
          "default",
          "rfl",
          "valid",
          "isn",
          "use",
          "graph",
          "theorem",
          "exact",
          "needed",
          "NeZero",
          "chromaticNumber_eq_biInf",
          "mapping",
          "valued",
          "finitely"
        ]
      }
    },
    {
      "id": 432,
      "before_code": "/-! ### Cliques -/",
      "suggestion": "\r\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) (hc : G.Colorable n) :\r\n    s.card \u2264 n := by\r\n  simpa using hc.card_le_of_pairwise_adj _ <| s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n",
      "body": "```suggestion\r\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) (hc : G.Colorable n) :\r\n    s.card \u2264 n := by\r\n  simpa using hc.card_le_of_pairwise_adj _ <| s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Cliques"
        ]
      }
    },
    {
      "id": 433,
      "before_code": "/-! ### Cliques -/\n\n\ntheorem IsClique.card_le_of_coloring {s : Finset V} (h : G.IsClique s) [Fintype \u03b1]\n    (C : G.Coloring \u03b1) : s.card \u2264 Fintype.card \u03b1 := by\n  rw [isClique_iff_induce_eq] at h\n  have f : G.induce \u2191s \u21aag G := Embedding.comap (Function.Embedding.subtype fun x => x \u2208 \u2191s) G\n  rw [h] at f\n  convert Fintype.card_le_of_injective _ (C.comp f.toHom).injective_of_top_hom using 1\n  simp\n\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) {n : \u2115}\n    (hc : G.Colorable n) : s.card \u2264 n := by\n  convert h.card_le_of_coloring hc.some\n  simp",
      "suggestion": "\r\n  exact h.card_le_of_colorable C.colorable\r\n",
      "body": "```suggestion\r\n  exact h.card_le_of_colorable C.colorable\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "topics": [
          "finset",
          "function",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "convert",
          "Cliques",
          "Function",
          "Colorable",
          "injective_of_top_hom",
          "toHom",
          "using",
          "Finset",
          "Coloring",
          "card_le_of_colorable",
          "have",
          "card_le_of_coloring",
          "subtype",
          "Embedding",
          "IsClique",
          "comp",
          "simp",
          "induce",
          "card_le_of_injective",
          "card",
          "theorem",
          "isClique_iff_induce_eq",
          "Fintype",
          "comap",
          "some"
        ]
      }
    },
    {
      "id": 434,
      "before_code": "/-! ### Cliques -/\n\n\ntheorem IsClique.card_le_of_coloring {s : Finset V} (h : G.IsClique s) [Fintype \u03b1]\n    (C : G.Coloring \u03b1) : s.card \u2264 Fintype.card \u03b1 := by\n  rw [isClique_iff_induce_eq] at h\n  have f : G.induce \u2191s \u21aag G := Embedding.comap (Function.Embedding.subtype fun x => x \u2208 \u2191s) G\n  rw [h] at f\n  convert Fintype.card_le_of_injective _ (C.comp f.toHom).injective_of_top_hom using 1\n  simp\n\ntheorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) {n : \u2115}\n    (hc : G.Colorable n) : s.card \u2264 n := by\n  convert h.card_le_of_coloring hc.some\n  simp\n\ntheorem IsClique.card_le_chromaticNumber {s : Finset V} (h : G.IsClique s) :\n    s.card \u2264 G.chromaticNumber := by\n  obtain (hc | hc) := eq_or_ne G.chromaticNumber \u22a4\n  \u00b7 rw [hc]\n    exact le_top\n  \u00b7 have hc' := hc\n    rw [chromaticNumber_ne_top_iff_exists] at hc'\n    obtain \u27e8n, c\u27e9 := hc'\n    rw [\u2190 ENat.coe_toNat_eq_self] at hc\n    rw [\u2190 hc, Nat.cast_le]\n    exact h.card_le_of_colorable (colorable_chromaticNumber c)",
      "suggestion": "\r\n    s.card \u2264 G.chromaticNumber := by\r\n  simpa using card_le_chromaticNumber_of_pairwise_adj _ <|\r\n    s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n",
      "body": "```suggestion\r\n    s.card \u2264 G.chromaticNumber := by\r\n  simpa using card_le_chromaticNumber_of_pairwise_adj _ <|\r\n    s.pairwise_subtype_iff_pairwise_finset _ |>.mpr h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "topics": [
          "nat",
          "order",
          "function",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "convert",
          "Cliques",
          "chromaticNumber_ne_top_iff_exists",
          "cast_le",
          "chromaticNumber",
          "obtain",
          "Function",
          "Colorable",
          "toHom",
          "injective_of_top_hom",
          "using",
          "Nat",
          "Finset",
          "Coloring",
          "card_le_of_colorable",
          "have",
          "le_top",
          "card_le_of_coloring",
          "subtype",
          "card_le_chromaticNumber",
          "Embedding",
          "IsClique",
          "ENat",
          "comap",
          "comp",
          "colorable_chromaticNumber",
          "simp",
          "induce",
          "card_le_of_injective",
          "card",
          "theorem",
          "exact",
          "isClique_iff_induce_eq",
          "Fintype",
          "eq_or_ne",
          "coe_toNat_eq_self",
          "some"
        ]
      }
    },
    {
      "id": 444,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=",
      "suggestion": "\r\n  \u27e8fun h_surj \u21a6 Surjective.isEmpty h_surj, fun _ \u21a6 Surjective.of_isEmpty f \u27e9\r\n",
      "body": "nit: bad indent,\r\n```suggestion\r\n  \u27e8fun h_surj \u21a6 Surjective.isEmpty h_surj, fun _ \u21a6 Surjective.of_isEmpty f \u27e9\r\n```\r\n\r\nThis might golf to\r\n```suggestion\r\n  \u27e8.isEmpty, fun _ \u21a6 Surjective.of_isEmpty f \u27e9\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "theorem",
          "and_true",
          "IsEmpty",
          "leftTotal_iff_isEmpty_left",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 449,
      "before_code": "set f' := fun i => (f i : M\u2081 i \u2192\u2097[R] M\u2081' i)\n  rw [\u2190 zero_compLinearMap f', compLinearMap_inj f' fun i => (f i).surjective]",
      "suggestion": "\r\ndef compMultilinearMap (g : MultilinearMap R M\u2081 M\u2082) (f : (i : \u03b9) \u2192 MultilinearMap R (N i) (M\u2081 i)) :\r\n    MultilinearMap R (fun j : \u03a3 i, \u03b2 i \u21a6 N j.fst j.snd) M\u2082 where\r\n  toFun m := g fun i \u21a6 f i (Sigma.curry m i)\r\n  map_update_add' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n  map_update_smul' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n",
      "body": "A few changes and we can do it in a single `intro; classical; simp`:\r\n\r\n* `DecidableEq` is not needed to define `toFun`, so we should add this assumption (with `classical`) only for the proofs.\r\n* We only need to introduce `hDecEqSigma`, the rest is handled by `simp`. Might as well put the hypothesis before the colon (but I would also accept `intro` here).\r\n* `simp only` can do all the rewriting if we hint it what to exactly rewrite. In particular, breaking `[Sigma.apply_curry_update .., Sigma.c",
      "path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "function"
        ],
        "transforms": [
          "cleanup_simp",
          "line_break",
          "remove_redundant"
        ],
        "keywords": [
          "compLinearMap_inj",
          "zero_compLinearMap",
          "surjective",
          "set"
        ]
      }
    },
    {
      "id": 483,
      "before_code": "\u03bcH[d] (K.orthogonalProjection '' s) \u2264 \u03bcH[d] s := by\n  simpa using K.lipschitzWith_orthogonalProjection.hausdorffMeasure_image_le hs s",
      "suggestion": "\r\n    apply iInf_le_of_le fun _ => {x}\r\n    simpa using hs\r\n",
      "body": "```suggestion\r\n    apply iInf_le_of_le fun _ => {x}\r\n    simpa using hs\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply"
        ],
        "body_tactics": [
          "simpa",
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "orthogonalProjection",
          "simpa",
          "hausdorffMeasure_image_le",
          "lipschitzWith_orthogonalProjection",
          "using"
        ]
      }
    },
    {
      "id": 485,
      "before_code": "\u03bcH[d] (K.orthogonalProjection '' s) \u2264 \u03bcH[d] s := by\n  simpa using K.lipschitzWith_orthogonalProjection.hausdorffMeasure_image_le hs s",
      "suggestion": "\r\n    have h_isolated (x) (hx : x \u2208 E) : \u2203 U : Set X,\r\n    IsOpen U \u2227 x \u2208 U \u2227 U \u2229 E = {x} := by\r\n",
      "body": "```suggestion\r\n    have h_isolated (x) (hx : x \u2208 E) : \u2203 U : Set X,\r\n    IsOpen U \u2227 x \u2208 U \u2227 U \u2229 E = {x} := by\r\n```\r\nYou don't need to intro if you use this syntax.",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have",
          "intro"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "orthogonalProjection",
          "simpa",
          "hausdorffMeasure_image_le",
          "lipschitzWith_orthogonalProjection",
          "using"
        ]
      }
    },
    {
      "id": 487,
      "before_code": "theorem restrict_Ico_eq_restrict_Ioc : \u03bc.restrict (Ico a b) = \u03bc.restrict (Ioc a b) :=\n  restrict_congr_set Ico_ae_eq_Ioc",
      "suggestion": "\r\n    {\u03bc : Measure X} [NoAtoms \u03bc] (h_sep : IsSeparable E) (hE : 0 < \u03bc E) :\r\n",
      "body": "```suggestion\r\n    {\u03bc : Measure X} [NoAtoms \u03bc] (h_sep : IsSeparable E) (hE : 0 < \u03bc E) :\r\n```\r\nas you have already opened `TopologicalSpace`, or you can choose to not open `TopologicalSpace`.\r\n\r\nAlso the measure `\u03bc` should be an implicit variable because you have ` (hE : 0 < \u03bc E)`.",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/NoAtoms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "restrict",
          "theorem",
          "Ico_ae_eq_Ioc",
          "restrict_congr_set",
          "Ico",
          "Ioc",
          "restrict_Ico_eq_restrict_Ioc"
        ]
      }
    },
    {
      "id": 488,
      "before_code": "theorem restrict_Ico_eq_restrict_Ioc : \u03bc.restrict (Ico a b) = \u03bc.restrict (Ioc a b) :=\n  restrict_congr_set Ico_ae_eq_Ioc",
      "suggestion": "\r\n  exact hE.ne' <| (separableSpace_iff_countable.mp h_sep.separableSpace\r\n    |> E.countable_coe_iff.mp).measure_zero \u03bc\r\n",
      "body": "```suggestion\r\n  exact hE.ne' <| (separableSpace_iff_countable.mp h_sep.separableSpace\r\n    |> E.countable_coe_iff.mp).measure_zero \u03bc\r\n```\r\nsame here",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/NoAtoms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "restrict",
          "theorem",
          "Ico_ae_eq_Ioc",
          "restrict_congr_set",
          "Ico",
          "Ioc",
          "restrict_Ico_eq_restrict_Ioc"
        ]
      }
    },
    {
      "id": 489,
      "before_code": "IsDiscrete S \u2194 \u2200 x \u2208 S, \ud835\udcdd[\u2260] x \u2293 \ud835\udcdf S = \u22a5 := by\n  rw [isDiscrete_iff_discreteTopology, discreteTopology_subtype_iff]",
      "suggestion": "\r\n  simpa [discreteTopology_subtype_iff, AccPt] using h\r\n",
      "body": "```suggestion\r\n  simpa [discreteTopology_subtype_iff, AccPt] using h\r\n```",
      "path": "Mathlib/Topology/DiscreteSubset.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "discreteTopology_subtype_iff",
          "isDiscrete_iff_discreteTopology",
          "IsDiscrete"
        ]
      }
    },
    {
      "id": 490,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term\n\n/--\n`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying `apply` operation.",
      "suggestion": "* `apply (config := cfg) e` allows for additional configuration (see `Lean.Meta.ApplyConfig`):\n",
      "body": "(will apply after the build finishes)\n```suggestion\n* `apply (config := cfg) e` allows for additional configuration (see `Lean.Meta.ApplyConfig`):\n```",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "operation",
          "but",
          "open",
          "section",
          "apply",
          "Mathlib",
          "Lean",
          "pass",
          "configuration",
          "ApplyConfig",
          "like",
          "Elab",
          "public",
          "underlying",
          "allows",
          "Term",
          "provide",
          "you",
          "namespace",
          "config",
          "cfg",
          "Meta",
          "meta",
          "Tactic"
        ]
      }
    },
    {
      "id": 491,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term",
      "suggestion": "/-- Elaborator for the configuration in `apply (config := cfg)` syntax. -/\ndeclare_config_elab elabApplyConfig ApplyConfig\n",
      "body": "```suggestion\n/-- Elaborator for the configuration in `apply (config := cfg)` syntax. -/\ndeclare_config_elab elabApplyConfig ApplyConfig\n```",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Elab",
          "Mathlib",
          "public",
          "Lean",
          "Term",
          "Meta",
          "meta",
          "open",
          "Tactic",
          "section",
          "namespace"
        ]
      }
    },
    {
      "id": 492,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term\n\n/--\n`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying `apply` operation.",
      "suggestion": "\r\n  * `-synthAssignedInstances` will not synthesize instance implicit arguments if they have been\r\n",
      "body": "The `ApplyConfig` docstring for `synthAssignedInstances` is a bit confusing: it explains what `synthAssignedInstances := true` does, but this is in fact already the case by default. So `-synthAssignedInstances` does the opposite: it does not resynthesize and therefore there is nothing to check.\r\n\r\nBut we can get rid of the \"even\" in this sentence, because that would be confusing.\r\n\r\n```suggestion\r\n  * `-synthAssignedInstances` will not synthesize instance implicit arguments if they have been\r\n``",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "operation",
          "but",
          "open",
          "section",
          "apply",
          "Mathlib",
          "Lean",
          "pass",
          "configuration",
          "ApplyConfig",
          "like",
          "Elab",
          "public",
          "underlying",
          "allows",
          "Term",
          "provide",
          "you",
          "namespace",
          "config",
          "cfg",
          "Meta",
          "meta",
          "Tactic"
        ]
      }
    },
    {
      "id": 493,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term\n\n/--\n`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying `apply` operation.\n-/\nelab (name := applyWith) \"apply\" \" (\" &\"config\" \" := \" cfg:term \") \" e:term : tactic => do\n  let cfg \u2190 unsafe evalTerm ApplyConfig (mkConst ``ApplyConfig) cfg",
      "suggestion": "\r\nelab (name := applyWith) \"apply \" cfg:optConfig e:term : tactic => do\r\n",
      "body": "```suggestion\r\nelab (name := applyWith) \"apply \" cfg:optConfig e:term : tactic => do\r\n```\r\nI *think* that this will pretty-print better, but I cannot test it right now.",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "operation",
          "applyWith",
          "but",
          "open",
          "section",
          "apply",
          "Mathlib",
          "Lean",
          "pass",
          "mkConst",
          "configuration",
          "unsafe",
          "ApplyConfig",
          "like",
          "name",
          "elab",
          "Elab",
          "public",
          "underlying",
          "allows",
          "Term",
          "provide",
          "you",
          "evalTerm",
          "tactic",
          "namespace",
          "term",
          "config",
          "cfg",
          "Meta",
          "meta",
          "Tactic"
        ]
      }
    },
    {
      "id": 494,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term\n\n/--\n`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying `apply` operation.\n-/\nelab (name := applyWith) \"apply\" \" (\" &\"config\" \" := \" cfg:term \") \" e:term : tactic => do\n  let cfg \u2190 unsafe evalTerm ApplyConfig (mkConst ``ApplyConfig) cfg",
      "suggestion": "\r\nelab (name := applyWith) \"apply\" ppSpace cfg:optConfig e:term : tactic => do\r\n",
      "body": "Good catch! I would expect this to pretty-print even better (also untested if it works; it is valid syntax).\r\n```suggestion\r\nelab (name := applyWith) \"apply\" ppSpace cfg:optConfig e:term : tactic => do\r\n```",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "operation",
          "applyWith",
          "but",
          "open",
          "section",
          "apply",
          "Mathlib",
          "Lean",
          "pass",
          "mkConst",
          "configuration",
          "unsafe",
          "ApplyConfig",
          "like",
          "name",
          "elab",
          "Elab",
          "public",
          "underlying",
          "allows",
          "Term",
          "provide",
          "you",
          "evalTerm",
          "tactic",
          "namespace",
          "term",
          "config",
          "cfg",
          "Meta",
          "meta",
          "Tactic"
        ]
      }
    },
    {
      "id": 495,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term\n\n/--\n`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying `apply` operation.\n-/\nelab (name := applyWith) \"apply\" \" (\" &\"config\" \" := \" cfg:term \") \" e:term : tactic => do\n  let cfg \u2190 unsafe evalTerm ApplyConfig (mkConst ``ApplyConfig) cfg",
      "suggestion": "\r\nelab (name := applyWith) \"apply\" cfg:optConfig ppSpace e:term : tactic => do\r\n",
      "body": "@[user], so:\r\n```suggestion\r\nelab (name := applyWith) \"apply\" cfg:optConfig ppSpace e:term : tactic => do\r\n```\r\n?",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "operation",
          "applyWith",
          "but",
          "open",
          "section",
          "apply",
          "Mathlib",
          "Lean",
          "pass",
          "mkConst",
          "configuration",
          "unsafe",
          "ApplyConfig",
          "like",
          "name",
          "elab",
          "Elab",
          "public",
          "underlying",
          "allows",
          "Term",
          "provide",
          "you",
          "evalTerm",
          "tactic",
          "namespace",
          "term",
          "config",
          "cfg",
          "Meta",
          "meta",
          "Tactic"
        ]
      }
    },
    {
      "id": 499,
      "before_code": "end median",
      "suggestion": "theorem medial_points [CharZero k] (s : Simplex k P n) (i : Fin (n + 1)) :\n",
      "body": "This should be a `theorem` instead of a `def` to be consistent with similar lemmas in the codebase. For example, `face_points` and `face_points'` in `Simplex/Basic.lean` (lines 103-111) are theorems that also just return `rfl`. Since this is a definitional equality that serves as a simplification lemma, it should be declared as a `theorem`.\n```suggestion\ntheorem medial_points [CharZero k] (s : Simplex k P n) (i : Fin (n + 1)) :\n```",
      "path": "Mathlib/LinearAlgebra/AffineSpace/Simplex/Centroid.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "median",
          "end"
        ]
      }
    },
    {
      "id": 510,
      "before_code": "theorem aleph0_le_preAleph {o : Ordinal} : \u2135\u2080 \u2264 preAleph o \u2194 \u03c9 \u2264 o := by\n  rw [\u2190 preAleph_omega0, preAleph_le_preAleph]",
      "suggestion": "\r\ntheorem card_le_preAleph (o : Ordinal) : o.card \u2264 preAleph o :=\r\n  o.card_preOmega.trans_ge <| card_le_card <| o.le_preOmega_self\r\n",
      "body": "```suggestion\r\ntheorem card_le_preAleph (o : Ordinal) : o.card \u2264 preAleph o :=\r\n  o.card_preOmega.trans_ge <| card_le_card <| o.le_preOmega_self\r\n```",
      "path": "Mathlib/SetTheory/Cardinal/Aleph.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "preAleph",
          "Ordinal",
          "preAleph_le_preAleph",
          "aleph0_le_preAleph",
          "preAleph_omega0"
        ]
      }
    },
    {
      "id": 512,
      "before_code": "continuous_invFun := Units.continuous_iff.mpr\n    \u27e8continuous_pi fun _ \u21a6 Units.continuous_val.comp <| continuous_apply _,\n      continuous_pi fun _ \u21a6 Units.continuous_coe_inv.comp <| continuous_apply _\u27e9",
      "suggestion": "\r\n@[simps! apply]\r\n",
      "body": "instead of this\r\n```suggestion\r\n@[simps! apply]\r\n```\r\nI think you should do:\r\n```lean\r\ntheorem symm_mapContinuousMulEquiv_apply (f : M \u2243\u209c* N) (a : N\u02e3) :\r\n    (mapContinuousMulEquiv f).symm a = map f.symm a := rfl\r\n\r\n@[simp] theorem symm_mapContinuousMulEquiv (f : M \u2243\u209c* N) :\r\n    (mapContinuousMulEquiv f).symm = mapContinuousMulEquiv f.symm := rfl\r\n\r\n@[simp] theorem toMulEquiv_mapContinuousMulEquiv (f : M \u2243\u209c* N) :\r\n    (mapContinuousMulEquiv f : M\u02e3 \u2243* N\u02e3) = mapEquiv f := rfl\r\n```",
      "path": "Mathlib/Topology/Algebra/Group/Units.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply",
          "simp"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "Units",
          "mpr",
          "continuous_pi",
          "continuous_iff",
          "comp",
          "continuous_coe_inv",
          "continuous_apply",
          "continuous_val",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 520,
      "before_code": "Indep m\u2081 m\u2083 \u03ba \u03bc :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)",
      "suggestion": "theorem iIndep_of_iIndep_of_le {m\u2081 m\u2082 : \u03b9 \u2192 MeasurableSpace \u03a9} {_m\u03a9 : MeasurableSpace \u03a9}\n    {\u03ba : Kernel \u03b1 \u03a9} {\u03bc : Measure \u03b1} (h_indep : iIndep m\u2082 \u03ba \u03bc) (h_le : \u2200 i, m\u2081 i \u2264 m\u2082 i) :\n    iIndep m\u2081 \u03ba \u03bc :=\n",
      "body": "`m\u2081` and `m\u2082` have the same type so you can put them together.\n```suggestion\ntheorem iIndep_of_iIndep_of_le {m\u2081 m\u2082 : \u03b9 \u2192 MeasurableSpace \u03a9} {_m\u03a9 : MeasurableSpace \u03a9}\n    {\u03ba : Kernel \u03b1 \u03a9} {\u03bc : Measure \u03b1} (h_indep : iIndep m\u2082 \u03ba \u03bc) (h_le : \u2200 i, m\u2081 i \u2264 m\u2082 i) :\n    iIndep m\u2081 \u03ba \u03bc :=\n```",
      "path": "Mathlib/Probability/Independence/Kernel/Indep.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ht1",
          "ht2",
          "h_indep",
          "h32",
          "Indep"
        ]
      }
    },
    {
      "id": 521,
      "before_code": "Indep m\u2081 m\u2083 \u03ba \u03bc :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)",
      "suggestion": "  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n",
      "body": "I suggest this proof instead:\n```suggestion\n  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n```\nIt's exactly the same but I reworked the variables (and removed unnecessary parentheses). We often use `s`, `t` for sets. Here `s` and `t` are not of the same kind (`s` is a finset of the index type while `t` is a family of sets) so it's better to use `s` and `t` rather than `t1` and `t2` which suggests they are of the same kind. As `i` is an element of the index type `\u03b9`, `i` is the usual",
      "path": "Mathlib/Probability/Independence/Kernel/Indep.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "ht1",
          "ht2",
          "h_indep",
          "h32",
          "Indep"
        ]
      }
    },
    {
      "id": 522,
      "before_code": "def Weird (n : \u2115) : Prop := Abundant n \u2227 \u00ac Pseudoperfect n\n\ntheorem not_pseudoperfect_iff_forall :\n    \u00ac Pseudoperfect n \u2194 n = 0 \u2228 \u2200 s \u2286 properDivisors n, \u2211 i \u2208 s, i \u2260 n := by\n  rw [Pseudoperfect, not_and_or]\n  simp only [not_lt, nonpos_iff_eq_zero, not_exists, not_and, ne_eq]\n\ntheorem deficient_one : Deficient 1 := zero_lt_one\ntheorem deficient_two : Deficient 2 := one_lt_two\ntheorem deficient_three : Deficient 3 := by norm_num [Deficient]\n\ntheorem abundant_twelve : Abundant 12 := by\n  rw [Abundant, show properDivisors 12 = {1,2,3,4,6} by rfl]\n  simp\n\ntheorem weird_seventy : Weird 70 := by\n  rw [Weird, Abundant, not_pseudoperfect_iff_forall]\n  have h : properDivisors 70 = {1, 2, 5, 7, 10, 14, 35} := by rfl",
      "suggestion": "\r\n  rw [Weird, Abundant, not_pseudoperfect_iff_forall,\r\n    show properDivisors 70 = {1, 2, 5, 7, 10, 14, 35} by rfl]\r\n",
      "body": "```suggestion\r\n  rw [Weird, Abundant, not_pseudoperfect_iff_forall,\r\n    show properDivisors 70 = {1, 2, 5, 7, 10, 14, 35} by rfl]\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "norm_num",
          "simp",
          "have"
        ],
        "topics": [
          "order",
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "nonpos_iff_eq_zero",
          "abundant_twelve",
          "show",
          "deficient_three",
          "have",
          "Prop",
          "ne_eq",
          "not_and",
          "deficient_one",
          "norm_num",
          "not_pseudoperfect_iff_forall",
          "Deficient",
          "Pseudoperfect",
          "weird_seventy",
          "not_and_or",
          "def",
          "properDivisors",
          "Abundant",
          "Weird",
          "simp",
          "one_lt_two",
          "rfl",
          "not_lt",
          "only",
          "theorem",
          "zero_lt_one",
          "not_exists",
          "deficient_two"
        ]
      }
    },
    {
      "id": 523,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n",
      "body": "```suggestion\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "have",
          "refine"
        ],
        "removed_tactics": [
          "omega",
          "intro"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 524,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\n  have := abundancyIndex_le_ofDvd hd hn\r\n  have := ne_zero_of_dvd_ne_zero hn hd\r\n  grind [abundant_iff_two_lt_abundancyIndex]\r\n",
      "body": "```suggestion\r\n  have := abundancyIndex_le_ofDvd hd hn\r\n  have := ne_zero_of_dvd_ne_zero hn hd\r\n  grind [abundant_iff_two_lt_abundancyIndex]\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 525,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\n  have hmn : m * n \u2260 0 := mul_ne_zero hm hn\r\n  exact Abundant.ofDvd h (Nat.dvd_mul_left n m) hmn\r\n",
      "body": "```suggestion\r\n  have hmn : m * n \u2260 0 := mul_ne_zero hm hn\r\n  exact Abundant.ofDvd h (Nat.dvd_mul_left n m) hmn\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "exact",
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "obtain",
          "rw",
          "omega",
          "intro"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 529,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "theorem abundant_945 : Abundant 945 := by decide +kernel\n",
      "body": "```suggestion\ntheorem abundant_945 : Abundant 945 := by decide +kernel\n```\nIf you add `deriving Decidable` after the def of `Abundant`.\n\nBut why 945? And why can't this proof be inline?",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "decide"
        ],
        "body_tactics": [
          "decide"
        ],
        "new_tactics": [
          "decide"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 541,
      "before_code": "(s : {s : Finset I // Finset.card s = n}) : \u22c0[R]^n M :=\n  \u03b9Multi R n fun i \u21a6 v <| Finset.orderIsoOfFin s.val s.property i",
      "suggestion": "lemma \u03b9Multi_family_eq_coe_comp {I : Type*} [LinearOrder I] (v : I \u2192 M) :\n    ExteriorAlgebra.\u03b9Multi_family R n v = (\u2191) \u2218 \u03b9Multi_family R n v :=\n",
      "body": "I don't think this should be `simp`. Other minor tweaks as follows:\n```suggestion\nlemma \u03b9Multi_family_eq_coe_comp {I : Type*} [LinearOrder I] (v : I \u2192 M) :\n    ExteriorAlgebra.\u03b9Multi_family R n v = (\u2191) \u2218 \u03b9Multi_family R n v :=\n```",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "Finset",
          "property",
          "orderIsoOfFin",
          "val",
          "card"
        ]
      }
    },
    {
      "id": 542,
      "before_code": "Submodule.span R (Set.range (ExteriorAlgebra.\u03b9Multi R n)) = \u22c0[R]^n M :=\n  ExteriorAlgebra.\u03b9Multi_span_fixedDegree R n",
      "suggestion": "open Set Submodule in\n/-- If a set `s` spans the module `M`, then the set of all elements of the form `x\u2081 \u2227 \u22ef \u2227 x\u2099`\nspans `\u22c0\u207f M`. -/\nlemma \u03b9Multi_span_fixedDegree_of_span_eq_top {s : Set M} (hs : span R s = \u22a4) :\n    span R (ExteriorAlgebra.\u03b9Multi R n '' {a | range a \u2286 s}) = \u22c0[R]^n M := by\n  apply le_antisymm\n  \u00b7 rw [span_le]\n    rintro - \u27e8y, \u27e8y_mem, rfl\u27e9\u27e9\n    apply ExteriorAlgebra.\u03b9Multi_range R n\n    simp\n  \u00b7 rw [ExteriorAlgebra.exteriorPower, LinearMap.range_eq_map, \u2190 hs, map_span, span_pow, span_le]\n    rintro x hx\n    obtain \u27e8f, rfl\u27e9 := Set.mem_pow.mp hx\n    refine mem_span_of_mem \u27e8ExteriorAlgebra.\u03b9Inv \u2218 Subtype.val \u2218 f, ?_, ?_\u27e9\n    \u00b7 rw [Set.mem_setOf_eq, Set.range_comp, Set.image_subset_iff]\n      apply Subset.trans ?_ (s.image_subset_preimage_of_inverse ExteriorAlgebra.\u03b9_leftInverse)\n      grind\n",
      "body": "This is mostly just vanity golfing. I think the main (minor) advantages are that the doc string and formal statement are slightly more human-friendly.\n```suggestion\nopen Set Submodule in\n/-- If a set `s` spans the module `M`, then the set of all elements of the form `x\u2081 \u2227 \u22ef \u2227 x\u2099`\nspans `\u22c0\u207f M`. -/\nlemma \u03b9Multi_span_fixedDegree_of_span_eq_top {s : Set M} (hs : span R s = \u22a4) :\n    span R (ExteriorAlgebra.\u03b9Multi R n '' {a | range a \u2286 s}) = \u22c0[R]^n M := by\n  apply le_antisymm\n  \u00b7 rw [span_le]\n    rint",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "grind",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "grind",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "rw",
          "refine",
          "simp",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "range",
          "Set",
          "span",
          "Submodule",
          "ExteriorAlgebra"
        ]
      }
    },
    {
      "id": 543,
      "before_code": "Submodule.range_subtype]\n  exact ExteriorAlgebra.\u03b9Multi_span_fixedDegree R n",
      "suggestion": "open Set Submodule in\n/-- A version of `\u03b9Multi_span_fixedDegree_of_span` that works in the exterior power. -/\nlemma \u03b9Multi_span_of_span {s : Set M} (hs : span R s = \u22a4) :\n    span R (\u03b9Multi R n '' {a | range a \u2286 s}) = \u22a4 := by\n  apply LinearMap.map_injective (ker_subtype (\u22c0[R]^n M))\n  simpa [LinearMap.map_span, Set.image_image] using \u03b9Multi_span_fixedDegree_of_span R n M hs\n",
      "body": "```suggestion\nopen Set Submodule in\n/-- A version of `\u03b9Multi_span_fixedDegree_of_span` that works in the exterior power. -/\nlemma \u03b9Multi_span_of_span {s : Set M} (hs : span R s = \u22a4) :\n    span R (\u03b9Multi R n '' {a | range a \u2286 s}) = \u22a4 := by\n  apply LinearMap.map_injective (ker_subtype (\u22c0[R]^n M))\n  simpa [LinearMap.map_span, Set.image_image] using \u03b9Multi_span_fixedDegree_of_span R n M hs\n```",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply"
        ],
        "body_tactics": [
          "simpa",
          "apply"
        ],
        "new_tactics": [
          "simpa",
          "apply"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "range_subtype",
          "Submodule",
          "ExteriorAlgebra"
        ]
      }
    },
    {
      "id": 544,
      "before_code": "map n (g \u2218\u2097 f) = map n g \u2218\u2097 map n f := by\n  aesop",
      "suggestion": "open Submodule Set in\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and distinct indexes\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\nprivate lemma mem_span_of_injective_aux {I : Type*} [LinearOrder I] {v : I \u2192 M}\n    {\u03b1 : Fin n \u2192 I} (\u03b1_inj : Injective \u03b1) :\n    ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) \u2208 span R (range (ExteriorAlgebra.\u03b9Multi_family R n v)) := by\n",
      "body": "We almost never want to have a hypothesis of the form `h\u03b1 : f = v \u2218 \u03b1`: the user should just rewrite before calling the lemma. Also, I think we should write doc strings in much more informal language, after all the formal statement is right there below. So how about:\n```suggestion\nopen Submodule Set in\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and distinct indexes\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\nthe ",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "map",
          "aesop"
        ]
      }
    },
    {
      "id": 546,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family_span_fixedDegree_aux\r\n    {I : Type*} [LinearOrder I] (v : I \u2192 M) (\u03b1 : Fin n \u2192 I) :\r\n    ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) \u2208 span R (range (ExteriorAlgebra.\u03b9Multi_family R n v)) := by\r\n  by_cases \u03b1_inj : Injective \u03b1; swap\r\n  \u00b7 suffices ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) = 0 by simp [this]\r\n    exact AlternatingMap.map_eq_zero_of_not_injective _ _ <| fun h \u21a6 \u03b1_inj (Injective.of_comp h)\r\n",
      "body": "Looking at this one last time, even though it is a private \"auxiliary\" lemma, I think we should fold in the case analysis on whether `\u03b1` is injective so that we don't have a redundant hypothesis:\r\n```suggestion\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 547,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "    rintro - \u27e8f, \u27e8f_range, rfl\u27e9\u27e9\n    rw [Set.mem_setOf] at f_range\n    obtain \u27e8\u03b1, rfl\u27e9 := Set.range_subset_range_iff_exists_comp.mp f_range\n    exact \u03b9Multi_family_span_fixedDegree_aux R v \u03b1\n",
      "body": "After the suggestion above, this can become:\n```suggestion\n    rintro - \u27e8f, \u27e8f_range, rfl\u27e9\u27e9\n    rw [Set.mem_setOf] at f_range\n    obtain \u27e8\u03b1, rfl\u27e9 := Set.range_subset_range_iff_exists_comp.mp f_range\n    exact \u03b9Multi_family_span_fixedDegree_aux R v \u03b1\n```",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 548,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "  simpa using \u03b9Multi_family_span_fixedDegree_of_span R hv\n",
      "body": "I slightly prefer the following, not because it is shorter but because it names fewer lemmas explicitly so it's slightly more maintainable (though what you had was also fine):\n```suggestion\n  simpa using \u03b9Multi_family_span_fixedDegree_of_span R hv\n```",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 549,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "    (map n (span R (range v)).subtype).range = span R (range (\u03b9Multi_family R n v)) := by\n",
      "body": "If we add `open Set Submodule in` above then this can become:\n```suggestion\n    (map n (span R (range v)).subtype).range = span R (range (\u03b9Multi_family R n v)) := by\n```\nwhich I find easier to take in at a glance.",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 550,
      "before_code": "theorem isOpen_implies_isOpen_iff : (\u2200 s, IsOpen[t\u2081] s \u2192 IsOpen[t\u2082] s) \u2194 t\u2082 \u2264 t\u2081 :=\n  Iff.rfl",
      "suggestion": "@[simp, push]\n",
      "body": "```suggestion\n@[simp, push]\n```",
      "path": "Mathlib/Topology/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Iff",
          "isOpen_implies_isOpen_iff",
          "IsOpen",
          "rfl"
        ]
      }
    },
    {
      "id": 551,
      "before_code": "theorem isOpen_implies_isOpen_iff : (\u2200 s, IsOpen[t\u2081] s \u2192 IsOpen[t\u2082] s) \u2194 t\u2082 \u2264 t\u2081 :=\n  Iff.rfl",
      "suggestion": "@[simp, push]\n",
      "body": "```suggestion\n@[simp, push]\n```",
      "path": "Mathlib/Topology/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Iff",
          "isOpen_implies_isOpen_iff",
          "IsOpen",
          "rfl"
        ]
      }
    },
    {
      "id": 554,
      "before_code": "/-- We say that a type has `MeasurableSup` if `(c \u2294 \u00b7)` and `(\u00b7 \u2294 c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (\u00b7 \u2294 \u00b7)` see `MeasurableSup\u2082`. -/\nclass MeasurableSup (M : Type*) [MeasurableSpace M] [Max M] : Prop where\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7)\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c)",
      "suggestion": "\r\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7) := by intro c; measurability\r\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c) := by intro c; measurability\r\n",
      "body": "Do we have a good understanding of when to use `fun_prop` vs `measurability`? I thought the latter was now based on the former and therefore as fast but also slightly stronger. Therefore I was expecting\r\n```suggestion\r\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7) := by intro c; measurability\r\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c) := by intro c; measurability\r\n```",
      "path": "Mathlib/MeasureTheory/Order/Lattice.lean",
      "tags": {
        "before_tactics": [
          "measurability"
        ],
        "suggestion_tactics": [
          "measurability",
          "intro"
        ],
        "body_tactics": [
          "fun_prop",
          "measurability",
          "have",
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "measurability",
          "order"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "Type",
          "typeclass",
          "class",
          "type",
          "has",
          "Max",
          "For",
          "MeasurableSup",
          "Prop",
          "are",
          "see",
          "say",
          "assuming",
          "measurable_sup_const",
          "that",
          "measurability",
          "MeasurableSpace",
          "measurable_const_sup",
          "uncurry",
          "functions",
          "measurable",
          "Measurable"
        ]
      }
    },
    {
      "id": 563,
      "before_code": "let c \u2190 Term.exprToSyntax (mkConst `Complex)\n      Term.elabTerm (\u2190 `(\ud835\udcd8($c))) none\n    else throwError \"`{e}` is not the complex upper half plane\"",
      "suggestion": "              if \u2190 withReducible (pureIsDefEq R q(\u211d) <&&> pureIsDefEq E F) then\n",
      "body": "Nit: this way, we avoid evaluating the second conjunct unless we have to! Also slightly more readable.\n```suggestion\n              if \u2190 withReducible (pureIsDefEq R q(\u211d) <&&> pureIsDefEq E F) then\n```",
      "path": "Mathlib/Geometry/Manifold/Notation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "half",
          "else",
          "Complex",
          "elabTerm",
          "mkConst",
          "none",
          "Term",
          "exprToSyntax",
          "throwError",
          "complex",
          "plane",
          "upper"
        ]
      }
    },
    {
      "id": 564,
      "before_code": "-- TODO: consider lowering monad to `MetaM`\ndef findModel (e : Expr) (baseInfo : Option (Expr \u00d7 Expr) := none) : TermElabM Expr := do\n  trace[Elab.DiffGeo.MDiff] \"Finding a model for: {e}\"\n  if let some m \u2190 tryStrategy m!\"TotalSpace\"     fromTotalSpace     then return m\n  if let some m \u2190 tryStrategy m!\"TangentBundle\"  fromTangentBundle  then return m\n  if let some m \u2190 tryStrategy m!\"NormedSpace\"    fromNormedSpace    then return m\n  if let some m \u2190 tryStrategy m!\"Manifold\"       fromManifold       then return m\n  if let some m \u2190 tryStrategy m!\"ContinuousLinearMap\" fromCLM       then return m\n  if let some m \u2190 tryStrategy m!\"RealInterval\"   fromRealInterval   then return m\n  if let some m \u2190 tryStrategy m!\"UpperHalfPlane\" fromUpperHalfPlane then return m\n  if let some m \u2190 tryStrategy m!\"NormedField\"    fromNormedField    then return m\n  throwError \"Could not find a model with corners for `{e}`\"",
      "suggestion": "  throwError \"Could not find a model with corners for `{e}`.\n  \n  Hint: failures to find a model with corners can be debugged with the command `set_option trace.Elab.DiffGeo.MDiff true`.\"\n",
      "body": "(Existing but increasingly useful as there are more strategies now.) Should this give a tip on how to debug the failure, something like the error when a typeclass search fails:\n\n```suggestion\n  throwError \"Could not find a model with corners for `{e}`.\n  \n  Hint: failures to find a model with corners can be debugged with the command `set_option trace.Elab.DiffGeo.MDiff true`.\"\n```",
      "path": "Mathlib/Geometry/Manifold/Notation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "set_theory",
          "list",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "findModel",
          "fromCLM",
          "trace",
          "MetaM",
          "NormedField",
          "Expr",
          "TermElabM",
          "tryStrategy",
          "fromTotalSpace",
          "find",
          "lowering",
          "TangentBundle",
          "Manifold",
          "fromTangentBundle",
          "TODO",
          "MDiff",
          "fromManifold",
          "fromNormedSpace",
          "for",
          "Finding",
          "monad",
          "Elab",
          "def",
          "then",
          "ContinuousLinearMap",
          "none",
          "throwError",
          "return",
          "UpperHalfPlane",
          "fromUpperHalfPlane",
          "corners",
          "DiffGeo",
          "consider",
          "fromNormedField",
          "model",
          "fromRealInterval",
          "Could",
          "Option",
          "NormedSpace",
          "RealInterval",
          "baseInfo",
          "TotalSpace",
          "some"
        ]
      }
    },
    {
      "id": 568,
      "before_code": "@[simp, norm_cast]\nlemma coe_I : I = Complex.I := rfl",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis lemma was in #32955, but got renamed to `im_pnat_div_pos` in the review process. Please remove the duplicate.",
      "path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "complex",
          "norm"
        ],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "coe_I",
          "lemma",
          "Complex",
          "simp",
          "rfl",
          "norm_cast"
        ]
      }
    },
    {
      "id": 569,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    by simpa using im_pnat_div_pos 1 z\u27e9)\r\n",
      "body": "```suggestion\r\n    by simpa using im_pnat_div_pos 1 z\u27e9)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 570,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n      (by simpa using norm_exp_two_pi_I_lt_one \u27e8-N / z, im_pnat_div_pos N z\u27e9)]\r\n",
      "body": "```suggestion\r\n      (by simpa using norm_exp_two_pi_I_lt_one \u27e8-N / z, im_pnat_div_pos N z\u27e9)]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 571,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n",
      "body": "```suggestion\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n```\r\n(re-labelling variables for consistency with previous lemma)",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "grind",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "grind",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "grind",
          "congr",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 572,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simp_rw [inv_neg, mul_neg, mul_sum]\r\n  rw [Summable.tsum_finsetSum (fun i hi \u21a6 by apply linear_left_summable (ne_zero z) i le_rfl)]\r\n",
      "body": "```suggestion\r\n  simp_rw [inv_neg, mul_neg, mul_sum]\r\n  rw [Summable.tsum_finsetSum (fun i hi \u21a6 by apply linear_left_summable (ne_zero z) i le_rfl)]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "rw"
        ],
        "body_tactics": [
          "apply",
          "rw"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 573,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simpa [e2Summand, eisSummand, \u2190 mul_sum] using aux_sum_Ico_S_identity z N\r\n",
      "body": "```suggestion\r\n  simpa [e2Summand, eisSummand, \u2190 mul_sum] using aux_sum_Ico_S_identity z N\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 575,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact fun i hi \u21a6 by simpa using linear_left_summable (ne_zero z) i le_rfl\r\n",
      "body": "```suggestion\r\n  exact fun i hi \u21a6 by simpa using linear_left_summable (ne_zero z) i le_rfl\r\n```\r\nI don't think we need `omega` to tell us that `2 \u2264 2`; and doing it this way avoids having to specify `k`.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "simpa",
          "exact",
          "omega"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_omega"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 576,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (m * z + n + 1)) =\r\n    1 / (m * z - b) - 1 / (m * z + b) := by\r\n  convert telescope_aux' b (fun n \u21a6 1 / ((m : \u2102) * z + n)) using 2 <;>\r\n  simp [add_assoc, sub_eq_add_neg]\r\n",
      "body": "I'd suggest splitting this up:\r\n```suggestion\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "aesop",
          "grind",
          "induction",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "grind",
          "induction",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "aesop",
          "induction",
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp",
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 577,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simpa using (tendsto_zero_inv_linear_sub z m).sub (tendsto_zero_inv_linear z m)\r\n",
      "body": "```suggestion\r\n  simpa using (tendsto_zero_inv_linear_sub z m).sub (tendsto_zero_inv_linear z m)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 578,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n      grind [Int.cast_natCast]\r\n",
      "body": "```suggestion\r\n      grind [Int.cast_natCast]\r\n```\r\nI'm not sure what lemmas `grind` knows; less than `simp`, but more than nothing. Similarly elsewhere in this proof.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "simp"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 579,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 simpa using summable_left_one_div_linear_sub_one_div_linear z (-d) d\r\n",
      "body": "```suggestion\r\n  \u00b7 simpa using summable_left_one_div_linear_sub_one_div_linear z (-d) d\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 581,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n",
      "body": "```suggestion\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n```\r\nAlso the capitalization is inconsistent: `Summable_cotTerm` is a proof of summability, not a statement of summability, so it should be lowercase \u2013 please change it wherever it's defined and here to match.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "aesop",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "aesop",
          "have"
        ],
        "new_tactics": [
          "aesop",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 582,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    simp only [\u2190 Nat.cast_add_one] at this\r\n",
      "body": "```suggestion\r\n    simp only [\u2190 Nat.cast_add_one] at this\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 583,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    apply this.subtype\r\n",
      "body": "Isn't `Nat.succ 0` a complicated way to write \"1\"? But better still,\r\n```suggestion\r\n    apply this.subtype\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 584,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  have := tendsto_zero_geometric_tsum_pnat (norm_exp_two_pi_I_lt_one \u27e8_, im_pnat_div_pos 1 z\u27e9)\r\n",
      "body": "```suggestion\r\n  have := tendsto_zero_geometric_tsum_pnat (norm_exp_two_pi_I_lt_one \u27e8_, im_pnat_div_pos 1 z\u27e9)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 585,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact this.congr <| by grind\r\n",
      "body": "```suggestion\r\n  exact this.congr <| by grind\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 586,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact tendsto_comp_val_Ioi_atTop.mpr tendsto_inv_atTop_nhds_zero_nat\r\n",
      "body": "```suggestion\r\n  exact tendsto_comp_val_Ioi_atTop.mpr tendsto_inv_atTop_nhds_zero_nat\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 587,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simp only [telescope_aux z, aux_tsum_identity_1 z] at this\r\n",
      "body": "```suggestion\r\n  simp only [telescope_aux z, aux_tsum_identity_1 z] at this\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 588,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 exact tendsto_comp_val_Ioi_atTop.mpr <| \r\n      by simpa using (tendsto_inv_atTop_nhds_zero_nat (\ud835\udd5c := \u2102)).const_mul (-2)\r\n",
      "body": "```suggestion\r\n  \u00b7 exact tendsto_comp_val_Ioi_atTop.mpr <| \r\n      by simpa using (tendsto_inv_atTop_nhds_zero_nat (\ud835\udd5c := \u2102)).const_mul (-2)\r\n```\r\nSome of the proofs here are a bit awkward (here and elsewhere in this file) because you are using `tendsto_comp_val_Ioi_atTop` with `\u2115+` arguments, relying on the defeq that `\u2115+ = \u2191(Set.Ioi 0)` (which `rw` and `simp` cannot see through). I wonder if it would be better to have a version of `tendsto_comp_val_Ioi_atTop` stated for the `\u2115+` case (maybe `PN",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 589,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 simpa only [aux_tsum_identity_2] using tendsto_comp_val_Ioi_atTop.mpr (aux_tendsto_tsum z)\r\n",
      "body": "```suggestion\r\n  \u00b7 simpa only [aux_tsum_identity_2] using tendsto_comp_val_Ioi_atTop.mpr (aux_tendsto_tsum z)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 590,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    apply (summable_left_one_div_linear_sub_one_div_linear z i (i + 1)).congr\r\n",
      "body": "`i` is already in `\u2124`, you don't need the type annotation \r\n```suggestion\r\n    apply (summable_left_one_div_linear_sub_one_div_linear z i (i + 1)).congr\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "congr"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 601,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n",
      "body": "```suggestion\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 602,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n",
      "body": "```suggestion\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 603,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n    have H : g = (swap a (g a) * (swap b c)) * (swap b c * (swap (g a) (g (g a)))) := by\r\n      simp [mul_assoc, \u2190 hg3.eq_swap_mul_swap_iff_mem_support.mpr ha]\r\n    rw [H]\r\n",
      "body": "```suggestion\r\n    have H : g = (swap a (g a) * (swap b c)) * (swap b c * (swap (g a) (g (g a)))) := by\r\n      simp [mul_assoc, \u2190 hg3.eq_swap_mul_swap_iff_mem_support.mpr ha]\r\n    rw [H]\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 604,
      "before_code": "simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *\n  grind",
      "suggestion": "theorem disjoint_swap_swap {x y z t : \u03b1} (h : [x, y, z, t].Nodup) :\n    Disjoint (swap x y) (swap z t) := by\n  intro; grind\n",
      "body": "We should drop the redundant finiteness assumption. Luckily, `grind` comes to the rescue:\n```suggestion\ntheorem disjoint_swap_swap {x y z t : \u03b1} (h : [x, y, z, t].Nodup) :\n    Disjoint (swap x y) (swap z t) := by\n  intro; grind\n```",
      "path": "Mathlib/GroupTheory/Perm/Support.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "intro"
        ],
        "body_tactics": [
          "grind",
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [
          "remove_redundant",
          "use_grind"
        ],
        "keywords": [
          "mul_apply",
          "swap_apply_def",
          "grind",
          "eq_iff",
          "mem_support",
          "simp",
          "injective",
          "only"
        ]
      }
    },
    {
      "id": 607,
      "before_code": "end disjointOfUnion",
      "suggestion": "\r\nlemma _root_.Set.Ioc_mem_setOf_Ioc_le [LinearOrder \u03b1] (u v : \u03b1) :\r\n",
      "body": "You already have \u03b1 as a variable, don't you? Same below.\r\n```suggestion\r\nlemma _root_.Set.Ioc_mem_setOf_Ioc_le [LinearOrder \u03b1] (u v : \u03b1) :\r\n```",
      "path": "Mathlib/MeasureTheory/SetSemiring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "disjointOfUnion"
        ]
      }
    },
    {
      "id": 609,
      "before_code": "end disjointOfUnion",
      "suggestion": "\r\n    IsSetSemiring (Set.range fun x : \u03b1 \u00d7 \u03b1 \u21a6 Set.Ioc x.1 x.2) where\r\n",
      "body": "This is perhaps a nicer spelling for what you're doing.\r\n```suggestion\r\n    IsSetSemiring (Set.range fun x : \u03b1 \u00d7 \u03b1 \u21a6 Set.Ioc x.1 x.2) where\r\n```",
      "path": "Mathlib/MeasureTheory/SetSemiring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "disjointOfUnion"
        ]
      }
    },
    {
      "id": 614,
      "before_code": "\u03bc.map f s \u2264 \u03bc.map f t := by gcongr\n    _ = \u03bc (f \u207b\u00b9' s) := by rw [map_apply hf.measurable htm, hft, measure_toMeasurable]",
      "suggestion": "  rw [\u2190 Set.preimage_image_eq s hf.injective, \u2190 hf.map_apply, \u2190 hf.map_apply]\n",
      "body": "```suggestion\n  rw [\u2190 Set.preimage_image_eq s hf.injective, \u2190 hf.map_apply, \u2190 hf.map_apply]\n```\nIf `simp_rw` also works, you can remove the second `hf.map_apply` also.",
      "path": "Mathlib/MeasureTheory/Measure/Map.lean",
      "tags": {
        "before_tactics": [
          "gcongr",
          "rw"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "gcongr"
        ],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "gcongr",
          "map_apply",
          "map",
          "hft",
          "htm",
          "measure_toMeasurable",
          "measurable"
        ]
      }
    },
    {
      "id": 633,
      "before_code": "rw [zpow_natCast]\n  apply one_le_pow_of_one_le' H",
      "suggestion": "\r\ntheorem one_lt_zpow {x : G} (hx : 1 < x) {n : \u2124} (hn : 0 < n) : 1 < x ^ n := by\r\n  lift n to \u2115 using Int.le_of_lt hn\r\n  rw [zpow_natCast]\r\n  exact one_lt_pow' hx (Int.natCast_pos.mp hn).ne'\r\n",
      "body": "Sorry for breaking your code\r\n```suggestion\r\ntheorem one_lt_zpow {x : G} (hx : 1 < x) {n : \u2124} (hn : 0 < n) : 1 < x ^ n := by\r\n  lift n to \u2115 using Int.le_of_lt hn\r\n  rw [zpow_natCast]\r\n  exact one_lt_pow' hx (Int.natCast_pos.mp hn).ne'\r\n```",
      "path": "Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "apply",
          "zpow_natCast",
          "one_le_pow_of_one_le"
        ]
      }
    },
    {
      "id": 634,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero\n\nsection MultiplicativeNotation\n\n/-- Notation for `WithZero (Multiplicative \u2115)` -/\nscoped[Multiplicative] notation \"\u2115\u2098\u2080\" => WithZero (Multiplicative \u2115)\n\n/-- Notation for `WithZero (Multiplicative \u2124)` -/\nscoped[Multiplicative] notation \"\u2124\u2098\u2080\" => WithZero (Multiplicative \u2124)\n\nend MultiplicativeNotation",
      "suggestion": "\r\ntheorem Int.ofAdd_neg_natCast_lt_one {n : \u2115} : (Multiplicative.ofAdd (-n : \u2124) : \u2124\u2098\u2080) < 1 := by\r\n  rw [\u2190 coe_one, coe_lt_coe, \u2190 ofAdd_zero, ofAdd_lt]\r\n  omega\r\n",
      "body": "This lemma feels overly specific. Can you either:\r\n* drop it\r\n* generalise it, maybe something like\r\n```suggestion\r\ntheorem Int.ofAdd_neg_natCast_lt_one {n : \u2115} : (Multiplicative.ofAdd (-n : \u2124) : \u2124\u2098\u2080) < 1 := by\r\n  rw [\u2190 coe_one, coe_lt_coe, \u2190 ofAdd_zero, ofAdd_lt]\r\n  omega\r\n```\r\n(didn't fix the proof)",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "omega"
        ],
        "body_tactics": [
          "rw",
          "omega"
        ],
        "new_tactics": [
          "rw",
          "omega"
        ],
        "removed_tactics": [],
        "topics": [
          "int",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_omega"
        ],
        "keywords": [
          "end",
          "Notation",
          "scoped",
          "WithZero",
          "MultiplicativeNotation",
          "instLinearOrderedCommMonoidWithZero",
          "Multiplicative",
          "notation",
          "commGroupWithZero",
          "section",
          "for"
        ]
      }
    },
    {
      "id": 636,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero",
      "suggestion": "theorem one_lt_div' [LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1) {b : \u03b1} (hb : 0 < b) :\n    1 < a / b \u2194 b < a := by\n  rw [\u2190 mul_lt_mul_right (zero_lt_iff.mpr hb), one_mul, div_eq_mul_inv, inv_mul_cancel_right\u2080 hb]\n",
      "body": "Can you generalise that to `GroupWithZero` + `LinearOrder` + compatibility typeclasses by assuming \n```suggestion\ntheorem one_lt_div' [LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1) {b : \u03b1} (hb : 0 < b) :\n    1 < a / b \u2194 b < a := by\n  rw [\u2190 mul_lt_mul_right (zero_lt_iff.mpr hb), one_mul, div_eq_mul_inv, inv_mul_cancel_right\u2080 hb]\n```\nThis way it will also apply to eg linearly ordered fields. Same for the three lemmas below",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "apply",
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "WithZero",
          "end",
          "commGroupWithZero",
          "instLinearOrderedCommMonoidWithZero"
        ]
      }
    },
    {
      "id": 643,
      "before_code": "theorem inf_orthogonal_eq_bot : K \u2293 K\u15ee = \u22a5 := by\n  rw [eq_bot_iff]\n  intro x\n  simp only [toSubmodule_inf, orthogonal_toSubmodule_eq, Submodule.mem_inf, toSubmodule_bot,\n    Submodule.mem_bot, and_imp]\n  exact fun hx ho => inner_self_eq_zero.1 (ho x hx)",
      "suggestion": "\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n",
      "body": "```suggestion\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n```\r\nDoes this work?",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "theorem",
          "toSubmodule_inf",
          "exact",
          "eq_bot_iff",
          "mem_inf",
          "toSubmodule_bot",
          "mem_bot",
          "Submodule",
          "and_imp",
          "simp",
          "intro",
          "orthogonal_toSubmodule_eq",
          "inner_self_eq_zero",
          "inf_orthogonal_eq_bot"
        ]
      }
    },
    {
      "id": 644,
      "before_code": "theorem InnerProductSpace.symm_toEuclideanLin_rankOne {\ud835\udd5c m n : Type*} [RCLike \ud835\udd5c] [Fintype m]\n    [Fintype n] [DecidableEq n] (x : EuclideanSpace \ud835\udd5c m) (y : EuclideanSpace \ud835\udd5c n) :\n    toEuclideanLin.symm (rankOne \ud835\udd5c x y) = .vecMulVec x (star y) := by\n  simp [toEuclideanLin, toMatrix', \u2190 ext_iff, vecMulVec_apply, inner_single_right, mul_comm]",
      "suggestion": "\r\n  simp [toLpLin, toMatrix', \u2190 ext_iff, vecMulVec_apply, inner_single_right, mul_comm]\r\n",
      "body": "```suggestion\r\n  simp [toLpLin, toMatrix', \u2190 ext_iff, vecMulVec_apply, inner_single_right, mul_comm]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/PiL2.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Type",
          "toEuclideanLin",
          "rankOne",
          "symm",
          "symm_toEuclideanLin_rankOne",
          "EuclideanSpace",
          "RCLike",
          "DecidableEq",
          "star",
          "vecMulVec_apply",
          "toMatrix",
          "mul_comm",
          "vecMulVec",
          "simp",
          "InnerProductSpace",
          "theorem",
          "ext_iff",
          "Fintype",
          "inner_single_right"
        ]
      }
    },
    {
      "id": 654,
      "before_code": ".of_isCoveringMap_subtype (by simp) _ isCoveringMap_exp\n\nend Complex",
      "suggestion": "\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n",
      "body": "```suggestion\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n```",
      "path": "Mathlib/Analysis/Complex/CoveringMap.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "aesop",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "aesop",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "aesop",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "of_isCoveringMap_subtype",
          "end",
          "Complex",
          "simp",
          "isCoveringMap_exp"
        ]
      }
    },
    {
      "id": 655,
      "before_code": "rintro z \u27e8w, hw1, rfl\u27e9\n    exact (hg w (hs1 hw1)).eventually_constant_or_nhds_le_map_nhds.resolve_left (h w (hs1 hw1))\n        (image_mem_map (hs2.mem_nhds hw1))",
      "suggestion": "theorem Polynomial.eq_C_or_isOpenQuotientMap_eval (p : Polynomial \u2102) :\n    (\u2203 x, p = C x) \u2228 IsOpenQuotientMap p.eval := by\n",
      "body": "This is a very minor nit, but I think it makes more sense to read the declaration this way. If you have some reason to have the way you did, you can leave it that way.\n```suggestion\ntheorem Polynomial.eq_C_or_isOpenQuotientMap_eval (p : Polynomial \u2102) :\n    (\u2203 x, p = C x) \u2228 IsOpenQuotientMap p.eval := by\n```",
      "path": "Mathlib/Analysis/Complex/OpenMapping.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "mem_nhds",
          "eventually_constant_or_nhds_le_map_nhds",
          "hs1",
          "exact",
          "image_mem_map",
          "hs2",
          "rintro",
          "resolve_left",
          "rfl",
          "hw1"
        ]
      }
    },
    {
      "id": 658,
      "before_code": "lemma stdSimplexHomeomorphUnitInterval_one :\n    stdSimplexHomeomorphUnitInterval \u27e8_, single_mem_stdSimplex _ 1\u27e9 = 1 := rfl",
      "suggestion": "\r\n  Metric.diam_le_of_forall_dist_le zero_le_one fun x hx y hy \u21a6\r\n    (dist_pi_le_iff zero_le_one).mpr fun i \u21a6 by\r\n",
      "body": "looks weird indented, in my opinion,\r\n```suggestion\r\n  Metric.diam_le_of_forall_dist_le zero_le_one fun x hx y hy \u21a6\r\n    (dist_pi_le_iff zero_le_one).mpr fun i \u21a6 by\r\n```\r\nI guess the rest can be indented more tho if you want?",
      "path": "Mathlib/Analysis/Convex/StdSimplex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "rfl",
          "single_mem_stdSimplex",
          "stdSimplexHomeomorphUnitInterval",
          "stdSimplexHomeomorphUnitInterval_one"
        ]
      }
    },
    {
      "id": 660,
      "before_code": "rw [isLittleO_iff_forall_isBigOWith, isLittleO_iff_forall_isBigOWith]\n  simp [isBigOWith_mul_iff_isBigOWith_div hf]",
      "suggestion": "\r\n      _ \u2264 C\u2081 * \u2016g m\u2016 := by\r\n        gcongr\r\n        exact Finset.le_sup' (fun x => \u2016f x\u2016 / \u2016g x\u2016) (Finset.mem_def.mpr hm)\r\n",
      "body": "```suggestion\r\n      _ \u2264 C\u2081 * \u2016g m\u2016 := by\r\n        gcongr\r\n        exact Finset.le_sup' (fun x => \u2016f x\u2016 / \u2016g x\u2016) (Finset.mem_def.mpr hm)\r\n```",
      "path": "Mathlib/Analysis/Asymptotics/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "gcongr"
        ],
        "body_tactics": [
          "exact",
          "gcongr"
        ],
        "new_tactics": [
          "exact",
          "gcongr"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isBigOWith_mul_iff_isBigOWith_div",
          "simp",
          "isLittleO_iff_forall_isBigOWith"
        ]
      }
    },
    {
      "id": 662,
      "before_code": "map n (g \u2218\u2097 f) = map n g \u2218\u2097 map n f := by\n  aesop",
      "suggestion": "\r\n/-- If a linear map has a retraction, then the map it induces on exterior powers is injective. -/\r\nlemma map_injective {f : M \u2192\u2097[R] N} (g : N \u2192\u2097[R] M) (hg : g \u2218\u2097 f = .id) :\r\n    Injective (map n f) :=\r\n  RightInverse.injective (g := map n g)\r\n    (fun _ \u21a6 by rw [\u2190 LinearMap.comp_apply, \u2190 map_comp, hg, map_id, LinearMap.id_coe, id_eq])\r\n\r\n/-- If the base ring is a field, then any injective linear map induces an injective map on\r\nexterior powers. -/\r\nlemma map_injective_field {K : Type*} [Field K] [Module K M] [Module K N]\r\n    {f : M \u2192\u2097[K] N} (hf : Injective f) :\r\n    Injective (map n f) :=\r\n  map_injective _ (f.exists_leftInverse_of_injective (LinearMap.ker_eq_bot.mpr hf)).choose_spec\r\n",
      "body": "It is almost always more convenient to destruct an existential hypothesis and I think we should do so here. Given that and some other very minor style tweaks I suggest:\r\n```suggestion\r\n/-- If a linear map has a retraction, then the map it induces on exterior powers is injective. -/\r\nlemma map_injective {f : M \u2192\u2097[R] N} (g : N \u2192\u2097[R] M) (hg : g \u2218\u2097 f = .id) :\r\n    Injective (map n f) :=\r\n  RightInverse.injective (g := map n g)\r\n    (fun _ \u21a6 by rw [\u2190 LinearMap.comp_apply, \u2190 map_comp, hg, map_id, Line",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "ring",
          "rw"
        ],
        "body_tactics": [
          "ring",
          "rw"
        ],
        "new_tactics": [
          "ring",
          "rw"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "map",
          "aesop"
        ]
      }
    },
    {
      "id": 663,
      "before_code": "have B : \u2200\u1da0 x in atTop, x + 1 \u2264 exp x := eventually_atTop.2 \u27e80, fun x _ => add_one_le_exp x\u27e9\n  exact tendsto_atTop_mono' atTop B A",
      "suggestion": "  have h_le : y \u2264 exp (y - 1) := by simpa using add_one_le_exp (y - 1)\n  have h_mul_le : y * rexp (-y) \u2264 rexp (y - 1) * rexp (-y) := by gcongr\n  simpa [\u2190 exp_add, sub_add_eq_add_sub] using h_mul_le\n",
      "body": "```suggestion\n  have h_le : y \u2264 exp (y - 1) := by simpa using add_one_le_exp (y - 1)\n  have h_mul_le : y * rexp (-y) \u2264 rexp (y - 1) * rexp (-y) := by gcongr\n  simpa [\u2190 exp_add, sub_add_eq_add_sub] using h_mul_le\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Exp.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "simpa",
          "gcongr",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "gcongr",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "gcongr"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exp",
          "eventually_atTop",
          "exact",
          "have",
          "tendsto_atTop_mono",
          "add_one_le_exp",
          "atTop"
        ]
      }
    },
    {
      "id": 664,
      "before_code": "lemma uIoo_of_gt (h : b < a) : uIoo a b = Ioo b a := uIoo_of_ge h.le\n\nlemma uIoo_self : uIoo a a = \u2205 := by simp [uIoo]",
      "suggestion": "\r\nlemma uIoo_self : uIoo a a = \u2205 := by simp [uIoo]\r\n",
      "body": "```suggestion\r\nlemma uIoo_self : uIoo a a = \u2205 := by simp [uIoo]\r\n```",
      "path": "Mathlib/Order/Interval/Set/UnorderedInterval.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "uIoo_of_gt",
          "uIoo",
          "lemma",
          "uIoo_self",
          "simp",
          "uIoo_of_ge",
          "Ioo"
        ]
      }
    },
    {
      "id": 665,
      "before_code": "meromorphicNFOn_inv.mp <| AnalyticOnNhd.meromorphicNFOn <|\n    analyticOnNhd_univ_iff_differentiable.mpr differentiable_one_div_Gamma\n\nlemma MeromorphicOn.Gamma : MeromorphicOn Gamma univ :=\n  MeromorphicNFOn.Gamma.meromorphicOn",
      "suggestion": "\r\n-- TODO: restate `MeromorphicNFOn.Gamma` when `MeromorphicNF` is defined\r\n\r\nlemma Meromorphic.Gamma : Meromorphic Gamma :=\r\n",
      "body": "Sorry,  I didn't know that all `assert_not_exists`ed names should be available later, so now tests fail.\r\nPlease remove `assert_not_exists`:\r\n```suggestion\r\n-- TODO: restate `MeromorphicNFOn.Gamma` when `MeromorphicNF` is defined\r\n\r\nlemma Meromorphic.Gamma : Meromorphic Gamma :=\r\n```",
      "path": "Mathlib/Analysis/Meromorphic/Complex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "differentiability"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "lemma",
          "univ",
          "meromorphicNFOn",
          "AnalyticOnNhd",
          "meromorphicNFOn_inv",
          "analyticOnNhd_univ_iff_differentiable",
          "differentiable_one_div_Gamma",
          "MeromorphicOn",
          "meromorphicOn",
          "Gamma",
          "MeromorphicNFOn"
        ]
      }
    },
    {
      "id": 667,
      "before_code": "(hx : \u2200 r : R, r \u2022 x \u2208 Submodule.span R s \u2192 r = 0) : LinearIndepOn R id (insert x s) :=\n  hs.insert' <| by simpa",
      "suggestion": "/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?_\n  have aux (j : \u03b9) (hjs : j \u2208 s) (hji : j \u2260 i) : g j * (f i) (v j) = 0 := by simp [h1 hji.symm]\n  simpa [s.sum_eq_single i aux (by aesop), h2 i] using congr_arg (f i) hrel\n",
      "body": "Just a few minor style tweaks:\n```suggestion\n/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?",
      "path": "Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "have",
          "aesop",
          "simp",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "insert",
          "LinearIndepOn",
          "span",
          "simpa",
          "Submodule"
        ]
      }
    },
    {
      "id": 669,
      "before_code": "G.Reachable u v := by\n  rw [Subsingleton.allEq u v]",
      "suggestion": "lemma not_reachable_of_degree_zero {G : SimpleGraph V} {u v : V} [Fintype (G.neighborSet u)]\n    (huv : u \u2260 v) (hu : G.degree u = 0) :\n",
      "body": "```suggestion\nlemma not_reachable_of_degree_zero {G : SimpleGraph V} {u v : V} [Fintype (G.neighborSet u)]\n    (huv : u \u2260 v) (hu : G.degree u = 0) :\n```\n(re-using the V from outside, and putting the typeclass argument before the propositional one)",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Connected.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Subsingleton",
          "allEq",
          "Reachable"
        ]
      }
    },
    {
      "id": 670,
      "before_code": "end PartialOrder",
      "suggestion": "  le_of_not_gt (h.not_lt hy)\n",
      "body": "```suggestion\n  le_of_not_gt (h.not_lt hy)\n```\nI'd suggest proving this and the later ones like this, for simplicity.",
      "path": "Mathlib/Order/Minimal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "PartialOrder",
          "end"
        ]
      }
    },
    {
      "id": 684,
      "before_code": "end InjectiveResolution",
      "suggestion": "  { exact := ShortComplex.exact_cokernel _ }\n",
      "body": "```suggestion\n  { exact := ShortComplex.exact_cokernel _ }\n```",
      "path": "Mathlib/CategoryTheory/Abelian/Injective/Resolution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "InjectiveResolution",
          "end"
        ]
      }
    },
    {
      "id": 687,
      "before_code": "theorem card_le_of_injective (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) : card \u03b1 \u2264 card \u03b2 :=\n  Finset.card_le_card_of_injOn f (fun _ _ => Finset.mem_univ _) fun _ _ _ _ h => hf h",
      "suggestion": "\r\ntheorem not_injective_of_card_lt (f : \u03b1 \u2192 \u03b2) (h : card \u03b2 < card \u03b1) :\r\n",
      "body": "```suggestion\r\ntheorem not_injective_of_card_lt (f : \u03b1 \u2192 \u03b2) (h : card \u03b2 < card \u03b1) :\r\n```\r\nI think we can drop this, docstrings which just read out the statement are not particularly interesting.",
      "path": "Mathlib/Data/Fintype/Card.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "function",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "Injective",
          "theorem",
          "mem_univ",
          "Finset",
          "Function",
          "card_le_of_injective",
          "card_le_card_of_injOn",
          "card"
        ]
      }
    },
    {
      "id": 688,
      "before_code": "theorem card_le_of_injective (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) : card \u03b1 \u2264 card \u03b2 :=\n  Finset.card_le_card_of_injOn f (fun _ _ => Finset.mem_univ _) fun _ _ _ _ h => hf h",
      "suggestion": "\r\n    \u00acFunction.Injective f :=\r\n  Nat.not_le_of_lt h \u2218 card_le_of_injective f\r\n",
      "body": "Golfs slightly to\r\n```suggestion\r\n    \u00acFunction.Injective f :=\r\n  Nat.not_le_of_lt h \u2218 card_le_of_injective f\r\n```",
      "path": "Mathlib/Data/Fintype/Card.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "function",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "Injective",
          "theorem",
          "mem_univ",
          "Finset",
          "Function",
          "card_le_of_injective",
          "card_le_card_of_injOn",
          "card"
        ]
      }
    },
    {
      "id": 691,
      "before_code": "end IsSetSemiring",
      "suggestion": "\r\n  rcases h.eq_or_lt with rfl | huv\r\n  \u00b7 grind [Set.Ioc_eq_empty_iff]\r\n  rw [Set.Ioc_eq_Ioc_iff huv] at hu'v'\r\n  grind\r\n",
      "body": "```suggestion\r\n  rcases h.eq_or_lt with rfl | huv\r\n  \u00b7 grind [Set.Ioc_eq_empty_iff]\r\n  rw [Set.Ioc_eq_Ioc_iff huv] at hu'v'\r\n  grind\r\n```\r\ncombined with my other suggestion, this golfs quite a bit, and in my eyes without any loss of readability",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "cases",
          "rw"
        ],
        "body_tactics": [
          "grind",
          "cases",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "cases",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 692,
      "before_code": "end IsSetSemiring",
      "suggestion": "\r\n  classical\r\n  rw [onIocAux, dite_eq_right_iff]\r\n  grind [Set.Ioc_eq_empty_iff]\r\n",
      "body": "```suggestion\r\n  classical\r\n  rw [onIocAux, dite_eq_right_iff]\r\n  grind [Set.Ioc_eq_empty_iff]\r\n```\r\na golf, if you like",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "rw"
        ],
        "body_tactics": [
          "grind",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 693,
      "before_code": "end IsSetSemiring",
      "suggestion": "      simp [this, onIocAux_empty f]\n",
      "body": "```suggestion\n      simp [this, onIocAux_empty f]\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 694,
      "before_code": "end IsSetSemiring",
      "suggestion": "      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n",
      "body": "```suggestion\n      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "rw",
          "simp",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 695,
      "before_code": "end IsSetSemiring",
      "suggestion": "      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n",
      "body": "```suggestion\n      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 696,
      "before_code": "end IsSetSemiring",
      "suggestion": "      have UI' : \u22c3\u2080 \u2191I' = Ioc u u' := by\n        have : (Ioc u' v \u222a \u22c3\u2080 \u2191I') \\ Ioc u' v = \u22c3\u2080 \u2191I' := by\n          refine Disjoint.sup_sdiff_cancel_left ?_\n          simp only [coe_erase, disjoint_sUnion_right, mem_diff, mem_singleton_iff, and_imp, I']\n          intro u hu hu'\n          exact (h'I hu tI hu').symm\n        simp only [I_eq_insert, coe_insert, sUnion_insert] at h'uv\n        grind\n",
      "body": "```suggestion\n      have UI' : \u22c3\u2080 \u2191I' = Ioc u u' := by\n        have : (Ioc u' v \u222a \u22c3\u2080 \u2191I') \\ Ioc u' v = \u22c3\u2080 \u2191I' := by\n          refine Disjoint.sup_sdiff_cancel_left ?_\n          simp only [coe_erase, disjoint_sUnion_right, mem_diff, mem_singleton_iff, and_imp, I']\n          intro u hu hu'\n          exact (h'I hu tI hu').symm\n        simp only [I_eq_insert, coe_insert, sUnion_insert] at h'uv\n        grind\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "refine",
          "simp",
          "intro",
          "exact",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 697,
      "before_code": "end IsSetSemiring",
      "suggestion": "      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n",
      "body": "```suggestion\n      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 698,
      "before_code": "ext\n  simp +contextual [imp_false]",
      "suggestion": "\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n",
      "body": "I know you're not a fan but `diagSet` seems to fit the hypothesis pretty well:\r\n```suggestion\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n```\r\nThe current proof (just without the underscore) will also work after your #32679 is merged",
      "path": "Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simpa",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "contextual",
          "imp_false",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 699,
      "before_code": "theorem deleteEdges_deleteEdges (s s' : Set (Sym2 V)) :\n    (G.deleteEdges s).deleteEdges s' = G.deleteEdges (s \u222a s') := by simp [deleteEdges, sdiff_sdiff]\n\n@[simp] lemma deleteEdges_empty : G.deleteEdges \u2205 = G := by simp [deleteEdges]",
      "suggestion": "\r\n-- This is not marked `simp` since `deleteEdges_of_subset_diagSet` already proves it\r\n",
      "body": "```suggestion\r\n-- This is not marked `simp` since `deleteEdges_of_subset_diagSet` already proves it\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "lemma",
          "theorem",
          "deleteEdges_deleteEdges",
          "Set",
          "deleteEdges_empty",
          "simp",
          "deleteEdges",
          "Sym2",
          "sdiff_sdiff"
        ]
      }
    },
    {
      "id": 709,
      "before_code": "@[simp] lemma natCast_eq_zero {a n : \u2115} [NeZero n] : (a : Fin n) = 0 \u2194 n \u2223 a := by\n  simp [Fin.ext_iff, Nat.dvd_iff_mod_eq_zero]",
      "suggestion": "@[simp] lemma natCast_zero {n : \u2115} [NeZero n] : ((0 : \u2115) : Fin n) = 0 := by\n",
      "body": "```suggestion\n@[simp] lemma natCast_zero {n : \u2115} [NeZero n] : ((0 : \u2115) : Fin n) = 0 := by\n```\nWhen the right hand side of an eq or an iff is obvious, the Mathlib naming puts just the left hand side.",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "lemma",
          "ext_iff",
          "natCast_eq_zero",
          "Nat",
          "NeZero",
          "dvd_iff_mod_eq_zero",
          "simp",
          "Fin"
        ]
      }
    },
    {
      "id": 711,
      "before_code": "open Filter Set Metric\nopen scoped Topology Pointwise\n\nvariable (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]\nvariable {E : Type*} [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]\n\n/-- The set of all tangent directions to the set `s` at the point `x`. -/\ndef tangentConeAt (s : Set E) (x : E) : Set E :=\n  { y : E | \u2203 (c : \u2115 \u2192 \ud835\udd5c) (d : \u2115 \u2192 E),\n    (\u2200\u1da0 n in atTop, x + d n \u2208 s) \u2227\n    Tendsto (fun n => \u2016c n\u2016) atTop atTop \u2227\n    Tendsto (fun n => c n \u2022 d n) atTop (\ud835\udcdd y) }",
      "suggestion": "\r\n/-- A special case of `mem_tangentConeAt_of_frequently` which is convenient for XXX. -/\r\ntheorem mem_tangentConeAt_of_seq {\u03b1 : Type*} (l : Filter \u03b1) [l.NeBot] (c : \u03b1 \u2192 R) (d : \u03b1 \u2192 E)\r\n",
      "body": "Could you add a docstring along the lines of\r\n```suggestion\r\n/-- A special case of `mem_tangentConeAt_of_frequently` which is convenient for XXX. -/\r\ntheorem mem_tangentConeAt_of_seq {\u03b1 : Type*} (l : Filter \u03b1) [l.NeBot] (c : \u03b1 \u2192 R) (d : \u03b1 \u2192 E)\r\n```",
      "path": "Mathlib/Analysis/Calculus/TangentCone/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "algebra",
          "nat",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "Topology",
          "Type",
          "Metric",
          "tangentConeAt",
          "open",
          "atTop",
          "scoped",
          "set",
          "Filter",
          "point",
          "TopologicalSpace",
          "variable",
          "def",
          "Pointwise",
          "Tendsto",
          "tangent",
          "NontriviallyNormedField",
          "AddCommMonoid",
          "Set",
          "directions",
          "all"
        ]
      }
    },
    {
      "id": 723,
      "before_code": "simp_rw [card_filter_univ_succ', Vector.get_cons_zero, Vector.toList_cons, Vector.get_cons_succ,\n      hxs, List.count_cons, add_comm (ite (x = a) 1 0), beq_iff_eq]",
      "suggestion": "\r\nGiven a \"downward-closed\" predicate `p` on `Fin n` (which could be spelt `Antitone p`), \r\nthen `p` holds for more than `j` elements iff it holds for `p` itself.\r\n",
      "body": "```suggestion\r\nGiven a \"downward-closed\" predicate `p` on `Fin n` (which could be spelt `Antitone p`), \r\nthen `p` holds for more than `j` elements iff it holds for `p` itself.\r\n```",
      "path": "Mathlib/Data/Fintype/Fin.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "card_filter_univ_succ",
          "toList_cons",
          "hxs",
          "beq_iff_eq",
          "add_comm",
          "get_cons_succ",
          "count_cons",
          "Vector",
          "get_cons_zero",
          "List",
          "simp_rw",
          "ite"
        ]
      }
    },
    {
      "id": 725,
      "before_code": "simp_rw [card_filter_univ_succ', Vector.get_cons_zero, Vector.toList_cons, Vector.get_cons_succ,\n      hxs, List.count_cons, add_comm (ite (x = a) 1 0), beq_iff_eq]",
      "suggestion": "\r\ntheorem lt_card_filter_iff_apply_of_imp {j : Fin n} (p : Fin n \u2192 Prop) [DecidablePred p]\r\n",
      "body": "```suggestion\r\ntheorem lt_card_filter_iff_apply_of_imp {j : Fin n} (p : Fin n \u2192 Prop) [DecidablePred p]\r\n```",
      "path": "Mathlib/Data/Fintype/Fin.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "card_filter_univ_succ",
          "toList_cons",
          "hxs",
          "beq_iff_eq",
          "add_comm",
          "get_cons_succ",
          "count_cons",
          "Vector",
          "get_cons_zero",
          "List",
          "simp_rw",
          "ite"
        ]
      }
    },
    {
      "id": 729,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 730,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 731,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 732,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 733,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 734,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 735,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 736,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 737,
      "before_code": "simp_rw [card_filter_univ_succ', Vector.get_cons_zero, Vector.toList_cons, Vector.get_cons_succ,\n      hxs, List.count_cons, add_comm (ite (x = a) 1 0), beq_iff_eq]",
      "suggestion": "theorem lt_card_filter_univ_iff_apply_of_imp {j : Fin n} (p : Fin n \u2192 Prop) [DecidablePred p]\n",
      "body": "```suggestion\ntheorem lt_card_filter_univ_iff_apply_of_imp {j : Fin n} (p : Fin n \u2192 Prop) [DecidablePred p]\n```",
      "path": "Mathlib/Data/Fintype/Fin.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "card_filter_univ_succ",
          "toList_cons",
          "hxs",
          "beq_iff_eq",
          "add_comm",
          "get_cons_succ",
          "count_cons",
          "Vector",
          "get_cons_zero",
          "List",
          "simp_rw",
          "ite"
        ]
      }
    },
    {
      "id": 738,
      "before_code": "ext s hs\n  simp [hs]",
      "suggestion": "\r\n  ext s hs\r\n  simp_rw [sum_apply _ hs, join_apply hs, lintegral_sum_measure]\r\n",
      "body": "```suggestion\r\n  ext s hs\r\n  simp_rw [sum_apply _ hs, join_apply hs, lintegral_sum_measure]\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 739,
      "before_code": "let \u27e8f, hfm, hf\u27e9 := hg\n  \u27e8(bind \u00b7 f), measurable_bind' hfm, (ae_ae_of_ae_join hf).mono fun _ \u21a6 bind_congr_right\u27e9",
      "suggestion": "\r\n  simp_rw [bind, map_sum h, join_sum]\r\n",
      "body": "```suggestion\r\n  simp_rw [bind, map_sum h, join_sum]\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "bind",
          "mono",
          "hfm",
          "measurable_bind",
          "ae_ae_of_ae_join",
          "bind_congr_right"
        ]
      }
    },
    {
      "id": 740,
      "before_code": "end map -- section",
      "suggestion": "\r\n  simp only [isProbabilityMeasure_iff, MeasurableSet.univ, Measure.bind_apply _ hf\u2080]\r\n  simp_rw [isProbabilityMeasure_iff] at hf\u2081\r\n  exact lintegral_eq_const hf\u2081\r\n",
      "body": "Alternative:\r\n```suggestion\r\n  simp only [isProbabilityMeasure_iff, MeasurableSet.univ, Measure.bind_apply _ hf\u2080]\r\n  simp_rw [isProbabilityMeasure_iff] at hf\u2081\r\n  exact lintegral_eq_const hf\u2081\r\n```\r\nYou can keep your version if you prefer.",
      "path": "Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "map",
          "end",
          "section"
        ]
      }
    },
    {
      "id": 745,
      "before_code": "(p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (\u2a05 i, p i) = \u2a05 i, comap f (p i) :=\n  (gc_map_comap f).u_iInf",
      "suggestion": "\r\n    (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (s.inf p) = s.inf fun i \u21a6 comap f (p i) := by\r\n  simp [Finset.inf_eq_iInf]\r\n",
      "body": "```suggestion\r\n    (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (s.inf p) = s.inf fun i \u21a6 comap f (p i) := by\r\n  simp [Finset.inf_eq_iInf]\r\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Map.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "gc_map_comap",
          "Submodule",
          "comap",
          "u_iInf"
        ]
      }
    },
    {
      "id": 746,
      "before_code": "theorem comap_iInf (K : \u03b9 \u2192 Ideal S) : (iInf K).comap f = \u2a05 i, (K i).comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_iInf",
      "suggestion": "\r\n    (s.inf K).comap f = s.inf fun i \u21a6 (K i).comap f := by\r\n  simp [Finset.inf_eq_iInf, comap_iInf]\r\n",
      "body": "```suggestion\r\n    (s.inf K).comap f = s.inf fun i \u21a6 (K i).comap f := by\r\n  simp [Finset.inf_eq_iInf, comap_iInf]\r\n```",
      "path": "Mathlib/RingTheory/Ideal/Maps.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Ideal",
          "GaloisConnection",
          "theorem",
          "comap_iInf",
          "gc_map_comap",
          "iInf",
          "map",
          "u_iInf",
          "comap"
        ]
      }
    },
    {
      "id": 750,
      "before_code": "@[to_additive norm_add\u2083_le /-- **Triangle inequality** for the norm. -/]\nlemma norm_mul\u2083_le' : \u2016a * b * c\u2016 \u2264 \u2016a\u2016 + \u2016b\u2016 + \u2016c\u2016 := norm_mul_le_of_le' (norm_mul_le' _ _) le_rfl",
      "suggestion": "  norm_mul_le_of_le' norm_mul\u2083_le' le_rfl\n",
      "body": "```suggestion\n  norm_mul_le_of_le' norm_mul\u2083_le' le_rfl\n```",
      "path": "Mathlib/Analysis/Normed/Group/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "lemma",
          "le_rfl",
          "inequality",
          "norm_mul_le_of_le",
          "norm",
          "for",
          "Triangle",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 756,
      "before_code": "simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b\u2081, h, \u2190 mul_assoc, mul_comm _ (f a)]",
      "suggestion": "    exact (hki.2 (hs hi hj hij k (by grind))).elim\n",
      "body": "```suggestion\n    exact (hki.2 (hs hi hj hij k (by grind))).elim\n```",
      "path": "Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mul_assoc",
          "not_true_eq_false",
          "false_and",
          "mem_erase",
          "ne_eq",
          "not_false_eq_true",
          "simp",
          "mul_comm",
          "only",
          "prod_insert"
        ]
      }
    },
    {
      "id": 768,
      "before_code": "rcases IH with \u27e8d, had, hdb\u27e9\n  exact \u27e8_, had, hdb.tail hbc\u27e9",
      "suggestion": "\r\ntheorem symmetric (hr : Symmetric r) : Symmetric (TransGen r) := by\r\n  intro x y h\r\n  induction h with\r\n  | single i => exact .single (hr i)\r\n  | tail _ h\u2081 h\u2082 => exact .head (hr h\u2081) h\u2082\r\n",
      "body": "```suggestion\r\ntheorem symmetric (hr : Symmetric r) : Symmetric (TransGen r) := by\r\n  intro x y h\r\n  induction h with\r\n  | single i => exact .single (hr i)\r\n  | tail _ h\u2081 h\u2082 => exact .head (hr h\u2081) h\u2082\r\n```",
      "path": "Mathlib/Logic/Relation.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases"
        ],
        "suggestion_tactics": [
          "exact",
          "induction",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "induction",
          "intro"
        ],
        "new_tactics": [
          "induction",
          "intro"
        ],
        "removed_tactics": [
          "cases"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "had",
          "rcases",
          "hdb",
          "tail",
          "hbc"
        ]
      }
    },
    {
      "id": 770,
      "before_code": "theorem preCantorSet_antitone : Antitone preCantorSet := by\n  apply antitone_nat_of_succ_le\n  intro m",
      "suggestion": "\r\n  refine antitone_nat_of_succ_le fun m \u21a6 ?_\r\n",
      "body": "Since we're already golfing:\r\n```suggestion\r\n  refine antitone_nat_of_succ_le fun m \u21a6 ?_\r\n```",
      "path": "Mathlib/Topology/Instances/CantorSet.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "intro"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "apply",
          "intro"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "antitone_nat_of_succ_le",
          "theorem",
          "preCantorSet",
          "preCantorSet_antitone",
          "Antitone",
          "intro"
        ]
      }
    },
    {
      "id": 774,
      "before_code": "theorem symm_comp : e.symm.toLinearMap \u2218\u209b\u2097 e.toLinearMap = LinearMap.id :=\n  LinearMap.ext e.symm_apply_apply",
      "suggestion": "\r\n    e\u2081\u2082.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n\r\n@[simp]\r\nlemma symm_comp_assoc (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) [RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082] :\r\n    e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n",
      "body": "```suggestion\r\n    e\u2081\u2082.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n\r\n@[simp]\r\nlemma symm_comp_assoc (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) [RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082] :\r\n    e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n```",
      "path": "Mathlib/Algebra/Module/Equiv/Defs.lean",
      "tags": {
        "before_tactics": [
          "ext"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "LinearMap",
          "theorem",
          "symm_apply_apply",
          "symm_comp",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 777,
      "before_code": "\u00b7 rwa [inf_of_le_right (show (LinearMap.ker f) \u2264\n      (LinearMap.ker g).comap f from comap_mono bot_le)]",
      "suggestion": "\r\n/-- If $M \u2192 N \u2192 P \u2192 0$ is exact and $M$ and $P$ are finitely generated then so is $N$.\r\n",
      "body": "```suggestion\r\n/-- If $M \u2192 N \u2192 P \u2192 0$ is exact and $M$ and $P$ are finitely generated then so is $N$.\r\n```",
      "path": "Mathlib/RingTheory/Finiteness/Finsupp.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rwa",
          "LinearMap",
          "inf_of_le_right",
          "show",
          "comap",
          "from",
          "comap_mono",
          "bot_le",
          "ker"
        ]
      }
    },
    {
      "id": 780,
      "before_code": "\u00b7 rwa [inf_of_le_right (show (LinearMap.ker f) \u2264\n      (LinearMap.ker g).comap f from comap_mono bot_le)]",
      "suggestion": "\r\n/-- If `M \u2192 N \u2192 P \u2192 0` is exact and `M` and `P` are finitely generated then so is `N`.\r\n",
      "body": "```suggestion\r\n/-- If `M \u2192 N \u2192 P \u2192 0` is exact and `M` and `P` are finitely generated then so is `N`.\r\n```\r\nI am guessing we should either backticks + unicode or dollar signs + TeX.",
      "path": "Mathlib/RingTheory/Finiteness/Finsupp.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rwa",
          "LinearMap",
          "inf_of_le_right",
          "show",
          "comap",
          "from",
          "comap_mono",
          "bot_le",
          "ker"
        ]
      }
    },
    {
      "id": 782,
      "before_code": "intro x\n  rw [ValuationSubring.valuation_le_one_iff, mem_valuationSubring_iff]",
      "suggestion": "\r\ntheorem isNontrivial_valuation_valuationSubring_iff :\r\n",
      "body": "```suggestion\r\ntheorem isNontrivial_valuation_valuationSubring_iff :\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "intro"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mem_valuationSubring_iff",
          "valuation_le_one_iff",
          "ValuationSubring",
          "intro"
        ]
      }
    },
    {
      "id": 787,
      "before_code": "intro x\n  rw [ValuationSubring.valuation_le_one_iff, mem_valuationSubring_iff]",
      "suggestion": "\r\n  isNontrivial_iff_isEquiv_isNontrivial (isEquiv_valuation_valuationSubring v).symm\r\n",
      "body": "Does this work?\r\n```suggestion\r\n  isNontrivial_iff_isEquiv_isNontrivial (isEquiv_valuation_valuationSubring v).symm\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "intro"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mem_valuationSubring_iff",
          "valuation_le_one_iff",
          "ValuationSubring",
          "intro"
        ]
      }
    },
    {
      "id": 804,
      "before_code": "\u00b7 exact fun e h \u21a6 isNoetherianRing_of_ringEquiv _ (.piCongrLeft _ e)\n  \u00b7 infer_instance\n  \u00b7 exact fun ih \u21a6 isNoetherianRing_of_ringEquiv _ (.symm .piOptionEquivProd)",
      "suggestion": "\r\n/-- A submodule contained in an FG submodule is FG over noetherian rings. -/\r\n",
      "body": "```suggestion\r\n/-- A submodule contained in an FG submodule is FG over noetherian rings. -/\r\n```",
      "path": "Mathlib/RingTheory/Noetherian/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "piCongrLeft",
          "infer_instance",
          "exact",
          "piOptionEquivProd",
          "isNoetherianRing_of_ringEquiv"
        ]
      }
    },
    {
      "id": 809,
      "before_code": "end IsNontrivial",
      "suggestion": "\r\nvariable {B : Type*} {A : Type*} [CommSemiring A] [Ring B] [Algebra A B] (v : Valuation B \u0393\u2080)\r\n",
      "body": "```suggestion\r\nvariable {B : Type*} {A : Type*} [CommSemiring A] [Ring B] [Algebra A B] (v : Valuation B \u0393\u2080)\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "IsNontrivial",
          "end"
        ]
      }
    },
    {
      "id": 815,
      "before_code": "variable (K)\n\n-- TODO: turn `hT` into an assumption `T \u2264 iSup K`. That's what `Set.iUnionLift` needs\n/-- Define an algebra homomorphism on a directed supremum of subalgebras by defining\nit on each subalgebra, and proving that it agrees on the intersection of subalgebras. -/\nnoncomputable def iSupLift (dir : Directed (\u00b7 \u2264 \u00b7) K) (f : \u2200 i, K i \u2192\u2090[R] B)\n    (hf : \u2200 (i j : \u03b9) (h : K i \u2264 K j), f i = (f j).comp (inclusion h))\n    (T : Subalgebra R A) (hT : T = iSup K) : \u21a5T \u2192\u2090[R] B :=\n  { toFun := Set.iUnionLift (fun i => \u2191(K i)) (fun i x => f i x)\n        (fun i j x hxi hxj => by\n          let \u27e8k, hik, hjk\u27e9 := dir i j\n          dsimp\n          rw [hf i k hik, hf j k hjk]\n          rfl)\n        (T : Set A) (by rw [hT, coe_iSup_of_directed dir])\n    map_one' := by apply Set.iUnionLift_const _ (fun _ => 1) <;> simp\n    map_zero' := by apply Set.iUnionLift_const _ (fun _ => 0) <;> simp\n    map_mul' := by\n      subst hT;\n      apply Set.iUnionLift_binary (coe_iSup_of_directed dir) dir _ (fun _ => (\u00b7 * \u00b7)) <;> simp\n    map_add' := by\n      subst hT;\n      apply Set.iUnionLift_binary (coe_iSup_of_directed dir) dir _ (fun _ => (\u00b7 + \u00b7)) <;> simp\n    commutes' := fun r => by apply Set.iUnionLift_const _ (fun _ => algebraMap R _ r) <;> simp }",
      "suggestion": "\r\n    simp [hf i k hik, hf j k hjk]\r\n",
      "body": "```suggestion\r\n    simp [hf i k hik, hf j k hjk]\r\n```",
      "path": "Mathlib/Algebra/Algebra/Subalgebra/Directed.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "rw"
        ],
        "topics": [
          "list",
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "map_one",
          "dir",
          "iUnionLift_binary",
          "map_zero",
          "subst",
          "algebra",
          "assumption",
          "hjk",
          "proving",
          "subalgebra",
          "each",
          "defining",
          "turn",
          "hik",
          "intersection",
          "commutes",
          "Subalgebra",
          "TODO",
          "apply",
          "noncomputable",
          "subalgebras",
          "Define",
          "needs",
          "map_mul",
          "hxj",
          "That",
          "iUnionLift",
          "into",
          "iUnionLift_const",
          "iSupLift",
          "def",
          "variable",
          "coe_iSup_of_directed",
          "toFun",
          "supremum",
          "that",
          "comp",
          "map_add",
          "homomorphism",
          "simp",
          "rfl",
          "dsimp",
          "inclusion",
          "Directed",
          "agrees",
          "what",
          "hxi",
          "Set",
          "iSup",
          "directed"
        ]
      }
    },
    {
      "id": 816,
      "before_code": "theorem irreducible_of_factor {a : \u03b1} : \u2200 x : \u03b1, x \u2208 factors a \u2192 Irreducible x := fun x h =>\n  (prime_of_factor x h).irreducible",
      "suggestion": "  have hf : factors a \u2260 0 := by\n    intro hf\n    simpa [hf, Associated.comm, ha.not_isUnit] using factors_prod ha.ne_zero\n",
      "body": "I think this is clearer as:\n```suggestion\n  have hf : factors a \u2260 0 := by\n    intro hf\n    simpa [hf, Associated.comm, ha.not_isUnit] using factors_prod ha.ne_zero\n```\nand then deindent the rest of the proof",
      "path": "Mathlib/RingTheory/UniqueFactorizationDomain/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "irreducible",
          "theorem",
          "Irreducible",
          "factors",
          "irreducible_of_factor",
          "prime_of_factor"
        ]
      }
    },
    {
      "id": 818,
      "before_code": "simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]",
      "suggestion": "  grind [Finset.card_eq_zero, primeFactors_eq_empty]\n",
      "body": "Looks like this can be:\n```suggestion\n  grind [Finset.card_eq_zero, primeFactors_eq_empty]\n```",
      "path": "Mathlib/Data/Nat/Factorization/PrimePow.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Finsupp",
          "support_factorization",
          "Nat",
          "pos_iff_ne_zero",
          "card_support_eq_one",
          "simp_rw",
          "isPrimePow_iff_factorization_eq_single"
        ]
      }
    },
    {
      "id": 823,
      "before_code": "rw [PrimeSpectrum.isClosed_singleton_iff_isMaximal, closedPoint]\n  infer_instance",
      "suggestion": "\r\ntheorem primeSpectrum_eq_of_krullDimLE_one [IsDomain R] [hd : Ring.KrullDimLE 1 R]\r\n",
      "body": "```suggestion\r\ntheorem primeSpectrum_eq_of_krullDimLE_one [IsDomain R] [hd : Ring.KrullDimLE 1 R]\r\n```\r\nOr maybe `Ring.KrullDimLE.eq_bot_or_eq_top`.",
      "path": "Mathlib/RingTheory/Spectrum/Prime/Topology.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "PrimeSpectrum",
          "isClosed_singleton_iff_isMaximal",
          "closedPoint",
          "infer_instance"
        ]
      }
    },
    {
      "id": 826,
      "before_code": "rw [PrimeSpectrum.isClosed_singleton_iff_isMaximal, closedPoint]\n  infer_instance",
      "suggestion": "\r\ntheorem Ring.KrullDimLE.eq_bot_or_eq_top [IsDomain R] [Ring.KrullDimLE 1 R]\r\n",
      "body": "```suggestion\r\ntheorem Ring.KrullDimLE.eq_bot_or_eq_top [IsDomain R] [Ring.KrullDimLE 1 R]\r\n```",
      "path": "Mathlib/RingTheory/Spectrum/Prime/Topology.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "PrimeSpectrum",
          "isClosed_singleton_iff_isMaximal",
          "closedPoint",
          "infer_instance"
        ]
      }
    },
    {
      "id": 827,
      "before_code": "rw [PrimeSpectrum.isClosed_singleton_iff_isMaximal, closedPoint]\n  infer_instance",
      "suggestion": "\ninstance [IsDomain R] [Ring.KrullDimLE 1 R] [Nontrivial (PrimeSpectrum R)] :\n    IsSimpleOrder (PrimeSpectrum R) where\n  eq_bot_or_eq_top := Ring.KrullDimLE.eq_bot_or_eq_top\n\n",
      "body": "Is it worth adding the following for the 1-dimensional case:\n```suggestion\n\ninstance [IsDomain R] [Ring.KrullDimLE 1 R] [Nontrivial (PrimeSpectrum R)] :\n    IsSimpleOrder (PrimeSpectrum R) where\n  eq_bot_or_eq_top := Ring.KrullDimLE.eq_bot_or_eq_top\n\n```",
      "path": "Mathlib/RingTheory/Spectrum/Prime/Topology.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "PrimeSpectrum",
          "isClosed_singleton_iff_isMaximal",
          "closedPoint",
          "infer_instance"
        ]
      }
    },
    {
      "id": 830,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
      "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 831,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
      "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 832,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
      "body": "```suggestion\n  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 833,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
      "body": "```suggestion\n  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 837,
      "before_code": "instance [Nontrivial M] : Nontrivial P.invtRootSubmodule where\n  exists_pair_ne := \u27e8\u22a5, \u22a4, by rw [ne_eq, Subtype.ext_iff]; exact bot_ne_top\u27e9",
      "suggestion": "    q = \u22a4 \u2194 range P.root \u2286 q :=\n  \u27e8fun h \u21a6 by simp [h], fun h \u21a6 by simpa using Submodule.span_mono h (R := K)\u27e9\n",
      "body": "How about:\n```suggestion\n    q = \u22a4 \u2194 range P.root \u2286 q :=\n  \u27e8fun h \u21a6 by simp [h], fun h \u21a6 by simpa using Submodule.span_mono h (R := K)\u27e9\n```\n(I confess I'm slightly amazed I could golf this so much: it suggests our `simp` sets are in pretty good shape)",
      "path": "Mathlib/LinearAlgebra/RootSystem/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Subtype",
          "ext_iff",
          "Nontrivial",
          "exact",
          "invtRootSubmodule",
          "ne_eq",
          "exists_pair_ne",
          "instance",
          "bot_ne_top"
        ]
      }
    },
    {
      "id": 846,
      "before_code": "map_id _ := rfl\n  map_comp := by rintro _ _ _ \u27e8p\u27e9 \u27e8q\u27e9; exact congr_arg Quotient.mk'' (p.map_trans q f.continuous)",
      "suggestion": "@[simp]\nprotected theorem map_id : map (.id X) = \ud835\udfed _ := by\n",
      "body": "```suggestion\n@[simp]\nprotected theorem map_id : map (.id X) = \ud835\udfed _ := by\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "congr_arg",
          "Quotient",
          "exact",
          "map_trans",
          "map_comp",
          "rintro",
          "continuous",
          "rfl",
          "map_id"
        ]
      }
    },
    {
      "id": 847,
      "before_code": "map_id _ := rfl\n  map_comp := by rintro _ _ _ \u27e8p\u27e9 \u27e8q\u27e9; exact congr_arg Quotient.mk'' (p.map_trans q f.continuous)",
      "suggestion": "@[simp]\nprotected theorem map_comp {Z : Type*} [TopologicalSpace Z] (g : C(Y, Z)) (f : C(X, Y)) :\n",
      "body": "```suggestion\n@[simp]\nprotected theorem map_comp {Z : Type*} [TopologicalSpace Z] (g : C(Y, Z)) (f : C(X, Y)) :\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "congr_arg",
          "Quotient",
          "exact",
          "map_trans",
          "map_comp",
          "rintro",
          "continuous",
          "rfl",
          "map_id"
        ]
      }
    },
    {
      "id": 848,
      "before_code": "## Main definitions\n\n  - `FundamentalGroupoidFunctor.homotopicMapsNatIso H` The natural isomorphism\n    between the induced functors `f : \u03c0(X) \u2964 \u03c0(Y)` and `g : \u03c0(X) \u2964 \u03c0(Y)`, given a homotopy\n    `H : f \u223c g`\n\n  - `FundamentalGroupoidFunctor.equivOfHomotopyEquiv hequiv` The equivalence of the categories\n    `\u03c0(X)` and `\u03c0(Y)` given a homotopy equivalence `hequiv : X \u2243\u2095 Y` between them.\n\n## Implementation notes\n  - In order to be more universe polymorphic, we define `ContinuousMap.Homotopy.uliftMap`\n  which lifts a homotopy from `I \u00d7 X \u2192 Y` to `(TopCat.of ((ULift I) \u00d7 X)) \u2192 Y`. This is because\n  this construction uses `FundamentalGroupoidFunctor.prodToProdTop` to convert between\n  pairs of paths in I and X and the corresponding path after passing through a homotopy `H`.\n  But `FundamentalGroupoidFunctor.prodToProdTop` requires two spaces in the same universe.\n-/\n\n@[expose] public section\n\n\nnoncomputable section\n\nuniverse u\n\nopen FundamentalGroupoid\n\nopen CategoryTheory",
      "suggestion": "  apply CategoryTheory.Equivalence.mk (map hequiv) (map hequiv.symm)\n",
      "body": "```suggestion\n  apply CategoryTheory.Equivalence.mk (map hequiv) (map hequiv.symm)\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "equiv",
          "list",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "FundamentalGroupoid",
          "natural",
          "homotopicMapsNatIso",
          "convert",
          "expose",
          "after",
          "which",
          "But",
          "isomorphism",
          "CategoryTheory",
          "Main",
          "open",
          "section",
          "paths",
          "equivOfHomotopyEquiv",
          "This",
          "noncomputable",
          "universe",
          "corresponding",
          "notes",
          "equivalence",
          "requires",
          "spaces",
          "more",
          "passing",
          "TopCat",
          "pairs",
          "two",
          "homotopy",
          "public",
          "path",
          "definitions",
          "ULift",
          "uses",
          "induced",
          "prodToProdTop",
          "FundamentalGroupoidFunctor",
          "between",
          "Homotopy",
          "given",
          "construction",
          "uliftMap",
          "categories",
          "functors",
          "them",
          "through",
          "Implementation",
          "same",
          "hequiv",
          "this"
        ]
      }
    },
    {
      "id": 853,
      "before_code": "rw [totient_mul _, totient_prime hp]\n  simpa [h] using coprime_or_dvd_of_prime hp n",
      "suggestion": "\r\n  simpa using totient_mul_of_prime_of_not_dvd prime_two hn.not_two_dvd_nat\r\n",
      "body": "Does\r\n```suggestion\r\n  simpa using totient_mul_of_prime_of_not_dvd prime_two hn.not_two_dvd_nat\r\n```\r\nwork here?",
      "path": "Mathlib/Data/Nat/Totient.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "simpa",
          "totient_mul",
          "totient_prime",
          "coprime_or_dvd_of_prime",
          "using"
        ]
      }
    },
    {
      "id": 858,
      "before_code": "ext\n    simp",
      "suggestion": "\r\n@[simp] theorem lcoeFun_apply (x : \u03b1) (m : M) (f : \u03b1 \u2192\u2080 M) : lcoeFun (R := R) f = \u21d1f :=\r\n  rfl\r\n",
      "body": "I think actually the `simps` above is to blame, and we should remove it and instead write\r\n```suggestion\r\n@[simp] theorem lcoeFun_apply (x : \u03b1) (m : M) (f : \u03b1 \u2192\u2080 M) : lcoeFun (R := R) f = \u21d1f :=\r\n  rfl\r\n```",
      "path": "Mathlib/LinearAlgebra/Finsupp/Pi.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 859,
      "before_code": "ext\n    simp",
      "suggestion": "\r\n@[simp] theorem lcoeFun_comp_lsingle [DecidableEq \u03b1] (x : \u03b1) :\r\n",
      "body": "```suggestion\r\n@[simp] theorem lcoeFun_comp_lsingle [DecidableEq \u03b1] (x : \u03b1) :\r\n```",
      "path": "Mathlib/LinearAlgebra/Finsupp/Pi.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 860,
      "before_code": "(entourageProd u v).IsSymm where\n  symm _ _ := .imp u.symm v.symm",
      "suggestion": "@[simp]\ntheorem image_entourageProd_prod (u : SetRel \u03b1 \u03b1) (v : SetRel \u03b2 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n",
      "body": "```suggestion\n@[simp]\ntheorem image_entourageProd_prod (u : SetRel \u03b1 \u03b1) (v : SetRel \u03b2 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n```",
      "path": "Mathlib/Topology/UniformSpace/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsSymm",
          "entourageProd",
          "symm",
          "imp"
        ]
      }
    },
    {
      "id": 861,
      "before_code": "(entourageProd u v).IsSymm where\n  symm _ _ := .imp u.symm v.symm",
      "suggestion": "@[simp]\ntheorem preimage_entourageProd_prod (u : SetRel \u03b1 \u03b1) (v : SetRel \u03b2 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n",
      "body": "```suggestion\n@[simp]\ntheorem preimage_entourageProd_prod (u : SetRel \u03b1 \u03b1) (v : SetRel \u03b2 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n```",
      "path": "Mathlib/Topology/UniformSpace/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsSymm",
          "entourageProd",
          "symm",
          "imp"
        ]
      }
    },
    {
      "id": 862,
      "before_code": "end LinearMap.transvection\n\nend baseChange",
      "suggestion": "@[simp] theorem det [Module.Free R V] [Module.Finite R V]\n",
      "body": "```suggestion\n@[simp] theorem det [Module.Free R V] [Module.Finite R V]\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "LinearMap",
          "end",
          "baseChange"
        ]
      }
    },
    {
      "id": 863,
      "before_code": "end LinearMap.transvection\n\nend baseChange",
      "suggestion": "@[simp] theorem _root_.LinearEquiv.det_eq_one\n",
      "body": "```suggestion\n@[simp] theorem _root_.LinearEquiv.det_eq_one\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "LinearMap",
          "end",
          "baseChange"
        ]
      }
    },
    {
      "id": 865,
      "before_code": "ext\n  simp",
      "suggestion": "@[simp]\ntheorem order_exp (A : Type*) [Ring A] [Algebra \u211a A] [Nontrivial A] : (exp A).order = 0 :=\n",
      "body": "```suggestion\n@[simp]\ntheorem order_exp (A : Type*) [Ring A] [Algebra \u211a A] [Nontrivial A] : (exp A).order = 0 :=\n```",
      "path": "Mathlib/RingTheory/PowerSeries/Exp.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "ring",
          "simp"
        ],
        "body_tactics": [
          "ring",
          "simp"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 871,
      "before_code": "have h\u2082 := cos_pi_div_three;\n    have h\u2082 := cos_zero] <;>\n  simp [injOn_cos h_bnd \u27e8by positivity, by linarith [pi_nonneg]\u27e9 (h\u2082 \u25b8 h)]",
      "suggestion": "  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n",
      "body": "```suggestion\n  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n```",
      "path": "Mathlib/NumberTheory/Niven.lean",
      "tags": {
        "before_tactics": [
          "positivity",
          "have",
          "simp",
          "linarith"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "grind",
          "have",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "grind",
          "have",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "grind",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "removed_tactics": [
          "positivity",
          "simp",
          "linarith"
        ],
        "topics": [],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "injOn_cos",
          "cos_pi_div_three",
          "positivity",
          "pi_nonneg",
          "have",
          "h_bnd",
          "simp",
          "linarith",
          "cos_zero"
        ]
      }
    },
    {
      "id": 875,
      "before_code": "have h\u2082 := cos_pi_div_three;\n    have h\u2082 := cos_zero] <;>\n  simp [injOn_cos h_bnd \u27e8by positivity, by linarith [pi_nonneg]\u27e9 (h\u2082 \u25b8 h)]",
      "suggestion": "theorem irrational_cos_rat_mul_pi {r : \u211a} (hr\u2081 : r.den \u2260 1) (hr\u2082 : r.den \u2260 2) (hr\u2083 : r.den \u2260 3) :\n",
      "body": "Now this lemma does not apply to `1/5`, right? Can't you do\n```suggestion\ntheorem irrational_cos_rat_mul_pi {r : \u211a} (hr\u2081 : r.den \u2260 1) (hr\u2082 : r.den \u2260 2) (hr\u2083 : r.den \u2260 3) :\n```\nAnd then in fact, all of these could be summarized as `3 < r.den`, I guess.",
      "path": "Mathlib/NumberTheory/Niven.lean",
      "tags": {
        "before_tactics": [
          "positivity",
          "have",
          "simp",
          "linarith"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "positivity",
          "have",
          "simp",
          "linarith"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "injOn_cos",
          "cos_pi_div_three",
          "positivity",
          "pi_nonneg",
          "have",
          "h_bnd",
          "simp",
          "linarith",
          "cos_zero"
        ]
      }
    },
    {
      "id": 880,
      "before_code": "modify (\u00b7.insert pendingMVarId)\n          go pendingMVarId\n\n/-- Modifier `recover` for a tactic (sequence) to debug cases where goals are closed incorrectly.\nThe tactic `recover tacs` for a tactic (sequence) `tacs` applies the tactics and then adds goals\nthat are not closed, starting from the original goal. -/",
      "suggestion": "\r\nsolving them (i.e. goals were removed from the MetaM state without the metavariable\r\nbeing assigned), resulting in the error \"(kernel) declaration has metavariables\". -/\r\n",
      "body": "```suggestion\r\nsolving them (i.e. goals were removed from the MetaM state without the metavariable\r\nbeing assigned), resulting in the error \"(kernel) declaration has metavariables\". -/\r\n```",
      "path": "Mathlib/Tactic/Recover.lean",
      "tags": {
        "before_tactics": [
          "cases"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Modifier",
          "pendingMVarId",
          "recover",
          "adds",
          "insert",
          "original",
          "cases",
          "applies",
          "are",
          "closed",
          "starting",
          "for",
          "goals",
          "then",
          "tacs",
          "sequence",
          "incorrectly",
          "that",
          "tactic",
          "modify",
          "goal",
          "tactics",
          "from",
          "debug"
        ]
      }
    },
    {
      "id": 882,
      "before_code": "modify (\u00b7.insert pendingMVarId)\n          go pendingMVarId\n\n/-- Modifier `recover` for a tactic (sequence) to debug cases where goals are closed incorrectly.\nThe tactic `recover tacs` for a tactic (sequence) `tacs` applies the tactics and then adds goals\nthat are not closed, starting from the original goal. -/",
      "suggestion": "\r\nincorrectly marked as closed. This helps to debug issues where a tactic closes goals without\r\n",
      "body": "It is slightly more complicated some metavariables could hypothetically be omitted from the `MetaM` context without being assigned at that point, because they are guaranteed to be solved when the main goal is solved). I can't think of a case where that intentionally happens though, it should be OK to lie slightly in this docstring.\r\n\r\n```suggestion\r\nincorrectly marked as closed. This helps to debug issues where a tactic closes goals without\r\n```",
      "path": "Mathlib/Tactic/Recover.lean",
      "tags": {
        "before_tactics": [
          "cases"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Modifier",
          "pendingMVarId",
          "recover",
          "adds",
          "insert",
          "original",
          "cases",
          "applies",
          "are",
          "closed",
          "starting",
          "for",
          "goals",
          "then",
          "tacs",
          "sequence",
          "incorrectly",
          "that",
          "tactic",
          "modify",
          "goal",
          "tactics",
          "from",
          "debug"
        ]
      }
    },
    {
      "id": 890,
      "before_code": "open Parser\n\n/--\n`tfae_have` introduces hypotheses for proving goals of the form `TFAE [P\u2081, P\u2082, ...]`. Specifically,\n`tfae_have i <arrow> j := ...` introduces a hypothesis of type `P\u1d62 <arrow> P\u2c7c` to the local\ncontext, where `<arrow>` can be `\u2192`, `\u2190`, or `\u2194`. Note that `i` and `j` are natural number indices\n(beginning at 1) used to specify the propositions `P\u2081, P\u2082, ...` that appear in the goal.",
      "suggestion": "\r\n`tfae_have i \u2192 j := t`, where the goal is `TFAE [P\u2081, P\u2082, ...]` introduces a hypothesis\r\n`tfae_i_to_j : P\u1d62 \u2192 P\u2c7c` and proof `t` to the local context. Note that `i` and `j` are\r\nnatural number literals (beginning at 1) used as indices to specify the propositions\r\n`P\u2081, P\u2082, ...` that appear in the goal.\r\n",
      "body": "```suggestion\r\n`tfae_have i \u2192 j := t`, where the goal is `TFAE [P\u2081, P\u2082, ...]` introduces a hypothesis\r\n`tfae_i_to_j : P\u1d62 \u2192 P\u2c7c` and proof `t` to the local context. Note that `i` and `j` are\r\nnatural number literals (beginning at 1) used as indices to specify the propositions\r\n`P\u2081, P\u2082, ...` that appear in the goal.\r\n```",
      "path": "Mathlib/Tactic/TFAE.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "natural",
          "proving",
          "arrow",
          "type",
          "open",
          "local",
          "form",
          "Note",
          "indices",
          "are",
          "context",
          "hypothesis",
          "for",
          "goals",
          "can",
          "TFAE",
          "beginning",
          "used",
          "number",
          "that",
          "appear",
          "hypotheses",
          "introduces",
          "Specifically",
          "propositions",
          "goal",
          "specify",
          "Parser",
          "tfae_have"
        ]
      }
    },
    {
      "id": 891,
      "before_code": "open Parser\n\n/--\n`tfae_have` introduces hypotheses for proving goals of the form `TFAE [P\u2081, P\u2082, ...]`. Specifically,\n`tfae_have i <arrow> j := ...` introduces a hypothesis of type `P\u1d62 <arrow> P\u2c7c` to the local\ncontext, where `<arrow>` can be `\u2192`, `\u2190`, or `\u2194`. Note that `i` and `j` are natural number indices\n(beginning at 1) used to specify the propositions `P\u2081, P\u2082, ...` that appear in the goal.",
      "suggestion": "\r\n* `tfae_have hij : i \u2192 j := t` names the introduced hypothesis `hij` instead of `tfae_i_to_j`.\r\n",
      "body": "```suggestion\r\n* `tfae_have hij : i \u2192 j := t` names the introduced hypothesis `hij` instead of `tfae_i_to_j`.\r\n```",
      "path": "Mathlib/Tactic/TFAE.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "natural",
          "proving",
          "arrow",
          "type",
          "open",
          "local",
          "form",
          "Note",
          "indices",
          "are",
          "context",
          "hypothesis",
          "for",
          "goals",
          "can",
          "TFAE",
          "beginning",
          "used",
          "number",
          "that",
          "appear",
          "hypotheses",
          "introduces",
          "Specifically",
          "propositions",
          "goal",
          "specify",
          "Parser",
          "tfae_have"
        ]
      }
    },
    {
      "id": 892,
      "before_code": "obtain \u27e8b', hb', d_ab\u27e9 := exists_lt_mul_right_of_nonneg ha'.1 hd d_ab\n  exact d_ab.le.trans (h a' ha'.1 ha'.2 b' hb'.1 hb'.2)\n\ntheorem mul_self_inj_of_nonneg (a0 : 0 \u2264 a) (b0 : 0 \u2264 b) : a * a = b * b \u2194 a = b :=\n  mul_self_eq_mul_self_iff.trans <|\n    or_iff_left_of_imp fun h => by grind",
      "suggestion": "\r\n  have := fun h \u21a6 le_antisymm (neg_nonneg.mp h) b0\r\n  grind [sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg]\r\n",
      "body": "this is the same proof, but just using grind:\r\n```suggestion\r\n  have := fun h \u21a6 le_antisymm (neg_nonneg.mp h) b0\r\n  grind [sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg]\r\n```\r\nnot sure what file this could go to though\r\n\r\nalso, we have this [sq_eq_sq\u2080](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#sq_eq_sq%E2%82%80) which is essentially the same (but uses `LinearOrder`)",
      "path": "Mathlib/Algebra/Order/Field/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "grind",
          "obtain"
        ],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mul_self_eq_mul_self_iff",
          "theorem",
          "exact",
          "mul_self_inj_of_nonneg",
          "grind",
          "d_ab",
          "obtain",
          "trans",
          "exists_lt_mul_right_of_nonneg",
          "or_iff_left_of_imp"
        ]
      }
    },
    {
      "id": 901,
      "before_code": "bot := \u27e8\u22a5, by simp\u27e9\n  bot_le _ _ := by simp +contextual",
      "suggestion": "\r\n@[simps]\r\ndef subrepresentationSubmoduleOrderIso : Subrepresentation \u03c1 \u2243o Submodule A[G] \u03c1.asModule where\r\n",
      "body": "```suggestion\r\n@[simps]\r\ndef subrepresentationSubmoduleOrderIso : Subrepresentation \u03c1 \u2243o Submodule A[G] \u03c1.asModule where\r\n```",
      "path": "Mathlib/RepresentationTheory/Subrepresentation.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "contextual",
          "bot_le",
          "simp",
          "bot"
        ]
      }
    },
    {
      "id": 902,
      "before_code": "bot := \u27e8\u22a5, by simp\u27e9\n  bot_le _ _ := by simp +contextual",
      "suggestion": "\r\nsubrepresentations of `\u03c1`. -/\r\n@[simps]\r\ndef submoduleSubrepresentationOrderIso : Submodule A[G] M \u2243o\r\n",
      "body": "```suggestion\r\nsubrepresentations of `\u03c1`. -/\r\n@[simps]\r\ndef submoduleSubrepresentationOrderIso : Submodule A[G] M \u2243o\r\n```",
      "path": "Mathlib/RepresentationTheory/Subrepresentation.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "contextual",
          "bot_le",
          "simp",
          "bot"
        ]
      }
    },
    {
      "id": 907,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  simp [Lagrange.basis, basisDivisor, div_eq_mul_inv, prod_mul_distrib, \u2190 map_prod,\n    \u2190 prod_inv_distrib, mul_assoc]\n",
      "body": "```suggestion\n  simp [Lagrange.basis, basisDivisor, div_eq_mul_inv, prod_mul_distrib, \u2190 map_prod,\n    \u2190 prod_inv_distrib, mul_assoc]\n```\nThis can be done in one `simp`.",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 908,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "theorem iterate_derivative_interpolate (hvs : Set.InjOn v s) {k : \u2115} (hk : k < #s) :\n    derivative^[k] (interpolate s v r) =\n      k.factorial * \u2211 i \u2208 s, C (r i / \u220f j \u2208 s.erase i, (v i - v j)) *\n        \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n",
      "body": "```suggestion\ntheorem iterate_derivative_interpolate (hvs : Set.InjOn v s) {k : \u2115} (hk : k < #s) :\n    derivative^[k] (interpolate s v r) =\n      k.factorial * \u2211 i \u2208 s, C (r i / \u220f j \u2208 s.erase i, (v i - v j)) *\n        \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n```\nI think this makes the statement easier to read.",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 909,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  simp_rw [interpolate_eq_sum, iterate_derivative_sum, iterate_derivative_C_mul, mul_sum s,\n    \u2190 mul_assoc, mul_comm (k.factorial : F[X]), mul_assoc]\n",
      "body": "```suggestion\n  simp_rw [interpolate_eq_sum, iterate_derivative_sum, iterate_derivative_C_mul, mul_sum s,\n    \u2190 mul_assoc, mul_comm (k.factorial : F[X]), mul_assoc]\n```\nThe arguments are the first explicit arguments, so the expressions can be simplified.",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 910,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_injOn hvs').mono (by grind)\n        case i_surj => grind [card_image_of_injOn, hvs'.mono]\n        case h =>\n          rw [eq_comm]\n          exact prod_image <| by grind [hvs'.mono]\n",
      "body": "```suggestion\n          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_in",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "rw",
          "intro",
          "omega"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_omega",
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 911,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  rw [iterate_derivative_interpolate _ hvs hk]\n  simp [eval_finset_sum, eval_prod]\n",
      "body": "```suggestion\n  rw [iterate_derivative_interpolate _ hvs hk]\n  simp [eval_finset_sum, eval_prod]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 912,
      "before_code": "namespace Matrix",
      "suggestion": "\r\n@[simp] lemma permMatrix_refl [Zero R] [One R] : Equiv.Perm.permMatrix R (.refl n) = 1 := by\r\n  simp [\u2190 Matrix.ext_iff, Matrix.one_apply]\r\n\r\n@[simp]\r\nlemma permMatrix_one [Zero R] [One R] : (1 : Equiv.Perm n).permMatrix R = 1 :=\r\n  permMatrix_refl\r\n",
      "body": "how about also adding the `Equiv.refl` part?\r\n\r\n```suggestion\r\n@[simp] lemma permMatrix_refl [Zero R] [One R] : Equiv.Perm.permMatrix R (.refl n) = 1 := by\r\n  simp [\u2190 Matrix.ext_iff, Matrix.one_apply]\r\n\r\n@[simp]\r\nlemma permMatrix_one [Zero R] [One R] : (1 : Equiv.Perm n).permMatrix R = 1 :=\r\n  permMatrix_refl\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/Permutation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Matrix",
          "namespace"
        ]
      }
    },
    {
      "id": 913,
      "before_code": "minTensorProduct C\u2081 C\u2082 \u2264 maxTensorProduct C\u2081 C\u2082 := by\n  exact Submodule.span_le.mpr (tmul_subset_maxTensorProduct C\u2081 C\u2082)",
      "suggestion": "    TensorProduct.lid R H (\u03c6.rTensor H z) \u2208\n      dual (dualPairing R H) (dual (dualPairing R H).flip C\u2082) := by\n",
      "body": "```suggestion\n    TensorProduct.lid R H (\u03c6.rTensor H z) \u2208\n      dual (dualPairing R H) (dual (dualPairing R H).flip C\u2082) := by\n```\nrewrap for clarity",
      "path": "Mathlib/Geometry/Convex/Cone/TensorProduct.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "tmul_subset_maxTensorProduct",
          "mpr",
          "exact",
          "maxTensorProduct",
          "Submodule",
          "minTensorProduct",
          "span_le"
        ]
      }
    },
    {
      "id": 914,
      "before_code": "minTensorProduct C\u2081 C\u2082 \u2264 maxTensorProduct C\u2081 C\u2082 := by\n  exact Submodule.span_le.mpr (tmul_subset_maxTensorProduct C\u2081 C\u2082)",
      "suggestion": "  refine \u27e8?_, fun hz \u21a6\n    \u27e8(TensorProduct.comm R H G) z, ?_, (TensorProduct.comm R H G).symm_apply_apply z\u27e9\u27e9\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9 \u03c8 h\u03c8 \u03c6 h\u03c6\n    simpa [dualDistrib_apply_comm] using hw \u03c6 h\u03c6 \u03c8 h\u03c8\n  \u00b7 intro \u03c6 h\u03c6 \u03c8 h\u03c8\n    simpa [dualDistrib_apply_comm] using hz \u03c8 h\u03c8 \u03c6 h\u03c6\n",
      "body": "```suggestion\n  refine \u27e8?_, fun hz \u21a6\n    \u27e8(TensorProduct.comm R H G) z, ?_, (TensorProduct.comm R H G).symm_apply_apply z\u27e9\u27e9\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9 \u03c8 h\u03c8 \u03c6 h\u03c6\n    simpa [dualDistrib_apply_comm] using hw \u03c6 h\u03c6 \u03c8 h\u03c8\n  \u00b7 intro \u03c6 h\u03c6 \u03c8 h\u03c8\n    simpa [dualDistrib_apply_comm] using hz \u03c8 h\u03c8 \u03c6 h\u03c6\n```\ngolf; unsqueeze terminal simps",
      "path": "Mathlib/Geometry/Convex/Cone/TensorProduct.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "tmul_subset_maxTensorProduct",
          "mpr",
          "exact",
          "maxTensorProduct",
          "Submodule",
          "minTensorProduct",
          "span_le"
        ]
      }
    },
    {
      "id": 915,
      "before_code": "minTensorProduct C\u2081 C\u2082 \u2264 maxTensorProduct C\u2081 C\u2082 := by\n  exact Submodule.span_le.mpr (tmul_subset_maxTensorProduct C\u2081 C\u2082)",
      "suggestion": "  simp [minTensorProduct, map, span, Submodule.map_span, Set.image_image2,\n    Set.image2_swap (\u00b7 \u2297\u209c[R] \u00b7 : H \u2192 G \u2192 _)]\n",
      "body": "```suggestion\n  simp [minTensorProduct, map, span, Submodule.map_span, Set.image_image2,\n    Set.image2_swap (\u00b7 \u2297\u209c[R] \u00b7 : H \u2192 G \u2192 _)]\n```\nunsqueeze terminal simp",
      "path": "Mathlib/Geometry/Convex/Cone/TensorProduct.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "tmul_subset_maxTensorProduct",
          "mpr",
          "exact",
          "maxTensorProduct",
          "Submodule",
          "minTensorProduct",
          "span_le"
        ]
      }
    },
    {
      "id": 928,
      "before_code": "lemma not_monotone_not_antitone_iff_exists_le_le :\n    \u00ac Monotone f \u2227 \u00ac Antitone f \u2194\n      \u2203 a b c, a \u2264 b \u2227 b \u2264 c \u2227 ((f a < f b \u2227 f c < f b) \u2228 (f b < f a \u2227 f b < f c)) := by\n  simp_rw [Monotone, Antitone, not_forall, not_le]\n  refine Iff.symm \u27e8?_, ?_\u27e9\n  \u00b7 rintro \u27e8a, b, c, hab, hbc, \u27e8hfab, hfcb\u27e9 | \u27e8hfba, hfbc\u27e9\u27e9\n    exacts [\u27e8\u27e8_, _, hbc, hfcb\u27e9, _, _, hab, hfab\u27e9, \u27e8\u27e8_, _, hab, hfba\u27e9, _, _, hbc, hfbc\u27e9]\n  rintro \u27e8\u27e8a, b, hab, hfba\u27e9, c, d, hcd, hfcd\u27e9\n  obtain hda | had := le_total d a\n  \u00b7 obtain hfad | hfda := le_total (f a) (f d)\n    \u00b7 exact \u27e8c, d, b, hcd, hda.trans hab, Or.inl \u27e8hfcd, hfba.trans_le hfad\u27e9\u27e9\n    \u00b7 exact \u27e8c, a, b, hcd.trans hda, hab, Or.inl \u27e8hfcd.trans_le hfda, hfba\u27e9\u27e9\n  obtain hac | hca := le_total a c\n  \u00b7 obtain hfdb | hfbd := le_or_gt (f d) (f b)\n    \u00b7 exact \u27e8a, c, d, hac, hcd, Or.inr \u27e8hfcd.trans <| hfdb.trans_lt hfba, hfcd\u27e9\u27e9\n    obtain hfca | hfac := lt_or_ge (f c) (f a)\n    \u00b7 exact \u27e8a, c, d, hac, hcd, Or.inr \u27e8hfca, hfcd\u27e9\u27e9\n    obtain hbd | hdb := le_total b d\n    \u00b7 exact \u27e8a, b, d, hab, hbd, Or.inr \u27e8hfba, hfbd\u27e9\u27e9\n    \u00b7 exact \u27e8a, d, b, had, hdb, Or.inl \u27e8hfac.trans_lt hfcd, hfbd\u27e9\u27e9\n  \u00b7 obtain hfdb | hfbd := le_or_gt (f d) (f b)\n    \u00b7 exact \u27e8c, a, b, hca, hab, Or.inl \u27e8hfcd.trans <| hfdb.trans_lt hfba, hfba\u27e9\u27e9\n    obtain hfca | hfac := lt_or_ge (f c) (f a)\n    \u00b7 exact \u27e8c, a, b, hca, hab, Or.inl \u27e8hfca, hfba\u27e9\u27e9\n    obtain hbd | hdb := le_total b d\n    \u00b7 exact \u27e8a, b, d, hab, hbd, Or.inr \u27e8hfba, hfbd\u27e9\u27e9\n    \u00b7 exact \u27e8a, d, b, had, hdb, Or.inl \u27e8hfac.trans_lt hfcd, hfbd\u27e9\u27e9",
      "suggestion": "  simp only [Monotone, Antitone]\n  grind [not_le]\n",
      "body": "Let's make it clear that `grind` only needs to know about `not_le`, especially as the pattern `grind [foo, bar, baz]` can be a bit brittle to changes in `grind`\n```suggestion\n  simp only [Monotone, Antitone]\n  grind [not_le]\n```",
      "path": "Mathlib/Order/Monotone/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "suggestion_tactics": [
          "grind",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "lemma",
          "hca",
          "rintro",
          "Iff",
          "hfcb",
          "obtain",
          "hfac",
          "lt_or_ge",
          "inl",
          "hfba",
          "exacts",
          "symm",
          "refine",
          "not_le",
          "hfca",
          "hfbd",
          "Antitone",
          "simp_rw",
          "trans_le",
          "hfab",
          "hda",
          "hab",
          "hcd",
          "had",
          "not_monotone_not_antitone_iff_exists_le_le",
          "hbc",
          "hfbc",
          "hfdb",
          "hac",
          "le_total",
          "hfad",
          "exact",
          "Monotone",
          "hfcd",
          "le_or_gt",
          "not_forall",
          "trans",
          "hbd",
          "hdb",
          "trans_lt",
          "hfda",
          "inr"
        ]
      }
    },
    {
      "id": 929,
      "before_code": "(isPullback_inl_inl_coprodMap g f).of_iso (.refl _) (.refl _) (coprod.braiding _ _)\n    (coprod.braiding _ _) (by simp) (by simp) (by simp) (by simp)",
      "suggestion": "      simp [isCompl_iff, disjoint_iff, codisjoint_iff, \u2190 TopologicalSpace.Opens.coe_inj]\n",
      "body": "```suggestion\n      simp [isCompl_iff, disjoint_iff, codisjoint_iff, \u2190 TopologicalSpace.Opens.coe_inj]\n```",
      "path": "Mathlib/AlgebraicGeometry/Limits.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isPullback_inl_inl_coprodMap",
          "of_iso",
          "braiding",
          "refl",
          "simp",
          "coprod"
        ]
      }
    },
    {
      "id": 930,
      "before_code": "simp_rw [measurable_iff_comap_le, MeasurableSpace.pi, MeasurableSpace.comap_iSup,\n    MeasurableSpace.comap_comp, Function.comp_def, iSup_le_iff]",
      "suggestion": "theorem MeasurableSpace.comap_le_comap_pi {g : (a : \u03b4) \u2192 \u03b2 \u2192 X a} (a : \u03b4) :\n    .comap (g a) inferInstance \u2264 pi.comap (fun b c \u21a6 g c b) := by\n  simpa only [pi, comap_iSup] using le_iSup_of_le a <| by measurability\n",
      "body": "```suggestion\ntheorem MeasurableSpace.comap_le_comap_pi {g : (a : \u03b4) \u2192 \u03b2 \u2192 X a} (a : \u03b4) :\n    .comap (g a) inferInstance \u2264 pi.comap (fun b c \u21a6 g c b) := by\n  simpa only [pi, comap_iSup] using le_iSup_of_le a <| by measurability\n```",
      "path": "Mathlib/MeasureTheory/MeasurableSpace/Constructions.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "measurability"
        ],
        "body_tactics": [
          "simpa",
          "measurability"
        ],
        "new_tactics": [
          "simpa",
          "measurability"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "order",
          "function"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "comp_def",
          "iSup_le_iff",
          "comap_iSup",
          "comap_comp",
          "simp_rw",
          "MeasurableSpace",
          "Function",
          "measurable_iff_comap_le"
        ]
      }
    },
    {
      "id": 934,
      "before_code": "intros\n    ext\n    simp [fromModuleCatToModuleCatLinearEquivtoModuleCatObj]",
      "suggestion": "\r\n    IsMoritaEquivalent R\u2080 R (Matrix \u03b9 \u03b9 R) := \u27e8h.map <| moritaEquivMatrix R R\u2080\u27e9\u27e9\r\n",
      "body": "nit: \r\n```suggestion\r\n    IsMoritaEquivalent R\u2080 R (Matrix \u03b9 \u03b9 R) := \u27e8h.map <| moritaEquivMatrix R R\u2080\u27e9\u27e9\r\n```\r\nor perhaps\r\n```suggestion\r\n    IsMoritaEquivalent R\u2080 R (Matrix \u03b9 \u03b9 R) := \u27e8Nonempty.map <| moritaEquivMatrix R R\u2080\u27e9\r\n```\r\nwhich means you don't need to name `h`.",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "fromModuleCatToModuleCatLinearEquivtoModuleCatObj",
          "intros",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 935,
      "before_code": "intros\n    ext\n    simp [fromModuleCatToModuleCatLinearEquivtoModuleCatObj]",
      "suggestion": "\r\n  toFun m i := \u27e8single j i (1 : R) \u2022 m, single j i (1 : R) \u2022 m, by\r\n",
      "body": "Does this work as the shorter\r\n```suggestion\r\n  toFun m i := \u27e8single j i (1 : R) \u2022 m, single j i (1 : R) \u2022 m, by\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "fromModuleCatToModuleCatLinearEquivtoModuleCatObj",
          "intros",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 936,
      "before_code": "intros\n    ext\n    simp [fromModuleCatToModuleCatLinearEquivtoModuleCatObj]",
      "suggestion": "\r\ndef moritaEquivalenceMatrix (R\u2080 : Type*) [CommRing R\u2080] [Algebra R\u2080 R] (i : \u03b9) :\r\n",
      "body": "```suggestion\r\ndef moritaEquivalenceMatrix (R\u2080 : Type*) [CommRing R\u2080] [Algebra R\u2080 R] (i : \u03b9) :\r\n```\r\nsince you decided to call the type `MoritaEquivalence`.",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "fromModuleCatToModuleCatLinearEquivtoModuleCatObj",
          "intros",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 947,
      "before_code": "/-!\n# Subrepresentations\n\nThis file defines subrepresentations of a group representation.\n\n-/\n\n@[expose] public section\n\nopen Pointwise\n\nuniverse u\n\nvariable {A : Type*} [CommRing A]\n\nvariable {G : Type*} [Group G]\n\nvariable {W : Type*} [AddCommMonoid W] [Module A W]\n\nvariable {\u03c1 : Representation A G W}",
      "suggestion": "variable {A G W : Type*} [CommRing A] [Monoid G] [AddCommMonoid W] [Module A W]\n  {\u03c1 : Representation A G W}\n",
      "body": "It looks like `M` is unused:\n```suggestion\nvariable {A G W : Type*} [CommRing A] [Monoid G] [AddCommMonoid W] [Module A W]\n  {\u03c1 : Representation A G W}\n```",
      "path": "Mathlib/RepresentationTheory/Subrepresentation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "file",
          "Module",
          "expose",
          "Type",
          "representation",
          "open",
          "Representation",
          "section",
          "This",
          "universe",
          "Group",
          "subrepresentations",
          "CommRing",
          "variable",
          "public",
          "Pointwise",
          "group",
          "defines",
          "Subrepresentations",
          "AddCommMonoid"
        ]
      }
    },
    {
      "id": 958,
      "before_code": "obtain \u27e8s, hs, rfl\u27e9 := Polynomial.isUnit_iff.mp H\n  simp [hq, Polynomial.natDegree_C_mul hr] at hp'",
      "suggestion": "/-- In a field, the notion of primitive polynomials is degenerate. -/\n@[simp]\ntheorem isPrimitive_iff_ne_zero {F : Type*} [Field F] (p : F[X]) : p.IsPrimitive \u2194 p \u2260 0 :=\n",
      "body": "Maybe:\n```suggestion\n/-- In a field, the notion of primitive polynomials is degenerate. -/\n@[simp]\ntheorem isPrimitive_iff_ne_zero {F : Type*} [Field F] (p : F[X]) : p.IsPrimitive \u2194 p \u2260 0 :=\n```",
      "path": "Mathlib/RingTheory/Polynomial/Content.lean",
      "tags": {
        "before_tactics": [
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isUnit_iff",
          "natDegree_C_mul",
          "obtain",
          "simp",
          "rfl",
          "Polynomial"
        ]
      }
    },
    {
      "id": 962,
      "before_code": "`Over.forget X` is equivalent to the existence of each binary product `X \u2a2f -`. -/\ninstance : (forget X).IsLeftAdjoint := \u27e8_, \u27e8forgetAdjStar X\u27e9\u27e9",
      "suggestion": "\r\n@[simps!]\r\nnoncomputable def starPullbackIsoStar [HasPullbacks C] {X Y : C} (f : X \u27f6 Y) :\r\n",
      "body": "```suggestion\r\n@[simps!]\r\nnoncomputable def starPullbackIsoStar [HasPullbacks C] {X Y : C} (f : X \u27f6 Y) :\r\n```\r\nThe lemmas look reasonable to me, can you also check them?",
      "path": "Mathlib/CategoryTheory/Comma/Over/Pullback.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "binary",
          "IsLeftAdjoint",
          "product",
          "existence",
          "Over",
          "forgetAdjStar",
          "forget",
          "each",
          "equivalent",
          "instance"
        ]
      }
    },
    {
      "id": 965,
      "before_code": "end QuasiFinite",
      "suggestion": "  have : IsLocalizedModule (.powers r) (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8fun x \u21a6 IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n      \u27e8x, hrp' x.2\u27e9, fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simp [Submonoid.mem_powers_iff]\u27e9\n",
      "body": "```suggestion\n  have : IsLocalizedModule (.powers r) (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8fun x \u21a6 IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n      \u27e8x, hrp' x.2\u27e9, fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simp [Submonoid.mem_powers_iff]\u27e9\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 967,
      "before_code": "end QuasiFinite",
      "suggestion": "  have : IsLocalizedModule p.primeCompl (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p)),\n      fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simpa using \u27e81, p.primeCompl.one_mem\u27e9\u27e9\n",
      "body": "```suggestion\n  have : IsLocalizedModule p.primeCompl (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p)),\n      fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simpa using \u27e81, p.primeCompl.one_mem\u27e9\u27e9\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 968,
      "before_code": "end QuasiFinite",
      "suggestion": "  obtain \u27e8r, hrp, H\u27e9 := exists_bijective_map_powers p.primeCompl\n      (Algebra.linearMap S (Localization.AtPrime p)) (.id (R := S) (M := Localization.AtPrime p))\n      (Algebra.linearMap S (Localization.AtPrime p)) <| by\n    convert show Function.Bijective LinearMap.id from Function.bijective_id\n    apply IsLocalizedModule.ext p.primeCompl (Algebra.linearMap S (Localization.AtPrime p))\n    \u00b7 exact IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n    \u00b7 simp [IsLocalizedModule.map_comp]\n",
      "body": "```suggestion\n  obtain \u27e8r, hrp, H\u27e9 := exists_bijective_map_powers p.primeCompl\n      (Algebra.linearMap S (Localization.AtPrime p)) (.id (R := S) (M := Localization.AtPrime p))\n      (Algebra.linearMap S (Localization.AtPrime p)) <| by\n    convert show Function.Bijective LinearMap.id from Function.bijective_id\n    apply IsLocalizedModule.ext p.primeCompl (Algebra.linearMap S (Localization.AtPrime p))\n    \u00b7 exact IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n    \u00b7 sim",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "ext",
          "exact",
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "ext",
          "exact",
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "simp",
          "ext",
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 970,
      "before_code": "end QuasiFinite",
      "suggestion": "  -- As S\u209a is an artinian local ring, its prime spectrum is a singleton.\n  obtain rfl : q = IsLocalRing.closedPoint _ := Subsingleton.elim _ _\n",
      "body": "```suggestion\n  -- As S\u209a is an artinian local ring, its prime spectrum is a singleton.\n  obtain rfl : q = IsLocalRing.closedPoint _ := Subsingleton.elim _ _\n```\nI was quite confused for a bit what was going on here.",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "ring"
        ],
        "body_tactics": [
          "obtain",
          "ring"
        ],
        "new_tactics": [
          "obtain",
          "ring"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 971,
      "before_code": "end QuasiFinite",
      "suggestion": "    congr($(e.symm_apply_apply \u27e8\u27e8q, \u2039_\u203a\u27e9, PrimeSpectrum.ext (q.over_def p).symm\u27e9).1.1).symm\n",
      "body": "```suggestion\n    congr($(e.symm_apply_apply \u27e8\u27e8q, \u2039_\u203a\u27e9, PrimeSpectrum.ext (q.over_def p).symm\u27e9).1.1).symm\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr",
          "ext"
        ],
        "body_tactics": [
          "congr",
          "ext"
        ],
        "new_tactics": [
          "congr",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 972,
      "before_code": "end QuasiFinite\n\nend Algebra",
      "suggestion": "  algebraize [f.toRingHom]\n",
      "body": "```suggestion\n  algebraize [f.toRingHom]\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Algebra",
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 973,
      "before_code": "end QuasiFinite\n\nend Algebra",
      "suggestion": "  algebraize [f.toRingHom]\n",
      "body": "```suggestion\n  algebraize [f.toRingHom]\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Algebra",
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 974,
      "before_code": "end QuasiFinite\n\nend Algebra",
      "suggestion": "lemma not_ker_le_map_C_of_surjective_of_quasiFiniteAt\n    (f : R[X] \u2192\u2090[R] S) (hf : Function.Surjective f)\n    (P : Ideal S) [P.IsPrime] [Algebra.QuasiFiniteAt R P] : \u00ac RingHom.ker f \u2264 (P.under R).map C := by\n",
      "body": "Why not?\n```suggestion\nlemma not_ker_le_map_C_of_surjective_of_quasiFiniteAt\n    (f : R[X] \u2192\u2090[R] S) (hf : Function.Surjective f)\n    (P : Ideal S) [P.IsPrime] [Algebra.QuasiFiniteAt R P] : \u00ac RingHom.ker f \u2264 (P.under R).map C := by\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Algebra",
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 978,
      "before_code": "map_smul' := g.hom.map_smul }\n  map_add' _ _ := rfl",
      "suggestion": "\r\n/-- Restrictions of scalars along equal ring homomorphisms are naturally isomorphic. -/\r\n",
      "body": "```suggestion\r\n/-- Restrictions of scalars along equal ring homomorphisms are naturally isomorphic. -/\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/ChangeOfRings.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "rfl",
          "hom",
          "map_smul",
          "map_add"
        ]
      }
    },
    {
      "id": 979,
      "before_code": "map_smul' := g.hom.map_smul }\n  map_add' _ _ := rfl",
      "suggestion": "\r\n\r\n@[simp]\r\nlemma restrictScalarsCongr_inv_app\r\n    {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] {f g : R \u2192+* S} (e : f = g)\r\n    (M : ModuleCat S) (x : M) :\r\n  (restrictScalarsCongr e).inv.app M x = x := rfl\r\n\r\n",
      "body": "```suggestion\r\n\r\n@[simp]\r\nlemma restrictScalarsCongr_inv_app\r\n    {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] {f g : R \u2192+* S} (e : f = g)\r\n    (M : ModuleCat S) (x : M) :\r\n  (restrictScalarsCongr e).inv.app M x = x := rfl\r\n\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/ChangeOfRings.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ring",
          "simp"
        ],
        "body_tactics": [
          "ring",
          "simp"
        ],
        "new_tactics": [
          "ring",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "rfl",
          "hom",
          "map_smul",
          "map_add"
        ]
      }
    },
    {
      "id": 980,
      "before_code": "pushforward.{v} (S := R) (F := \ud835\udfed _) (\ud835\udfd9 R) \u2245 \ud835\udfed _ :=\n  Iso.refl _",
      "suggestion": "\r\n/-- Pushforwards along equal morphisms of sheaves of rings are isomorphic. -/\r\n",
      "body": "```suggestion\r\n/-- Pushforwards along equal morphisms of sheaves of rings are isomorphic. -/\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/PushforwardContinuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Iso",
          "refl",
          "pushforward"
        ]
      }
    },
    {
      "id": 981,
      "before_code": "pushforward.{v} (S := R) (F := \ud835\udfed _) (\ud835\udfd9 R) \u2245 \ud835\udfed _ :=\n  Iso.refl _",
      "suggestion": "\r\n\r\n@[simp] lemma pushforwardCongr_inv_app_val_app\r\n    {\u03c6 \u03c8 : S \u27f6 (F.sheafPushforwardContinuous RingCat.{u} J K).obj R} (e : \u03c6 = \u03c8) (M U x) :\r\n  ((pushforwardCongr e).inv.app M).val.app U x = x := rfl\r\n\r\n",
      "body": "```suggestion\r\n\r\n@[simp] lemma pushforwardCongr_inv_app_val_app\r\n    {\u03c6 \u03c8 : S \u27f6 (F.sheafPushforwardContinuous RingCat.{u} J K).obj R} (e : \u03c6 = \u03c8) (M U x) :\r\n  ((pushforwardCongr e).inv.app M).val.app U x = x := rfl\r\n\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/PushforwardContinuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Iso",
          "refl",
          "pushforward"
        ]
      }
    },
    {
      "id": 982,
      "before_code": "end",
      "suggestion": "\r\n@[simps]\r\n",
      "body": "```suggestion\r\n@[simps]\r\n```\r\nThese are already the only projections added.",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/PushforwardContinuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 983,
      "before_code": "instance : Abelian X.Modules :=\n  inferInstanceAs (Abelian (SheafOfModules.{u} X.ringCatSheaf))",
      "suggestion": "\r\ninstance : HasLimits X.Modules :=\r\n  inferInstanceAs (HasLimits (SheafOfModules X.ringCatSheaf))\r\n\r\ninstance : HasColimits X.Modules :=\r\n  inferInstanceAs (HasColimits (SheafOfModules X.ringCatSheaf)))\r\n",
      "body": "```suggestion\r\ninstance : HasLimits X.Modules :=\r\n  inferInstanceAs (HasLimits (SheafOfModules X.ringCatSheaf))\r\n\r\ninstance : HasColimits X.Modules :=\r\n  inferInstanceAs (HasColimits (SheafOfModules X.ringCatSheaf)))\r\n```\r\nvery much optionnal, but might as well mimic the pattern from the lines just above.",
      "path": "Mathlib/AlgebraicGeometry/Modules/Sheaf.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Abelian",
          "Modules",
          "inferInstanceAs",
          "SheafOfModules",
          "ringCatSheaf",
          "instance"
        ]
      }
    },
    {
      "id": 984,
      "before_code": "instance : Abelian X.Modules :=\n  inferInstanceAs (Abelian (SheafOfModules.{u} X.ringCatSheaf))",
      "suggestion": "\r\n@[simps!]\r\ndef toPresheafOfModules : X.Modules \u2964 X.PresheafOfModules := SheafOfModules.forget _\r\n",
      "body": "```suggestion\r\n@[simps!]\r\ndef toPresheafOfModules : X.Modules \u2964 X.PresheafOfModules := SheafOfModules.forget _\r\n```\r\nor is this intentional that there are no characterizing lemmas for this def? (aside from the fact that it is fully faithful)",
      "path": "Mathlib/AlgebraicGeometry/Modules/Sheaf.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Abelian",
          "Modules",
          "inferInstanceAs",
          "SheafOfModules",
          "ringCatSheaf",
          "instance"
        ]
      }
    },
    {
      "id": 985,
      "before_code": "instance : Abelian X.Modules :=\n  inferInstanceAs (Abelian (SheafOfModules.{u} X.ringCatSheaf))",
      "suggestion": "\r\n\r\n@[simp] lemma Hom.comp_app {K : X.Modules} (\u03c6 : M \u27f6 N) (\u03c8 : N \u27f6 K) :\r\n    (\u03c6 \u226b \u03c8).app U = \u03c6.app U \u226b \u03c8.app U := rfl\r\n\r\n@[simp] lemma Hom.id_app (M : X.Modules) : (\ud835\udfd9 M : _ \u27f6 _).app U = \ud835\udfd9 _ := rfl\r\n\r\n",
      "body": "```suggestion\r\n\r\n@[simp] lemma Hom.comp_app {K : X.Modules} (\u03c6 : M \u27f6 N) (\u03c8 : N \u27f6 K) :\r\n    (\u03c6 \u226b \u03c8).app U = \u03c6.app U \u226b \u03c8.app U := rfl\r\n\r\n@[simp] lemma Hom.id_app (M : X.Modules) : (\ud835\udfd9 M : _ \u27f6 _).app U = \ud835\udfd9 _ := rfl\r\n\r\n```",
      "path": "Mathlib/AlgebraicGeometry/Modules/Sheaf.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Abelian",
          "Modules",
          "inferInstanceAs",
          "SheafOfModules",
          "ringCatSheaf",
          "instance"
        ]
      }
    },
    {
      "id": 989,
      "before_code": "pushforward.{v} (S := R) (F := \ud835\udfed _) (\ud835\udfd9 R) \u2245 \ud835\udfed _ :=\n  Iso.refl _",
      "suggestion": "/-- Pushforwards along equal morphisms of sheaves of rings are isomorphic. -/\n",
      "body": "```suggestion\n/-- Pushforwards along equal morphisms of sheaves of rings are isomorphic. -/\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/PushforwardContinuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Iso",
          "refl",
          "pushforward"
        ]
      }
    },
    {
      "id": 996,
      "before_code": "(g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g :=\n  rfl",
      "suggestion": "@[simp]\nlemma coe_prod {\u03b9 : Type} {s : Finset \u03b9} (hs : s.Nonempty) {k : \u03b9 \u2192 \u2124}\n",
      "body": "```suggestion\n@[simp]\nlemma coe_prod {\u03b9 : Type} {s : Finset \u03b9} (hs : s.Nonempty) {k : \u03b9 \u2192 \u2124}\n```\nFollowing what `coe_mul` does.",
      "path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "SlashInvariantForm",
          "mul"
        ]
      }
    },
    {
      "id": 997,
      "before_code": "(g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g :=\n  rfl",
      "suggestion": "@[simp]\nlemma coe_prodType {\u03b9 : Type} [Fintype \u03b9] [Nonempty \u03b9] {k : \u03b9 \u2192 \u2124} (m : \u2124)\n",
      "body": "```suggestion\n@[simp]\nlemma coe_prodType {\u03b9 : Type} [Fintype \u03b9] [Nonempty \u03b9] {k : \u03b9 \u2192 \u2124} (m : \u2124)\n```",
      "path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "SlashInvariantForm",
          "mul"
        ]
      }
    },
    {
      "id": 999,
      "before_code": "(g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g :=\n  rfl",
      "suggestion": "\r\n@[simps -fullyApplied]\r\ndef prod {\u03b9 : Type} {s : Finset \u03b9} (hs : s.Nonempty) {k : \u03b9 \u2192 \u2124} (m : \u2124)\r\n",
      "body": "If you do\r\n```suggestion\r\n@[simps -fullyApplied]\r\ndef prod {\u03b9 : Type} {s : Finset \u03b9} (hs : s.Nonempty) {k : \u03b9 \u2192 \u2124} (m : \u2124)\r\n```\r\nthen it will autogenerate the `coe_prod` lemma for you. Ditto for the other `def`'s here.",
      "path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "SlashInvariantForm",
          "mul"
        ]
      }
    },
    {
      "id": 1000,
      "before_code": "(g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g :=\n  rfl",
      "suggestion": "\r\n  toFun := \u220f i \u2208 s, f i\r\n",
      "body": "```suggestion\r\n  toFun := \u220f i \u2208 s, f i\r\n```\r\n(needed to get the autogenerated simp lemma to look right)",
      "path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "SlashInvariantForm",
          "mul"
        ]
      }
    },
    {
      "id": 1001,
      "before_code": "example (\u0393 : Subgroup (GL (Fin 2) \u211d)) [\u0393.HasDetOne] : Algebra \u2102 (\u2a01 i, ModularForm \u0393 i) :=\ninferInstance",
      "suggestion": "\r\n@[simps! -fullyApplied]\r\ndef prod {\u03b9 : Type} {s : Finset \u03b9} (hs : s.Nonempty) {k : \u03b9 \u2192 \u2124} (m : \u2124)\r\n",
      "body": "```suggestion\r\n@[simps! -fullyApplied]\r\ndef prod {\u03b9 : Type} {s : Finset \u03b9} (hs : s.Nonempty) {k : \u03b9 \u2192 \u2124} (m : \u2124)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "complex",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "example",
          "inferInstance",
          "HasDetOne",
          "Fin",
          "Algebra",
          "ModularForm"
        ]
      }
    },
    {
      "id": 1003,
      "before_code": "toFun := let := Fintype.ofFinite \ud835\udcac; \u220f q : \ud835\udcac, quotientFunc f q\n  slash_action_eq' h hh := by\n    let := Fintype.ofFinite \ud835\udcac\n    simpa [\u2190 Finset.card_univ, ModularForm.prod_slash Finset.univ_nonempty,\n      quotientFunc_smul f hh, Subgroup.HasDetPlusMinusOne.abs_det hh,\n      -Matrix.GeneralLinearGroup.val_det_apply] using Equiv.prod_comp (MulAction.toPerm (_ : \u210b)) _",
      "suggestion": "\r\n      quotientFunc_smul f hh, Subgroup.HasDetPlusMinusOne.abs_det hh,\r\n      -Matrix.GeneralLinearGroup.val_det_apply] using Equiv.prod_comp (MulAction.toPerm (_ : \u210b)) _\r\n",
      "body": "Nonstandard indenting?\r\n```suggestion\r\n      quotientFunc_smul f hh, Subgroup.HasDetPlusMinusOne.abs_det hh,\r\n      -Matrix.GeneralLinearGroup.val_det_apply] using Equiv.prod_comp (MulAction.toPerm (_ : \u210b)) _\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/NormTrace.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset",
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "prod_comp",
          "quotientFunc",
          "ModularForm",
          "univ_nonempty",
          "Finset",
          "Equiv",
          "quotientFunc_smul",
          "MulAction",
          "slash_action_eq",
          "ofFinite",
          "toFun",
          "GeneralLinearGroup",
          "HasDetPlusMinusOne",
          "val_det_apply",
          "abs_det",
          "simpa",
          "prod_slash",
          "Fintype",
          "Matrix",
          "card_univ",
          "toPerm",
          "using"
        ]
      }
    },
    {
      "id": 1004,
      "before_code": "(g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g :=\n  rfl",
      "suggestion": "\r\n@[simps!  -fullyApplied]\r\n",
      "body": "```suggestion\r\n@[simps!  -fullyApplied]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "SlashInvariantForm",
          "mul"
        ]
      }
    },
    {
      "id": 1005,
      "before_code": "example (\u0393 : Subgroup (GL (Fin 2) \u211d)) [\u0393.HasDetOne] : Algebra \u2102 (\u2a01 i, ModularForm \u0393 i) :=\ninferInstance",
      "suggestion": "\r\n@[simps!  -fullyApplied]\r\n",
      "body": "```suggestion\r\n@[simps!  -fullyApplied]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "complex",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "example",
          "inferInstance",
          "HasDetOne",
          "Fin",
          "Algebra",
          "ModularForm"
        ]
      }
    },
    {
      "id": 1006,
      "before_code": "example (\u0393 : Subgroup (GL (Fin 2) \u211d)) [\u0393.HasDetOne] : Algebra \u2102 (\u2a01 i, ModularForm \u0393 i) :=\ninferInstance",
      "suggestion": "\r\n@[simps! -fullyApplied]\r\n",
      "body": "```suggestion\r\n@[simps! -fullyApplied]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "complex",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "example",
          "inferInstance",
          "HasDetOne",
          "Fin",
          "Algebra",
          "ModularForm"
        ]
      }
    },
    {
      "id": 1037,
      "before_code": "DFunLike.coe_injective.addCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl",
      "suggestion": "\r\nopen Classical in\r\n@[simp]\r\ntheorem sum_apply {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 \ud835\udce2(E, F)) (x : E) :\r\n    (\u2211 i \u2208 s, f i) x = \u2211 i \u2208 s, f i x := by\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert i s his h =>\r\n    simp [his, h]\r\n",
      "body": "```suggestion\r\nopen Classical in\r\n@[simp]\r\ntheorem sum_apply {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 \ud835\udce2(E, F)) (x : E) :\r\n    (\u2211 i \u2208 s, f i) x = \u2211 i \u2208 s, f i x := by\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert i s his h =>\r\n    simp [his, h]\r\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "induction",
          "simp"
        ],
        "body_tactics": [
          "induction",
          "simp"
        ],
        "new_tactics": [
          "induction",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "rfl",
          "coe_injective",
          "DFunLike",
          "addCommGroup"
        ]
      }
    },
    {
      "id": 1038,
      "before_code": "DFunLike.coe_injective.addCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl",
      "suggestion": "\r\n  | insert i s his h => simp [his, h]\r\n",
      "body": "```suggestion\r\n  | insert i s his h => simp [his, h]\r\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "rfl",
          "coe_injective",
          "DFunLike",
          "addCommGroup"
        ]
      }
    },
    {
      "id": 1050,
      "before_code": "convert (sum_map _ (addRightEmbedding k) (\u00b7.choose k)).symm using 2\n  rw [map_add_right_Ico, zero_add, add_right_comm, Ico_add_one_right_eq_Icc]",
      "suggestion": "\r\nlemma sum_range_multichoose (n k : \u2115) :\r\n    \u2211 i \u2208 Finset.range (n + 1), k.multichoose i = (n + k).choose k := by\r\n  cases k with\r\n  | zero => simp [Finset.sum_range_succ']\r\n  | succ k => grind [multichoose_eq, choose_symm_of_eq_add, sum_range_add_choose]\r\n",
      "body": "```suggestion\r\nlemma sum_range_multichoose (n k : \u2115) :\r\n    \u2211 i \u2208 Finset.range (n + 1), k.multichoose i = (n + k).choose k := by\r\n  cases k with\r\n  | zero => simp [Finset.sum_range_succ']\r\n  | succ k => grind [multichoose_eq, choose_symm_of_eq_add, sum_range_add_choose]\r\n```\r\nThis theorem can be proved in a shorter way, and with fewer assumptions. \r\n(Also, I think patterns like `simp only [\u2190 h1 \u25b8 h2 \u25b8 (sum_Icc_choose (n + (k - 1)) (k - 1))` should be avoided from mathlib, since they're pretty to",
      "path": "Mathlib/Data/Nat/Choose/Sum.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "grind",
          "cases",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "cases",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "Ico_add_one_right_eq_Icc",
          "addRightEmbedding",
          "symm",
          "convert",
          "zero_add",
          "add_right_comm",
          "choose",
          "sum_map",
          "map_add_right_Ico",
          "using"
        ]
      }
    },
    {
      "id": 1052,
      "before_code": "\u27e8\u22a4\u27e9\n\nattribute [match_pattern] Bot.bot Top.top",
      "suggestion": "\r\n/-- In the case where the type is _not_ linearly ordered. -/\r\nrecommended_spelling \"sup\" for \"\u2294\" in [Max.max]\r\n",
      "body": "Note that `recommended_spelling` takes a docstring; we could use it to add a remark to `Max.max` as well, along the lines of\r\n```suggestion\r\n/-- In the case where the type is _not_ linearly ordered. -/\r\nrecommended_spelling \"sup\" for \"\u2294\" in [Max.max]\r\n```",
      "path": "Mathlib/Order/Notation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Top",
          "Bot",
          "bot",
          "match_pattern",
          "attribute",
          "top"
        ]
      }
    },
    {
      "id": 1055,
      "before_code": "/-! ### Properties about `aleph0` -/\n\ntheorem nat_lt_aleph0 (n : \u2115) : (n : Cardinal.{u}) < \u2135\u2080 :=\n  succ_le_iff.1\n    (by\n      rw [\u2190 nat_succ, \u2190 lift_mk_fin, aleph0, lift_mk_le.{u}]\n      exact \u27e8\u27e8(\u2191), fun a b => Fin.ext\u27e9\u27e9)",
      "suggestion": "\r\n@[simp] lemma natCast_lt_aleph0 {n : \u2115} : (n : Cardinal.{u}) < \u2135\u2080 := by\r\n",
      "body": "Shouldn't this be called?\r\n```suggestion\r\n@[simp] lemma natCast_lt_aleph0 {n : \u2115} : (n : Cardinal.{u}) < \u2135\u2080 := by\r\n```",
      "path": "Mathlib/SetTheory/Cardinal/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "ext"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "about",
          "aleph0",
          "ext",
          "theorem",
          "exact",
          "Properties",
          "nat_succ",
          "Fin",
          "lift_mk_le",
          "lift_mk_fin",
          "succ_le_iff",
          "nat_lt_aleph0",
          "Cardinal"
        ]
      }
    },
    {
      "id": 1056,
      "before_code": "e.conj f = ((\u2191e : M\u2081' \u2192\u209b\u2097[\u03c3\u2081'\u2082'] M\u2082').comp f).comp (e.symm : M\u2082' \u2192\u209b\u2097[\u03c3\u2082'\u2081'] M\u2081') :=\n  rfl",
      "suggestion": "\r\n/--\r\nNote this has lower `simp` priority for performance reasons, so that we rewrite as\r\n`e.conj LinearMap.id x => LinearMap.id x` => `x` rather than\r\n`e.conj LinearMap.id x => e (LinearMap.id (e.symm x)) => e (e.symm x) => x`.\r\n-/\r\n",
      "body": "```suggestion\r\n/--\r\nNote this has lower `simp` priority for performance reasons, so that we rewrite as\r\n`e.conj LinearMap.id x => LinearMap.id x` => `x` rather than\r\n`e.conj LinearMap.id x => e (LinearMap.id (e.symm x)) => e (e.symm x) => x`.\r\n-/\r\n```",
      "path": "Mathlib/Algebra/Module/Equiv/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "symm",
          "conj"
        ]
      }
    },
    {
      "id": 1064,
      "before_code": "characteristic f \u22a4 - characteristic (f \u00b7 - a\u2080) \u22a4 = proximity f \u22a4 - proximity (f \u00b7 - a\u2080) \u22a4 := by\n  simp [\u2190 Pi.sub_def, characteristic, logCounting_sub_const h]",
      "suggestion": "\r\n    0 \u2264 characteristic f a r := \r\n  add_nonneg (proximity_nonneg r) (logCounting_nonneg hr)\r\n",
      "body": "In this case, the `simp` is only applying defeqs, so you can just do this:\r\n```suggestion\r\n    0 \u2264 characteristic f a r := \r\n  add_nonneg (proximity_nonneg r) (logCounting_nonneg hr)\r\n```\r\nIn case it weren't, you could do this (do you know about `simpa`)?\r\n```suggestion\r\n    0 \u2264 characteristic f a r := by\r\n  simpa only [characteristic, Pi.add_apply] using\r\n  \tadd_nonneg (proximity_nonneg r) (logCounting_nonneg hr)\r\n```\r\n`simpa` is helpful when you want to construct a term, but both that term and",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CharacteristicFunction.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "logCounting_sub_const",
          "proximity",
          "sub_def",
          "characteristic",
          "simp"
        ]
      }
    },
    {
      "id": 1065,
      "before_code": "@[simp] theorem logCounting_const_zero {e : WithTop E} :\n    logCounting (0 : \ud835\udd5c \u2192 E) e = 0 := logCounting_const",
      "suggestion": "\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n",
      "body": "```suggestion\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n```",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CountingFunction.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "positivity"
        ],
        "body_tactics": [
          "simpa",
          "positivity"
        ],
        "new_tactics": [
          "simpa",
          "positivity"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "logCounting",
          "WithTop",
          "theorem",
          "logCounting_const_zero",
          "logCounting_const",
          "simp"
        ]
      }
    },
    {
      "id": 1076,
      "before_code": "isLocalizedModule_iff_isLocalization.mp inferInstance\n  inferInstance",
      "suggestion": "\r\n  \u00b7 simp [tensorKaehlerEquiv']\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [tensorKaehlerEquiv']\r\n```",
      "path": "Mathlib/RingTheory/Kaehler/TensorProduct.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "isLocalizedModule_iff_isLocalization",
          "inferInstance"
        ]
      }
    },
    {
      "id": 1077,
      "before_code": "isLocalizedModule_iff_isLocalization.mp inferInstance\n  inferInstance",
      "suggestion": "\r\n  rw [show s \u2297\u209c[R] 1 = algebraMap S (S \u2297[R] A) s by rfl,\r\n    show (algebraMap A (S \u2297[R] A)) a = 1 \u2297\u209c[R] a by rfl,\r\n    algebraMap_smul, \u2190 Derivation.map_smul, smul_tmul', smul_eq_mul, mul_one]\r\n",
      "body": "```suggestion\r\n  rw [show s \u2297\u209c[R] 1 = algebraMap S (S \u2297[R] A) s by rfl,\r\n    show (algebraMap A (S \u2297[R] A)) a = 1 \u2297\u209c[R] a by rfl,\r\n    algebraMap_smul, \u2190 Derivation.map_smul, smul_tmul', smul_eq_mul, mul_one]\r\n```\r\nI think this is slightly better: this way it\u2019s clear what defeq are being used.",
      "path": "Mathlib/RingTheory/Kaehler/TensorProduct.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "isLocalizedModule_iff_isLocalization",
          "inferInstance"
        ]
      }
    },
    {
      "id": 1084,
      "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
      "suggestion": "\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n",
      "body": "Untested, but something like this should work?\r\n```suggestion\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "new_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "_ha",
          "mem_top",
          "le_top",
          "theorem"
        ]
      }
    },
    {
      "id": 1085,
      "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
      "suggestion": "\r\n  refine fun h \u21a6 \u27e8\u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9, ?_\u27e9\r\n",
      "body": "You could merge these two lines as well (though you might argue the original is cleaner)\r\n```suggestion\r\n  refine fun h \u21a6 \u27e8\u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9, ?_\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "_ha",
          "mem_top",
          "le_top",
          "theorem"
        ]
      }
    },
    {
      "id": 1102,
      "before_code": "(s.reindex e).touchpoint signs i = s.touchpoint (signs.map e.symm) (e.symm i) :=\n  orthogonalProjectionSpan_congr (s.range_faceOpposite_reindex _ _) (s.excenter_reindex _ _)",
      "suggestion": "\r\n  haveI := Nonempty.map (AffineSubspace.inclusion hS) inferInstance\r\n  exact (h.touchpoint_map S.subtype\u2090\u1d62 i).symm\r\n",
      "body": "```suggestion\r\n  haveI := Nonempty.map (AffineSubspace.inclusion hS) inferInstance\r\n  exact (h.touchpoint_map S.subtype\u2090\u1d62 i).symm\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Incenter.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "orthogonalProjectionSpan_congr",
          "reindex",
          "map",
          "signs",
          "touchpoint",
          "range_faceOpposite_reindex",
          "excenter_reindex"
        ]
      }
    },
    {
      "id": 1103,
      "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
      "suggestion": "\r\n  simp only [Submodule.ext_iff, mem_map, mem_orthogonal, forall_exists_index, and_imp,\r\n    forall_apply_eq_imp_iff\u2082, LinearIsometryEquiv.inner_map_eq_flip]\r\n  exact fun x \u21a6 \u27e8fun \u27e8y, hy\u27e9 z hz \u21a6 by simp [\u2190 hy.2, hy.1 _ hz], fun h \u21a6 \u27e8_, h, by simp\u27e9\u27e9\r\n",
      "body": "```suggestion\r\n  simp only [Submodule.ext_iff, mem_map, mem_orthogonal, forall_exists_index, and_imp,\r\n    forall_apply_eq_imp_iff\u2082, LinearIsometryEquiv.inner_map_eq_flip]\r\n  exact fun x \u21a6 \u27e8fun \u27e8y, hy\u27e9 z hz \u21a6 by simp [\u2190 hy.2, hy.1 _ hz], fun h \u21a6 \u27e8_, h, by simp\u27e9\u27e9\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "CompleteSpace",
          "instOrthogonalCompleteSpace",
          "isClosed_orthogonal",
          "instance",
          "completeSpace_coe"
        ]
      }
    },
    {
      "id": 1104,
      "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
      "suggestion": "\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n",
      "body": "(I don't know if this is recommended, but you _can_ technically do this in one line:\r\n```suggestion\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n```\r\n)\r\nProbably over-golfed though... so less of a suggestion, and more of an observation I guess",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "cleanup_simp",
          "use_aesop"
        ],
        "keywords": [
          "CompleteSpace",
          "instOrthogonalCompleteSpace",
          "isClosed_orthogonal",
          "instance",
          "completeSpace_coe"
        ]
      }
    },
    {
      "id": 1113,
      "before_code": "convert ((open_iff i subset_rfl).mp open_V).inter open_W using 1\n    refine Set.ext fun e \u21a6 and_right_comm.trans (and_congr_right fun \u27e8hV, hU\u27e9 \u21a6 ?_)\n    rw [Set.mem_preimage, dif_pos hV, inj i (inv_U i _) hU (f_inv i _)]",
      "suggestion": "\r\n  /- for each preimage e of x, choose a homeomorphism \u03c6\u2091\r\n    from a neighborhood of e to its image -/\r\n  choose \u03c6 h\u03c6 using fun e : f \u207b\u00b9' {x} \u21a6 h e e.2\r\n  -- separately, choose pairwise disjoint neighborhoods V\u2091 by Hausdorff-ness\r\n  have \u27e8V, hV, disj\u27e9 := fin.t2_separation\r\n  -- let V\u2091' be the intersection V\u2091 \u2229 dom(\u03c6\u2091)\r\n  let V' (e : f \u207b\u00b9' {x}) := V e \u2229 (\u03c6 e).source\r\n  have hV' e : IsOpen (V' e) := (hV e).2.inter (\u03c6 e).open_source\r\n  have : \u22c3 e, V' e \u2208 nhdsSet (f \u207b\u00b9' {x}) :=\r\n    (isOpen_iUnion hV').mem_nhdsSet.2 fun e he \u21a6 mem_iUnion_of_mem \u27e8e, he\u27e9 \u27e8(hV e).1, (h\u03c6 _).1\u27e9\r\n  -- since f is a closed map, the union of the V\u2091' contains the preimage of a neighborhood U \u220b x\r\n  have \u27e8W, hWx, hWV\u27e9 := isClosedMap_iff_comap_nhds_le.mp hf this\r\n  cases isEmpty_or_nonempty (f \u207b\u00b9' {x})\r\n  \u00b7 exact .of_preimage_eq_empty _ hWx (by simpa using hWV)\r\n  have \u27e8U, hUW, hU, hxU\u27e9 := mem_nhds_iff.mp hWx\r\n  -- show that the intersection of U with the images of V\u2091' is evenly covered\r\n  let U' := U \u2229 \u22c2 e : f \u207b\u00b9' ",
      "body": "```suggestion\r\n  /- for each preimage e of x, choose a homeomorphism \u03c6\u2091\r\n    from a neighborhood of e to its image -/\r\n  choose \u03c6 h\u03c6 using fun e : f \u207b\u00b9' {x} \u21a6 h e e.2\r\n  -- separately, choose pairwise disjoint neighborhoods V\u2091 by Hausdorff-ness\r\n  have \u27e8V, hV, disj\u27e9 := fin.t2_separation\r\n  -- let V\u2091' be the intersection V\u2091 \u2229 dom(\u03c6\u2091)\r\n  let V' (e : f \u207b\u00b9' {x}) := V e \u2229 (\u03c6 e).source\r\n  have hV' e : IsOpen (V' e) := (hV e).2.inter (\u03c6 e).open_source\r\n  have : \u22c3 e, V' e \u2208 nhdsSet (f \u207b\u00b9' {x}) :=\r\n    (",
      "path": "Mathlib/Topology/Covering/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "removed_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "and_right_comm",
          "refine",
          "ext",
          "convert",
          "f_inv",
          "open_iff",
          "dif_pos",
          "inter",
          "and_congr_right",
          "subset_rfl",
          "open_W",
          "inv_U",
          "Set",
          "trans",
          "mem_preimage",
          "using",
          "open_V",
          "inj"
        ]
      }
    },
    {
      "id": 1119,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    exact (one_ne_zero heq).elim\r\n",
      "body": "Here's a slight golf.\r\n```suggestion\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at he",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 1121,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n",
      "body": "```suggestion\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n```\r\nThis is slightly shorter.",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "simp_all",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 1122,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n",
      "body": "```suggestion\n  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "grind",
          "simp_all",
          "have",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp_all",
          "have",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "have",
          "simp",
          "simp_all"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 1126,
      "before_code": "refine \u27e8s, hs, fun i hi \u21a6 \u27e8t i, this i hi\u27e9, fun i _ \u21a6 hc i, ?_\u27e9\n    simp_rw [coe_mk, \u2190 heq, \u2190 heq', Set.image_sigma_eq_iUnion, Function.comp_apply]\n\nlemma of_iUnion_eq_of_finite (s : Set (Set S)) (hs : \u22c3 t \u2208 s, t = U) (hf : s.Finite)\n    (H : \u2200 t \u2208 s, IsCompactOpenCovered f t) : IsCompactOpenCovered f U := by\n  rw [iff_isCompactOpenCovered_sigmaMk, iff_of_unique]\n  have (t) (h : t \u2208 s) : \u2203 (V : Opens (\u03a3 i, X i)),\n      IsCompact V.1 \u2227 (fun p \u21a6 f p.fst p.snd) '' V.carrier = t := by\n    have := H t h\n    rwa [iff_isCompactOpenCovered_sigmaMk, iff_of_unique] at this\n  choose V hVeq hVc using this\n  refine \u27e8\u2a06 (t : s), V t t.2, ?_, ?_\u27e9\n  \u00b7 simp only [Opens.iSup_mk, Opens.carrier_eq_coe, Opens.coe_mk]\n    have : Finite s := hf\n    exact isCompact_iUnion (fun _ \u21a6 hVeq _ _)\n  \u00b7 simp [Set.image_iUnion, \u2190 hs]\n    simp_all",
      "suggestion": "\r\n    \u00b7 simp [Opens.forall]\r\n",
      "body": "```suggestion\r\n    \u00b7 simp [Opens.forall]\r\n```\r\nI think this is not necessary?",
      "path": "Mathlib/Topology/Sets/CompactOpenCovered.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "exact",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine",
          "exact",
          "have",
          "rw",
          "simp_all"
        ],
        "topics": [
          "set_theory",
          "order",
          "function",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "isCompact_iUnion",
          "lemma",
          "rwa",
          "iSup_mk",
          "hVc",
          "of_iUnion_eq_of_finite",
          "simp_all",
          "Function",
          "snd",
          "iff_isCompactOpenCovered_sigmaMk",
          "refine",
          "fst",
          "coe_mk",
          "have",
          "heq",
          "simp_rw",
          "IsCompact",
          "IsCompactOpenCovered",
          "comp_apply",
          "hVeq",
          "image_sigma_eq_iUnion",
          "choose",
          "simp",
          "carrier_eq_coe",
          "only",
          "image_iUnion",
          "Finite",
          "exact",
          "iff_of_unique",
          "Set",
          "this",
          "Opens",
          "carrier",
          "using"
        ]
      }
    },
    {
      "id": 1127,
      "before_code": "refine \u27e8s, hs, fun i hi \u21a6 \u27e8t i, this i hi\u27e9, fun i _ \u21a6 hc i, ?_\u27e9\n    simp_rw [coe_mk, \u2190 heq, \u2190 heq', Set.image_sigma_eq_iUnion, Function.comp_apply]\n\nlemma of_iUnion_eq_of_finite (s : Set (Set S)) (hs : \u22c3 t \u2208 s, t = U) (hf : s.Finite)\n    (H : \u2200 t \u2208 s, IsCompactOpenCovered f t) : IsCompactOpenCovered f U := by\n  rw [iff_isCompactOpenCovered_sigmaMk, iff_of_unique]\n  have (t) (h : t \u2208 s) : \u2203 (V : Opens (\u03a3 i, X i)),\n      IsCompact V.1 \u2227 (fun p \u21a6 f p.fst p.snd) '' V.carrier = t := by\n    have := H t h\n    rwa [iff_isCompactOpenCovered_sigmaMk, iff_of_unique] at this\n  choose V hVeq hVc using this\n  refine \u27e8\u2a06 (t : s), V t t.2, ?_, ?_\u27e9\n  \u00b7 simp only [Opens.iSup_mk, Opens.carrier_eq_coe, Opens.coe_mk]\n    have : Finite s := hf\n    exact isCompact_iUnion (fun _ \u21a6 hVeq _ _)\n  \u00b7 simp [Set.image_iUnion, \u2190 hs]\n    simp_all",
      "suggestion": "\r\n  \u00b7 simp [Opens.forall]\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [Opens.forall]\r\n```",
      "path": "Mathlib/Topology/Sets/CompactOpenCovered.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "exact",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine",
          "exact",
          "have",
          "rw",
          "simp_all"
        ],
        "topics": [
          "set_theory",
          "order",
          "function",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "isCompact_iUnion",
          "lemma",
          "rwa",
          "iSup_mk",
          "hVc",
          "of_iUnion_eq_of_finite",
          "simp_all",
          "Function",
          "snd",
          "iff_isCompactOpenCovered_sigmaMk",
          "refine",
          "fst",
          "coe_mk",
          "have",
          "heq",
          "simp_rw",
          "IsCompact",
          "IsCompactOpenCovered",
          "comp_apply",
          "hVeq",
          "image_sigma_eq_iUnion",
          "choose",
          "simp",
          "carrier_eq_coe",
          "only",
          "image_iUnion",
          "Finite",
          "exact",
          "iff_of_unique",
          "Set",
          "this",
          "Opens",
          "carrier",
          "using"
        ]
      }
    },
    {
      "id": 1132,
      "before_code": "have hdc : d * c = 1 := mul_left_cancel\u2080 hac0 this\n  exact \u27e8\u27e8c, d, hcd, hdc\u27e9, rfl\u27e9\n\ntheorem dvd_dvd_iff_associated [CancelMonoidWithZero M] {a b : M} : a \u2223 b \u2227 b \u2223 a \u2194 a ~\u1d64 b :=",
      "suggestion": "\r\ntheorem dvd_dvd_iff_associated [MonoidWithZero M] [IsCancelMulZero M] {a b : M} :\r\n",
      "body": "The statement is symmetric. Should we therefore overassume a little for simplicity?\r\n```suggestion\r\ntheorem dvd_dvd_iff_associated [MonoidWithZero M] [IsCancelMulZero M] {a b : M} :\r\n```",
      "path": "Mathlib/Algebra/GroupWithZero/Associated.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "have"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "CancelMonoidWithZero",
          "theorem",
          "exact",
          "have",
          "this",
          "hcd",
          "hdc",
          "hac0",
          "rfl",
          "dvd_dvd_iff_associated"
        ]
      }
    },
    {
      "id": 1135,
      "before_code": "all_goals exact le_ofPrime A (PrimeSpectrum.asIdeal _),\n      fun h => by apply ofPrime_le_of_le; exact h\u27e9 }\n\ninstance le_total_ideal : IsTotal {S // A \u2264 S} LE.le := by",
      "suggestion": "\r\ninstance le_total_ideal : @Std.Total {S // A \u2264 S} (\u00b7 \u2264 \u00b7) := by\r\n",
      "body": "We really should have some sort of abbrev `IsTotalLE`.\r\n```suggestion\r\ninstance le_total_ideal : @[user].Total {S // A \u2264 S} (\u00b7 \u2264 \u00b7) := by\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "apply"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "IsTotal",
          "apply",
          "asIdeal",
          "all_goals",
          "exact",
          "PrimeSpectrum",
          "le_ofPrime",
          "ofPrime_le_of_le",
          "le_total_ideal",
          "instance"
        ]
      }
    },
    {
      "id": 1137,
      "before_code": "variable {R : Type*}\n\ntheorem _root_.PreValuationRing.iff_dvd_total [Semigroup R] :\n    PreValuationRing R \u2194 IsTotal R (\u00b7 \u2223 \u00b7) := by\n  classical\n  refine \u27e8fun H => \u27e8fun a b => ?_\u27e9, fun H => \u27e8fun a b => ?_\u27e9\u27e9\n  \u00b7 obtain \u27e8c, rfl | rfl\u27e9 := PreValuationRing.cond a b <;> simp\n  \u00b7 obtain \u27e8c, rfl\u27e9 | \u27e8c, rfl\u27e9 := @IsTotal.total _ _ H a b <;> use c <;> simp",
      "suggestion": "\r\n  \u00b7 obtain \u27e8c, rfl\u27e9 | \u27e8c, rfl\u27e9 := @total_of _ _ H a b <;> use c <;> simp\r\n",
      "body": "Do you mean:\r\n```suggestion\r\n  \u00b7 obtain \u27e8c, rfl\u27e9 | \u27e8c, rfl\u27e9 := @[user] _ _ H a b <;> use c <;> simp\r\n```\r\nI don't see the benefit, I think using the built-in field is better than the Mathlib lemma.\r\nIf you mean `total_of H a b` then it's impossible, `H` is a proof of being total, while `total_of` only makes `r` explicit and not the `Std.Total` instance.\r\nSo I changed it to `H.total a b`.",
      "path": "Mathlib/RingTheory/Valuation/ValuationRing.lean",
      "tags": {
        "before_tactics": [
          "obtain",
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "IsTotal",
          "Semigroup",
          "refine",
          "variable",
          "cond",
          "_root_",
          "theorem",
          "total",
          "Type",
          "obtain",
          "PreValuationRing",
          "simp",
          "iff_dvd_total",
          "rfl",
          "classical",
          "use"
        ]
      }
    },
    {
      "id": 1142,
      "before_code": "@[simp]\ntheorem filter_ne_eq_erase' (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : f.filter (i \u2260 \u00b7) = f.erase i := by\n  rw [\u2190 filter_ne_eq_erase f i]\n  congr with j\n  exact ne_comm",
      "suggestion": "\r\n  ext; grind\r\n",
      "body": "```suggestion\r\n  ext; grind\r\n```\r\n\r\nIn the meantime, it is preferable to the one-liner `ext; grind`. (also `filter_ne_eq_erase` while you're at it)",
      "path": "Mathlib/Data/DFinsupp/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "congr",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "ext"
        ],
        "body_tactics": [
          "grind",
          "ext"
        ],
        "new_tactics": [
          "grind",
          "ext"
        ],
        "removed_tactics": [
          "exact",
          "congr",
          "rw",
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "filter_ne_eq_erase",
          "erase",
          "theorem",
          "exact",
          "filter",
          "ne_comm",
          "simp",
          "congr"
        ]
      }
    },
    {
      "id": 1148,
      "before_code": "set_option linter.unusedTactic false in\nadd_aesop_rules safe tactic (rule_sets := [finiteness]) (by positivity)\n\n/-- Tactic to solve goals of the form `*** < \u221e` and (equivalently) `*** \u2260 \u221e` in the extended\nnonnegative reals (`\u211d\u22650\u221e`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (config := { introsTransparency? := some .reducible, terminal := true, enableSimp := false })\n    (rule_sets := [$(Lean.mkIdent `finiteness):ident, -default, -builtin]))",
      "suggestion": "\r\n| `(tactic| finiteness $c:Aesop.tactic_clause* [$h,+]) =>\r\n",
      "body": "```suggestion\r\n| `(tactic| finiteness $c:Aesop.tactic_clause* [$h,+]) =>\r\n```\r\nI believe you can use this to ensure that there is at least one argument (the next line doesn't change) (also below).",
      "path": "Mathlib/Tactic/Finiteness.lean",
      "tags": {
        "before_tactics": [
          "positivity",
          "aesop"
        ],
        "suggestion_tactics": [
          "aesop"
        ],
        "body_tactics": [
          "aesop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "positivity"
        ],
        "topics": [
          "real",
          "set_theory",
          "equiv"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "tactic_clause",
          "reducible",
          "reals",
          "true",
          "safe",
          "terminal",
          "nonnegative",
          "Tactic",
          "equivalently",
          "mkIdent",
          "form",
          "finiteness",
          "positivity",
          "Lean",
          "builtin",
          "linter",
          "introsTransparency",
          "name",
          "false",
          "solve",
          "goals",
          "unusedTactic",
          "aesop",
          "add_aesop_rules",
          "macro",
          "ident",
          "default",
          "tactic",
          "config",
          "extended",
          "Aesop",
          "rule_sets",
          "enableSimp",
          "set_option",
          "some"
        ]
      }
    },
    {
      "id": 1165,
      "before_code": "ContinuousLinearMap.fst \ud835\udd5c E E + ContinuousLinearMap.snd \ud835\udd5c E E |>.isBigOTVS_comp\n    |>.trans <| h\u2081.prodMk h\u2082",
      "suggestion": "\r\n@[to_fun]\r\nprotected theorem IsLittleOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n",
      "body": "```suggestion\r\n@[to_fun]\r\nprotected theorem IsLittleOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n```\r\nUnfortunately this does not work earlier because we can't provide our own name...",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigOTVS_comp",
          "ContinuousLinearMap",
          "fst",
          "trans",
          "prodMk",
          "snd"
        ]
      }
    },
    {
      "id": 1166,
      "before_code": "ContinuousLinearMap.fst \ud835\udd5c E E + ContinuousLinearMap.snd \ud835\udd5c E E |>.isBigOTVS_comp\n    |>.trans <| h\u2081.prodMk h\u2082",
      "suggestion": "\r\n\r\ntheorem isLittleOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isLittleOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =o[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =o[\ud835\udd5c; l] g :=\r\n  isLittleOTVS_comm\r\n\r\n@[to_fun]\r\nprotected theorem IsBigOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n\r\ntheorem isBigOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isBigOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =O[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =O[\ud835\udd5c; l] g :=\r\n  isBigOTVS_comm\r\n\r\n",
      "body": "Why no also add the following?\r\n```suggestion\r\n\r\ntheorem isLittleOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isLittleOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =o[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =o[\ud835\udd5c; l] g :=\r\n  isLittleOTVS_comm\r\n\r\n@[to_fun]\r\nprotected theorem IsBigOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n\r\ntheorem isBigOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 ",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigOTVS_comp",
          "ContinuousLinearMap",
          "fst",
          "trans",
          "prodMk",
          "snd"
        ]
      }
    },
    {
      "id": 1167,
      "before_code": "ContinuousLinearMap.fst \ud835\udd5c E E + ContinuousLinearMap.snd \ud835\udd5c E E |>.isBigOTVS_comp\n    |>.trans <| h\u2081.prodMk h\u2082",
      "suggestion": "\r\n\r\ntheorem IsBigOTVS.triangle [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E]\r\n    {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : Filter \u03b1}\r\n    (h\u2081 : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) (h\u2082 : (f\u2082 - f\u2083) =O[\ud835\udd5c; l] g) : (f\u2081 - f\u2083) =O[\ud835\udd5c; l] g := by\r\n  simpa using h\u2081.add h\u2082\r\n\r\n",
      "body": "While you're at it:\r\n```suggestion\r\n\r\ntheorem IsBigOTVS.triangle [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E]\r\n    {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : Filter \u03b1}\r\n    (h\u2081 : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) (h\u2082 : (f\u2082 - f\u2083) =O[\ud835\udd5c; l] g) : (f\u2081 - f\u2083) =O[\ud835\udd5c; l] g := by\r\n  simpa using h\u2081.add h\u2082\r\n\r\n```",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigOTVS_comp",
          "ContinuousLinearMap",
          "fst",
          "trans",
          "prodMk",
          "snd"
        ]
      }
    },
    {
      "id": 1174,
      "before_code": "/-- Elaborate `DepRewrite.Config`. -/\ndeclare_config_elab elabDepRewriteConfig Config\n\n@[tactic depRewriteSeq, inherit_doc depRewriteSeq]",
      "suggestion": "\r\n@[tactic depRewriteSeq, inherit_doc depRewriteSeq]\r\n",
      "body": "You're right, this is an elaborator while `@[tactic_doc]` belongs on the syntax definition. I'll revert it.\r\n\r\n```suggestion\r\n@[tactic depRewriteSeq, inherit_doc depRewriteSeq]\r\n```",
      "path": "Mathlib/Tactic/DepRewrite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "elabDepRewriteConfig",
          "DepRewrite",
          "Elaborate",
          "Config",
          "declare_config_elab",
          "inherit_doc",
          "tactic",
          "depRewriteSeq"
        ]
      }
    },
    {
      "id": 1175,
      "before_code": "(depRewriteTarget term symm cfg)\n      (throwTacticEx `depRewrite \u00b7 \"did not find instance of the pattern in the current goal\")\n\n@[tactic depRwSeq, inherit_doc depRwSeq]",
      "suggestion": "\r\n@[tactic depRwSeq, inherit_doc depRwSeq]\r\n",
      "body": "```suggestion\r\n@[tactic depRwSeq, inherit_doc depRwSeq]\r\n```",
      "path": "Mathlib/Tactic/DepRewrite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "term",
          "depRewriteTarget",
          "symm",
          "did",
          "cfg",
          "goal",
          "current",
          "depRewrite",
          "pattern",
          "find",
          "inherit_doc",
          "tactic",
          "instance",
          "depRwSeq",
          "throwTacticEx"
        ]
      }
    },
    {
      "id": 1176,
      "before_code": "(withMainContext <| cleanupCasts (\u2190 getMainTarget)))\n    replaceMainGoal ((\u2190 getMainGoal) :: r.mvarIds)\n\n@[tactic depRewrite, inherit_doc depRewriteSeq]",
      "suggestion": "\r\n@[tactic depRewrite, inherit_doc depRewriteSeq]\r\n",
      "body": "```suggestion\r\n@[tactic depRewrite, inherit_doc depRewriteSeq]\r\n```",
      "path": "Mathlib/Tactic/DepRewrite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "mvarIds",
          "withMainContext",
          "replaceMainGoal",
          "depRewrite",
          "cleanupCasts",
          "getMainGoal",
          "getMainTarget",
          "tactic",
          "inherit_doc",
          "depRewriteSeq"
        ]
      }
    },
    {
      "id": 1177,
      "before_code": "(depRewriteTarget term symm cfg)\n      (throwTacticEx `depRewrite \u00b7 \"did not find instance of the pattern in the current goal\")\n\n@[tactic depRw, inherit_doc depRwSeq]",
      "suggestion": "\r\n@[tactic depRw, inherit_doc depRwSeq]\r\n",
      "body": "```suggestion\r\n@[tactic depRw, inherit_doc depRwSeq]\r\n```",
      "path": "Mathlib/Tactic/DepRewrite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "term",
          "depRewriteTarget",
          "symm",
          "did",
          "cfg",
          "goal",
          "current",
          "depRw",
          "depRewrite",
          "pattern",
          "find",
          "inherit_doc",
          "tactic",
          "instance",
          "depRwSeq",
          "throwTacticEx"
        ]
      }
    },
    {
      "id": 1179,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "/-- If an integer non-constant polynomial has Mahler measure equal to 1 and is not a multiple of X,\n",
      "body": "The docstring says \"is a multiple of X\" but based on the parameter name \"hX : \u00ac X \u2223 p\", it should say \"is NOT a multiple of X\".\n```suggestion\n/-- If an integer non-constant polynomial has Mahler measure equal to 1 and is not a multiple of X,\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1180,
      "before_code": "le_prod_of_submultiplicative_on_pred_of_nonneg f (fun _ \u21a6 True) h0 h_one\n    (fun x y _ _ \u21a6 h_mul x y) (by simp) s (by simp)",
      "suggestion": "      \u00b7 exact le_trans (zero_le_one' \u03b2) (h1 a)\n",
      "body": "The use of `MulOpposite.one_le_op.mp (h1 a)` appears incorrect. The lemma `MulOpposite.one_le_op` states `1 \u2264 op a \u2194 1 \u2264 a`, so `.mp` requires a hypothesis of the form `1 \u2264 op (f a)`, but `h1 a` provides `1 \u2264 f a`, not `1 \u2264 op (f a)`. The expression `le_trans (zero_le_one' \u03b2) (h1 a)` should be sufficient to prove `0 \u2264 f a`.\n```suggestion\n      \u00b7 exact le_trans (zero_le_one' \u03b2) (h1 a)\n```",
      "path": "Mathlib/Algebra/Order/BigOperators/Ring/Multiset.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "True",
          "le_prod_of_submultiplicative_on_pred_of_nonneg",
          "simp",
          "h_one",
          "h_mul"
        ]
      }
    },
    {
      "id": 1181,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "-- y is z as an element of K\n",
      "body": "Comment should have a space after `--`. It should be `-- y is z as an element of K` instead of `--y is z as an element of K`.\n```suggestion\n-- y is z as an element of K\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1183,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  have h_ineq := h \u25b8 (leading_coeff_le_mahlerMeasure <| p.map (castRingHom \u2102))\n  rw [leadingCoeff_map_of_injective (castRingHom \u2102).injective_int, eq_intCast]\n",
      "body": "```suggestion\n  have h_ineq := h \u25b8 (leading_coeff_le_mahlerMeasure <| p.map (castRingHom \u2102))\n  rw [leadingCoeff_map_of_injective (castRingHom \u2102).injective_int, eq_intCast]\n```\n(minor golfing; possibly the `rw` line can be combined with the next after this)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "rw",
          "have"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1184,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  rw [leadingCoeff_map_of_injective (castRingHom \u2102).injective_int, eq_intCast] at this\n",
      "body": "```suggestion\n  rw [leadingCoeff_map_of_injective (castRingHom \u2102).injective_int, eq_intCast] at this\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1185,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "\r\n  have : p.leadingCoeff = 1 \u2228 p.leadingCoeff = -1 := abs_eq_abs.mp <|\r\n    abs_leadingCoeff_eq_one_of_mahlerMeasure_eq_one h\r\n",
      "body": "```suggestion\r\n  have : p.leadingCoeff = 1 \u2228 p.leadingCoeff = -1 := abs_eq_abs.mp <|\r\n    abs_leadingCoeff_eq_one_of_mahlerMeasure_eq_one h\r\n```\r\n(`<|` should be at the end of the line, not at the beginning)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1186,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "        mem_le_prod_of_one_le _ (fun a \u21a6 le_max_left 1 \u2016a\u2016) _ z hz\n",
      "body": "```suggestion\n        mem_le_prod_of_one_le _ (fun a \u21a6 le_max_left 1 \u2016a\u2016) _ z hz\n```\n(this is where you'll have some simplification from making the arguments implicit)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1187,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "/- We want to use `NumberField.Embeddings.pow_eq_one_of_norm_le_one` but it can only be applied to\nelements of number fields. We thus first construct the number field `K` obtained by adjoining `z`\nto `\u211a`.\n-/\n",
      "body": "```suggestion\n/- We want to use `NumberField.Embeddings.pow_eq_one_of_norm_le_one` but it can only be applied to\nelements of number fields. We thus first construct the number field `K` obtained by adjoining `z`\nto `\u211a`.\n-/\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1188,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  suffices \u2203 (n : \u2115) (_ : 0 < n), y ^ n = 1 by\n    obtain \u27e8n, hn\u2080, hn\u2081\u27e9 := this\n    exact \u27e8n, hn\u2080, congrArg (algebraMap K \u2102) hn\u2081\u27e9\n  refine NumberField.Embeddings.pow_eq_one_of_norm_le_one (x := y) K \u2102 (Subtype.coe_ne_coe.mp hz\u2080)\n    (coe_isIntegral_iff.mp <| isIntegral_of_mahlerMeasure_eq_one h hz)\n    fun \u03c6 \u21a6 norm_root_le_one_of_mahlerMeasure_eq_one h ?_\n  -- the conjugates of `y` are inside the closed unit disk\n",
      "body": "```suggestion\n  suffices \u2203 (n : \u2115) (_ : 0 < n), y ^ n = 1 by\n    obtain \u27e8n, hn\u2080, hn\u2081\u27e9 := this\n    exact \u27e8n, hn\u2080, congrArg (algebraMap K \u2102) hn\u2081\u27e9\n  refine NumberField.Embeddings.pow_eq_one_of_norm_le_one (x := y) K \u2102 (Subtype.coe_ne_coe.mp hz\u2080)\n    (coe_isIntegral_iff.mp <| isIntegral_of_mahlerMeasure_eq_one h hz)\n    fun \u03c6 \u21a6 norm_root_le_one_of_mahlerMeasure_eq_one h ?_\n  -- the conjugates of `y` are inside the closed unit disk\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "new_tactics": [
          "obtain",
          "refine"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1189,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  rw [mem_aroots] at hz \u22a2\n  refine \u27e8hz.1, ?_\u27e9\n  have H (\u03c8 : K \u2192+* \u2102) : \u03c8 ((aeval y) p) = (aeval (\u03c8 y)) p := by\n    conv_rhs => rw [\u2190 map_id (p := p)]\n    exact p.map_aeval_eq_aeval_map (by ext; simp) y\n  rw [\u2190 H, map_eq_zero_iff _ \u03c6.injective,\n    \u2190 map_eq_zero_iff _ (FaithfulSMul.algebraMap_injective \u21a5K \u2102), H]\n  exact hz.2\n",
      "body": "```suggestion\n  rw [mem_aroots] at hz \u22a2\n  refine \u27e8hz.1, ?_\u27e9\n  have H (\u03c8 : K \u2192+* \u2102) : \u03c8 ((aeval y) p) = (aeval (\u03c8 y)) p := by\n    conv_rhs => rw [\u2190 map_id (p := p)]\n    exact p.map_aeval_eq_aeval_map (by ext; simp) y\n  rw [\u2190 H, map_eq_zero_iff _ \u03c6.injective,\n    \u2190 map_eq_zero_iff _ (FaithfulSMul.algebraMap_injective \u21a5K \u2102), H]\n  exact hz.2\n```\n* The `convert`s resulting in an `Iff` are a bit ugly.\n* The way I have arranged it is closer to the usual Mathlib style (arguing \"backwards\").\n* Also, one ",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "ext",
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1190,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "    rwa [p.degree_map_eq_of_injective (castRingHom \u2102).injective_int]\n",
      "body": "```suggestion\n    rwa [p.degree_map_eq_of_injective (castRingHom \u2102).injective_int]\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1191,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "\r\n  exact (mem_aroots.mp h_z_root).2\r\n",
      "body": "```suggestion\r\n  exact (mem_aroots.mp h_z_root).2\r\n```\r\n(use the API instead of unfolding `aeval`)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 1194,
      "before_code": "rintro rfl\n      exact \u27e81, rfl\u27e9 }",
      "suggestion": "\r\n  have : Away (algebraMap R S z) T := by rwa [iff_of_associated h]\r\n",
      "body": "```suggestion\r\n  have : Away (algebraMap R S z) T := by rwa [iff_of_associated h]\r\n```",
      "path": "Mathlib/RingTheory/Localization/Away/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "exact",
          "rintro"
        ]
      }
    },
    {
      "id": 1195,
      "before_code": "rintro rfl\n      exact \u27e81, rfl\u27e9 }",
      "suggestion": "\r\n  have : Away (algebraMap R S y) S := away_of_isUnit_of_bijective _ h Function.bijective_id\r\n",
      "body": "```suggestion\r\n  have : Away (algebraMap R S y) S := away_of_isUnit_of_bijective _ h Function.bijective_id\r\n```",
      "path": "Mathlib/RingTheory/Localization/Away/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "exact",
          "rintro"
        ]
      }
    },
    {
      "id": 1196,
      "before_code": "rintro rfl\n      exact \u27e81, rfl\u27e9 }",
      "suggestion": "\r\n  have : Away (algebraMap R S x) S := away_of_isUnit_of_bijective _ h Function.bijective_id\r\n",
      "body": "```suggestion\r\n  have : Away (algebraMap R S x) S := away_of_isUnit_of_bijective _ h Function.bijective_id\r\n```",
      "path": "Mathlib/RingTheory/Localization/Away/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "exact",
          "rintro"
        ]
      }
    },
    {
      "id": 1198,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  have : e\u209a = b.repr.symm := by\r\n    ext i\r\n    trans IsLocalizedModule.map p.primeCompl l\u2081 l\u2082 e (l\u2081 (Finsupp.single i 1))\r\n    \u00b7 simp [e\u209a, -IsLocalizedModule.map_apply, l\u2081]\r\n    \u00b7 simp [l\u2082, e, hb, v]\r\n",
      "body": "I think this is more readable than squeezed simps.\r\n```suggestion\r\n  have : e\u209a = b.repr.symm := by\r\n    ext i\r\n    trans IsLocalizedModule.map p.primeCompl l\u2081 l\u2082 e (l\u2081 (Finsupp.single i 1))\r\n    \u00b7 simp [e\u209a, -IsLocalizedModule.map_apply, l\u2081]\r\n    \u00b7 simp [l\u2082, e, hb, v]\r\n```\r\n(if you change the definition of `e`)",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "have",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "have",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "have",
          "ext"
        ],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1199,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  have he\u209a : Function.Bijective e\u209a := this \u25b8 b.repr.symm.bijective\r\n",
      "body": "```suggestion\r\n  have he\u209a : Function.Bijective e\u209a := this \u25b8 b.repr.symm.bijective\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1200,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  let e : (\u03ba \u2192\u2080 S) \u2192\u2097[S] \u03a9[S\u2044R] :=\r\n",
      "body": "```suggestion\r\n  let e : (\u03ba \u2192\u2080 S) \u2192\u2097[S] \u03a9[S\u2044R] :=\r\n```\r\nWhy do you have parentheses around Omega? (in other places as well).",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "omega",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_omega"
        ],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1201,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  \u00b7 simp [\u2190 PrimeSpectrum.iSup_basicOpen_eq_top_iff, TopologicalSpace.Opens.ext_iff, Set.ext_iff]\r\n    grind\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [\u2190 PrimeSpectrum.iSup_basicOpen_eq_top_iff, TopologicalSpace.Opens.ext_iff, Set.ext_iff]\r\n    grind\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1203,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  -- `\u03a9[S\u209a\u2044R]` is projective, so free over the local ring `S\u209a` and\r\n",
      "body": "```suggestion\r\n  -- `\u03a9[S\u209a\u2044R]` is projective, so free over the local ring `S\u209a` and\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1204,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  obtain \u27e8\u03ba, a, b, hb\u27e9 := Module.exists_basis_of_span_of_flat _\r\n    (span_range_map_derivation_of_isLocalization R _ (Localization.AtPrime p) p.primeCompl)\r\n",
      "body": "```suggestion\r\n  obtain \u27e8\u03ba, a, b, hb\u27e9 := Module.exists_basis_of_span_of_flat _\r\n    (span_range_map_derivation_of_isLocalization R _ (Localization.AtPrime p) p.primeCompl)\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1205,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  exact \u27e8algebraMap S _ (a i), by simp +zetaDelta [IsLocalizedModule.map_linearCombination]\u27e9\r\n",
      "body": "```suggestion\r\n  exact \u27e8algebraMap S _ (a i), by simp +zetaDelta [IsLocalizedModule.map_linearCombination]\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 1213,
      "before_code": "rwa [hf i hi, map_add, hn, hm, \u2190 Int.cast_add, \u2190 Int.cast_one, Int.cast_inj] at contra\n  lia",
      "suggestion": "/-- An alternate constructor for `RootPairing.Base` which demands the axioms for roots but not for\ncoroots. (This requires the ambient root system to be crystallographic and reduced.) -/\n",
      "body": "```suggestion\n/-- An alternate constructor for `RootPairing.Base` which demands the axioms for roots but not for\ncoroots. (This requires the ambient root system to be crystallographic and reduced.) -/\n```",
      "path": "Mathlib/LinearAlgebra/RootSystem/BaseExists.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "constructor"
        ],
        "body_tactics": [
          "constructor"
        ],
        "new_tactics": [
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "cast_one",
          "rwa",
          "Int",
          "cast_inj",
          "map_add",
          "lia",
          "contra",
          "cast_add"
        ]
      }
    },
    {
      "id": 1215,
      "before_code": "rwa [hf i hi, map_add, hn, hm, \u2190 Int.cast_add, \u2190 Int.cast_one, Int.cast_inj] at contra\n  lia",
      "suggestion": "coroots. -/\n",
      "body": "I added this comment from a suggestion rather quickly, but I'm not so sure it is helpful now: the existence of a base trivially implies crystallographic and even reduced (because Mathlib's `RootPairing.Base` is slightly stronger than the informal literature).\n```suggestion\ncoroots. -/\n```",
      "path": "Mathlib/LinearAlgebra/RootSystem/BaseExists.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "cast_one",
          "rwa",
          "Int",
          "cast_inj",
          "map_add",
          "lia",
          "contra",
          "cast_add"
        ]
      }
    },
    {
      "id": 1217,
      "before_code": "theorem toCompacts_injective : Function.Injective (toCompacts (\u03b1 := \u03b1)) :=\n  .of_comp (f := SetLike.coe) SetLike.coe_injective",
      "suggestion": "\r\n@[simp]\r\ntheorem range_toCompacts : range (toCompacts (\u03b1 := \u03b1)) = {\u22a5}\u1d9c := by\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem range_toCompacts : range (toCompacts (\u03b1 := \u03b1)) = {\u22a5}\u1d9c := by\r\n```",
      "path": "Mathlib/Topology/Sets/Compacts.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "Injective",
          "toCompacts",
          "theorem",
          "SetLike",
          "toCompacts_injective",
          "of_comp",
          "Function",
          "coe",
          "coe_injective"
        ]
      }
    },
    {
      "id": 1218,
      "before_code": "theorem coe_bot : (\u2191(\u22a5 : Compacts \u03b1) : Set \u03b1) = \u2205 :=\n  rfl",
      "suggestion": "\r\n@[simp]\r\ntheorem coe_nonempty {s : Compacts \u03b1} : (s : Set \u03b1).Nonempty \u2194 s \u2260 \u22a5 :=\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem coe_nonempty {s : Compacts \u03b1} : (s : Set \u03b1).Nonempty \u2194 s \u2260 \u22a5 :=\r\n```",
      "path": "Mathlib/Topology/Sets/Compacts.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "coe_bot",
          "theorem",
          "Set",
          "rfl",
          "Compacts"
        ]
      }
    },
    {
      "id": 1219,
      "before_code": "obtain \u27e8u, hut, hu, hu'\u27e9 := decomposition_erase_inf ht\n  exact \u27e8u, hu, fun _ hi \u21a6 ht' (hut hi), ht''.mono hut, hu'\u27e9\n\nlemma IsLasker.minimal [DecidableEq (Ideal R)] (h : IsLasker R) (I : Ideal R) :\n    \u2203 t : Finset (Ideal R), t.inf id = I \u2227 (\u2200 \u2983J\u2984, J \u2208 t \u2192 J.IsPrimary) \u2227\n      ((t : Set (Ideal R)).Pairwise ((\u00b7 \u2260 \u00b7) on radical)) \u2227\n      (\u2200 \u2983J\u2984, J \u2208 t \u2192 \u00ac (t.erase J).inf id \u2264 J) := by\n  obtain \u27e8s, hs, hs'\u27e9 := h I\n  exact exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs hs'",
      "suggestion": "\r\nare primary, have pairwise distinct radicals, and removing any ideal changes the intersection. -/\r\n",
      "body": "```suggestion\r\nare primary, have pairwise distinct radicals, and removing any ideal changes the intersection. -/\r\n```",
      "path": "Mathlib/RingTheory/Lasker.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "IsLasker",
          "erase",
          "lemma",
          "Ideal",
          "mono",
          "radical",
          "exact",
          "inf",
          "Finset",
          "hut",
          "Set",
          "IsPrimary",
          "obtain",
          "Pairwise",
          "minimal",
          "DecidableEq",
          "exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition",
          "decomposition_erase_inf"
        ]
      }
    },
    {
      "id": 1220,
      "before_code": "obtain \u27e8u, hut, hu, hu'\u27e9 := decomposition_erase_inf ht\n  exact \u27e8u, hu, fun _ hi \u21a6 ht' (hut hi), ht''.mono hut, hu'\u27e9\n\nlemma IsLasker.minimal [DecidableEq (Ideal R)] (h : IsLasker R) (I : Ideal R) :\n    \u2203 t : Finset (Ideal R), t.inf id = I \u2227 (\u2200 \u2983J\u2984, J \u2208 t \u2192 J.IsPrimary) \u2227\n      ((t : Set (Ideal R)).Pairwise ((\u00b7 \u2260 \u00b7) on radical)) \u2227\n      (\u2200 \u2983J\u2984, J \u2208 t \u2192 \u00ac (t.erase J).inf id \u2264 J) := by\n  obtain \u27e8s, hs, hs'\u27e9 := h I\n  exact exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs hs'",
      "suggestion": "\r\n  obtain \u27e8s, hs\u2081, hs\u2082\u27e9 := h I\r\n  obtain \u27e8t, h\u2081, h\u2082, h\u2083, h\u2084\u27e9 :=\r\n    exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs1 hs2\r\n  exact \u27e8t, h\u2081, h\u2082, h\u2083, h\u2084\u27e9\r\n",
      "body": "I think you're more familiar with mathlib style than I am, but I've been told to subscript indices before\r\n```suggestion\r\n  obtain \u27e8s, hs\u2081, hs\u2082\u27e9 := h I\r\n  obtain \u27e8t, h\u2081, h\u2082, h\u2083, h\u2084\u27e9 :=\r\n    exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs1 hs2\r\n  exact \u27e8t, h\u2081, h\u2082, h\u2083, h\u2084\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Lasker.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain"
        ],
        "body_tactics": [
          "exact",
          "obtain"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "IsLasker",
          "erase",
          "lemma",
          "Ideal",
          "mono",
          "radical",
          "exact",
          "inf",
          "Finset",
          "hut",
          "Set",
          "IsPrimary",
          "obtain",
          "Pairwise",
          "minimal",
          "DecidableEq",
          "exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition",
          "decomposition_erase_inf"
        ]
      }
    },
    {
      "id": 1222,
      "before_code": "end Group",
      "suggestion": "\r\ntheorem mulIndicator_singleton (i : \u03b9) (x : M) :\r\n",
      "body": "If we don't need to disambiguate, then we usually don't describe the RHS in the name.\r\n```suggestion\r\ntheorem mulIndicator_singleton (i : \u03b9) (x : M) :\r\n```",
      "path": "Mathlib/Algebra/Group/Indicator.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "Group"
        ]
      }
    },
    {
      "id": 1224,
      "before_code": "finsum (fun d \u21a6 coeff d f \u2022 (constantCoeff (d.prod fun s e => (a s) ^ e))) := by\n  simp only [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_subst ha f 0]",
      "suggestion": "\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n",
      "body": "```suggestion\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Substitution.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "coeff",
          "prod",
          "coeff_zero_eq_constantCoeff_apply",
          "coeff_subst",
          "simp",
          "finsum",
          "constantCoeff",
          "only"
        ]
      }
    },
    {
      "id": 1232,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "lemma mem_orthogonal_iff (v : E) : v \u2208 (K.toSubmodule)\u15ee \u2194 v \u2208 K\u15ee := Iff.rfl\n",
      "body": "```suggestion\nlemma mem_orthogonal_iff (v : E) : v \u2208 (K.toSubmodule)\u15ee \u2194 v \u2208 K\u15ee := Iff.rfl\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 1233,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "theorem mem_orthogonal (v : E) : v \u2208 K\u15ee \u2194 \u2200 u \u2208 K, \u27eau, v\u27eb = 0 := Iff.rfl\n",
      "body": "```suggestion\ntheorem mem_orthogonal (v : E) : v \u2208 K\u15ee \u2194 \u2200 u \u2208 K, \u27eau, v\u27eb = 0 := Iff.rfl\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 1234,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "theorem mem_orthogonal' (v : E) : v \u2208 K\u15ee \u2194 \u2200 u \u2208 K, \u27eav, u\u27eb = 0 :=\n  Submodule.mem_orthogonal' (K.toSubmodule) v\n",
      "body": "```suggestion\ntheorem mem_orthogonal' (v : E) : v \u2208 K\u15ee \u2194 \u2200 u \u2208 K, \u27eav, u\u27eb = 0 :=\n  Submodule.mem_orthogonal' (K.toSubmodule) v\n```\nYou can apply directly the Submodule version as it is defeq to the current one thanks to your definition of orthogonal. You can do the same in many statements below.",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 1241,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n",
      "body": "```suggestion\n    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n```\nMost of the time, `by exact` is useless.",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 1246,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "lemma orthogonal_toSubmodule_eq : K.orthogonal.toSubmodule = K.toSubmodule.orthogonal := rfl\n",
      "body": "```suggestion\nlemma orthogonal_toSubmodule_eq : K.orthogonal.toSubmodule = K.toSubmodule.orthogonal := rfl\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 1250,
      "before_code": "integer `z` (in the supertype) to `\u2115` (the subtype), given a proof that `z \u2265 0`;\npropositions concerning `z` will still be over `\u2124`. `zify` changes propositions about `\u2115` (the\nsubtype) to propositions about `\u2124` (the supertype), without changing the type of any variable.",
      "suggestion": "The `norm_cast` tactic can be used after `lift` to normalize introduced casts.\n",
      "body": "```suggestion\nThe `norm_cast` tactic can be used after `lift` to normalize introduced casts.\n```",
      "path": "Mathlib/Tactic/Lift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "norm_cast"
        ],
        "body_tactics": [
          "norm_cast"
        ],
        "new_tactics": [
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "order",
          "nat",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "supertype",
          "type",
          "concerning",
          "changing",
          "subtype",
          "changes",
          "variable",
          "over",
          "integer",
          "that",
          "given",
          "will",
          "about",
          "propositions",
          "zify",
          "without",
          "any",
          "still",
          "proof"
        ]
      }
    },
    {
      "id": 1253,
      "before_code": "def homMk {X Y : P.FullSubcategory} (f : X.obj \u27f6 Y.obj) : X \u27f6 Y where\n  hom := f",
      "suggestion": "lemma homMk_surjective {X Y : P.FullSubcategory} :\n    Function.Surjective (homMk : (X.obj \u27f6 Y.obj) \u2192 _) :=\n  fun f \u21a6 \u27e8f.hom, rfl\u27e9\n",
      "body": "```suggestion\nlemma homMk_surjective {X Y : P.FullSubcategory} :\n    Function.Surjective (homMk : (X.obj \u27f6 Y.obj) \u2192 _) :=\n  fun f \u21a6 \u27e8f.hom, rfl\u27e9\n```\nThis is def-eq, but probably slightly more useful?",
      "path": "Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hom",
          "def",
          "FullSubcategory",
          "homMk",
          "obj"
        ]
      }
    },
    {
      "id": 1255,
      "before_code": "variable {\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} [Preorder \u03b9] {f : Filtration \u03b9 m}",
      "suggestion": "protected theorem measurable {i : \u03b9} (hf : Adapted f u) : Measurable[m] (u i) :=\n  (hf i).mono (f.le i) (by rfl)\n\ntheorem measurable_le {i j : \u03b9} (hf : Adapted f u) (hij : i \u2264 j) : Measurable[f j] (u i) :=\n  (hf i).mono (f.mono hij) (by rfl)\n",
      "body": "```suggestion\nprotected theorem measurable {i : \u03b9} (hf : Adapted f u) : Measurable[m] (u i) :=\n  (hf i).mono (f.le i) (by rfl)\n\ntheorem measurable_le {i j : \u03b9} (hf : Adapted f u) (hij : i \u2264 j) : Measurable[f j] (u i) :=\n  (hf i).mono (f.mono hij) (by rfl)\n```",
      "path": "Mathlib/Probability/Process/Adapted.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "variable",
          "Filtration",
          "Type",
          "Preorder",
          "MeasurableSpace"
        ]
      }
    },
    {
      "id": 1263,
      "before_code": "F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]",
      "suggestion": "\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n",
      "body": "```suggestion\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n```\r\nvery minor, but this way you don\u2019t have to guess what the `rwa` is proving from the source.",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isoAdd",
          "inv",
          "shiftFunctorAdd",
          "app",
          "_eq_shiftFunctorAdd",
          "map",
          "simp",
          "_inv_app",
          "only"
        ]
      }
    },
    {
      "id": 1264,
      "before_code": "F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]",
      "suggestion": "\r\n  simp_rw [\u2190 Functor.map_comp_assoc]\r\n",
      "body": "```suggestion\r\n  simp_rw [\u2190 Functor.map_comp_assoc]\r\n```",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isoAdd",
          "inv",
          "shiftFunctorAdd",
          "app",
          "_eq_shiftFunctorAdd",
          "map",
          "simp",
          "_inv_app",
          "only"
        ]
      }
    },
    {
      "id": 1265,
      "before_code": "end Functor",
      "suggestion": "\r\n@[simp, reassoc]\r\n",
      "body": "```suggestion\r\n@[simp, reassoc]\r\n```",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Functor"
        ]
      }
    },
    {
      "id": 1266,
      "before_code": "end Functor",
      "suggestion": "\r\n@[simp, reassoc]\r\n",
      "body": "```suggestion\r\n@[simp, reassoc]\r\n```",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Functor"
        ]
      }
    },
    {
      "id": 1268,
      "before_code": "end GrothendieckTopology",
      "suggestion": "\r\n/-- If the pairwise pullbacks exist, this is the pre-`1`-hypercover where the covers\r\n",
      "body": "```suggestion\r\n/-- If the pairwise pullbacks exist, this is the pre-`1`-hypercover where the covers\r\n```\r\nFeel free to ignore, but I feel that the word \"naive\" should be avoided in docstrings.",
      "path": "Mathlib/CategoryTheory/Sites/Hypercover/One.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "GrothendieckTopology"
        ]
      }
    },
    {
      "id": 1273,
      "before_code": "abbrev fromPath {x\u2080 x\u2081 : X} (p : Path.Homotopic.Quotient x\u2080 x\u2081) :\n    FundamentalGroupoid.mk x\u2080 \u27f6 FundamentalGroupoid.mk x\u2081 := p",
      "suggestion": "\r\n    fromPath (Path.Homotopic.Quotient.mk f) = fromPath (Path.Homotopic.Quotient.mk g) \u2194\r\n      f.Homotopic g :=\r\n",
      "body": "```suggestion\r\n    fromPath (Path.Homotopic.Quotient.mk f) = fromPath (Path.Homotopic.Quotient.mk g) \u2194\r\n      f.Homotopic g :=\r\n```\r\n\r\nThere have been some changes (#31574) and now the simp normal form is `Path.Homotopic.Quotient.mk f` instead of `\u27e6f\u27e7` (the two are definitionally equal, but not at reducible transparency). In practice, this means that use of automation will more likely drive you into this form rather than the one you are currently using, and it will make it slightly easier to app",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "apply",
          "have",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simp"
        ],
        "keywords": [
          "FundamentalGroupoid",
          "abbrev",
          "Quotient",
          "fromPath",
          "Path",
          "Homotopic"
        ]
      }
    },
    {
      "id": 1287,
      "before_code": "section Semiring\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {N N\u2081 N\u2082 P P\u2081 P\u2082 : Submodule R M}\n\n/-- `N.colon P` is the ideal of all elements `r : R` such that `r \u2022 P \u2286 N`. -/\ndef colon (N P : Submodule R M) : Ideal R where\n  carrier := {r : R | (r \u2022 P : Set M) \u2286 N}\n  add_mem' ha hb :=\n    (Set.add_smul_subset _ _ _).trans ((Set.add_subset_add ha hb).trans_eq (by simp))\n  zero_mem' := by simp [Set.zero_smul_set P.nonempty]\n  smul_mem' r := by\n    simp only [Set.mem_setOf_eq, smul_eq_mul, mul_smul, Set.smul_set_subset_iff]\n    intro x hx y hy\n    exact N.smul_mem _ (hx hy)\n\ntheorem mem_colon {r} : r \u2208 N.colon P \u2194 \u2200 p \u2208 P, r \u2022 p \u2208 N := Set.smul_set_subset_iff\n\ninstance (priority := low) : (N.colon P).IsTwoSided where\n  mul_mem_of_left {r} s hr p hp := by\n    obtain \u27e8p, hp, rfl\u27e9 := hp\n    exact hr \u27e8_, P.smul_mem _ hp, (mul_smul ..).symm\u27e9\n\n@[simp]\ntheorem colon_top {I : Ideal R} [I.IsTwoSided] : I.colon \u22a4 = I := by\n  simp_rw [SetLike.ext_iff, mem_colon, smul_eq_mul]\n  exact fun x \u21a6 \u27e8fun h \u21a6 mul_one x \u25b8 h 1 trivial, fun h _ _ \u21a6 I.mul_mem_right _ h\u27e9\n\n@[simp]\ntheorem colon_bot : colon \u22a5 N = N.annihilator := by\n  simp_rw [SetLike.ext_iff, mem_colon, mem_annihilator, mem_bot, forall_const]\n\ntheorem colon_mono (hn : N\u2081 \u2264 N\u2082) (hp : P\u2081 \u2264 P\u2082) : N\u2081.colon P\u2082 \u2264 N\u2082.colon P\u2081 := fun _ hrnp =>\n  mem_colon.2 fun p\u2081 hp\u2081 => hn <| mem_colon.1 hrnp p\u2081 <| hp hp\u2081\n\ntheorem _root_.Ideal.le_colon {I J : Ideal R} [I.IsTwoSided] : I \u2264 I.colon J := by\n  calc I = I.colon \u22a4 := colon_top.symm\n       _ \u2264 I.colon J := colon_mono (le_refl I) le_top\n\nend Semiring\n\nsection CommSemiring\n\nvariable [CommSemiring R] [AddCommMonoid M] [Module R M]\nvariable {N P : Submodule R M}\n\ntheorem mem_colon' {r} : r \u2208 N.colon P \u2194 P \u2264 comap (r \u2022 (LinearMap.id : M \u2192\u2097[R] M)) N :=\n  mem_colon\n\ntheorem iInf_colon_iSup (\u03b9\u2081 : Sort*) (f : \u03b9\u2081 \u2192 Submodule R M) (\u03b9\u2082 : Sort*)\n    (g : \u03b9\u2082 \u2192 Submodule R M) : (\u2a05 i, f i).colon (\u2a06 j, g j) = \u2a05 (i) (j), (f i).colon (g j) :=\n  le_antisymm (le_iInf fun _ => le_iInf fun _ => c",
      "suggestion": "\r\n/-- A variant for arbitrary sets in commutative semirings -/\r\ntheorem colon_bot' : colon (\u22a5 : Submodule R M) S = (Submodule.span R S).annihilator := by\r\n",
      "body": "```suggestion\r\n/-- A variant for arbitrary sets in commutative semirings -/\r\ntheorem colon_bot' : colon (\u22a5 : Submodule R M) S = (Submodule.span R S).annihilator := by\r\n```\r\nIn general we would prefer if primed lemmas are explained about their difference with the original lemma.",
      "path": "Mathlib/RingTheory/Ideal/Colon.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "obtain",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain",
          "simp",
          "intro",
          "exact",
          "have"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mul_mem_of_left",
          "calc",
          "smul_set_subset_iff",
          "le_refl",
          "add_smul_subset",
          "annihilator",
          "add_subset_add",
          "map_le_iff_le_comap",
          "Ideal",
          "le_top",
          "have",
          "priority",
          "intro",
          "such",
          "CommSemiring",
          "trivial",
          "def",
          "that",
          "mul_one",
          "simp",
          "le_iInf",
          "rfl",
          "mul_mem_right",
          "IsTwoSided",
          "theorem",
          "trans",
          "mul_smul",
          "smul_mem",
          "Sort",
          "end",
          "nonempty",
          "iSup_le",
          "_root_",
          "variable",
          "mem_bot",
          "mem_setOf_eq",
          "ext_iff",
          "mem_colon",
          "zero_smul_set",
          "le_antisymm",
          "iInf_colon_iSup",
          "elements",
          "mem_annihilator",
          "colon_mono",
          "colon_top",
          "simp_rw",
          "trans_eq",
          "SetLike",
          "exact"
        ]
      }
    },
    {
      "id": 1288,
      "before_code": "section Semiring\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {N N\u2081 N\u2082 P P\u2081 P\u2082 : Submodule R M}\n\n/-- `N.colon P` is the ideal of all elements `r : R` such that `r \u2022 P \u2286 N`. -/\ndef colon (N P : Submodule R M) : Ideal R where\n  carrier := {r : R | (r \u2022 P : Set M) \u2286 N}\n  add_mem' ha hb :=\n    (Set.add_smul_subset _ _ _).trans ((Set.add_subset_add ha hb).trans_eq (by simp))\n  zero_mem' := by simp [Set.zero_smul_set P.nonempty]\n  smul_mem' r := by\n    simp only [Set.mem_setOf_eq, smul_eq_mul, mul_smul, Set.smul_set_subset_iff]\n    intro x hx y hy\n    exact N.smul_mem _ (hx hy)\n\ntheorem mem_colon {r} : r \u2208 N.colon P \u2194 \u2200 p \u2208 P, r \u2022 p \u2208 N := Set.smul_set_subset_iff\n\ninstance (priority := low) : (N.colon P).IsTwoSided where\n  mul_mem_of_left {r} s hr p hp := by\n    obtain \u27e8p, hp, rfl\u27e9 := hp\n    exact hr \u27e8_, P.smul_mem _ hp, (mul_smul ..).symm\u27e9\n\n@[simp]\ntheorem colon_top {I : Ideal R} [I.IsTwoSided] : I.colon \u22a4 = I := by\n  simp_rw [SetLike.ext_iff, mem_colon, smul_eq_mul]\n  exact fun x \u21a6 \u27e8fun h \u21a6 mul_one x \u25b8 h 1 trivial, fun h _ _ \u21a6 I.mul_mem_right _ h\u27e9\n\n@[simp]\ntheorem colon_bot : colon \u22a5 N = N.annihilator := by\n  simp_rw [SetLike.ext_iff, mem_colon, mem_annihilator, mem_bot, forall_const]\n\ntheorem colon_mono (hn : N\u2081 \u2264 N\u2082) (hp : P\u2081 \u2264 P\u2082) : N\u2081.colon P\u2082 \u2264 N\u2082.colon P\u2081 := fun _ hrnp =>\n  mem_colon.2 fun p\u2081 hp\u2081 => hn <| mem_colon.1 hrnp p\u2081 <| hp hp\u2081\n\ntheorem _root_.Ideal.le_colon {I J : Ideal R} [I.IsTwoSided] : I \u2264 I.colon J := by\n  calc I = I.colon \u22a4 := colon_top.symm\n       _ \u2264 I.colon J := colon_mono (le_refl I) le_top\n\nend Semiring\n\nsection CommSemiring\n\nvariable [CommSemiring R] [AddCommMonoid M] [Module R M]\nvariable {N P : Submodule R M}\n\ntheorem mem_colon' {r} : r \u2208 N.colon P \u2194 P \u2264 comap (r \u2022 (LinearMap.id : M \u2192\u2097[R] M)) N :=\n  mem_colon\n\ntheorem iInf_colon_iSup (\u03b9\u2081 : Sort*) (f : \u03b9\u2081 \u2192 Submodule R M) (\u03b9\u2082 : Sort*)\n    (g : \u03b9\u2082 \u2192 Submodule R M) : (\u2a05 i, f i).colon (\u2a06 j, g j) = \u2a05 (i) (j), (f i).colon (g j) :=\n  le_antisymm (le_iInf fun _ => le_iInf fun _ => c",
      "suggestion": "\r\n@[simp]\r\ntheorem colon_span : N.colon (span R S) = N.colon S := by\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem colon_span : N.colon (span R S) = N.colon S := by\r\n```",
      "path": "Mathlib/RingTheory/Ideal/Colon.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "obtain",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "have",
          "intro"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mul_mem_of_left",
          "calc",
          "smul_set_subset_iff",
          "le_refl",
          "add_smul_subset",
          "annihilator",
          "add_subset_add",
          "map_le_iff_le_comap",
          "Ideal",
          "le_top",
          "have",
          "priority",
          "intro",
          "such",
          "CommSemiring",
          "trivial",
          "def",
          "that",
          "mul_one",
          "simp",
          "le_iInf",
          "rfl",
          "mul_mem_right",
          "IsTwoSided",
          "theorem",
          "trans",
          "mul_smul",
          "smul_mem",
          "Sort",
          "end",
          "nonempty",
          "iSup_le",
          "_root_",
          "variable",
          "mem_bot",
          "mem_setOf_eq",
          "ext_iff",
          "mem_colon",
          "zero_smul_set",
          "le_antisymm",
          "iInf_colon_iSup",
          "elements",
          "mem_annihilator",
          "colon_mono",
          "colon_top",
          "simp_rw",
          "trans_eq",
          "SetLike",
          "exact"
        ]
      }
    },
    {
      "id": 1289,
      "before_code": "section Semiring\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {N N\u2081 N\u2082 P P\u2081 P\u2082 : Submodule R M}\n\n/-- `N.colon P` is the ideal of all elements `r : R` such that `r \u2022 P \u2286 N`. -/\ndef colon (N P : Submodule R M) : Ideal R where\n  carrier := {r : R | (r \u2022 P : Set M) \u2286 N}\n  add_mem' ha hb :=\n    (Set.add_smul_subset _ _ _).trans ((Set.add_subset_add ha hb).trans_eq (by simp))\n  zero_mem' := by simp [Set.zero_smul_set P.nonempty]\n  smul_mem' r := by\n    simp only [Set.mem_setOf_eq, smul_eq_mul, mul_smul, Set.smul_set_subset_iff]\n    intro x hx y hy\n    exact N.smul_mem _ (hx hy)\n\ntheorem mem_colon {r} : r \u2208 N.colon P \u2194 \u2200 p \u2208 P, r \u2022 p \u2208 N := Set.smul_set_subset_iff\n\ninstance (priority := low) : (N.colon P).IsTwoSided where\n  mul_mem_of_left {r} s hr p hp := by\n    obtain \u27e8p, hp, rfl\u27e9 := hp\n    exact hr \u27e8_, P.smul_mem _ hp, (mul_smul ..).symm\u27e9\n\n@[simp]\ntheorem colon_top {I : Ideal R} [I.IsTwoSided] : I.colon \u22a4 = I := by\n  simp_rw [SetLike.ext_iff, mem_colon, smul_eq_mul]\n  exact fun x \u21a6 \u27e8fun h \u21a6 mul_one x \u25b8 h 1 trivial, fun h _ _ \u21a6 I.mul_mem_right _ h\u27e9\n\n@[simp]\ntheorem colon_bot : colon \u22a5 N = N.annihilator := by\n  simp_rw [SetLike.ext_iff, mem_colon, mem_annihilator, mem_bot, forall_const]\n\ntheorem colon_mono (hn : N\u2081 \u2264 N\u2082) (hp : P\u2081 \u2264 P\u2082) : N\u2081.colon P\u2082 \u2264 N\u2082.colon P\u2081 := fun _ hrnp =>\n  mem_colon.2 fun p\u2081 hp\u2081 => hn <| mem_colon.1 hrnp p\u2081 <| hp hp\u2081\n\ntheorem _root_.Ideal.le_colon {I J : Ideal R} [I.IsTwoSided] : I \u2264 I.colon J := by\n  calc I = I.colon \u22a4 := colon_top.symm\n       _ \u2264 I.colon J := colon_mono (le_refl I) le_top",
      "suggestion": "\r\ntheorem colon_mono_right (hn : N\u2081 \u2264 N\u2082) (hs : S\u2081 \u2286 S\u2082) : N\u2081.colon S\u2082 \u2264 N\u2082.colon S\u2081 :=\r\n",
      "body": "```suggestion\r\ntheorem colon_mono_right (hn : N\u2081 \u2264 N\u2082) (hs : S\u2081 \u2286 S\u2082) : N\u2081.colon S\u2082 \u2264 N\u2082.colon S\u2081 :=\r\n```\r\nIt's also useful to have `colon_mono_left`.",
      "path": "Mathlib/RingTheory/Ideal/Colon.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mul_mem_of_left",
          "colon",
          "calc",
          "smul_set_subset_iff",
          "le_refl",
          "colon_bot",
          "add_smul_subset",
          "obtain",
          "annihilator",
          "nonempty",
          "zero_mem",
          "elements",
          "add_subset_add",
          "section",
          "symm",
          "Ideal",
          "_root_",
          "mem_annihilator",
          "colon_mono",
          "le_top",
          "colon_top",
          "Submodule",
          "priority",
          "intro",
          "ideal",
          "simp_rw",
          "such",
          "smul_eq_mul",
          "trivial",
          "def",
          "variable",
          "trans_eq",
          "SetLike",
          "forall_const",
          "Semiring",
          "mem_bot",
          "that",
          "mul_one",
          "simp",
          "rfl",
          "mul_mem_right",
          "IsTwoSided",
          "only",
          "low",
          "AddCommMonoid",
          "mem_setOf_eq",
          "theorem",
          "ext_iff",
          "exact"
        ]
      }
    },
    {
      "id": 1293,
      "before_code": "/-! ### Exceptional Cartan matrices -/",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis should have been flagged by the `emptyLine` linter.",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Cartan",
          "Exceptional",
          "matrices"
        ]
      }
    },
    {
      "id": 1296,
      "before_code": "ext x\n  simp_all",
      "suggestion": "\r\n    (G : Type*) [Monoid G] [MulSemiringAction G R] [SMulCommClass G S R] (f : S[X]) :\r\n",
      "body": "```suggestion\r\n    (G : Type*) [Monoid G] [MulSemiringAction G R] [SMulCommClass G S R] (f : S[X]) :\r\n```\r\nshould work?",
      "path": "Mathlib/Algebra/Polynomial/Roots.lean",
      "tags": {
        "before_tactics": [
          "simp_all",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp_all",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp_all",
          "ext"
        ]
      }
    },
    {
      "id": 1312,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm",
      "suggestion": "  lift P.degree to \u2115 with n hn\n  \u00b7 contrapose hP\n    simp [hP]\n  simp [hP, \u2190 WithBot.coe_one, \u2190 WithBot.coe_add]\n",
      "body": "This also works:\n```suggestion\n  lift P.degree to \u2115 with n hn\n  \u00b7 contrapose hP\n    simp [hP]\n  simp [hP, \u2190 WithBot.coe_one, \u2190 WithBot.coe_add]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "eval",
          "Polynomial",
          "open",
          "symm",
          "scoped",
          "eq_interpolate",
          "interpolate",
          "insert_subset_iff",
          "InjOn",
          "sdiff_singleton_eq_erase",
          "hvs",
          "card",
          "Classical",
          "interpolate_poly_eq_self",
          "theorem",
          "exact",
          "Set",
          "degree",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 1314,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm\n\ntheorem leadingCoeff_eq_sum\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : s.card = P.degree + 1) :\n    P.leadingCoeff = \u2211 i \u2208 s, (P.eval (v i)) / \u220f j \u2208 s.erase i, ((v i) - (v j)) := by\n  have P_degree : P.degree = \u2191(s.card - 1) := by\n    cases h : P.degree\n    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n  have P_natDegree : P.natDegree = s.card - 1 := natDegree_eq_of_degree_eq_some P_degree\n  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n  rw [leadingCoeff, P_natDegree]\n  rw (occs := [1]) [\u2190 interpolate_poly_eq_self hvs hP']\n  rw [interpolate_apply, finset_sum_coeff]\n  congr! with i hi\n  rw [coeff_C_mul, \u2190 natDegree_basis hvs hi, \u2190 leadingCoeff, leadingCoeff_basis hvs hi]\n  field_simp",
      "suggestion": "\r\n  lift P.degree to \u2115 using (by contrapose! hP; simp [hP]) with deg hdeg\r\n",
      "body": "```suggestion\r\n  lift P.degree to \u2115 using (by contrapose! hP; simp [hP]) with deg hdeg\r\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "field_simp",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp",
          "congr"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "field_simp",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "congr"
        ],
        "topics": [
          "nat",
          "set_theory",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "leadingCoeff_basis",
          "interpolate_apply",
          "eval",
          "leadingCoeff_eq_sum",
          "simp_all",
          "Polynomial",
          "open",
          "natDegree_eq_of_degree_eq_some",
          "symm",
          "occs",
          "coe_inj",
          "scoped",
          "cases",
          "Nat",
          "grind",
          "have",
          "eq_interpolate",
          "case",
          "interpolate",
          "cast_withBot",
          "by_contra",
          "insert_subset_iff",
          "InjOn",
          "finset_sum_coeff",
          "erase",
          "sdiff_singleton_eq_erase",
          "WithBot",
          "bot",
          "hvs",
          "simp",
          "leadingCoeff",
          "P_natDegree",
          "congr",
          "natDegree_basis",
          "degree",
          "card",
          "s_card",
          "Classical",
          "natDegree",
          "field_simp",
          "interpolate_poly_eq_self",
          "theorem",
          "exact",
          "cast_lt",
          "Set",
          "suffices",
          "coeff_C_mul",
          "coe",
          "P_degree"
        ]
      }
    },
    {
      "id": 1315,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm",
      "suggestion": "\r\n  rw (occs := [1]) [eq_interpolate hvs hP]\r\n  rw [interpolate_apply, finset_sum_coeff]\r\n  congr! with i hi\r\n  rw [coeff_C_mul, \u2190 natDegree_basis hvs hi, \u2190 leadingCoeff, leadingCoeff_basis hvs hi]\r\n  field_simp\r\n",
      "body": "The second arm of the rw is unnecessary--it's proving a hypothesis.\r\n```suggestion\r\n  rw (occs := [1]) [eq_interpolate hvs hP]\r\n  rw [interpolate_apply, finset_sum_coeff]\r\n  congr! with i hi\r\n  rw [coeff_C_mul, \u2190 natDegree_basis hvs hi, \u2190 leadingCoeff, leadingCoeff_basis hvs hi]\r\n  field_simp\r\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "congr",
          "field_simp",
          "rw"
        ],
        "body_tactics": [
          "congr",
          "field_simp",
          "rw"
        ],
        "new_tactics": [
          "congr",
          "rw",
          "field_simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "mpr",
          "eval",
          "Polynomial",
          "open",
          "symm",
          "scoped",
          "eq_interpolate",
          "interpolate",
          "insert_subset_iff",
          "InjOn",
          "sdiff_singleton_eq_erase",
          "hvs",
          "card",
          "Classical",
          "interpolate_poly_eq_self",
          "theorem",
          "exact",
          "Set",
          "degree",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 1324,
      "before_code": "rw [I_sq]\n    ring",
      "suggestion": "\r\n@[simp] theorem _root_.RCLike.to_complex_nonneg_iff {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {a : \ud835\udd5c} :\r\n",
      "body": "```suggestion\r\n@[simp] theorem _root_.RCLike.to_complex_nonneg_iff {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {a : \ud835\udd5c} :\r\n```",
      "path": "Mathlib/Analysis/Complex/Basic.lean",
      "tags": {
        "before_tactics": [
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "ring",
          "I_sq"
        ]
      }
    },
    {
      "id": 1328,
      "before_code": "namespace RCLike",
      "suggestion": "\r\n@[simp] theorem map_apply_real (x : \u211d) : map \u211d K x = x := by simp [im, re]\r\n",
      "body": "```suggestion\r\n@[simp] theorem map_apply_real (x : \u211d) : map \u211d K x = x := by simp [im, re]\r\n```",
      "path": "Mathlib/Analysis/RCLike/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "RCLike",
          "namespace"
        ]
      }
    },
    {
      "id": 1337,
      "before_code": "calc \u27e6p\u2081\u27e7\n      _ = trans (trans \u27e6p\u2081\u27e7 (symm \u27e6p\u2082\u27e7)) \u27e6p\u2082\u27e7 := by simp\n      _ = \u27e6p\u2082\u27e7 := by grind",
      "suggestion": "\r\n/-- We say that a set is simply connected if it's a simply connected topological space\r\n",
      "body": "```suggestion\r\n/-- We say that a set is simply connected if it's a simply connected topological space\r\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "grind",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "calc",
          "grind",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 1338,
      "before_code": "calc \u27e6p\u2081\u27e7\n      _ = trans (trans \u27e6p\u2081\u27e7 (symm \u27e6p\u2082\u27e7)) \u27e6p\u2082\u27e7 := by simp\n      _ = \u27e6p\u2082\u27e7 := by grind",
      "suggestion": "\r\n    {s : Set X} :\r\n    IsSimplyConnected (f '' s) \u2194 IsSimplyConnected s :=\r\n",
      "body": "```suggestion\r\n    {s : Set X} :\r\n    IsSimplyConnected (f '' s) \u2194 IsSimplyConnected s :=\r\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "grind",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "calc",
          "grind",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 1339,
      "before_code": "calc \u27e6p\u2081\u27e7\n      _ = trans (trans \u27e6p\u2081\u27e7 (symm \u27e6p\u2082\u27e7)) \u27e6p\u2082\u27e7 := by simp\n      _ = \u27e6p\u2082\u27e7 := by grind",
      "suggestion": "\r\n      prop' := by simp }\u27e9\r\n",
      "body": "```suggestion\r\n      prop' := by simp }\u27e9\r\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "grind"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "calc",
          "grind",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 1340,
      "before_code": "calc \u27e6p\u2081\u27e7\n      _ = trans (trans \u27e6p\u2081\u27e7 (symm \u27e6p\u2082\u27e7)) \u27e6p\u2082\u27e7 := by simp\n      _ = \u27e6p\u2082\u27e7 := by grind",
      "suggestion": "\r\n@[to_additive (attr := simp)]\r\ntheorem isSimplyConnected_smul_set_iff {G : Type*} [Group G]\r\n    [MulAction G X] [ContinuousConstSMul G X] {c : G} {s : Set X} :\r\n    IsSimplyConnected (c \u2022 s) \u2194 IsSimplyConnected s :=\r\n  Homeomorph.smul c |>.isSimplyConnected_image\r\n\r\n@[simp]\r\ntheorem isSimplyConnected_smul_set\u2080_iff {G : Type*} [GroupWithZero G] [MulAction G X]\r\n    [ContinuousConstSMul G X] {c : G} {s : Set X} (hc : c \u2260 0) :\r\n    IsSimplyConnected (c \u2022 s) \u2194 IsSimplyConnected s :=\r\n  isSimplyConnected_smul_set_iff (c := Units.mk0 c hc)\r\n",
      "body": "```suggestion\r\n@[to_additive (attr := simp)]\r\ntheorem isSimplyConnected_smul_set_iff {G : Type*} [Group G]\r\n    [MulAction G X] [ContinuousConstSMul G X] {c : G} {s : Set X} :\r\n    IsSimplyConnected (c \u2022 s) \u2194 IsSimplyConnected s :=\r\n  Homeomorph.smul c |>.isSimplyConnected_image\r\n\r\n@[simp]\r\ntheorem isSimplyConnected_smul_set\u2080_iff {G : Type*} [GroupWithZero G] [MulAction G X]\r\n    [ContinuousConstSMul G X] {c : G} {s : Set X} (hc : c \u2260 0) :\r\n    IsSimplyConnected (c \u2022 s) \u2194 IsSimplyConnected s :=\r",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "grind"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "calc",
          "grind",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 1345,
      "before_code": "@[to_additive addCentralizer_empty]\ntheorem centralizer_empty : (\u2205 : Set M).centralizer = \u22a4 := by\n  simp only [centralizer, mem_empty_iff_false, IsEmpty.forall_iff, implies_true, setOf_true,\n    top_eq_univ]",
      "suggestion": "\r\n  simp [centralizer]\r\n",
      "body": "Does this not work?\r\n```suggestion\r\n  simp [centralizer]\r\n```",
      "path": "Mathlib/Algebra/Group/Center.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "top_eq_univ",
          "mem_empty_iff_false",
          "theorem",
          "centralizer_empty",
          "setOf_true",
          "Set",
          "IsEmpty",
          "implies_true",
          "centralizer",
          "addCentralizer_empty",
          "simp",
          "forall_iff",
          "only"
        ]
      }
    },
    {
      "id": 1350,
      "before_code": "fun _ h\u2081 _ h\u2082 \u21a6 h\u2082 _ fun _ h\u2083 \u21a6 h\u2081 _ fun _ h\u2084 \u21a6 h_comm _ h\u2084 _ h\u2083\n\n@[to_additive addCentralizer_empty]\ntheorem centralizer_empty : (\u2205 : Set M).centralizer = \u22a4 := by\n  simp only [centralizer, mem_empty_iff_false, IsEmpty.forall_iff, implies_true, setOf_true,\n    top_eq_univ]",
      "suggestion": "\r\n@[simp] theorem centralizer_empty : (\u2205 : Set M).centralizer = \u22a4 := by simp [centralizer]\r\n",
      "body": "yeah sure\r\n```suggestion\r\n@[simp] theorem centralizer_empty : (\u2205 : Set M).centralizer = \u22a4 := by simp [centralizer]\r\n```",
      "path": "Mathlib/Algebra/Group/Center.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "top_eq_univ",
          "theorem",
          "centralizer_empty",
          "setOf_true",
          "IsEmpty",
          "implies_true",
          "Set",
          "centralizer",
          "addCentralizer_empty",
          "forall_iff",
          "simp",
          "mem_empty_iff_false",
          "h_comm",
          "only"
        ]
      }
    },
    {
      "id": 1351,
      "before_code": "fun _ h\u2081 _ h\u2082 \u21a6 h\u2082 _ fun _ h\u2083 \u21a6 h\u2081 _ fun _ h\u2084 \u21a6 h_comm _ h\u2084 _ h\u2083\n\n@[to_additive addCentralizer_empty]",
      "suggestion": "\r\n@[to_additive (attr := simp) addCentralizer_empty]\r\n",
      "body": "```suggestion\r\n@[to_additive (attr := simp) addCentralizer_empty]\r\n```",
      "path": "Mathlib/Algebra/Group/Center.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "to_additive",
          "addCentralizer_empty",
          "h_comm"
        ]
      }
    },
    {
      "id": 1365,
      "before_code": "lemma Odd.ne_two_of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : m \u2260 2 := by\n  rintro rfl\n  exact absurd (hn.of_dvd_nat hm) (by decide)",
      "suggestion": "\r\n",
      "body": "Not a fan of comments that just spell out the type signature.\r\n```suggestion\r\n```\r\nIf it were up to me I'd remove most of the other comments from this file, but I'd rather not waste anyone's time with a PR like that.",
      "path": "Mathlib/Algebra/Order/Ring/Abs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "decide"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "decide"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "Odd",
          "exact",
          "rintro",
          "decide",
          "absurd",
          "rfl",
          "of_dvd_nat",
          "ne_two_of_dvd_nat"
        ]
      }
    },
    {
      "id": 1366,
      "before_code": "lemma Odd.ne_two_of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : m \u2260 2 := by\n  rintro rfl\n  exact absurd (hn.of_dvd_nat hm) (by decide)",
      "suggestion": "lemma Int.le_abs_of_dvd {a b : \u2124} (h\u2081 : b \u2260 0) (h\u2082 : a \u2223 b) : a \u2264 |b| :=\n  le_of_dvd (by simpa) (by simpa)\n",
      "body": "```suggestion\nlemma Int.le_abs_of_dvd {a b : \u2124} (h\u2081 : b \u2260 0) (h\u2082 : a \u2223 b) : a \u2264 |b| :=\n  le_of_dvd (by simpa) (by simpa)\n```",
      "path": "Mathlib/Algebra/Order/Ring/Abs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "decide"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "decide"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "lemma",
          "Odd",
          "exact",
          "rintro",
          "decide",
          "absurd",
          "rfl",
          "of_dvd_nat",
          "ne_two_of_dvd_nat"
        ]
      }
    },
    {
      "id": 1369,
      "before_code": "## Behaviour under Arithmetic Operations\n-/",
      "suggestion": "\r\n    gcongr\r\n",
      "body": "This isn't just to golf. I want to make sure you know about the existence of this tactic.\r\n```suggestion\r\n    gcongr\r\n```",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CharacteristicFunction.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "gcongr"
        ],
        "body_tactics": [
          "gcongr"
        ],
        "new_tactics": [
          "gcongr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Behaviour",
          "Operations",
          "Arithmetic",
          "under"
        ]
      }
    },
    {
      "id": 1371,
      "before_code": "ext1 f\n  simp [hg\u2081, hg\u2082]",
      "suggestion": "\r\n    Lp.toTemperedDistribution (hg\u2082.toLp _ \u2022 f) = smulLeftCLM F g (Lp.toTemperedDistribution f) := by\r\n  ext u\r\n  simp only [Lp.toTemperedDistribution_apply, smulLeftCLM_apply_apply]\r\n  apply integral_congr_ae\r\n  filter_upwards [Lp.coeFn_lpSMul (r := r) (hg\u2082.toLp _) f, hg\u2082.coeFn_toLp] with x hg hg'\r\n  simp [hg, hg', hg\u2081, smul_smul, mul_comm]\r\n",
      "body": "We have an `HSMul` instance :smiley:\r\n```suggestion\r\n    Lp.toTemperedDistribution (hg\u2082.toLp _ \u2022 f) = smulLeftCLM F g (Lp.toTemperedDistribution f) := by\r\n  ext u\r\n  simp only [Lp.toTemperedDistribution_apply, smulLeftCLM_apply_apply]\r\n  apply integral_congr_ae\r\n  filter_upwards [Lp.coeFn_lpSMul (r := r) (hg\u2082.toLp _) f, hg\u2082.coeFn_toLp] with x hg hg'\r\n  simp [hg, hg', hg\u2081, smul_smul, mul_comm]\r\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "apply",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "ext1",
          "simp"
        ]
      }
    },
    {
      "id": 1377,
      "before_code": "end PosSemidef",
      "suggestion": "\r\ntheorem IsHermitian.det_abs [DecidableEq n] {A : Matrix n n \ud835\udd5c} (hA : A.IsHermitian) :\r\n",
      "body": "Or maybe\r\n```suggestion\r\ntheorem IsHermitian.det_abs [DecidableEq n] {A : Matrix n n \ud835\udd5c} (hA : A.IsHermitian) :\r\n```\r\nsince we have [Matrix.PosSemidef.inv_sqrt](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Matrix/Order.html#Matrix.PosSemidef.inv_sqrt)?\r\n\r\nUnless that one should be renamed to also include the word cfc?",
      "path": "Mathlib/Analysis/Matrix/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "PosSemidef",
          "end"
        ]
      }
    },
    {
      "id": 1378,
      "before_code": "_ \u2264 1 + x + (x / 2) ^ 2 := le_add_of_nonneg_right <| sq_nonneg _\n    _ = _ := by ring",
      "suggestion": "\r\n  convert congr_arg NNReal.toReal <| map_prod NNReal.sqrtHom (Real.toNNReal \u2218 x) s <;>\r\n    simp +contextual [-map_prod, NNReal.sqrtHom, hx]\r\n",
      "body": "```suggestion\r\n  convert congr_arg NNReal.toReal <| map_prod NNReal.sqrtHom (Real.toNNReal \u2218 x) s <;>\r\n    simp +contextual [-map_prod, NNReal.sqrtHom, hx]\r\n```",
      "path": "Mathlib/Data/Real/Sqrt.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "ring",
          "le_add_of_nonneg_right",
          "sq_nonneg"
        ]
      }
    },
    {
      "id": 1380,
      "before_code": "Matrix.toLinearMap\u2082' \ud835\udd5c A (star x) x = 0 \u2194 A *\u1d65 x = 0 := by\n  simpa only [toLinearMap\u2082'_apply'] using hA.dotProduct_mulVec_zero_iff x",
      "suggestion": "\r\n    (CFC.sqrt A).det ^ 2 = A.det := by\r\n",
      "body": "I guess the other option is to have\r\n```suggestion\r\n    (CFC.sqrt A).det ^ 2 = A.det := by\r\n```\r\nThe naming would be weird though: `det_sqrt_sq`? which sounds like `((CFC.sqrt A) ^ 2).det`",
      "path": "Mathlib/Analysis/Matrix/Order.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "Matrix",
          "simpa",
          "_apply",
          "star",
          "dotProduct_mulVec_zero_iff",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 1385,
      "before_code": "instance [Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] : IsSemireal R where\n  one_add_ne_zero hs amo := zero_ne_one' R (le_antisymm zero_le_one\n                              (le_of_le_of_eq (le_add_of_nonneg_right hs.nonneg) amo))",
      "suggestion": "\r\n      rw [add_comm] at hn\r\n      push_cast at hn\r\n      simpa using IsSemireal.one_add_ne_zero (by simp) hn\r\n",
      "body": "```suggestion\r\n      rw [add_comm] at hn\r\n      push_cast at hn\r\n      simpa using IsSemireal.one_add_ne_zero (by simp) hn\r\n```",
      "path": "Mathlib/Algebra/Ring/Semireal/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "body_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "ExistsAddOfLE",
          "le_antisymm",
          "zero_ne_one",
          "Semiring",
          "amo",
          "le_of_le_of_eq",
          "one_add_ne_zero",
          "LinearOrder",
          "IsSemireal",
          "instance",
          "le_add_of_nonneg_right",
          "IsStrictOrderedRing",
          "zero_le_one",
          "nonneg"
        ]
      }
    },
    {
      "id": 1387,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\ntheorem support_bot : (\u22a5 : SimpleGraph V).support = \u2205 := by\r\n  grind only [mem_support, Set.mem_empty_iff_false, bot_adj]\r\n",
      "body": "```suggestion\r\ntheorem support_bot : (\u22a5 : SimpleGraph V).support = \u2205 := by\r\n  grind only [mem_support, Set.mem_empty_iff_false, bot_adj]\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1388,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\n/-- The support of a graph is empty if there at most one vertex. -/\r\n@[simp]\r\ntheorem support_of_subsingleton [Subsingleton V] (G : SimpleGraph V) : G.support = \u2205 :=\r\n  Set.eq_empty_of_forall_notMem fun v \u27e8w, h\u27e9 => G.irrefl <| Subsingleton.elim v w \u25b8 h\r\n",
      "body": "```suggestion\r\n/-- The support of a graph is empty if there at most one vertex. -/\r\n@[simp]\r\ntheorem support_of_subsingleton [Subsingleton V] (G : SimpleGraph V) : G.support = \u2205 :=\r\n  Set.eq_empty_of_forall_notMem fun v \u27e8w, h\u27e9 => G.irrefl <| Subsingleton.elim v w \u25b8 h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1389,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\n  Set.eq_empty_of_forall_notMem fun _ \u27e8_, h\u27e9 => h\r\n",
      "body": "Or even shorter:\r\n```suggestion\r\n  Set.eq_empty_of_forall_notMem fun _ \u27e8_, h\u27e9 => h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1402,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "/--\nDetermines if the pretty-printed version of the given name would parse as an `ident` with an underlying name (via `getId`) equal to the original name. The pretty-printer usually escapes unparseable components of a name with `\u00ab\u00bb`, but makes exceptions for various names with special meaning, meaning that the result does not round trip. We therefore re-check those conditions here.\n\nThis function is intended to be \"safe\" in that it if it returns `true`, the name will definitely round trip. Any deviation from this behavior is a bug which should be fixed.\n-/\n-- See also [Zulip](https://leanprover.zulipchat.com/#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Check.20if.20a.20.60Lean.2EName.60.20is.20roundtrippable/with/565735560)\ndef Lean.Name.willRoundTrip (n : Name) : Bool :=\n  !n.isAnonymous -- anonymous names do not roundtrip\n    && !n.hasMacroScopes -- names with macroscopes do not roundtrip\n    && !maybePseudoSyntax -- names which might be \"pseudo-syntax\" do not roundtrip\n ",
      "body": "Oh, hey, this seems so familiar... :)\n\nIf we keep this, we should document the living daylights out of this function. Without doing so, it would be totally mysterious to a future maintainer of this file who is trying to figure out e.g. what core change made roundtripping break.\n\nHere's a first pass at documentation. (Sorry, adding newlines is necessary.)\n\n```suggestion\n/--\nDetermines if the pretty-printed version of the given name would parse as an `ident` with an underlying name (via `getId`) e",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 1406,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "      if let some n := n then appT f i (a :: acc) (some n.succ)\n",
      "body": "Can we just use `n` again instead of flipping it (here and below)? \ud83d\ude01\n```suggestion\n      if let some n := n then appT f i (a :: acc) (some n.succ)\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 1407,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "    let enterStx \u2190 `(conv| enter [$xs,*])\n    let funStx \u2190 `(conv| fun)\n    let skipStx \u2190 `(conv| skip)\n    if !xs.elemsAndSeps.isEmpty then arr := arr.push enterStx\n    for _ in [0:depth] do arr := arr.push funStx\n    arr := arr.push skipStx\n    let seq \u2190 `(convSeq1Indented|$arr:conv*)\n",
      "body": "I think we might be able to simplify this section as such; do you foresee any problems doing it this way?\n```suggestion\n    let enterStx \u2190 `(conv| enter [$xs,*])\n    let funStx \u2190 `(conv| fun)\n    let skipStx \u2190 `(conv| skip)\n    if !xs.elemsAndSeps.isEmpty then arr := arr.push enterStx\n    for _ in [0:depth] do arr := arr.push funStx\n    arr := arr.push skipStx\n    let seq \u2190 `(convSeq1Indented|$arr:conv*)\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 1408,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "        withLocalDeclD n t fun fvar => do\n          let e := b.instantiate1 fvar\n",
      "body": "Is there any reason not to simply use `withLocalDecl`(`D`), here and below?\n```suggestion\n        withLocalDeclD n t fun fvar => do\n          let e := b.instantiate1 fvar\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 1409,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "partial def Path.ofSubExprPosArray (expr : Expr) (pos : Array Nat) : MetaM Path :=\n  go expr 0\nwhere\n  go (expr : Expr) (i : Fin (pos.size + 1)) : MetaM Path :=\n",
      "body": "`pos` is constant in all helper decls, right? For readability (and for making that invariant obvious) I think it might be best to just bite the bullet on the type here, remove `pos` from `go` and `appT`, and then, if you like, add a separate `Path.ofSubExpr (expr : Expr) (subExpr : SubExpr)`\u2014or just call this decl on `subExpr.toArray`, if nothing else will use it.\n\n(We should really have fold-ish API around `SubExpr`, not just `SubExpr.Pos`...)\n\n(Note: if you add a decl, it would probably be nic",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 1420,
      "before_code": "ext1 f\n  exact smulLeftCLM_smulLeftCLM_apply hg\u2081 hg\u2082 f",
      "suggestion": "  apply Finset.sum_congr rfl\n",
      "body": "```suggestion\n  apply Finset.sum_congr rfl\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "ext1",
          "smulLeftCLM_smulLeftCLM_apply"
        ]
      }
    },
    {
      "id": 1423,
      "before_code": "le_sInf _ _ hS _ _ hf _ hR := hS _ hR _ hf\n  le_sup_left _ _ _ _ := Or.inl\n  le_sup_right _ _ _ _ := Or.inr\n  sup_le _ _ _ h\u2081 h\u2082 _ f := by--\u2130 S hS Y f := by",
      "suggestion": "\r\n  sup_le _ _ _ h\u2081 h\u2082 _ f := by\r\n",
      "body": "```suggestion\r\n  sup_le _ _ _ h\u2081 h\u2082 _ f := by\r\n```\r\nI wonder if this comment should simply be erased.",
      "path": "Mathlib/CategoryTheory/Sites/Sieves.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "le_sup_left",
          "le_sup_right",
          "le_sInf",
          "sup_le",
          "inl",
          "inr"
        ]
      }
    },
    {
      "id": 1425,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n/-! The Cartan matrices F\u2084 and G\u2082 are not simply laced because they contain\r\noff-diagonal entries that are neither 0 nor -1. -/\r\n",
      "body": "```suggestion\r\n/-! The Cartan matrices F\u2084 and G\u2082 are not simply laced because they contain\r\noff-diagonal entries that are neither 0 nor -1. -/\r\n```\r\n\r\nsince there is no /-! ### \u2026 about simply laced matrices in the files, it feels weird to add one for the matrices that are not simply laced.\r\n\r\nAlso, given that not having off-diagonals equals to 0 or -1 is the definition of not being simply laced, is the comment that useful?",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1426,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  have := hs (i := 1) (j := 2) (by decide)\r\n",
      "body": "```suggestion\r\n  have := hs (i := 1) (j := 2) (by decide)\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "decide",
          "have"
        ],
        "body_tactics": [
          "decide",
          "have"
        ],
        "new_tactics": [
          "decide",
          "have"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1427,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  have := hs (i := 0) (j := 1) (by decide)\r\n",
      "body": "```suggestion\r\n  have := hs (i := 0) (j := 1) (by decide)\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "decide",
          "have"
        ],
        "body_tactics": [
          "decide",
          "have"
        ],
        "new_tactics": [
          "decide",
          "have"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1428,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  rcases this with h | h <;> simp_all [G\u2082]\r\n\r\n",
      "body": "```suggestion\r\n  rcases this with h | h <;> simp_all [G\u2082]\r\n\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "cases",
          "simp_all"
        ],
        "body_tactics": [
          "cases",
          "simp_all"
        ],
        "new_tactics": [
          "cases",
          "simp_all"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1440,
      "before_code": "simpa using hl)\n      exact .sub (.div (by fun_prop) (by fun_prop) (by simpa)) (by fun_prop)",
      "suggestion": "\r\n@[simp] lemma deriv_weierstrassPExcept (l : \u2102) : deriv \u2118[L - l] l = \u2118'[L - l] l :=\r\n",
      "body": "```suggestion\r\n@[simp] lemma deriv_weierstrassPExcept (l : \u2102) : deriv \u2118[L - l] l = \u2118'[L - l] l :=\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "fun_prop",
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "simpa",
          "fun_prop",
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "sub",
          "simpa",
          "div",
          "fun_prop",
          "using"
        ]
      }
    },
    {
      "id": 1441,
      "before_code": "\u00b7 rw [analyticOrderAt_of_not_analyticAt hf,\n      analyticOrderAt_of_not_analyticAt fun hg \u21a6 hf <| hg.congr hfg.symm]",
      "suggestion": "\r\n@[simp] lemma analyticOrderAt_id : analyticOrderAt (\ud835\udd5c := \ud835\udd5c) id 0 = 1 :=\r\n",
      "body": "```suggestion\r\n@[simp] lemma analyticOrderAt_id : analyticOrderAt (\ud835\udd5c := \ud835\udd5c) id 0 = 1 :=\r\n```",
      "path": "Mathlib/Analysis/Analytic/Order.lean",
      "tags": {
        "before_tactics": [
          "congr",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "congr",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "congr",
          "analyticOrderAt_of_not_analyticAt",
          "symm",
          "hfg"
        ]
      }
    },
    {
      "id": 1444,
      "before_code": "end NormedLinearOrderedField_comap",
      "suggestion": "\r\n  simp [parallelepiped_basis_eq, x', Int.floor_le, Int.lt_floor_add_one, le_of_lt, add_comm (1 : \u211d)]\r\n",
      "body": "```suggestion\r\n  simp [parallelepiped_basis_eq, x', Int.floor_le, Int.lt_floor_add_one, le_of_lt, add_comm (1 : \u211d)]\r\n```\r\n(and then you don't need to add `Int.le_floor_add_one` any more)",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "NormedLinearOrderedField_comap",
          "end"
        ]
      }
    },
    {
      "id": 1446,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n  obtain (_ | _ | n) := n <;>\r\n  simp [iteratedDeriv_succ', iteratedDeriv_const]\r\n",
      "body": "```suggestion\r\n  obtain (_ | _ | n) := n <;>\r\n  simp [iteratedDeriv_succ', iteratedDeriv_const]\r\n```\r\n(fortunately `simp` is clever enough not to complain about unused simp lemmas when inside a `<;>` block)",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "cleanup_simp",
          "use_simp"
        ],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1448,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n    obtain \u27e8U, hU, H\u27e9 := ((hf.eventually (by simp)).and (hg.eventually (by simp))).exists_mem\r\n",
      "body": ":golf:\r\n```suggestion\r\n    obtain \u27e8U, hU, H\u27e9 := ((hf.eventually (by simp)).and (hg.eventually (by simp))).exists_mem\r\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1449,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n      all_goals clear IH H U hU; fun_prop (disch := simp_all)\r\n",
      "body": "This is quite slow because the context here includes a lot of complicated stuff, and `simp_all` simplifies everything it sees (it has no way to determine which parts of the context are relevant and which aren't). The following speeds it up substantially:\r\n```suggestion\r\n      all_goals clear IH H U hU; fun_prop (disch := simp_all)\r\n```\r\nIt's still slower than the hand-rolled proof but I think it's tolerable.",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "simp_all"
        ],
        "body_tactics": [
          "fun_prop",
          "simp_all"
        ],
        "new_tactics": [
          "fun_prop",
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1450,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n  simp [\u2190 smul_eq_mul, iteratedDerivWithin_smul hf hg hs hx]\r\n",
      "body": "```suggestion\r\n  simp [\u2190 smul_eq_mul, iteratedDerivWithin_smul hf hg hs hx]\r\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1451,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n  simpa [iteratedDerivWithin_univ] using\r\n    iteratedDerivWithin_mul hf.contDiffWithinAt hg.contDiffWithinAt uniqueDiffOn_univ trivial\r\n",
      "body": ":golf:\r\n```suggestion\r\n  simpa [iteratedDerivWithin_univ] using\r\n    iteratedDerivWithin_mul hf.contDiffWithinAt hg.contDiffWithinAt uniqueDiffOn_univ trivial\r\n```\r\nMaybe `iteratedDerivWithin_univ` should be `@[simp]`, matching `derivWithin_univ`, and then you get even more golf points.",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 1452,
      "before_code": "rw [weierstrassPExceptSeries, FormalMultilinearSeries.ofScalars_apply_eq,\n      FormalMultilinearSeries.coeff_ofScalars, smul_eq_mul]\n\nlemma analyticOnNhd_weierstrassPExcept (l\u2080 : \u2102) : AnalyticOnNhd \u2102 \u2118[L - l\u2080] (L.lattice \\ {l\u2080})\u1d9c :=\n  (L.differentiableOn_weierstrassPExcept l\u2080).analyticOnNhd L.isOpen_compl_lattice_diff",
      "suggestion": "\r\n    \u00b7 simp [Nat.factorial_succ (n + 1)]\r\n      field [(n + 1).factorial_pos.ne']\r\n",
      "body": "```suggestion\r\n    \u00b7 simp [Nat.factorial_succ (n + 1)]\r\n      field [(n + 1).factorial_pos.ne']\r\n```\r\nIt's a pity that `field_simp` isn't able to spot automatically that factorials are non-zero, given how often one needs to divide by `n!`. Perhaps one could do the following:\r\n- add an instance `NeZero n.factorial` for all `n : Nat` (a bundled version of `Nat.factorial_ne_zero`)\r\n- add `NeZero.ne` to the list of lemmas used by `field_simp` in line 85-6 of `Mathlib.Tactic.FieldSimp.Discharger`.\r\nB",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "field_simp",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "complex",
          "differentiability",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "analyticOnNhd_weierstrassPExcept",
          "FormalMultilinearSeries",
          "weierstrassPExceptSeries",
          "AnalyticOnNhd",
          "coeff_ofScalars",
          "isOpen_compl_lattice_diff",
          "ofScalars_apply_eq",
          "differentiableOn_weierstrassPExcept",
          "smul_eq_mul",
          "analyticOnNhd",
          "lattice"
        ]
      }
    },
    {
      "id": 1453,
      "before_code": "end Analytic",
      "suggestion": "\r\n/-- The Eisenstein series as a function on lattices.\r\n",
      "body": "```suggestion\r\n/-- The Eisenstein series as a function on lattices.\r\n```\r\nI think it would be nice to have some lemmas relating these declarations in the `PeriodPair` namespace to the declarations in the `ModularForms` namespace, e.g. [ModularForm.E](https://leanprover-community.github.io/mathlib4_docs/Mathlib/NumberTheory/ModularForms/EisensteinSeries/Basic.html#ModularForm.E). Probably the way to do this is to define a map from `UpperHalfPlane` to `PeriodPair` sending `x` to the lattice `Z +  ",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Analytic"
        ]
      }
    },
    {
      "id": 1454,
      "before_code": "exact (LinearMap.quotientInfEquivSupQuotient Y X).symm\n\nend JordanHolderModule",
      "suggestion": "protected theorem Module.Finite.toModuleEnd_surjective [Module.Finite (End R M) M] :\n",
      "body": "What do you think of\n```suggestion\nprotected theorem Module.Finite.toModuleEnd_surjective [Module.Finite (End R M) M] :\n```\nand mentioning the original name in a docstring?",
      "path": "Mathlib/RingTheory/SimpleModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "end",
          "LinearMap",
          "JordanHolderModule",
          "exact",
          "quotientInfEquivSupQuotient"
        ]
      }
    },
    {
      "id": 1455,
      "before_code": "exact (LinearMap.quotientInfEquivSupQuotient Y X).symm\n\nend JordanHolderModule",
      "suggestion": "\r\n/-- The Jacobson density theorem for a module finite over its endomorphism ring. -/\r\nprotected theorem Module.Finite.toModuleEnd_moduleEnd_surjective [Module.Finite (End R M) M] :\r\n",
      "body": "Something like\r\n```suggestion\r\n/-- The Jacobson density theorem for a module finite over its endomorphism ring. -/\r\nprotected theorem Module.Finite.toModuleEnd_moduleEnd_surjective [Module.Finite (End R M) M] :\r\n```\r\n? (I added another `moduleEnd` to emphasize the nested `End`).",
      "path": "Mathlib/RingTheory/SimpleModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "symm",
          "end",
          "LinearMap",
          "JordanHolderModule",
          "exact",
          "quotientInfEquivSupQuotient"
        ]
      }
    },
    {
      "id": 1460,
      "before_code": "\u00b7 intro Y hY\n    exact H _ hY",
      "suggestion": "",
      "body": "This line is unnecessary:\n```suggestion\n```",
      "path": "Mathlib/CategoryTheory/MorphismProperty/Ind.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "exact",
          "intro"
        ]
      }
    },
    {
      "id": 1471,
      "before_code": "iteratedSliceBackward f \u22d9 forget f \u22d9 forget X = forget f.left :=\n  rfl",
      "suggestion": "@[simps! hom_app_left_left inv_app_left_left]\n",
      "body": "```suggestion\n@[simps! hom_app_left_left inv_app_left_left]\n```\nThis is probably more useful",
      "path": "Mathlib/CategoryTheory/Comma/Over/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "forget",
          "left",
          "rfl",
          "iteratedSliceBackward"
        ]
      }
    },
    {
      "id": 1473,
      "before_code": "namespace Mathlib.Tactic.Conv\nopen Lean Parser.Tactic Parser.Tactic.Conv Elab.Tactic Meta\n\nsyntax (name := convLHS) \"conv_lhs\" (\" at \" ident)? (\" in \" (occs)? term)? \" => \" convSeq : tactic\nmacro_rules\n  | `(tactic| conv_lhs $[at $id]? $[in $[$occs]? $pat]? => $seq) =>\n    `(tactic| conv $[at $id]? $[in $[$occs]? $pat]? => lhs; ($seq:convSeq))",
      "suggestion": "\r\n* `conv_rhs at h => cs` runs `cs` on the right hand side of hypothesis `h`.\r\n* `conv_rhs in pat => cs` first looks for a subexpression matching `pat` (see the `pattern`\r\n  conv tactic) and then traverses into the right hand side of this subexpression.\r\n  This syntax also supports the `occs` clause for the pattern.\r\n",
      "body": "```suggestion\r\n* `conv_rhs at h => cs` runs `cs` on the right hand side of hypothesis `h`.\r\n* `conv_rhs in pat => cs` first looks for a subexpression matching `pat` (see the `pattern`\r\n  conv tactic) and then traverses into the right hand side of this subexpression.\r\n  This syntax also supports the `occs` clause for the pattern.\r\n```",
      "path": "Mathlib/Tactic/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pat",
          "seq",
          "conv_lhs",
          "open",
          "occs",
          "Mathlib",
          "Lean",
          "lhs",
          "syntax",
          "convSeq",
          "name",
          "macro_rules",
          "Conv",
          "Elab",
          "ident",
          "tactic",
          "namespace",
          "term",
          "conv",
          "Parser",
          "Meta",
          "convLHS",
          "Tactic"
        ]
      }
    },
    {
      "id": 1474,
      "before_code": "smul_comm r x y := by\n    rw [\u2190 single_zero_smul_eq_smul \u0393, \u2190 mul_smul', mul_comm, mul_smul', single_zero_smul_eq_smul \u0393]",
      "suggestion": "instance {\u0393 V : Type*} [Ring R] [IsDomain R] [AddCommGroup V] [AddCommMonoid \u0393]\n",
      "body": "Is the auto-generated name bad?\n```suggestion\ninstance {\u0393 V : Type*} [Ring R] [IsDomain R] [AddCommGroup V] [AddCommMonoid \u0393]\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [
          "ring"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "mul_smul",
          "smul_comm",
          "mul_comm",
          "single_zero_smul_eq_smul"
        ]
      }
    },
    {
      "id": 1478,
      "before_code": "that of a functor `T : X \u2964 A`, a functor `L : X \u2964 C`, and a `CatCommSqOver T L F G`.\nNote that this is *exactly* what an object of\n`((whiskeringRight X A B).obj F) \u22a1 ((whiskeringRight X C B).obj G)` is,\nso `CatCommSqOver F G X` is in fact an abbreviation for\n`((whiskeringRight X A B).obj F) \u22a1 ((whiskeringRight X C B).obj G)`. -/\nabbrev CatCommSqOver :=\n  (whiskeringRight X A B |>.obj F) \u22a1 (whiskeringRight X C B |>.obj G)\n\nnamespace CatCommSqOver",
      "suggestion": "@[simps! id_fst_app id_snd_app comp_fst_app comp_snd_app]\ninstance : Category (CatCommSqOver F G X) where\n",
      "body": "This generates four lemmas below:\n```suggestion\n@[simps! id_fst_app id_snd_app comp_fst_app comp_snd_app]\ninstance : Category (CatCommSqOver F G X) where\n```",
      "path": "Mathlib/CategoryTheory/Limits/Shapes/Pullback/Categorical/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "object",
          "whiskeringRight",
          "abbrev",
          "functor",
          "exactly",
          "what",
          "Note",
          "this",
          "that",
          "CatCommSqOver",
          "abbreviation",
          "obj",
          "fact",
          "for",
          "namespace"
        ]
      }
    },
    {
      "id": 1482,
      "before_code": "/-! ## The affine coordinate ring -/\n\n/-- The affine coordinate ring `R[W] := R[X, Y] / \u27e8W(X, Y)\u27e9` of a Weierstrass curve `W`. -/\nabbrev CoordinateRing : Type r :=",
      "suggestion": "variable (W') in\nabbrev CoordinateRing : Type r :=\n",
      "body": "```suggestion\nvariable (W') in\nabbrev CoordinateRing : Type r :=\n```",
      "path": "Mathlib/AlgebraicGeometry/EllipticCurve/Affine/Point.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Weierstrass",
          "curve",
          "abbrev",
          "coordinate",
          "Type",
          "CoordinateRing",
          "affine",
          "ring"
        ]
      }
    },
    {
      "id": 1483,
      "before_code": "instance ULift.instT5Space [T5Space X] : T5Space (ULift X) :=\n  IsEmbedding.uliftDown.t5Space",
      "suggestion": "    T5Space X \u2194 \u2200 s : Set X, IsOpen s \u2192 T4Space s where\n  mp := fun _ _ _ => inferInstance\n  mpr h := \n  \t{ toCompletelyNormalSpace :=\n        completelyNormalSpace_iff_forall_isOpen_normalSpace.2 fun s hs => (h s hs).toNormalSpace\n      toT1Space :=\n        have := h univ isOpen_univ\n        t1Space_of_injective_of_continuous\n          (fun _ _ => congrArg Subtype.val) (continuous_id.subtype_mk mem_univ) }\n",
      "body": "I prefer to use `where` or `:= by` when the proof of an `\u2194` where one of the proofs is more than a line or two.\n```suggestion\n    T5Space X \u2194 \u2200 s : Set X, IsOpen s \u2192 T4Space s where\n  mp := fun _ _ _ => inferInstance\n  mpr h := \n  \t{ toCompletelyNormalSpace :=\n        completelyNormalSpace_iff_forall_isOpen_normalSpace.2 fun s hs => (h s hs).toNormalSpace\n      toT1Space :=\n        have := h univ isOpen_univ\n        t1Space_of_injective_of_continuous\n          (fun _ _ => congrArg Subtype.val) (",
      "path": "Mathlib/Topology/Separation/Regular.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsEmbedding",
          "T5Space",
          "ULift",
          "uliftDown",
          "t5Space",
          "instT5Space",
          "instance"
        ]
      }
    },
    {
      "id": 1484,
      "before_code": "/-- A nonzero element in a domain integral over a field is a unit. -/\ntheorem IsIntegral.isUnit [Field R] [Ring S] [IsDomain S] [Algebra R S] {x : S}\n    (int : IsIntegral R x) (h0 : x \u2260 0) : IsUnit x :=\n  have : FiniteDimensional R (adjoin R {x}) := \u27e8(Submodule.fg_top _).mpr int.fg_adjoin_singleton\u27e9",
      "suggestion": "  have : FiniteDimensional R (adjoin R {x}) := Module.Finite.iff_fg.mpr int.fg_adjoin_singleton\n",
      "body": "```suggestion\n  have : FiniteDimensional R (adjoin R {x}) := Module.Finite.iff_fg.mpr int.fg_adjoin_singleton\n```",
      "path": "Mathlib/RingTheory/IntegralClosure/IsIntegralClosure/Basic.lean",
      "tags": {
        "before_tactics": [
          "ring",
          "have"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "nonzero",
          "Ring",
          "FiniteDimensional",
          "adjoin",
          "field",
          "have",
          "isUnit",
          "Field",
          "Submodule",
          "IsUnit",
          "over",
          "fg_adjoin_singleton",
          "unit",
          "IsDomain",
          "domain",
          "IsIntegral",
          "theorem",
          "element",
          "fg_top",
          "integral",
          "int",
          "Algebra"
        ]
      }
    },
    {
      "id": 1485,
      "before_code": "theorem IsIntegral.inv_mem_adjoin (int : IsIntegral R x) : x\u207b\u00b9 \u2208 adjoin R {x} := by\n  obtain rfl | h0 := eq_or_ne x 0\n  \u00b7 rw [inv_zero]; exact Subalgebra.zero_mem _\n  have : FiniteDimensional R (adjoin R {x}) := \u27e8(Submodule.fg_top _).mpr int.fg_adjoin_singleton\u27e9",
      "suggestion": "  have : FiniteDimensional R (adjoin R {x}) := Module.Finite.iff_fg.mpr int.fg_adjoin_singleton\n",
      "body": "```suggestion\n  have : FiniteDimensional R (adjoin R {x}) := Module.Finite.iff_fg.mpr int.fg_adjoin_singleton\n```",
      "path": "Mathlib/RingTheory/IntegralClosure/IsIntegralClosure/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw"
        ],
        "topics": [
          "int",
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "inv_mem_adjoin",
          "mpr",
          "rfl",
          "IsIntegral",
          "theorem",
          "fg_top",
          "exact",
          "FiniteDimensional",
          "have",
          "fg_adjoin_singleton",
          "obtain",
          "Submodule",
          "inv_zero",
          "int",
          "adjoin",
          "Subalgebra",
          "eq_or_ne",
          "zero_mem"
        ]
      }
    },
    {
      "id": 1491,
      "before_code": "theorem toSpanSingleton_eq_algebra_linearMap : toSpanSingleton R A 1 = Algebra.linearMap R A := by\n  ext; simp",
      "suggestion": "  map_smul' a x := x.induction_on (by simp) (by simp +contextual [mul', smul_tmul', mul_assoc])\n",
      "body": "```suggestion\n  map_smul' a x := x.induction_on (by simp) (by simp +contextual [mul', smul_tmul', mul_assoc])\n```",
      "path": "Mathlib/Algebra/Algebra/Bilinear.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "toSpanSingleton",
          "ext",
          "theorem",
          "linearMap",
          "simp",
          "toSpanSingleton_eq_algebra_linearMap",
          "Algebra"
        ]
      }
    },
    {
      "id": 1496,
      "before_code": "let missing := modulesWithoutMathlibImports.erase `Mathlib.Tactic.Linter.Header\n    -- This file is imported by `Mathlib/Tactic/Linter/Header.lean`.\n    |>.erase `Mathlib.Tactic.Linter.DirectoryDependency",
      "suggestion": "\r\n    -- These files are transitively imported by `Mathlib/Tactic/Linter/Header.lean`.\r\n    |>.erase `Mathlib.Tactic.Linter.DirectoryDependency\r\n    |>.erase `Mathlib.Lean.Linter\r\n",
      "body": "```suggestion\r\n    -- These files are transitively imported by `Mathlib/Tactic/Linter/Header.lean`.\r\n    |>.erase `Mathlib.Tactic.Linter.DirectoryDependency\r\n    |>.erase `Mathlib.Lean.Linter\r\n```",
      "path": "scripts/lint-style.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "file",
          "erase",
          "This",
          "modulesWithoutMathlibImports",
          "Mathlib",
          "Header",
          "missing",
          "lean",
          "DirectoryDependency",
          "Linter",
          "imported",
          "Tactic"
        ]
      }
    },
    {
      "id": 1504,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\n@[simp]\r\nlemma ringKrullDim_of_isNoetherianRing : ringKrullDim R[X] = ringKrullDim R + 1 := by\r\n",
      "body": "```suggestion\r\n@[simp]\r\nlemma ringKrullDim_of_isNoetherianRing : ringKrullDim R[X] = ringKrullDim R + 1 := by\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 1505,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\n@[simp]\r\nlemma MvPolynomial.ringKrullDim_of_isNoetherianRing {\u03b9 : Type*} [Finite \u03b9] :\r\n",
      "body": "```suggestion\r\n@[simp]\r\nlemma MvPolynomial.ringKrullDim_of_isNoetherianRing {\u03b9 : Type*} [Finite \u03b9] :\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 1506,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\n  have : p.IsPrime := by rw [P.over_def p]; infer_instance\r\n",
      "body": "```suggestion\r\n  have : p.IsPrime := by rw [P.over_def p]; infer_instance\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw",
          "have"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 1508,
      "before_code": "/-\nCopyright (c) 2025 Jingting Wang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jingting Wang\n-/\nmodule\n\npublic import Mathlib.Algebra.Polynomial.FieldDivision\npublic import Mathlib.RingTheory.KrullDimension.PID\npublic import Mathlib.RingTheory.LocalRing.ResidueField.Fiber\n\n/-!\n# Krull dimension of polynomial ring\n\nThis file proves properties of the krull dimension of the polynomial ring over a commutative ring\n\n## Main results\n\n* `Polynomial.ringKrullDim_le`: the krull dimension of the polynomial ring over a commutative ring\n  `R` is less than `2 * (ringKrullDim R) + 1`.",
      "suggestion": "\r\nFor noetherian rings:\r\n* `Polynomial.ringKrullDim_of_isNoetherianRing`: the Krull dimension of `R[X]` is `dim R + 1`.\r\n",
      "body": "```suggestion\r\nFor noetherian rings:\r\n* `Polynomial.ringKrullDim_of_isNoetherianRing`: the Krull dimension of `R[X]` is `dim R + 1`.\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "All",
          "file",
          "polynomial",
          "import",
          "FieldDivision",
          "results",
          "Jingting",
          "Main",
          "Apache",
          "Polynomial",
          "properties",
          "RingTheory",
          "ResidueField",
          "This",
          "Mathlib",
          "Krull",
          "license",
          "LocalRing",
          "ringKrullDim_le",
          "Authors",
          "dimension",
          "rights",
          "proves",
          "public",
          "Wang",
          "LICENSE",
          "under",
          "module",
          "over",
          "than",
          "PID",
          "Copyright",
          "KrullDimension",
          "ring",
          "less",
          "krull",
          "commutative",
          "reserved",
          "Fiber",
          "described",
          "ringKrullDim",
          "Algebra",
          "Released"
        ]
      }
    },
    {
      "id": 1509,
      "before_code": "end single",
      "suggestion": "\r\ntheorem trace_surjective [AddCommMonoid R] [Nonempty n] :\r\n    Function.Surjective (trace : Matrix n n R \u2192 R) := fun r \u21a6 by\r\n  classical\r\n  let i := Classical.arbitrary n\r\n  exact \u27e8single i i r, trace_single_eq_same i r\u27e9\r\n",
      "body": "No need to section things off. And better to just use the variables above. And also instead of repeating `Classical.arbitrary` just define it once:\r\n\r\n```suggestion\r\ntheorem trace_surjective [AddCommMonoid R] [Nonempty n] :\r\n    Function.Surjective (trace : Matrix n n R \u2192 R) := fun r \u21a6 by\r\n  classical\r\n  let i := Classical.arbitrary n\r\n  exact \u27e8single i i r, trace_single_eq_same i r\u27e9\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/Trace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "single",
          "end"
        ]
      }
    },
    {
      "id": 1510,
      "before_code": "end single",
      "suggestion": "\r\n  inhabit n\r\n  exact \u27e8single default default r, trace_single_eq_same default r\u27e9\r\n",
      "body": "I would probably do this:\r\n```suggestion\r\n  inhabit n\r\n  exact \u27e8single default default r, trace_single_eq_same default r\u27e9\r\n```\r\n\r\nIt feels more idiomatic to me, and signals \"the exact value does not matter\" similarly well.",
      "path": "Mathlib/LinearAlgebra/Matrix/Trace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "single",
          "end"
        ]
      }
    },
    {
      "id": 1513,
      "before_code": "(rootSpaceProduct R L H \u03b1 (-\u03b1) 0 (add_neg_cancel \u03b1) (\u27e8y, hy\u27e9 \u2297\u209c[R] \u27e8z, hz\u27e9)).property using 0\n  simp [hyz]",
      "suggestion": "lemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n",
      "body": "```suggestion\nlemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n```",
      "path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "exact",
          "simpa",
          "rw",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "rootSpaceProduct",
          "property",
          "simp",
          "add_neg_cancel",
          "using",
          "hyz"
        ]
      }
    },
    {
      "id": 1514,
      "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
      "suggestion": "    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n",
      "body": "There are two _independent_ changes here:\n\n1. Fix the `by exact` issue by adding `.toLinearMap` to help elaboration\n2. Add `.toSubmodule` rather than a coercion to avoid an indirect coercion (`LieIdeal` to `LieSubalgebra` to `Submodule`)\n```suggestion\n    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n```",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "add_lie",
          "mem_coe",
          "SetLike",
          "exact",
          "Submodule",
          "add_mem",
          "simp",
          "carrier_eq_coe",
          "only"
        ]
      }
    },
    {
      "id": 1515,
      "before_code": "(rootSpaceProduct R L H \u03b1 (-\u03b1) 0 (add_neg_cancel \u03b1) (\u27e8y, hy\u27e9 \u2297\u209c[R] \u27e8z, hz\u27e9)).property using 0\n  simp [hyz]",
      "suggestion": "lemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup\u2082_of_le \u03b1 h\u03b1 (le_refl _)\n",
      "body": "This lemma becomes more difficult to use if we include the bundled finiteness expressed as `H.root`. Instead I suggest:\n```suggestion\nlemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup\u2082_of_le \u03b1 h\u03b1 (le_refl _)\n```",
      "path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "exact",
          "rw",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rootSpaceProduct",
          "property",
          "simp",
          "add_neg_cancel",
          "using",
          "hyz"
        ]
      }
    },
    {
      "id": 1516,
      "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
      "suggestion": "\r\n-- This should probably be somewhere in the file `Algebra.Lie.Weights.RootSystem`\r\nopen LieSubmodule in\r\n@[simp]\r\nlemma biSup_corootSpace_eq_top :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 := by\r\n  simp only [\u2190 toSubmodule_inj, top_toSubmodule, iSup_toSubmodule,\r\n    \u2190 RootPairing.IsRootSystem.span_coroot_eq_top (P := rootSystem H),\r\n    coe_corootSpace_eq_span_singleton, Submodule.iSup_span]\r\n  congr\r\n  ext \u03b1\r\n  simp [eq_comm]\r\n\r\n-- This should probably be below `bisup_corootSpace_eq_top`\r\n@[simp]\r\nlemma biSup_corootSubmodule_eq_cartan :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSubmodule \u03b1 = H.toLieSubmodule := by\r\n  suffices \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 from\r\n    le_antisymm (by simp) (by simp [\u2190 LieSubmodule.map_iSup, this])\r\n  simp\r\n\r\nopen LieSubmodule in\r\n@[simp] lemma invtSubmoduleToLieIdeal_top :\r\n    invtSubmoduleToLieIdeal (\u22a4 : Submodule K (Module.Dual K H)) (by simp) = \u22a4 := by\r\n  simp_rw [\u2190 toSubmodule_inj, coe_",
      "body": "I think the right way to break this result down is as follows:\r\n```suggestion\r\n-- This should probably be somewhere in the file `Algebra.Lie.Weights.RootSystem`\r\nopen LieSubmodule in\r\n@[simp]\r\nlemma biSup_corootSpace_eq_top :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 := by\r\n  simp only [\u2190 toSubmodule_inj, top_toSubmodule, iSup_toSubmodule,\r\n    \u2190 RootPairing.IsRootSystem.span_coroot_eq_top (P := rootSystem H),\r\n    coe_corootSpace_eq_span_singleton, Submodule.iSup_span]\r\n  ",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "congr",
          "refine",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "congr",
          "refine",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "congr",
          "refine",
          "ext"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "line_break"
        ],
        "keywords": [
          "add_lie",
          "mem_coe",
          "SetLike",
          "exact",
          "Submodule",
          "add_mem",
          "simp",
          "carrier_eq_coe",
          "only"
        ]
      }
    },
    {
      "id": 1539,
      "before_code": "contrapose! hs\n  simpa [hs] using IsMeagre.empty",
      "suggestion": "  suffices IsMeagre (\u22c3 i : I, A i) by simpa\n",
      "body": "```suggestion\n  suffices IsMeagre (\u22c3 i : I, A i) by simpa\n```",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "contrapose",
          "empty",
          "IsMeagre",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 1540,
      "before_code": "applyReplacementFun t e #[]\n\n/-- Unfold auxlemmas in the type and value. -/",
      "suggestion": "\r\n/-- Unfold auxlemmas (generated by `simp`) in the type and value. -/\r\n",
      "body": "```suggestion\r\n/-- Unfold auxlemmas (generated by `simp`) in the type and value. -/\r\n```",
      "path": "Mathlib/Tactic/Translate/Core.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "auxlemmas",
          "Unfold",
          "value",
          "type",
          "applyReplacementFun"
        ]
      }
    },
    {
      "id": 1541,
      "before_code": "convexCombination (.duple x y hs ht h)\n\n/-- A binary convex combination with weight 0 on the first point returns the second point. -/\nproof_wanted convexComboPair_zero {x y : M} :\n  convexComboPair (0 : R) 1 (by simp) (by simp) (by simp) x y = y\n\n/-- A binary convex combination with weight 1 on the first point returns the first point. -/\nproof_wanted convexComboPair_one {x y : M} :\n  convexComboPair (1 : R) 0 (by simp) (by simp) (by simp) x y = x\n\n/-- A convex combination of a point with itself is that point. -/\nproof_wanted convexComboPair_same {s t : R} (hs : 0 \u2264 s) (ht : 0 \u2264 t) (h : s + t = 1) {x : M} :\n  convexComboPair s t hs ht h x x = x",
      "suggestion": "\r\n  simp only [StdSimplex.duple, StdSimplex.single, \u2190 Finsupp.single_add, h]\r\n",
      "body": "does this work?\r\n```suggestion\r\n  simp only [StdSimplex.duple, StdSimplex.single, \u2190 Finsupp.single_add, h]\r\n```",
      "path": "Mathlib/LinearAlgebra/ConvexSpace.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "binary",
          "returns",
          "convexComboPair",
          "combination",
          "second",
          "convexCombination",
          "duple",
          "convexComboPair_same",
          "that",
          "point",
          "convexComboPair_zero",
          "simp",
          "proof_wanted",
          "convexComboPair_one",
          "first",
          "itself",
          "weight",
          "convex"
        ]
      }
    },
    {
      "id": 1548,
      "before_code": "IsOpenMap f \u2194 LowerHemicontinuous (f \u207b\u00b9' {\u00b7}) := by\n  rw [isOpenMap_iff_kernImage, lowerHemicontinuous_iff_isClosed_preimage_Iic]\n  aesop",
      "suggestion": "@[simp]\nlemma upperHemicontinuousWithinAt_singleton_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} :\n",
      "body": "```suggestion\n@[simp]\nlemma upperHemicontinuousWithinAt_singleton_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} :\n```",
      "path": "Mathlib/Topology/Semicontinuity/Hemicontinuity.lean",
      "tags": {
        "before_tactics": [
          "aesop",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop",
          "rw"
        ],
        "topics": [
          "continuity",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "IsOpenMap",
          "aesop",
          "LowerHemicontinuous",
          "isOpenMap_iff_kernImage",
          "lowerHemicontinuous_iff_isClosed_preimage_Iic"
        ]
      }
    },
    {
      "id": 1550,
      "before_code": "(\u220f a \u2208 s, \u220f\u1da0 b : \u03b2, f a b) = \u220f\u1da0 b : \u03b2, \u220f a \u2208 s, f a b :=\n  (finprod_prod_comm s (fun b a => f a b) h).symm",
      "suggestion": "    \u220f\u1da0 x, \u220f y \u2208 s with f y = x, g y = \u220f k \u2208 s, g k := by\n",
      "body": "What you have is fine but we could also consider:\n```suggestion\n    \u220f\u1da0 x, \u220f y \u2208 s with f y = x, g y = \u220f k \u2208 s, g k := by\n```\nor even:\n```lean\n    \u220f\u1da0 x, \u220f y \u2208 s.filter (fun j \u21a6 f j = x), g y = \u220f k \u2208 s, g k := by\n```",
      "path": "Mathlib/Algebra/BigOperators/Finprod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "finprod_prod_comm"
        ]
      }
    },
    {
      "id": 1551,
      "before_code": "Tendsto (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm (f \u00d7\u02e2 (g \u00d7\u02e2 h)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) :=\n  (prod_assoc_symm f g h).le",
      "suggestion": "  simp [\u2190 prod_assoc]\n",
      "body": "A proof ending in `rfl` suggests missing lemmas:\n```suggestion\n  simp [\u2190 prod_assoc]\n```",
      "path": "Mathlib/Order/Filter/Prod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "prod_assoc_symm",
          "prodAssoc",
          "Tendsto",
          "Equiv"
        ]
      }
    },
    {
      "id": 1552,
      "before_code": "simp only [ContinuousLinearMap.ext_iff, ContinuousLinearMap.comp_apply] at hg'inv hg'invf \u22a2\n  simp [ContinuousLinearEquiv.eq_symm_apply, *]",
      "suggestion": "      letI x := xyz.1\n      letI y := xyz.2.1\n      letI z := xyz.2.2\n",
      "body": "Using `have` like this will generate a term containing an awkward `match` statement. Instead let's use:\n```suggestion\n      letI x := xyz.1\n      letI y := xyz.2.1\n      letI z := xyz.2.2\n```",
      "path": "Mathlib/Analysis/Calculus/Implicit.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "ContinuousLinearEquiv",
          "eq_symm_apply",
          "ext_iff",
          "ContinuousLinearMap",
          "inv",
          "comp_apply",
          "invf",
          "simp",
          "only"
        ]
      }
    },
    {
      "id": 1554,
      "before_code": "simp only [ContinuousLinearMap.ext_iff, ContinuousLinearMap.comp_apply] at hg'inv hg'invf \u22a2\n  simp [ContinuousLinearEquiv.eq_symm_apply, *]",
      "suggestion": "  simp_rw [nhds_prod_eq]\n  apply \u03c6.implicitFunction_apply_image.prod_mk \u03c6.prod_map_implicitFunction |>.mono\n  aesop\n",
      "body": "I'm proposing we drop this lemma but I'll note in passing that the proof can be just:\n```suggestion\n  simp_rw [nhds_prod_eq]\n  apply \u03c6.implicitFunction_apply_image.prod_mk \u03c6.prod_map_implicitFunction |>.mono\n  aesop\n```",
      "path": "Mathlib/Analysis/Calculus/Implicit.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop"
        ],
        "body_tactics": [
          "apply",
          "aesop"
        ],
        "new_tactics": [
          "apply",
          "aesop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "ContinuousLinearEquiv",
          "eq_symm_apply",
          "ext_iff",
          "ContinuousLinearMap",
          "inv",
          "comp_apply",
          "invf",
          "simp",
          "only"
        ]
      }
    },
    {
      "id": 1556,
      "before_code": "\u00b7 rw [h1]\n  \u00b7 rfl",
      "suggestion": "theorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitFunction xy.1 = xy.2 := by\n  refine h.implicitFunctionData.hasStrictFDerivAt.eventually_left_inverse.mono fun xy h\u2081 h\u2082 \u21a6 ?_\n  change (h.implicitFunctionData.implicitFunction xy.1 (f a)).2 = xy.2\n  change h.implicitFunctionData.implicitFunction xy.1 (f xy) = xy at h\u2081\n  aesop\n",
      "body": "I strongly encourage you to embrace the existing API for `ImplicitFunctionData`. You're currently fighting it quite a bit in this proof. I prefer the following golf not so much because it is shorter but because it makes it clear that this is really just a wrapper around `ImplicitFunctionData.hasStrictFDerivAt` and `HasStrictFDerivAt.eventually_left_inverse`:\n```suggestion\ntheorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitF",
      "path": "Mathlib/Analysis/Calculus/ImplicitContDiff.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "rfl"
        ]
      }
    },
    {
      "id": 1558,
      "before_code": "theorem pow_eq_one_of_norm_le_one {x : K} (hx\u2080 : x \u2260 0) (hxi : IsIntegral \u2124 x)\n    (hx : \u2200 \u03c6 : K \u2192+* A, \u2016\u03c6 x\u2016 \u2264 1) : \u2203 (n : \u2115) (_ : 0 < n), x ^ n = 1 := by\n  obtain \u27e8a, -, b, -, habne, h\u27e9 :=\n    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ \u00b7 : \u2115 \u2192 K) Set.infinite_univ\n      (by exact fun a _ => \u27e8hxi.pow a, fun \u03c6 => by simp [pow_le_one\u2080 (norm_nonneg (\u03c6 x)) <| hx \u03c6]\u27e9)",
      "suggestion": "\r\n      (fun a _ \u21a6 mem_setOf.mpr <|\r\n        \u27e8hxi.pow a, fun \u03c6 \u21a6 by simp [pow_le_one\u2080 (norm_nonneg (\u03c6 x)) <| hx \u03c6]\u27e9)\r\n",
      "body": "optional\r\n```suggestion\r\n      (fun a _ \u21a6 mem_setOf.mpr <|\r\n        \u27e8hxi.pow a, fun \u03c6 \u21a6 by simp [pow_le_one\u2080 (norm_nonneg (\u03c6 x)) <| hx \u03c6]\u27e9)\r\n```",
      "path": "Mathlib/NumberTheory/NumberField/InfinitePlace/Embeddings.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "norm",
          "set_theory",
          "nat",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "IsIntegral",
          "theorem",
          "exists_ne_map_eq_of_mapsTo",
          "hxi",
          "infinite_univ",
          "exact",
          "Set",
          "Infinite",
          "pow_eq_one_of_norm_le_one",
          "norm_nonneg",
          "obtain",
          "simp",
          "pow",
          "habne"
        ]
      }
    },
    {
      "id": 1562,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences",
      "suggestion": "\r\n    ((\u2205 : Std.HashSet Syntax.Range),\r\n     (\u2205 : Std.HashMap Syntax.Range (ContextInfo \u00d7 TacticInfo)),\r\n     (\u2205 : Std.HashSet Syntax.Range),\r\n     (\u2205 : Std.HashSet Syntax.Range)))\r\n",
      "body": "```suggestion\r\n    ((\u2205 : Std.HashSet Syntax.Range),\r\n     (\u2205 : Std.HashMap Syntax.Range (ContextInfo \u00d7 TacticInfo)),\r\n     (\u2205 : Std.HashSet Syntax.Range),\r\n     (\u2205 : Std.HashSet Syntax.Range)))\r\n```\r\nswitching to `HashSet`s/`HashMap` here, means that no duplicating needs to happen later.",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "children",
          "getKind",
          "byTactic",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "Similarly",
          "getting",
          "original",
          "syntax",
          "Array",
          "context",
          "getHeadInfo",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "filterMap",
          "visitM",
          "Tactic",
          "surrounding",
          "childTactics",
          "fileMap",
          "new",
          "snd",
          "child",
          "collect",
          "get",
          "into",
          "then"
        ]
      }
    },
    {
      "id": 1563,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n            if open Parser.Tactic in\r\n              #[`\u00ab;\u00bb, ``cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb, ``tacticSeq, ``tacticSeq1Indented,\r\n                ``Parser.Term.byTactic, ``tacticHave__, ``tacticLet__].contains stx.getKind then\r\n",
      "body": "```suggestion\r\n            if open Parser.Tactic in\r\n              #[`\u00ab;\u00bb, ``cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb, ``tacticSeq, ``tacticSeq1Indented,\r\n                ``Parser.Term.byTactic, ``tacticHave__, ``tacticLet__].contains stx.getKind then\r\n```\r\nTo me, this seems more easily extendable.  Possibly, I would even factor out the Array/HashSet of `SyntaxNodeKind`s.",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "ofTacticInfo"
        ]
      }
    },
    {
      "id": 1564,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences",
      "suggestion": "\r\n            if stx.isOfKind ``Parser.Tactic.tacticTry_ ||\r\n               stx.isOfKind ``Parser.Tactic.anyGoals then\r\n",
      "body": "```suggestion\r\n            if stx.isOfKind ``Parser.Tactic.tacticTry_ ||\r\n               stx.isOfKind ``Parser.Tactic.anyGoals then\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "children",
          "getKind",
          "byTactic",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "Similarly",
          "getting",
          "original",
          "syntax",
          "Array",
          "context",
          "getHeadInfo",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "filterMap",
          "visitM",
          "Tactic",
          "surrounding",
          "childTactics",
          "fileMap",
          "new",
          "snd",
          "child",
          "collect",
          "get",
          "into",
          "then"
        ]
      }
    },
    {
      "id": 1565,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences",
      "suggestion": "\r\n          if stx.isOfKind ``Parser.Tactic.tacticHave__ ||\r\n             stx.isOfKind ``Parser.Tactic.tacticLet__ then\r\n",
      "body": "```suggestion\r\n          if stx.isOfKind ``Parser.Tactic.tacticHave__ ||\r\n             stx.isOfKind ``Parser.Tactic.tacticLet__ then\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "children",
          "getKind",
          "byTactic",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "Similarly",
          "getting",
          "original",
          "syntax",
          "Array",
          "context",
          "getHeadInfo",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "filterMap",
          "visitM",
          "Tactic",
          "surrounding",
          "childTactics",
          "fileMap",
          "new",
          "snd",
          "child",
          "collect",
          "get",
          "into",
          "then"
        ]
      }
    },
    {
      "id": 1566,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences",
      "suggestion": "\r\n          if stx.isOfKind ``Parser.Tactic.tacticSeq ||\r\n             stx.isOfKind ``Parser.Tactic.tacticSeq1Indented then\r\n",
      "body": "```suggestion\r\n          if stx.isOfKind ``Parser.Tactic.tacticSeq ||\r\n             stx.isOfKind ``Parser.Tactic.tacticSeq1Indented then\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "children",
          "getKind",
          "byTactic",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "Similarly",
          "getting",
          "original",
          "syntax",
          "Array",
          "context",
          "getHeadInfo",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "filterMap",
          "visitM",
          "Tactic",
          "surrounding",
          "childTactics",
          "fileMap",
          "new",
          "snd",
          "child",
          "collect",
          "get",
          "into",
          "then"
        ]
      }
    },
    {
      "id": 1567,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n  let mkTacticNodes (tacs : Std.HashMap Syntax.Range (ContextInfo \u00d7 TacticInfo)) :\r\n      Array TacticNode :=\r\n    let sorted := tacs.toArray.qsort fun (r1, _, _) (r2, _, _) => r1.start < r2.start\r\n",
      "body": "```suggestion\r\n  let mkTacticNodes (tacs : Std.HashMap Syntax.Range (ContextInfo \u00d7 TacticInfo)) :\r\n      Array TacticNode :=\r\n    let sorted := tacs.toArray.qsort fun (r1, _, _) (r2, _, _) => r1.start < r2.start\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 1581,
      "before_code": "rw [and_congr_right IsClosed.isNowhereDense_iff,\n    isOpen_compl_iff, interior_eq_empty_iff_dense_compl]",
      "suggestion": "\r\n/-- To check that `s` is nowhere dense, it suffices to check that no point of `s`\r\nis in the interior of `closure s`. -/\r\nlemma isNowhereDense_iff_disjoint {s : Set X} :\r\n    IsNowhereDense s \u2194 Disjoint s (interior (closure s)) :=\r\n  \u27e8fun H \u21a6 H \u25b8 disjoint_empty _, fun H \u21a6\r\n    H.closure_left isOpen_interior |>.mono_left interior_subset |>.eq_bot_of_self\u27e9\r\n\r\n/-- To check that `s` is nowhere dense, it suffices to check that `closure s` is not a\r\nneighborhood of any point of `s`. -/\r\nlemma isNowhereDense_iff_forall_notMem_nhds {s : Set X} :\r\n    IsNowhereDense s \u2194 \u2200 x \u2208 s, closure s \u2209 \ud835\udcdd x := by\r\n  simp [isNowhereDense_iff_disjoint, disjoint_iff_inter_eq_empty, eq_empty_iff_forall_notMem,\r\n    mem_interior_iff_mem_nhds]\r\n\r\n/-- The image of a nowhere dense set through an inducing map is nowhere dense. -/\r\nlemma Topology.IsInducing.isNowhereDense_image {f : X \u2192 Y} [TopologicalSpace Y]\r\n    (hf : Topology.IsInducing f) {s : Set X} (h : IsNowhereDense s) : IsNowhereDense (f '' s) := by\r\n  rw",
      "body": "I was intrigued by this proof: it is slightly mathematically annoying, because you have to change the original `y` if it's not in `f '' s`. This led me to the following, which you should feel free to accept or not (i.e I have no preference):\r\n```suggestion\r\n/-- To check that `s` is nowhere dense, it suffices to check that no point of `s`\r\nis in the interior of `closure s`. -/\r\nlemma isNowhereDense_iff_disjoint {s : Set X} :\r\n    IsNowhereDense s \u2194 Disjoint s (interior (closure s)) :=\r\n  \u27e8fun H \u21a6",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "interior_eq_empty_iff_dense_compl",
          "and_congr_right",
          "isOpen_compl_iff",
          "IsClosed",
          "isNowhereDense_iff"
        ]
      }
    },
    {
      "id": 1582,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  obtain \u27e8x, rfl\u27e9 := h\u2081\r\n  choose c hc using @h\u2082\r\n  simp only [funext_iff] at hc\r\n  use x.substFunc c\r\n  funext v\r\n  induction x with\r\n  | var => simp\r\n  | func f ts ih => simp [\u2190 ih, \u2190 hc]\r\n",
      "body": "We have `choose` tactic, which is easier to read than raw `Classical.choose`.\r\n\r\n```suggestion\r\n  obtain \u27e8x, rfl\u27e9 := h\u2081\r\n  choose c hc using @[user]\r\n  simp only [funext_iff] at hc\r\n  use x.substFunc c\r\n  funext v\r\n  induction x with\r\n  | var => simp\r\n  | func f ts ih => simp [\u2190 ih, \u2190 hc]\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "funext",
          "induction",
          "simp"
        ],
        "body_tactics": [
          "funext",
          "have",
          "obtain",
          "induction",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "funext",
          "induction",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1583,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  obtain \u27e8\u03c6, rfl\u27e9 := h\r\n",
      "body": "```suggestion\r\n  obtain \u27e8\u03c6, rfl\u27e9 := h\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1584,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081_iff_termDefinable (f : M \u2192 M) : A.TermDefinable\u2081 L f \u2194\r\n    A.TermDefinable L (fun v \u21a6 f (v ())) := by\r\n  refine exists_congr fun \u03c6 \u21a6 ?_\r\n  rw [funext_iff, funext_iff, (Equiv.funUnique Unit M).forall_congr']\r\n  simp only [Equiv.funUnique_symm_apply, uniqueElim_const, Function.comp_apply]\r\n  congr!\r\n",
      "body": "This would be shorter (just an suggestion, feel free to ignore it)\r\n\r\n```suggestion\r\ntheorem TermDefinable\u2081_iff_termDefinable (f : M \u2192 M) : A.TermDefinable\u2081 L f \u2194\r\n    A.TermDefinable L (fun v \u21a6 f (v ())) := by\r\n  refine exists_congr fun \u03c6 \u21a6 ?_\r\n  rw [funext_iff, funext_iff, (Equiv.funUnique Unit M).forall_congr']\r\n  simp only [Equiv.funUnique_symm_apply, uniqueElim_const, Function.comp_apply]\r\n  congr!\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1585,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n    A.Definable\u2082 L f.graph.uncurry := by\r\n",
      "body": "```suggestion\r\n    A.Definable\u2082 L f.graph.uncurry := by\r\n```\r\nShorter",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1586,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  obtain \u27e8t, h\u27e9 := TermDefinable.Definable A L h\r\n",
      "body": "```suggestion\r\n  obtain \u27e8t, h\u27e9 := TermDefinable.Definable A L h\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1587,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\nvariable (L) in\r\n",
      "body": "```suggestion\r\nvariable (L) in\r\n```\r\nThe theorems below should not have argument `L` explicit.",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1588,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.const M C) :=\r\n  (TermDefinable.const C).termDefinable\u2081\r\n",
      "body": "Generalize\r\n\r\n```suggestion\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.c",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_fun_prop"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1589,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp {f g : M \u2192 M} (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable\u2081 L g) :\r\n    A.TermDefinable\u2081 L (f \u2218 g) :=\r\n  (hf.termDefinable.comp fun _ \u21a6 hg.termDefinable).termDefinable\u2081\r\n\r\n/-- A `TermDefinable` function postcomposed with `TermDefinable\u2081` is `TermDefinable`. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp_termDefinable {f : M \u2192 M} {g : (\u03b1 \u2192 M) \u2192 M}\r\n    (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable L g) : A.TermDefinable L (f \u2218 g) :=\r\n  hf.termDefinable.comp fun _ \u21a6 hg\r\n",
      "body": "```suggestion\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "new_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_fun_prop"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1591,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081.graph_definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n    A.Definable\u2082 L f.graph := by\r\n  obtain \u27e8t, h\u27e9 := h.termDefinable.tupleGraph_definable A L\r\n  use t.relabel (Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  ext v\r\n  convert Set.ext_iff.1 h (Sum.elim (fun _ \u21a6 v 0) (fun _ \u21a6 v 1))\r\n  rw [mem_setOf, mem_setOf, Formula.realize_relabel, Sum.comp_elim]\r\n  rfl\r\n",
      "body": "```suggestion\r\ntheorem TermDefinable\u2081.graph_definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n    A.Definable\u2082 L f.graph := by\r\n  obtain \u27e8t, h\u27e9 := h.termDefinable.tupleGraph_definable A L\r\n  use t.relabel (Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  ext v\r\n  convert Set.ext_iff.1 h (Sum.elim (fun _ \u21a6 v 0) (fun _ \u21a6 v 1))\r\n  rw [mem_setOf, mem_setOf, Formula.realize_relabel, Sum.comp_elim]\r\n  rfl\r\n```\r\n\r\n`rw [setOf]` is a defeq abuse (see docstring of `Set.setOf_app_iff`)",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1592,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- TermDefinable is transitive. If f is TermDefinable in a structure S on L, and all of the\r\nfunctions' realizations on S are TermDefinable on a structure T on L', then f is\r\nTermDefinable on T in L'. -/\r\n",
      "body": "```suggestion\r\n/-- TermDefinable is transitive. If f is TermDefinable in a structure S on L, and all of the\r\nfunctions' realizations on S are TermDefinable on a structure T on L', then f is\r\nTermDefinable on T in L'. -/\r\n```\r\n\r\nThe new [style guide](https://leanprover-community.github.io/contribute/doc.html) is to not indent the docstrings. Also for other multiline docstrings.",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1593,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  convert Set.ext_iff.1 h (v \u2218 Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  simp\r\n",
      "body": "golf\r\n```suggestion\r\n  convert Set.ext_iff.1 h (v \u2218 Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  simp\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 1607,
      "before_code": "(\"divisionAddMonoid\", \"SubtractionMonoid\"),\n  (\"subNegZeroAddMonoid\", \"SubNegZeroMonoid\"),\n  (\"modularCharacter\", \"AddModularCharacter\"),\n  (\"isQuotientCoveringMap\", \"IsAddQuotientCoveringMap\")]",
      "suggestion": "\r\n  (\"isQuotientCoveringMap\", \"IsAddQuotientCoveringMap\")]\r\n",
      "body": "```suggestion\r\n  (\"isQuotientCoveringMap\", \"IsAddQuotientCoveringMap\")]\r\n```",
      "path": "Mathlib/Tactic/Translate/ToAdditive.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "modularCharacter",
          "SubNegZeroMonoid",
          "subNegZeroAddMonoid",
          "SubtractionMonoid",
          "divisionAddMonoid",
          "AddModularCharacter",
          "isQuotientCoveringMap",
          "IsAddQuotientCoveringMap"
        ]
      }
    },
    {
      "id": 1616,
      "before_code": "(eq_bot_or_eq_top (Subgroup.zpowers g)).resolve_left (Subgroup.zpowers_ne_bot.2 hg)\n  exact \u27e8\u27e8g, (Subgroup.eq_top_iff' _).1 this\u27e9\u27e9\n\n@[to_additive]\ntheorem prime_card [Finite \u03b1] : (Nat.card \u03b1).Prime := by",
      "suggestion": "\r\ntheorem prime_card : (Nat.card \u03b1).Prime := by\r\n  have : Finite \u03b1 := CommSimple_is_Finite\r\n",
      "body": "I think you should just modify this proof instead of making another one\r\n```suggestion\r\ntheorem prime_card : (Nat.card \u03b1).Prime := by\r\n  have : Finite \u03b1 := CommSimple_is_Finite\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "to_additive",
          "Finite",
          "theorem",
          "exact",
          "Nat",
          "eq_bot_or_eq_top",
          "zpowers",
          "this",
          "eq_top_iff",
          "prime_card",
          "resolve_left",
          "zpowers_ne_bot",
          "Prime",
          "card"
        ]
      }
    },
    {
      "id": 1617,
      "before_code": "(eq_bot_or_eq_top (Subgroup.zpowers g)).resolve_left (Subgroup.zpowers_ne_bot.2 hg)\n  exact \u27e8\u27e8g, (Subgroup.eq_top_iff' _).1 this\u27e9\u27e9",
      "suggestion": "theorem IsSimpleGroup.finite : Finite \u03b1 := by\n",
      "body": "```suggestion\ntheorem IsSimpleGroup.finite : Finite \u03b1 := by\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "exact",
          "eq_bot_or_eq_top",
          "this",
          "zpowers",
          "eq_top_iff",
          "resolve_left",
          "zpowers_ne_bot"
        ]
      }
    },
    {
      "id": 1618,
      "before_code": "|>.symm.trans <| QuotientAddGroup.quotientAddEquivOfEq kereq\n    |>.symm.trans <| QuotientAddGroup.quotientKerEquivOfSurjective (zmultiplesHom G g) surj",
      "suggestion": "theorem exists_prime_addEquiv_ZMod [CommGroup G] [IsSimpleGroup G] :\n",
      "body": "```suggestion\ntheorem exists_prime_addEquiv_ZMod [CommGroup G] [IsSimpleGroup G] :\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "QuotientAddGroup",
          "quotientAddEquivOfEq",
          "quotientKerEquivOfSurjective",
          "kereq",
          "zmultiplesHom",
          "surj",
          "trans"
        ]
      }
    },
    {
      "id": 1619,
      "before_code": "|>.symm.trans <| QuotientAddGroup.quotientAddEquivOfEq kereq\n    |>.symm.trans <| QuotientAddGroup.quotientKerEquivOfSurjective (zmultiplesHom G g) surj",
      "suggestion": "/-- A commutative simple group is isomorphic to `ZMod p` for some prime `p`. -/\n",
      "body": "```suggestion\n/-- A commutative simple group is isomorphic to `ZMod p` for some prime `p`. -/\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "QuotientAddGroup",
          "quotientAddEquivOfEq",
          "quotientKerEquivOfSurjective",
          "kereq",
          "zmultiplesHom",
          "surj",
          "trans"
        ]
      }
    },
    {
      "id": 1621,
      "before_code": "|>.symm.trans <| QuotientAddGroup.quotientAddEquivOfEq kereq\n    |>.symm.trans <| QuotientAddGroup.quotientKerEquivOfSurjective (zmultiplesHom G g) surj",
      "suggestion": "  have orderG : Nat.card G = p := (orderOf_eq_card_of_zpowers_eq_top hg).symm\n",
      "body": "```suggestion\n  have orderG : Nat.card G = p := (orderOf_eq_card_of_zpowers_eq_top hg).symm\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "QuotientAddGroup",
          "quotientAddEquivOfEq",
          "quotientKerEquivOfSurjective",
          "kereq",
          "zmultiplesHom",
          "surj",
          "trans"
        ]
      }
    },
    {
      "id": 1622,
      "before_code": "|>.symm.trans <| QuotientAddGroup.quotientAddEquivOfEq kereq\n    |>.symm.trans <| QuotientAddGroup.quotientKerEquivOfSurjective (zmultiplesHom G g) surj",
      "suggestion": "  \u00b7 exact \u27e8(zmodAddCyclicAddEquiv (G := Additive G) inferInstance).symm\u27e9\n",
      "body": "```suggestion\n  \u00b7 exact \u27e8(zmodAddCyclicAddEquiv (G := Additive G) inferInstance).symm\u27e9\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "QuotientAddGroup",
          "quotientAddEquivOfEq",
          "quotientKerEquivOfSurjective",
          "kereq",
          "zmultiplesHom",
          "surj",
          "trans"
        ]
      }
    },
    {
      "id": 1632,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "  choose g hg1 hg2 hg3 using fun n => exists_open_dense_of_open_dense_subtype hd (hof n) (hdf n)\n",
      "body": "```suggestion\n  choose g hg1 hg2 hg3 using fun n => exists_open_dense_of_open_dense_subtype hd (hof n) (hdf n)\n```\nCan you just work with this? And simp/rw with `hg3` backwards, when needed.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 1633,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n",
      "body": "```suggestion\n  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n```\n\n`by exact` is (almost always) a no-op.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 1634,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "      (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset]))\n",
      "body": "```suggestion\n      (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset]))\n```",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 1635,
      "before_code": "(fun n => closure_mono <| hK_anti n) (fun n => (K n).nonempty.closure)\n      (K 0).isCompact.closure fun n => isClosed_closure\n  exact hK_nonempty.mono hK_subset",
      "suggestion": "    \u00b7 exact isClosed_closure.locallyCompactSpace\n",
      "body": "```suggestion\n    \u00b7 exact isClosed_closure.locallyCompactSpace\n```",
      "path": "Mathlib/Topology/Baire/LocallyCompactRegular.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "mono",
          "exact",
          "closure",
          "hK_nonempty",
          "closure_mono",
          "hK_subset",
          "nonempty",
          "isCompact",
          "isClosed_closure",
          "hK_anti"
        ]
      }
    },
    {
      "id": 1636,
      "before_code": "(fun n => closure_mono <| hK_anti n) (fun n => (K n).nonempty.closure)\n      (K 0).isCompact.closure fun n => isClosed_closure\n  exact hK_nonempty.mono hK_subset",
      "suggestion": "  have : BaireSpace ((\u2191) \u207b\u00b9' s : Set (closure s)) :=\n    (isG\u03b4_induced continuous_subtype_val hG).baireSpace_of_dense\n",
      "body": "```suggestion\n  have : BaireSpace ((\u2191) \u207b\u00b9' s : Set (closure s)) :=\n    (isG\u03b4_induced continuous_subtype_val hG).baireSpace_of_dense\n```",
      "path": "Mathlib/Topology/Baire/LocallyCompactRegular.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "mono",
          "exact",
          "closure",
          "hK_nonempty",
          "closure_mono",
          "hK_subset",
          "nonempty",
          "isCompact",
          "isClosed_closure",
          "hK_anti"
        ]
      }
    },
    {
      "id": 1637,
      "before_code": "theorem IsG\u03b4.iUnion [Finite \u03b9'] {f : \u03b9' \u2192 Set X} (h : \u2200 i, IsG\u03b4 (f i)) : IsG\u03b4 (\u22c3 i, f i) :=\n  .sUnion (finite_range _) <| forall_mem_range.2 h",
      "suggestion": "  obtain \u27e8U, hU1, hU2\u27e9 := hs.eq_iInter_nat\n",
      "body": "```suggestion\n  obtain \u27e8U, hU1, hU2\u27e9 := hs.eq_iInter_nat\n```",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "Finite",
          "theorem",
          "forall_mem_range",
          "iUnion",
          "Set",
          "sUnion",
          "finite_range"
        ]
      }
    },
    {
      "id": 1638,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "    (fun n => (hg1 n).inter (hV.1 n))\n    (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset])) (hg1 n))\n",
      "body": "```suggestion\n    (fun n => (hg1 n).inter (hV.1 n))\n    (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset])) (hg1 n))\n```\nI think this slightly improves readability.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 1642,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n",
      "body": "I would like to reformat this to make it easier to distinguish the different arguments. I originally thought this was one argument to `mkCLM`.\n```suggestion\n  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n```\nThen indent the remainder of the proof, and remove the final `)`.",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "simpa",
          "simp",
          "intro",
          "fun_prop"
        ],
        "body_tactics": [
          "ext",
          "simpa",
          "simp",
          "intro",
          "fun_prop"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "ext",
          "intro",
          "fun_prop"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa",
          "use_fun_prop"
        ],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 1643,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "        cases n with\n        | zero => \n          simp only [Finset.range_zero, Nat.choose_zero_succ, CharP.cast_eq_zero, zero_mul,\n            Finset.sum_const_zero]\n          positivity\n        | succ n =>\n          have : \u2211 k \u2208 Finset.range n,\n              (((n + 1).choose (k + 1 + 1)) : \u211d) * \u2016iteratedFDeriv \u211d (k + 1 + 1) L x\u2016 *\n              \u2016iteratedFDeriv \u211d (n + 1 - (k + 1 + 1)) f x\u2016 = 0 := by\n            apply Finset.sum_eq_zero\n            simp [iteratedFDeriv_succ_eq_comp_right, iteratedFDeriv_succ_const]\n          rw [Finset.sum_range_succ', this]\n",
      "body": "It's nicer to use `cases` here since `n : \u2115`. Then you don't have to futz with `n' + 1 = n` and all so forth.\n```suggestion\n        cases n with\n        | zero => \n          simp only [Finset.range_zero, Nat.choose_zero_succ, CharP.cast_eq_zero, zero_mul,\n            Finset.sum_const_zero]\n          positivity\n        | succ n =>\n          have : \u2211 k \u2208 Finset.range n,\n              (((n + 1).choose (k + 1 + 1)) : \u211d) * \u2016iteratedFDeriv \u211d (k + 1 + 1) L x\u2016 *\n              \u2016iteratedFDeriv \u211d (n + 1 - ",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "positivity",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "positivity",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "positivity",
          "rw",
          "simp",
          "cases",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 1644,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "        grw [le_opNorm, \u2190 le_seminorm \ud835\udd5c (k + 1) n f x, \u2190 le_seminorm \ud835\udd5c k (n - 1) f x]\n        apply le_of_eq\n        ring\n",
      "body": "no need for the `add_le_add` as that's sort of the point of `grw`. And I think `apply le_of_eq` is better so that we get a terminal `ring` call.\n```suggestion\n        grw [le_opNorm, \u2190 le_seminorm \ud835\udd5c (k + 1) n f x, \u2190 le_seminorm \ud835\udd5c k (n - 1) f x]\n        apply le_of_eq\n        ring\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "ring"
        ],
        "body_tactics": [
          "apply",
          "ring"
        ],
        "new_tactics": [
          "apply",
          "ring"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 1645,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "        gcongr <;> simp\n",
      "body": "```suggestion\n        gcongr <;> simp\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "gcongr",
          "simp"
        ],
        "body_tactics": [
          "gcongr",
          "simp"
        ],
        "new_tactics": [
          "gcongr",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 1646,
      "before_code": "continuousOn_sqrt := by fun_prop\n  sqrt_nonneg _ _ := by simp\n  sqrt_mul_sqrt x hx := by\n    simp only [Function.comp_apply,]",
      "suggestion": "    simp only [Function.comp_apply]\n",
      "body": "```suggestion\n    simp only [Function.comp_apply]\n```",
      "path": "Mathlib/Topology/ContinuousMap/ContinuousSqrt.lean",
      "tags": {
        "before_tactics": [
          "fun_prop",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "function"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "sqrt_mul_sqrt",
          "continuousOn_sqrt",
          "comp_apply",
          "simp",
          "sqrt_nonneg",
          "Function",
          "fun_prop",
          "only"
        ]
      }
    },
    {
      "id": 1648,
      "before_code": "convert hf.add hg.neg using 1\n  grind",
      "suggestion": "\r\n  classical\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert a s has ih => \r\n    obtain \u27e8hf, h\u27e9 := by simpa using hf\r\n    simpa [has] using hf.add (ih h)\r\n",
      "body": "When I saw this, I thought \"do we really not have `HasTemperateGrowth.add`?\" and then I realized we do. This is much easier than you're making it. You need to use an induction principle. In this case:\r\n```suggestion\r\n  classical\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert a s has ih => \r\n    obtain \u27e8hf, h\u27e9 := by simpa using hf\r\n    simpa [has] using hf.add (ih h)\r\n```",
      "path": "Mathlib/Analysis/Distribution/TemperateGrowth.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "removed_tactics": [
          "grind"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "add",
          "neg",
          "convert",
          "grind",
          "using"
        ]
      }
    },
    {
      "id": 1649,
      "before_code": "filter_upwards [Tendsto.eventually_const_lt (zero_lt_one) h\u03c6, hu\u03c6v] with x h\u03c6_pos huv'\n  simp [\u2190 Real.mul_rpow (le_of_lt h\u03c6_pos) (hv x), huv']",
      "suggestion": "\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <| Real.tendsto_log_atTop.comp g_tendsto\r\n",
      "body": "slightly cleaner\r\n```suggestion\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <",
      "path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "body_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "new_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "eventually_const_lt",
          "zero_lt_one",
          "Real",
          "Tendsto",
          "filter_upwards",
          "mul_rpow",
          "simp",
          "huv"
        ]
      }
    },
    {
      "id": 1654,
      "before_code": "return splitCase (s.extract i\u2081 s.endPos) 0 <| (s.extract 0 i\u2081)::r\n  return splitCase s i\u2081 r\n\n/-- Helper for `capitalizeLike`. -/\npartial def capitalizeLikeAux (s : String) (i : String.Pos := 0) (p : String) : String :=\n  if p.atEnd i || s.atEnd i then\n    p\n  else\n    let j := p.next i\n    if (s.get i).isLower then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toLower)\n    else if (s.get i).isUpper then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toUpper)\n    else\n      capitalizeLikeAux s j p\n\n/-- Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. -/\ndef capitalizeLike (r : String) (s : String) :=\n  capitalizeLikeAux r 0 s\n\n/-- Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. -/\ndef capitalizeFirstLike (s : String) : List String \u2192 List String\n  | x :: r => capitalizeLike s x :: r\n  | [] => []\n\n/--\nDictionary used by `guessName` to autogenerate names.\n\nNote: `guessName` capitalizes first element of the output according to\ncapitalization of the input. Input and first element should therefore be lower-case,\n2nd element should be capitalized properly.\n-/\ndef nameDict : String \u2192 List String\n  | \"one\"           => [\"zero\"]\n  | \"mul\"           => [\"add\"]\n  | \"smul\"          => [\"vadd\"]\n  | \"inv\"           => [\"neg\"]\n  | \"div\"           => [\"sub\"]\n  | \"prod\"          => [\"sum\"]\n  | \"hmul\"          => [\"hadd\"]\n  | \"hsmul\"         => [\"hvadd\"]\n  | \"hdiv\"          => [\"hsub\"]\n  | \"hpow\"          => [\"hsmul\"]\n  | \"finprod\"       => [\"finsum\"]\n  | \"tprod\"         => [\"tsum\"]\n  | \"pow\"           => [\"nsmul\"]\n  | \"npow\"          => [\"nsmul\"]\n  | \"zpow\"          => [\"zsmul\"]\n  | \"mabs\"          => [\"abs\"]\n  | \"monoid\"        => [\"add\", \"Monoid\"]\n  | \"submonoid\"     => [\"add\", \"Submonoid\"]\n  | \"group\"         => [\"add\", \"Group\"]\n  | \"subgroup\"      => [\"add\", \"Subgroup\"]\n  | \"semigroup\"     => [\"add\", \"Semigroup\"]\n  | \"magma\"         => [",
      "suggestion": "\r\nApply the `nameDict` and decapitalize the output like the input.\r\n\r\nE.g. `#eval applyNameDict [\"Inv\", \"HMul\", \"LE\", \"Conjugate\u2082\", \"SMul\", \"_\", \"ne\", \"_\", \"top\"]` yields\r\n`[\"Neg\", \"HAdd\", \"LE\", \"Conjugate\u2082\", \"VAdd\", \"_\", \"ne\", \"_\", \"top\"]`.\r\n",
      "body": "Just continuing the example from `splitCase`:\r\n```suggestion\r\nApply the `nameDict` and decapitalize the output like the input.\r\n\r\nE.g. `#eval applyNameDict [\"Inv\", \"HMul\", \"LE\", \"Conjugate\u2082\", \"SMul\", \"_\", \"ne\", \"_\", \"top\"]` yields\r\n`[\"Neg\", \"HAdd\", \"LE\", \"Conjugate\u2082\", \"VAdd\", \"_\", \"ne\", \"_\", \"top\"]`.\r\n```",
      "path": "Mathlib/Tactic/ToAdditive/GuessName.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "cases"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases"
        ],
        "topics": [
          "list",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Monoid",
          "divisible",
          "neg",
          "isUpper",
          "String",
          "submonoid",
          "next",
          "Unit",
          "mul",
          "add",
          "else",
          "grp",
          "toUpper",
          "rootable",
          "Group",
          "like",
          "hmul",
          "def",
          "mconv",
          "return",
          "that",
          "capitalizeLikeAux",
          "output",
          "input",
          "subgroup",
          "Commute",
          "finsum",
          "group",
          "semigrp",
          "Quantale",
          "conv",
          "Semiconj",
          "Prehaar",
          "endPos",
          "should",
          "List",
          "vadd",
          "longer",
          "Subgroup",
          "smul",
          "cyclic",
          "nameDict",
          "guessName",
          "apply",
          "abs",
          "Semigroup",
          "gpfree",
          "cases",
          "set",
          "Submonoid"
        ]
      }
    },
    {
      "id": 1655,
      "before_code": "return splitCase (s.extract i\u2081 s.endPos) 0 <| (s.extract 0 i\u2081)::r\n  return splitCase s i\u2081 r\n\n/-- Helper for `capitalizeLike`. -/\npartial def capitalizeLikeAux (s : String) (i : String.Pos := 0) (p : String) : String :=\n  if p.atEnd i || s.atEnd i then\n    p\n  else\n    let j := p.next i\n    if (s.get i).isLower then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toLower)\n    else if (s.get i).isUpper then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toUpper)\n    else\n      capitalizeLikeAux s j p\n\n/-- Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. -/\ndef capitalizeLike (r : String) (s : String) :=\n  capitalizeLikeAux r 0 s\n\n/-- Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. -/\ndef capitalizeFirstLike (s : String) : List String \u2192 List String\n  | x :: r => capitalizeLike s x :: r\n  | [] => []\n\n/--\nDictionary used by `guessName` to autogenerate names.\n\nNote: `guessName` capitalizes first element of the output according to\ncapitalization of the input. Input and first element should therefore be lower-case,\n2nd element should be capitalized properly.\n-/\ndef nameDict : String \u2192 List String\n  | \"one\"           => [\"zero\"]\n  | \"mul\"           => [\"add\"]\n  | \"smul\"          => [\"vadd\"]\n  | \"inv\"           => [\"neg\"]\n  | \"div\"           => [\"sub\"]\n  | \"prod\"          => [\"sum\"]\n  | \"hmul\"          => [\"hadd\"]\n  | \"hsmul\"         => [\"hvadd\"]\n  | \"hdiv\"          => [\"hsub\"]\n  | \"hpow\"          => [\"hsmul\"]\n  | \"finprod\"       => [\"finsum\"]\n  | \"tprod\"         => [\"tsum\"]\n  | \"pow\"           => [\"nsmul\"]\n  | \"npow\"          => [\"nsmul\"]\n  | \"zpow\"          => [\"zsmul\"]\n  | \"mabs\"          => [\"abs\"]\n  | \"monoid\"        => [\"add\", \"Monoid\"]\n  | \"submonoid\"     => [\"add\", \"Submonoid\"]\n  | \"group\"         => [\"add\", \"Group\"]\n  | \"subgroup\"      => [\"add\", \"Subgroup\"]\n  | \"semigroup\"     => [\"add\", \"Semigroup\"]\n  | \"magma\"         => [",
      "suggestion": "\r\n    `fixAbbreviation [\"eventually\", \"LE\", \"_\", \"one\"]` to `\"eventuallyLE_one\"`, since otherwise the\r\n    substring `LE_zero` gets replaced by `Nonpos`. -/\r\n",
      "body": "```suggestion\r\n    `fixAbbreviation [\"eventually\", \"LE\", \"_\", \"one\"]` to `\"eventuallyLE_one\"`, since otherwise the\r\n    substring `LE_zero` gets replaced by `Nonpos`. -/\r\n```",
      "path": "Mathlib/Tactic/ToAdditive/GuessName.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "cases"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "cases"
        ],
        "topics": [
          "list",
          "measurability",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Indicator",
          "NSMul",
          "Monoid",
          "neg",
          "divisible",
          "IsCancelAdd",
          "String",
          "subtractionMonoid",
          "isUpper",
          "submonoid",
          "isCancelAdd",
          "next",
          "AddCancel",
          "mul",
          "isLeftCancelAdd",
          "Unit",
          "add",
          "work",
          "else",
          "Neg",
          "Quotient",
          "grp",
          "rootable",
          "Division",
          "toUpper",
          "prone",
          "Has",
          "Nonpos",
          "Group",
          "reduce",
          "like",
          "Cancel",
          "hmul",
          "Unique",
          "few",
          "def",
          "well",
          "addRightCancel",
          "isOfFinAddOrder",
          "mconv",
          "return",
          "addQuotientMeasure",
          "naming",
          "input",
          "output",
          "subgroup",
          "Commute",
          "that",
          "finsum",
          "capitalizeLikeAux"
        ]
      }
    },
    {
      "id": 1657,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_mul_X_pow {n m : \u2115} (p : R[X]) :\n    derivative^[n] (p * X ^ m) = \u2211 k \u2208 Iic (min m n),\n      (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n",
      "body": "It took me a few moments to understand why the terms involving `derivative^[n - k]` were not junk given that one could have `k > n` (the answer being that in these cases `n.choose k = 0`). I also think that the `range x.succ` is easier to parse as `Iic x`. With these two points in mind, how do you feel about stating this as:\n```suggestion\ntheorem iterate_derivative_mul_X_pow {n m : \u2115} (p : R[X]) :\n    derivative^[n] (p * X ^ m) = \u2211 k \u2208 Iic (min m n),\n      (n.choose k * m.descFactorial k) \u2022 (der",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "cases",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1658,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "\r\ntheorem iterate_derivative_derivative_mul_X_pow {n m l : \u2115} (p : R[X]) (hl : m \u2264 l) :\r\n    derivative^[n] (derivative^[l] p * X ^ m) =\r\n      \u2211 k \u2208 range (min m n).succ,\r\n        ((n.choose k * m.descFactorial k) \u2022 (derivative^[n + (l - k)] p * X ^ (m - k))) := by\r\n  have {k : \u2115} (hk : k \u2208 range (min m n).succ) : n - k + l = n + (l - k) := by\r\n    replace hk : k \u2264 m \u2227 k \u2264 n := by simpa using hk\r\n    grind\r\n  simp_rw [iterate_derivative_mul_X_pow, \u2190 Function.iterate_add_apply]\r\n  exact Finset.sum_congr rfl fun k hk \u21a6 by simp [this hk]\r\n",
      "body": "I'm also dubious about this lemma since it's really just an extension of `iterate_derivative_mul_X_pow` which inlines a proof that `n + (m - k) = n - k + m` for `k` in the right range.\r\n\r\nOf course convenience lemmas can be justified if they come up enough. If you do have compelling evidence in favour then I think we should generalise since the repeated `m` is not relevant, and also avoid using low-level lemmas like `Nat.add_sub_assoc` as follows:\r\n```suggestion\r\ntheorem iterate_derivative_deriv",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1661,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n    simp_rw [iterate_derivative_mul, iterate_derivative_X_pow_eq_smul, mul_smul]\n    congr! 2 with k hk\n    norm_cast\n    ring\n  rw [hsum]\n  refine sum_congr_of_eq_on_inter (fun k hk hk' \u21a6 ?_) (by aesop) (by simp)\n  rcases le_or_gt k m with hkm | hkm\n  \u00b7 replace hk' : n < k := by simpa [hkm] using hk'\n    simp [Nat.choose_eq_zero_of_lt hk']\n  \u00b7 simp [Nat.descFactorial_eq_zero_iff_lt.mpr hkm]\n",
      "body": "Here's a slight golf. It's happens to be shorter but my main aim was to make the formal proof match how I think about this argument a bit more closely:\n```suggestion\ntheorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivati",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "ring",
          "norm_cast"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "ring",
          "norm_cast"
        ],
        "new_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_ring",
          "use_aesop"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1662,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_derivative_mul_X {n : \u2115} (p : R[X]) :\n    derivative^[n] (derivative p * X) = (derivative^[n + 1] p) * X + n \u2022 derivative^[n] p := by\n  convert (derivative p).iterate_derivative_mul_X_pow n 1; \u00b7 simp\n  rcases n with rfl | n <;> simp [sum_range_succ]\n",
      "body": "Another small golf, with similar goals to the one above. Also a rename (using primed names is allowed but only really as a last resort):\n```suggestion\ntheorem iterate_derivative_derivative_mul_X {n : \u2115} (p : R[X]) :\n    derivative^[n] (derivative p * X) = (derivative^[n + 1] p) * X + n \u2022 derivative^[n] p := by\n  convert (derivative p).iterate_derivative_mul_X_pow n 1; \u00b7 simp\n  rcases n with rfl | n <;> simp [sum_range_succ]\n```",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1663,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_derivative_mul_X_sq {n : \u2115} (p : R[X]) :\n    derivative^[n] (derivative^[2] p * X ^ 2) =\n      (derivative^[n + 2] p) * X ^ 2 + (2 * n) \u2022 (derivative^[n + 1] p) * X +\n        (n * (n - 1)) \u2022 derivative^[n] p := by\n  convert (derivative^[2] p).iterate_derivative_mul_X_pow n 2\n  rcases n with rfl | n; \u00b7 simp\n  rcases n with rfl | n; \u00b7 simp [sum_range_succ, \u2190 mul_assoc]\n  suffices ((n + 1 + 1) * (n + 1) / 2) * 2 = (n + 1 + 1) * (n + 1) by\n    simp [this, -nsmul_eq_mul, sum_range_succ, Nat.choose_two_right]\n    ring\n  rw [mul_comm (n + 1 + 1)]\n  exact Nat.div_mul_cancel (Nat.two_dvd_mul_add_one _)\n",
      "body": "One more golf, again with similar aims. The `simp` in this is disappointingly slow but within our tolerances:\n```suggestion\ntheorem iterate_derivative_derivative_mul_X_sq {n : \u2115} (p : R[X]) :\n    derivative^[n] (derivative^[2] p * X ^ 2) =\n      (derivative^[n + 2] p) * X ^ 2 + (2 * n) \u2022 (derivative^[n + 1] p) * X +\n        (n * (n - 1)) \u2022 derivative^[n] p := by\n  convert (derivative^[2] p).iterate_derivative_mul_X_pow n 2\n  rcases n with rfl | n; \u00b7 simp\n  rcases n with rfl | n; \u00b7 simp [sum_rang",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "cases",
          "rw",
          "simp",
          "ring"
        ],
        "body_tactics": [
          "exact",
          "cases",
          "rw",
          "simp",
          "ring"
        ],
        "new_tactics": [
          "exact",
          "cases",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 1664,
      "before_code": "lemma two_dvd_mul_add_one (k : \u2115) : 2 \u2223 k * (k + 1) :=\n  even_iff_two_dvd.mp (even_mul_succ_self k)",
      "suggestion": "lemma two_dvd_mul_sub_one (k : \u2115) : 2 \u2223 k * (k - 1) := by\n  rcases k with rfl | k; \u00b7 simp\n  simpa [mul_comm (k + 1)] using k.two_dvd_mul_add_one\n",
      "body": "After the golfs suggested above, this lemma is no longer needed but I think is still worth adding (despite containing an evil nat subtraction). However let's try for a more idiomatic proof:\n```suggestion\nlemma two_dvd_mul_sub_one (k : \u2115) : 2 \u2223 k * (k - 1) := by\n  rcases k with rfl | k; \u00b7 simp\n  simpa [mul_comm (k + 1)] using k.two_dvd_mul_add_one\n```",
      "path": "Mathlib/Algebra/Ring/Parity.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "cases",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "cases",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "cases",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "two_dvd_mul_add_one",
          "even_mul_succ_self",
          "lemma",
          "even_iff_two_dvd"
        ]
      }
    },
    {
      "id": 1666,
      "before_code": "map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\n@[simps]\r\n",
      "body": "```suggestion\r\n@[simps]\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "LinearMap",
          "map_comp",
          "mapMatrixModule",
          "mapMatrixModule_id",
          "map",
          "ModuleCat",
          "hom_ext",
          "ofHom",
          "mapMatrixModule_comp",
          "map_id"
        ]
      }
    },
    {
      "id": 1667,
      "before_code": "public import Mathlib.Algebra.Category.ModuleCat.Basic\npublic import Mathlib.LinearAlgebra.Matrix.Module\n\n/-!\n# Morita Equivalece between `R` and `M\u2099(R)`\n\n## Main definitions\n- `ModuleCat.toMatrixModCat`: The functor from `Mod-R` to `Mod-M\u2099(R)` induced by\n  `LinearMap.mapMatrixModule` and `Matrix.Module.matrixModule`.\n\n## TODO (Edison)\n- Prove `R` and `M\u2099(R)` are morita-equivalent.\n-/\n\n@[expose] public section\n\nuniverse u\n\nvariable (R \u03b9 : Type*) [Ring R] [Fintype \u03b9] [DecidableEq \u03b9]\n\nopen CategoryTheory Matrix.Module\n\n/-- The functor from `Mod-R` to `Mod-M\u2099(R)` induced by `LinearMap.mapModule` and\n  `Matrix.matrixModule`. -/\n@[simps]\ndef ModuleCat.toMatrixModCat : ModuleCat R \u2964 ModuleCat (Matrix \u03b9 \u03b9 R) where\n  obj M := ModuleCat.of (Matrix \u03b9 \u03b9 R) (\u03b9 \u2192 M)\n  map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\n  haveI (M : ModuleCat (Matrix \u03b9 \u03b9 R)) : IsScalarTower R (Matrix \u03b9 \u03b9 R) M :=\r\n    { smul_assoc r m x := show _ = (Matrix.scalar \u03b9 r) \u2022 (m \u2022 x) by\r\n        rw [\u2190 mul_smul, Matrix.scalar_apply, Matrix.smul_eq_diagonal_mul] }\r\n",
      "body": "```suggestion\r\n  haveI (M : ModuleCat (Matrix \u03b9 \u03b9 R)) : IsScalarTower R (Matrix \u03b9 \u03b9 R) M :=\r\n    { smul_assoc r m x := show _ = (Matrix.scalar \u03b9 r) \u2022 (m \u2022 x) by\r\n        rw [\u2190 mul_smul, Matrix.scalar_apply, Matrix.smul_eq_diagonal_mul] }\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "hom",
          "import",
          "expose",
          "Ring",
          "Type",
          "CategoryTheory",
          "mapModule",
          "Main",
          "open",
          "section",
          "TODO",
          "ModuleCat",
          "Basic",
          "Mathlib",
          "LinearMap",
          "functor",
          "universe",
          "map_comp",
          "mapMatrixModule",
          "map",
          "equivalent",
          "are",
          "morita",
          "DecidableEq",
          "mapMatrixModule_comp",
          "Prove",
          "LinearAlgebra",
          "variable",
          "public",
          "def",
          "definitions",
          "induced",
          "simps",
          "between",
          "Morita",
          "toMatrixModCat",
          "Mod",
          "ofHom",
          "obj",
          "map_id",
          "hom_ext",
          "matrixModule",
          "Equivalece",
          "Edison",
          "Category",
          "mapMatrixModule_id",
          "Fintype",
          "from",
          "Matrix"
        ]
      }
    },
    {
      "id": 1668,
      "before_code": "public import Mathlib.Algebra.Category.ModuleCat.Basic\npublic import Mathlib.LinearAlgebra.Matrix.Module\n\n/-!\n# Morita Equivalece between `R` and `M\u2099(R)`\n\n## Main definitions\n- `ModuleCat.toMatrixModCat`: The functor from `Mod-R` to `Mod-M\u2099(R)` induced by\n  `LinearMap.mapMatrixModule` and `Matrix.Module.matrixModule`.\n\n## TODO (Edison)\n- Prove `R` and `M\u2099(R)` are morita-equivalent.\n-/\n\n@[expose] public section\n\nuniverse u\n\nvariable (R \u03b9 : Type*) [Ring R] [Fintype \u03b9] [DecidableEq \u03b9]\n\nopen CategoryTheory Matrix.Module\n\n/-- The functor from `Mod-R` to `Mod-M\u2099(R)` induced by `LinearMap.mapModule` and\n  `Matrix.matrixModule`. -/\n@[simps]\ndef ModuleCat.toMatrixModCat : ModuleCat R \u2964 ModuleCat (Matrix \u03b9 \u03b9 R) where\n  obj M := ModuleCat.of (Matrix \u03b9 \u03b9 R) (\u03b9 \u2192 M)\n  map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\n    dsimp at x \u22a2\r\n",
      "body": "```suggestion\r\n    dsimp at x \u22a2\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "hom",
          "import",
          "expose",
          "Ring",
          "Type",
          "CategoryTheory",
          "mapModule",
          "Main",
          "open",
          "section",
          "TODO",
          "ModuleCat",
          "Basic",
          "Mathlib",
          "LinearMap",
          "functor",
          "universe",
          "map_comp",
          "mapMatrixModule",
          "map",
          "equivalent",
          "are",
          "morita",
          "DecidableEq",
          "mapMatrixModule_comp",
          "Prove",
          "LinearAlgebra",
          "variable",
          "public",
          "def",
          "definitions",
          "induced",
          "simps",
          "between",
          "Morita",
          "toMatrixModCat",
          "Mod",
          "ofHom",
          "obj",
          "map_id",
          "hom_ext",
          "matrixModule",
          "Equivalece",
          "Edison",
          "Category",
          "mapMatrixModule_id",
          "Fintype",
          "from",
          "Matrix"
        ]
      }
    },
    {
      "id": 1669,
      "before_code": "map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\ndef toModuleCatObj : Submodule R M :=\r\n  LinearMap.range (\u03c4\u2081\u2082 := .id _) <|\r\n    { __ := DistribMulAction.toAddMonoidHom M (single default default 1 : Matrix \u03b9 \u03b9 R)\r\n      map_smul' r x := by\r\n        dsimp\r\n        rw [\u2190 smul_assoc r, Matrix.smul_eq_diagonal_mul, show (diagonal fun x : \u03b9 \u21a6 r) *\r\n          single _ _ 1 = single default default 1 * diagonal (fun _ \u21a6 r) by ext; simp [Matrix.single],\r\n          SemigroupAction.mul_smul, \u2190 Matrix.smul_one_eq_diagonal]\r\n        nth_rw 1 [\u2190 one_smul (Matrix \u03b9 \u03b9 R) x]\r\n        rw [smul_assoc] }\r\n",
      "body": "Perhaps nicer to build the map first:\r\n```suggestion\r\ndef toModuleCatObj : Submodule R M :=\r\n  LinearMap.range (\u03c4\u2081\u2082 := .id _) <|\r\n    { __ := DistribMulAction.toAddMonoidHom M (single default default 1 : Matrix \u03b9 \u03b9 R)\r\n      map_smul' r x := by\r\n        dsimp\r\n        rw [\u2190 smul_assoc r, Matrix.smul_eq_diagonal_mul, show (diagonal fun x : \u03b9 \u21a6 r) *\r\n          single _ _ 1 = single default default 1 * diagonal (fun _ \u21a6 r) by ext; simp [Matrix.single],\r\n          SemigroupAction.mul_smul, \u2190 Matrix.",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "LinearMap",
          "map_comp",
          "mapMatrixModule",
          "mapMatrixModule_id",
          "map",
          "ModuleCat",
          "hom_ext",
          "ofHom",
          "mapMatrixModule_comp",
          "map_id"
        ]
      }
    },
    {
      "id": 1674,
      "before_code": "rw [\u2190 IsOpenImmersion.lift_fac U.\u03b9 g (by simp [U])]\n  infer_instance",
      "suggestion": "  \u00b7 dsimp [MorphismProperty.isomorphisms] at H \u22a2\n    exact IsZariskiLocalAtTarget.of_isPullback (.flip <| .of_hasPullback _ _) H\n",
      "body": "Untested:\n```suggestion\n  \u00b7 dsimp [MorphismProperty.isomorphisms] at H \u22a2\n    exact IsZariskiLocalAtTarget.of_isPullback (.flip <| .of_hasPullback _ _) H\n```",
      "path": "Mathlib/AlgebraicGeometry/Morphisms/FlatDescent.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "lift_fac",
          "simp",
          "IsOpenImmersion",
          "infer_instance"
        ]
      }
    },
    {
      "id": 1676,
      "before_code": "theorem uniqueProd_apply [Preorder \u03b1] [Unique \u03b1] [LE \u03b2] (x : \u03b1 \u00d7\u2097 \u03b2) :\n    uniqueProd \u03b1 \u03b2 x = (ofLex x).2 := rfl",
      "suggestion": "\r\n@[simps!]\r\ndef prodLexAssoc (\u03b1 \u03b2 \u03b3 : Type*)\r\n",
      "body": "```suggestion\r\n@[simps!]\r\ndef prodLexAssoc (\u03b1 \u03b2 \u03b3 : Type*)\r\n```",
      "path": "Mathlib/Order/Hom/Lex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ofLex",
          "theorem",
          "uniqueProd",
          "Preorder",
          "rfl",
          "Unique",
          "uniqueProd_apply"
        ]
      }
    },
    {
      "id": 1677,
      "before_code": "theorem uniqueProd_apply [Preorder \u03b1] [Unique \u03b1] [LE \u03b2] (x : \u03b1 \u00d7\u2097 \u03b2) :\n    uniqueProd \u03b1 \u03b2 x = (ofLex x).2 := rfl",
      "suggestion": "\r\n@[simps!]\r\ndef sumLexProdLexDistrib (\u03b1 \u03b2 \u03b3 : Type*)\r\n",
      "body": "```suggestion\r\n@[simps!]\r\ndef sumLexProdLexDistrib (\u03b1 \u03b2 \u03b3 : Type*)\r\n```",
      "path": "Mathlib/Order/Hom/Lex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ofLex",
          "theorem",
          "uniqueProd",
          "Preorder",
          "rfl",
          "Unique",
          "uniqueProd_apply"
        ]
      }
    },
    {
      "id": 1678,
      "before_code": "(sumLexDualAntidistrib \u03b1 \u03b2).symm (inr (toDual a)) = toDual (inl a) :=\n  rfl",
      "suggestion": "\r\nlemma sumLexEmpty_apply_inl [Preorder \u03b1] [IsEmpty \u03b2] [Preorder \u03b2] (x : \u03b1) :\r\n",
      "body": "```suggestion\r\nlemma sumLexEmpty_apply_inl [Preorder \u03b1] [IsEmpty \u03b2] [Preorder \u03b2] (x : \u03b1) :\r\n```",
      "path": "Mathlib/Data/Sum/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "sumLexDualAntidistrib",
          "symm",
          "rfl",
          "toDual",
          "inl",
          "inr"
        ]
      }
    },
    {
      "id": 1679,
      "before_code": "theorem uniqueProd_apply [Preorder \u03b1] [Unique \u03b1] [LE \u03b2] (x : \u03b1 \u00d7\u2097 \u03b2) :\n    uniqueProd \u03b1 \u03b2 x = (ofLex x).2 := rfl",
      "suggestion": "\r\n    simp only [Prod.Lex.le_iff, Prod.Lex.lt_iff, Equiv.trans_apply, Equiv.prodCongr_apply,\r\n      Equiv.prodAssoc_apply]\r\n    grind [EmbeddingLike.apply_eq_iff_eq, ofLex_toLex]\r\n",
      "body": "```suggestion\r\n    simp only [Prod.Lex.le_iff, Prod.Lex.lt_iff, Equiv.trans_apply, Equiv.prodCongr_apply,\r\n      Equiv.prodAssoc_apply]\r\n    grind [EmbeddingLike.apply_eq_iff_eq, ofLex_toLex]\r\n```",
      "path": "Mathlib/Order/Hom/Lex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "ofLex",
          "theorem",
          "uniqueProd",
          "Preorder",
          "rfl",
          "Unique",
          "uniqueProd_apply"
        ]
      }
    },
    {
      "id": 1680,
      "before_code": "@[gcongr]\ntheorem vertexCoverNum_mono (h : G \u2264 G') : vertexCoverNum G \u2264 vertexCoverNum G' :=\n  vertexCoverNum_le_vertexCoverNum_of_injective (Hom.ofLE h) Function.injective_id",
      "suggestion": "\r\n  (IsContained.of_le h).vertexCoverNum_le_vertexCoverNum\r\n",
      "body": "```suggestion\r\n  (IsContained.of_le h).vertexCoverNum_le_vertexCoverNum\r\n```\r\nDo we not have `IsContained.of_le`? If so, can you add it?",
      "path": "Mathlib/Combinatorics/SimpleGraph/VertexCover.lean",
      "tags": {
        "before_tactics": [
          "gcongr"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "gcongr"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "gcongr",
          "vertexCoverNum_mono",
          "theorem",
          "vertexCoverNum_le_vertexCoverNum_of_injective",
          "ofLE",
          "vertexCoverNum",
          "Hom",
          "Function",
          "injective_id"
        ]
      }
    },
    {
      "id": 1684,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n    \u00b7 filter_upwards [self_mem_nhdsWithin] with z (hz : _ \u2260 _)\r\n",
      "body": "I strongly recommend getting used to the `filter_upwards` tactic, it's a really nice tool:\r\n```suggestion\r\n    \u00b7 filter_upwards [self_mem_nhdsWithin] with z (hz : _ \u2260 _)\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 1685,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n",
      "body": "For this sort of argument (where `fun_prop` can't quite close the goal alone), I find it works well to put auxiliary facts into the context and then run `fun_prop` with a custom discharger:\r\n ```suggestion\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "use_fun_prop"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 1686,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n",
      "body": "We can use more automation here too:\r\n```suggestion\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "funext",
          "exact",
          "have",
          "simp",
          "fun_prop"
        ],
        "body_tactics": [
          "funext",
          "exact",
          "have",
          "simp",
          "fun_prop"
        ],
        "new_tactics": [
          "funext",
          "simp",
          "exact",
          "fun_prop",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 1689,
      "before_code": "rcases eq_or_ne x 0 with rfl | hx0 <;>\n  simp_all [one_apply_of_ne_zero]",
      "suggestion": "\r\n  rw [Submonoid.nontrivial_iff_exists_ne_one]\r\n  exact \u27e8Units.mk0 (v x) h0, \u27e8x, rfl\u27e9, mt Units.ext_iff.mp h1\u27e9\r\n",
      "body": "Personally I would do the opposite and be more tactic-y for the first step and more term-y for the end.\r\n```suggestion\r\n  rw [Submonoid.nontrivial_iff_exists_ne_one]\r\n  exact \u27e8Units.mk0 (v x) h0, \u27e8x, rfl\u27e9, mt Units.ext_iff.mp h1\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "simp_all"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [
          "cases",
          "simp_all"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rcases",
          "one_apply_of_ne_zero",
          "simp_all",
          "rfl",
          "hx0",
          "eq_or_ne"
        ]
      }
    },
    {
      "id": 1692,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194 Nonempty (G.CompleteBipartiteSubgraph (card \u03b1) (card \u03b2)) where\r\n  mp := fun \u27e8f\u27e9 \u21a6 \u27e8CompleteBipartiteSubgraph.ofCopy f\u27e9\r\n  mpr := fun \u27e8B\u27e9 \u21a6 \u27e8B.toCopy.comp <| Iso.toCopy \u27e8(equivFin \u03b1).sumCongr (equivFin \u03b2), by simp\u27e9\u27e9\r\n",
      "body": "nit:\r\n```suggestion\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194 Nonempty (G.CompleteBipartiteSubgraph (card \u03b1) (card \u03b2)) where\r\n  mp := fun \u27e8f\u27e9 \u21a6 \u27e8CompleteBipartiteSubgraph.ofCopy f\u27e9\r\n  mpr := fun \u27e8B\u27e9 \u21a6 \u27e8B.toCopy.comp <| Iso.toCopy \u27e8(equivFin \u03b1).sumCongr (equivFin \u03b2), by simp\u27e9\u27e9\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 1693,
      "before_code": "end IsBipartite",
      "suggestion": "\r\nstructure CompleteBipartiteSubgraph (G : SimpleGraph V) (k l : \u2115) where\r\n",
      "body": "It is quite confusing to use `s` and `t` as names for natural number-valued variables since they usually represent sets (and indeed you have sets here. What about\r\n```suggestion\r\nstructure CompleteBipartiteSubgraph (G : SimpleGraph V) (k l : \u2115) where\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 1694,
      "before_code": "end IsBipartite",
      "suggestion": "\r\nstructure CompleteBipartiteSubgraph (G : SimpleGraph V) where\r\n  /-- The \"left\" subset of vertices. -/\r\n  left : Set V\r\n  /-- The \"right\" subset of vertices. -/\r\n  right : Set V\r\n  /-- Vertices in the \"left\" and \"right\" subsets are adjacent. -/\r\n  Adj : \u2200 \u2983v\u2081\u2984, v\u2081 \u2208 left \u2192 \u2200 \u2983v\u2082\u2984, v\u2082 \u2208 right \u2192 G.Adj v\u2081 v\u2082\r\n",
      "body": "I have a use case for a very similar structure but where the parts are sets and there is no restriction on the cardinality, ie it looks like\r\n```suggestion\r\nstructure CompleteBipartiteSubgraph (G : SimpleGraph V) where\r\n  /-- The \"left\" subset of vertices. -/\r\n  left : Set V\r\n  /-- The \"right\" subset of vertices. -/\r\n  right : Set V\r\n  /-- Vertices in the \"left\" and \"right\" subsets are adjacent. -/\r\n  Adj : \u2200 \u2983v\u2081\u2984, v\u2081 \u2208 left \u2192 \u2200 \u2983v\u2082\u2984, v\u2082 \u2208 right \u2192 G.Adj v\u2081 v\u2082\r\n```\r\nHow possible would it be for y",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 1702,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n  obtain \u27e8fs\u27e9 : Nonempty (Fin a \u21aa left) := by\r\n    apply Function.Embedding.nonempty_of_card_le\r\n    rw [Fintype.card_fin, card_coe, card_left]\r\n",
      "body": "```suggestion\r\n  obtain \u27e8fs\u27e9 : Nonempty (Fin a \u21aa left) := by\r\n    apply Function.Embedding.nonempty_of_card_le\r\n    rw [Fintype.card_fin, card_coe, card_left]\r\n```\r\nSame below",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "apply",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 1703,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n    | .inl p\u2081, .inl p\u2082 => simp\r\n    | .inr p\u2081, .inl p\u2082 =>\r\n      simpa using (h (fs p\u2082).prop (ft p\u2081).prop).ne'\r\n    | .inl p\u2081, .inr p\u2082 =>\r\n      simpa using (h (fs p\u2081).prop (ft p\u2082).prop).symm.ne'\r\n    | .inr p\u2081, .inr p\u2082 => simp\r\n",
      "body": "nit:\r\n```suggestion\r\n    | .inl p\u2081, .inl p\u2082 => simp\r\n    | .inr p\u2081, .inl p\u2082 =>\r\n      simpa using (h (fs p\u2082).prop (ft p\u2081).prop).ne'\r\n    | .inl p\u2081, .inr p\u2082 =>\r\n      simpa using (h (fs p\u2081).prop (ft p\u2082).prop).symm.ne'\r\n    | .inr p\u2081, .inr p\u2082 => simp\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 1727,
      "before_code": "lemma reciprocalFactors_odd {n : \u2115} (h1 : n \u2260 1) (h2 : Odd n) :\n    reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1) := by\n  have h0 : n \u2260 0 := by\n    rintro rfl\n    norm_num [\u2190 Nat.not_even_iff_odd] at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.not_even_iff_odd.2 h2)]",
      "suggestion": "\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n",
      "body": "this is 10x slower than the previous proof. What about changing it to something like this?\r\n```suggestion\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n```\r\nso same as before, but the `n \u2260 0` is by `grind`.",
      "path": "Mathlib/GroupTheory/CommutingProbability.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "grind"
        ],
        "removed_tactics": [
          "norm_num",
          "have"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "norm_num",
          "reciprocalFactors_odd",
          "lemma",
          "reciprocalFactors",
          "not_even_iff_odd",
          "Odd",
          "Nat",
          "dif_neg",
          "have",
          "rintro",
          "if_neg",
          "rfl"
        ]
      }
    },
    {
      "id": 1728,
      "before_code": "{k\u2081 : Function.LeftInverse \u03c6' \u03c6} {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    (inverse' f g k\u2082 h\u2081 h\u2082).comp f (\u03ba := CompTriple.comp_inv k\u2081) = MulActionHom.id M := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2081 x",
      "suggestion": "  simpa using h\u2081.eq _\n",
      "body": "```suggestion\n  simpa using h\u2081.eq _\n```",
      "path": "Mathlib/GroupTheory/GroupAction/Hom.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "RightInverse",
          "id_apply",
          "ext_iff",
          "exact",
          "comp_apply",
          "MulActionHom",
          "comp",
          "CompTriple",
          "simp",
          "intro",
          "LeftInverse",
          "Function",
          "comp_inv",
          "only",
          "inverse"
        ]
      }
    },
    {
      "id": 1729,
      "before_code": "{k\u2081 : Function.LeftInverse \u03c6' \u03c6} {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    (inverse' f g k\u2082 h\u2081 h\u2082).comp f (\u03ba := CompTriple.comp_inv k\u2081) = MulActionHom.id M := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2081 x\n\n@[to_additive]\ntheorem inverse'_comp {f : X \u2192\u2091[\u03c6] Y} {g : Y \u2192 X}\n    {k\u2082 : Function.RightInverse \u03c6' \u03c6}\n    {h\u2081 : Function.LeftInverse g f} {h\u2082 : Function.RightInverse g f} :\n    f.comp (inverse' f g k\u2082 h\u2081 h\u2082) (\u03ba := CompTriple.comp_inv k\u2082) = MulActionHom.id N := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, id_apply]\n  exact h\u2082 x",
      "suggestion": "  simpa using h\u2082.eq _\n",
      "body": "```suggestion\n  simpa using h\u2082.eq _\n```",
      "path": "Mathlib/GroupTheory/GroupAction/Hom.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "to_additive",
          "RightInverse",
          "id_apply",
          "ext_iff",
          "theorem",
          "exact",
          "comp_apply",
          "MulActionHom",
          "comp",
          "CompTriple",
          "simp",
          "intro",
          "LeftInverse",
          "Function",
          "_comp",
          "comp_inv",
          "only",
          "inverse"
        ]
      }
    },
    {
      "id": 1732,
      "before_code": "(f.trans g).toLinearMap = g.toLinearMap.comp f.toLinearMap :=\n  rfl",
      "suggestion": "\r\ntheorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (f.prodCongr f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n",
      "body": "or instead\r\n```suggestion\r\ntheorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (f.prodCongr f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n```",
      "path": "Mathlib/Algebra/Algebra/Equiv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "trans",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 1733,
      "before_code": "(f.trans g).toLinearMap = g.toLinearMap.comp f.toLinearMap :=\n  rfl",
      "suggestion": "\r\ntheorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (Prod.map f f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n",
      "body": "I think it's better to use `Prod.map` on RHS, because it's a simp-normal form.\r\n```suggestion\r\ntheorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (Prod.map f f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n```",
      "path": "Mathlib/Algebra/Algebra/Equiv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "trans",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 1734,
      "before_code": "(f.trans g).toLinearMap = g.toLinearMap.comp f.toLinearMap :=\n  rfl",
      "suggestion": "\r\n@[simp] theorem linearEquivConj_mulLeft (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeft R x) = .mulLeft R (f x) := by\r\n  ext; simp [LinearEquiv.conj_apply]\r\n\r\n@[simp] theorem linearEquivConj_mulRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081) :\r\n    f.toLinearEquiv.conj (.mulRight R x) = .mulRight R (f x) := by\r\n  ext; simp [LinearEquiv.conj_apply]\r\n\r\n@[simp] theorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mulLeftRight R (Prod.map f f x) := by\r\n  cases x; ext; simp [LinearEquiv.conj_apply]\r\n",
      "body": "```suggestion\r\n@[simp] theorem linearEquivConj_mulLeft (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeft R x) = .mulLeft R (f x) := by\r\n  ext; simp [LinearEquiv.conj_apply]\r\n\r\n@[simp] theorem linearEquivConj_mulRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081) :\r\n    f.toLinearEquiv.conj (.mulRight R x) = .mulRight R (f x) := by\r\n  ext; simp [LinearEquiv.conj_apply]\r\n\r\n@[simp] theorem linearEquivConj_mulLeftRight (f : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081 \u00d7 A\u2081) :\r\n    f.toLinearEquiv.conj (.mulLeftRight R x) = .mu",
      "path": "Mathlib/Algebra/Algebra/Equiv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "cases",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "trans",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 1736,
      "before_code": "[DecidableEq S] [Nontrivial S] (f : \u2115 \u2192+* S) (hf : Function.Injective f) : \u2115\u221e \u2192+* WithTop S :=\n  {MonoidWithZeroHom.ENatMap f.toMonoidWithZeroHom hf, f.toAddMonoidHom.ENatMap with}",
      "suggestion": "@[simp]\nprotected lemma map_natCast_mul {R : Type*} [NonAssocSemiring R] [DecidableEq R] [CharZero R] (a b : \u2115\u221e) :\n",
      "body": "unless you have some reason that you explicitly eschewed this naming.\n```suggestion\n@[simp]\nprotected lemma map_natCast_mul {R : Type*} [NonAssocSemiring R] [DecidableEq R] [CharZero R] (a b : \u2115\u221e) :\n```",
      "path": "Mathlib/Data/ENat/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "nat",
          "algebra"
        ],
        "transforms": [
          "naming"
        ],
        "keywords": [
          "Injective",
          "WithTop",
          "Nontrivial",
          "ENatMap",
          "toAddMonoidHom",
          "DecidableEq",
          "MonoidWithZeroHom",
          "Function",
          "toMonoidWithZeroHom"
        ]
      }
    },
    {
      "id": 1750,
      "before_code": "theorem coplanar_triple (p\u2081 p\u2082 p\u2083 : P) : Coplanar k ({p\u2081, p\u2082, p\u2083} : Set P) :=\n  (collinear_pair k p\u2082 p\u2083).coplanar_insert p\u2081",
      "suggestion": "\r\n  have h : s.points i = (-n : k) \u2022 (s.faceOppositeCentroid i -\u1d65 s.centroid) +\u1d65 s.centroid := by\r\n",
      "body": "```suggestion\r\n  have h : s.points i = (-n : k) \u2022 (s.faceOppositeCentroid i -\u1d65 s.centroid) +\u1d65 s.centroid := by\r\n```",
      "path": "Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "coplanar_triple",
          "Set",
          "Coplanar",
          "coplanar_insert",
          "collinear_pair"
        ]
      }
    },
    {
      "id": 1751,
      "before_code": "theorem coplanar_triple (p\u2081 p\u2082 p\u2083 : P) : Coplanar k ({p\u2081, p\u2082, p\u2083} : Set P) :=\n  (collinear_pair k p\u2082 p\u2083).coplanar_insert p\u2081",
      "suggestion": "\r\n/-- For a simplex, the centroid, a vertex, and the corresponding `faceOppositeCentroid` are collinear.\r\n",
      "body": "```suggestion\r\n/-- For a simplex, the centroid, a vertex, and the corresponding `faceOppositeCentroid` are collinear.\r\n```",
      "path": "Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "coplanar_triple",
          "Set",
          "Coplanar",
          "coplanar_insert",
          "collinear_pair"
        ]
      }
    },
    {
      "id": 1752,
      "before_code": "variable {k : Type*} {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]\n  [AffineSpace V P]",
      "suggestion": "\r\ntheorem centroid_eq_affineCombination (s : Simplex k P n) :\r\n",
      "body": "```suggestion\r\ntheorem centroid_eq_affineCombination (s : Simplex k P n) :\r\n```",
      "path": "Mathlib/LinearAlgebra/AffineSpace/Simplex/Centroid.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "DivisionRing",
          "Module",
          "variable",
          "Type",
          "AddCommGroup",
          "AffineSpace"
        ]
      }
    },
    {
      "id": 1753,
      "before_code": "variable {k : Type*} {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]\n  [AffineSpace V P]",
      "suggestion": "theorem univ_centroid_eq (s : Simplex k P n) :\n",
      "body": "```suggestion\ntheorem univ_centroid_eq (s : Simplex k P n) :\n```",
      "path": "Mathlib/LinearAlgebra/AffineSpace/Simplex/Centroid.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "DivisionRing",
          "Module",
          "variable",
          "Type",
          "AddCommGroup",
          "AffineSpace"
        ]
      }
    },
    {
      "id": 1755,
      "before_code": "(fun _ _ _ _ he => AffineIndependent.injective s\u2081.independent he)\n      (fun _ _ _ _ he => AffineIndependent.injective s\u2082.independent he) h",
      "suggestion": "  exact affineSpan_mono _ (by simp) (s.faceOppositeCentroid_mem_affineSpan_face i)\n",
      "body": "```suggestion\n  exact affineSpan_mono _ (by simp) (s.faceOppositeCentroid_mem_affineSpan_face i)\n```\nDoes this work? If so, I wonder if this one-line should be an extra lemma. It seems to me that it can just be inlined when needed.",
      "path": "Mathlib/LinearAlgebra/AffineSpace/Simplex/Centroid.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "independent",
          "AffineIndependent",
          "injective"
        ]
      }
    },
    {
      "id": 1760,
      "before_code": "variable {k : Type*} {V : Type*} {P : Type*} [DivisionRing k] [AddCommGroup V] [Module k V]\n  [AffineSpace V P]",
      "suggestion": "theorem centroid_notMem_affineSpan_of_ne_univ [CharZero k] (s : Simplex k P n)\n",
      "body": "```suggestion\ntheorem centroid_notMem_affineSpan_of_ne_univ [CharZero k] (s : Simplex k P n)\n```",
      "path": "Mathlib/LinearAlgebra/AffineSpace/Simplex/Centroid.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "DivisionRing",
          "Module",
          "variable",
          "Type",
          "AddCommGroup",
          "AffineSpace"
        ]
      }
    },
    {
      "id": 1767,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_one' := by simp\r\n        mul_le' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_mul_le_add p.1 x y) <| add_le_add _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 _\r\n            \u00b7 use q y\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 _\r\n          \u00b7 simp_all\r\n        inv' x := by simp }\r\n",
      "body": "same proofs, just significantly shorter and easier to read\r\n\r\n```suggestion\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_one' := by simp\r\n        mul_le' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_mul_le_add p.1 x y) <| add_le_add _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "refine",
          "simp_all",
          "simp",
          "exact",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "com",
          "https",
          "add_apply",
          "theorem",
          "too",
          "pull",
          "skeleton",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "rfl",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 1768,
      "before_code": "instance : Inhabited (NonarchAddGroupSeminorm E) :=\n  \u27e80\u27e9\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_zero' := by simp\r\n        add_le_max' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_add_le_max p.1 x y) <| max_le_max _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 x\r\n            \u00b7 use q y\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 y\r\n          \u00b7 simp_all\r\n        neg' x := congr(\u2a06 _, $(map_neg_eq_map _ x)) }\r\n",
      "body": "```suggestion\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_zero' := by simp\r\n        add_le_max' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_add_le_max p.1 x y) <| max_le_max _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exa",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "com",
          "https",
          "Inhabited",
          "too",
          "pull",
          "skeleton",
          "NonarchAddGroupSeminorm",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "instance",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 1769,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "noncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n            all_goals\n              apply le_ciSup (f := (DFunLike.coe \u00b7 _) \u2218 Subtype.val) ?_ p\n              simpa [Set.range_comp] using Monotone.map_bddAbove (fun _ _ h' \u21a6 by exact h' _) h\n        inv' x := by simp }\n    else 0\n",
      "body": "I think `where` syntax is nicer here, and I provided a small golf to avoid the case split.\n```suggestion\nnoncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n     ",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa",
          "term_mode"
        ],
        "keywords": [
          "community",
          "com",
          "https",
          "add_apply",
          "theorem",
          "too",
          "pull",
          "skeleton",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "rfl",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 1770,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345\n@[to_additive]\ninstance : Max (GroupSeminorm E) :=",
      "suggestion": "\nlemma sSup_of_not_bddAbove {s : Set (GroupSeminorm E)} (hs : \u00acBddAbove s) :\n    sSup s = 0 := by\n  simp [SupSet.sSup, hs]\n\nlemma coe_sSup_apply {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = \u2a06 p : s, (p : GroupSeminorm E) x := by\n  simp [SupSet.sSup, hs]\n  rfl\n\nlemma coe_sSup_apply' {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = sSup ((\u00b7 x) '' s) := by\n  rw [coe_sSup_apply hs, \u2190 sSup_range]\n  congr\n  ext\n  simp\n\nlemma coe_iSup_apply {\u03b9 : Type*} (f : \u03b9 \u2192 GroupSeminorm E) (h : BddAbove (range f)) {x : E} :\n    \u21d1(\u2a06 i, f i) x = \u2a06 i, (f i : GroupSeminorm E) x := by\n  rw [\u2190 sSup_range, coe_sSup_apply h]\n  exact (Set.rangeFactorization_surjective.iSup_congr _ (by simp)) |>.symm\n\n@[to_additive]\ninstance : Max (GroupSeminorm E) :=\n",
      "body": "you should have these lemmas available for rewriting\n```suggestion\n\nlemma sSup_of_not_bddAbove {s : Set (GroupSeminorm E)} (hs : \u00acBddAbove s) :\n    sSup s = 0 := by\n  simp [SupSet.sSup, hs]\n\nlemma coe_sSup_apply {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = \u2a06 p : s, (p : GroupSeminorm E) x := by\n  simp [SupSet.sSup, hs]\n  rfl\n\nlemma coe_sSup_apply' {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = sSup ((\u00b7 x) '' s) := by\n  rw [coe_sSup_apply hs",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "exact",
          "rw",
          "simp",
          "congr"
        ],
        "body_tactics": [
          "ext",
          "exact",
          "have",
          "rw",
          "simp",
          "congr"
        ],
        "new_tactics": [
          "rw",
          "simp",
          "ext",
          "exact",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "skeleton",
          "GroupSeminorm",
          "github",
          "Max",
          "TODO",
          "SupSet",
          "to_additive",
          "add_apply",
          "leanprover",
          "com",
          "issuecomment",
          "rfl",
          "https",
          "theorem",
          "too",
          "pull",
          "mathlib",
          "from",
          "instance",
          "define"
        ]
      }
    },
    {
      "id": 1773,
      "before_code": "natDegree (\u2211 i \u2208 s, f i) \u2264 n :=\n  le_trans (natDegree_sum_le s f) <| (Finset.fold_max_le n).mpr <| by simpa",
      "suggestion": "  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n",
      "body": "```suggestion\n  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n```",
      "path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "body_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "natDegree_sum_le",
          "natDegree",
          "mpr",
          "fold_max_le",
          "Finset",
          "simpa",
          "le_trans"
        ]
      }
    },
    {
      "id": 1775,
      "before_code": "show \u2200 P Q : Prop, P \u2227 (P \u2192 Q) \u2194 P \u2227 Q by tauto]\n  simp_rw [\u2190 exists_and_left, \u2190 not_lt]\n  refine exists_congr fun p \u21a6 ?_\n  have H\u2081 : m \u2260 0 \u2192 p \u2223 m \u2192 m < N + 1 \u2192 p < N + 1 :=\n    fun h\u2081 h\u2082 h\u2083 \u21a6 (le_of_dvd (Nat.pos_of_ne_zero h\u2081) h\u2082).trans_lt h\u2083\n  have H\u2082 : m \u2260 0 \u2192 p \u2223 m \u2192 \u00ac m < p :=",
      "suggestion": "  have H : m \u2260 0 \u2192 p \u2223 m \u2192 \u00ac m < p :=\n",
      "body": "```suggestion\n  have H : m \u2260 0 \u2192 p \u2223 m \u2192 \u00ac m < p :=\n```",
      "path": "Mathlib/NumberTheory/SmoothNumbers.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "have"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "not_lt",
          "trans_lt",
          "refine",
          "tauto",
          "show",
          "Nat",
          "exists_and_left",
          "have",
          "Prop",
          "le_of_dvd",
          "simp_rw",
          "exists_congr",
          "pos_of_ne_zero"
        ]
      }
    },
    {
      "id": 1776,
      "before_code": "[SecondCountableTopology \u03b1] : Set.Countable {x | \u2203 z, z < f x \u2227 \u2200 y, y < x \u2192 f y \u2264 z} :=\n  countable_image_lt_image_Ioi (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48) f\n\ninstance instIsCountablyGenerated_atTop [SecondCountableTopology \u03b1] :\n    IsCountablyGenerated (atTop : Filter \u03b1) := by\n  obtain (h | \u27e8x, hx\u27e9) := Set.eq_empty_or_nonempty {x : \u03b1 | IsTop x}\n  \u00b7 rcases exists_countable_basis \u03b1 with \u27e8b, b_count, b_ne, hb\u27e9\n    have A (s : b) : s.1.Nonempty := by aesop (add simp [nonempty_iff_ne_empty])\n    choose a ha using A\n    have : atTop = generate (Ici '' range a) := by",
      "suggestion": "  \u00b7 obtain \u27e8s, s_count, hs\u27e9 := exists_countable_dense \u03b1\n",
      "body": "Let's use `obtain` here too since the rest of the proof spells things this way:\n```suggestion\n  \u00b7 obtain \u27e8s, s_count, hs\u27e9 := exists_countable_dense \u03b1\n```",
      "path": "Mathlib/Topology/Order/Basic.lean",
      "tags": {
        "before_tactics": [
          "aesop",
          "cases",
          "have",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "aesop",
          "simp",
          "have"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "nonempty_iff_ne_empty",
          "exists_countable_basis",
          "Countable",
          "rcases",
          "obtain",
          "atTop",
          "SecondCountableTopology",
          "countable_image_lt_image_Ioi",
          "add",
          "eq_empty_or_nonempty",
          "instIsCountablyGenerated_atTop",
          "have",
          "Filter",
          "aesop",
          "range",
          "IsTop",
          "b_ne",
          "Ici",
          "simp",
          "choose",
          "generate",
          "Nonempty",
          "IsCountablyGenerated",
          "Set",
          "instance",
          "b_count",
          "using"
        ]
      }
    },
    {
      "id": 1782,
      "before_code": "theorem isIndepSet_iff : G.IsIndepSet s \u2194 s.Pairwise (fun v w \u21a6 \u00acG.Adj v w) :=\n  Iff.rfl",
      "suggestion": "\r\n  .rfl\r\n",
      "body": "nit:\r\n```suggestion\r\n  .rfl\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Adj",
          "theorem",
          "isIndepSet_iff",
          "Iff",
          "IsIndepSet",
          "Pairwise",
          "rfl"
        ]
      }
    },
    {
      "id": 1797,
      "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
      "suggestion": "  simpa only [angle_comm] using h.angle_eq_right p\u2083\n",
      "body": "```suggestion\n  simpa only [angle_comm] using h.angle_eq_right p\u2083\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "by_cases",
          "Sbtw",
          "symm",
          "simp"
        ]
      }
    },
    {
      "id": 1798,
      "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
      "suggestion": "  exact Sbtw.angle_eq_right _ \u27e8h, hp\u2083p\u2082, hp\u2083p\u27e9\n",
      "body": "```suggestion\n  exact Sbtw.angle_eq_right _ \u27e8h, hp\u2083p\u2082, hp\u2083p\u27e9\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "by_cases",
          "Sbtw",
          "symm",
          "simp"
        ]
      }
    },
    {
      "id": 1799,
      "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
      "suggestion": "  simpa only [angle_comm] using h.angle_eq_right p\u2083 hp\u2081p\u2082\n",
      "body": "```suggestion\n  simpa only [angle_comm] using h.angle_eq_right p\u2083 hp\u2081p\u2082\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "by_cases",
          "Sbtw",
          "symm",
          "simp"
        ]
      }
    },
    {
      "id": 1812,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n",
      "body": "```suggestion\n  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n```\n`by exact` should be dropped most of the time.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 1813,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "  have h : a \u2260 b := by intro hab; simp [hab] at h\u03bc0\n",
      "body": "```suggestion\n  have h : a \u2260 b := by intro hab; simp [hab] at h\u03bc0\n```\nNo need to `subst`, it's something `simp` can do.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simp",
          "have",
          "intro"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 1814,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]\n\n/-- The mean value theorem for integrals:\nThere exists a point in an interval such that the mean of a continuous function over the interval\nequals the value of the function at the point. -/\ntheorem exists_eq_interval_average\n    {f : \u211d \u2192 \u211d} {a b : \u211d} (hab : a \u2260 b) (hf : ContinuousOn f (uIcc a b)) :\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d (x : \u211d) in a..b, f x := by\n  wlog h : a < b generalizing a b\n  \u00b7 rw [uIcc_comm] at hf\n    have := this hab.symm hf (lt_of_le_of_ne (le_of_not_gt h) (Ne.symm hab))\n    rwa [uIoo_comm, interval_average_symm] at this\n  let ave := \u2a0d (x : \u211d) in a..b, f x\n  have h_vol_fin1 : volume (uIoc a b) \u2260 0 := by simpa [h.le] using h\n  have h_vol_fin2 : volume (uIoc a b) \u2260 \u22a4 := by simp [h.le]\n  have h_intble : IntegrableOn f (uIoc a b) := by\n    have : IntegrableOn f (uIcc a b) := hf.integrableOn_uIcc\n    rwa [uIcc_of_lt h,integrableOn_Icc_iff_integrableOn_Ioc, \u2190uIoc_of_le (le_of_lt h)] at this\n  let S1 := {x | x \u2208 uIoc a b \u2227 f x \u2264 ave}\n  let S2 := {x | x \u2208 uIoc a b \u2227 ave \u2264 f x}\n  have h_meas1 : volume (S1 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_le_setAverage_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  have h_meas2 : volume (S2 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_setAverage_le_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  obtain \u27e8c1, \u27e8hc1_mem, hc1_le\u27e9, hc1'\u27e9 := nonempty_of_measure_ne_zero h_meas1\n  have hc1' : c1 \u2208 Ioo a b := by\n    rw [Set.uIoc_of_le (le_of_lt h)] at hc1_mem\n    rw [notMem_singleton_iff] at hc1'\n    exact \u27e8hc1_mem.1, lt_of_le_of_ne hc1_mem.2 hc1'\u27e9\n  obtain \u27e8c2, \u27e8hc2_mem, hc2_ge\u27e9, hc2'\u27e9 := nonempty_of_measure_ne_zero h_meas2\n  have hc2' : c2 \u2208 Ioo a b := by\n    rw [Se",
      "suggestion": "    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n",
      "body": "```suggestion\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n```\nsimp lemmas that you register elsewhere in the PR make the proof very direct!",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "cases",
          "have",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "continuity",
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "rwa",
          "codiscreteWithin",
          "interval_average_symm",
          "intervalIntegral",
          "le_of_lt",
          "Ioo_subset_Icc_self",
          "have",
          "mem_Ioo",
          "Filter",
          "notMem_singleton_iff",
          "integrableOn_uIcc",
          "intro",
          "hc2_mem",
          "such",
          "uIoc_of_le",
          "hab",
          "that",
          "simp",
          "h_ave",
          "volume",
          "theorem",
          "h_vol_fin2",
          "h_meas1",
          "h_meas2",
          "value",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "lt_of_lt_of_le",
          "There",
          "point",
          "imp",
          "uIcc",
          "intermediate_value_uIcc",
          "h_intble",
          "uIoo",
          "IntegrableOn",
          "hc1_mem",
          "continuous",
          "hc1_le",
          "hc1",
          "generalizing",
          "lt_of_le_of_ne",
          "interval",
          "Icc",
          "ave",
          "hc2",
          "measure_diff_null",
          "Ioo",
          "hc2_ge",
          "integrals"
        ]
      }
    },
    {
      "id": 1825,
      "before_code": "@[deprecated (since := \"2025-05-05\")] alias mulVec_stdBasisMatrix := single_mulVec",
      "suggestion": "\r\n  rw [sum_apply, diagonal_apply, Finset.sum_eq_single j] <;> simp +contextual [single_def]\r\n",
      "body": "```suggestion\r\n  rw [sum_apply, diagonal_apply, Finset.sum_eq_single j] <;> simp +contextual [single_def]\r\n```",
      "path": "Mathlib/Data/Matrix/Basis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "alias",
          "mulVec_stdBasisMatrix",
          "since",
          "single_mulVec",
          "deprecated"
        ]
      }
    },
    {
      "id": 1837,
      "before_code": "simp only [id_comp, mapDerivedCategoryFactorsh_hom_app, assoc, comp_id,\n        \u2190 Functor.map_comp_assoc, Iso.inv_hom_id_app, map_id, comp_obj])\n\ninstance : F.mapDerivedCategory.IsTriangulated :=\n  Functor.isTriangulated_of_precomp_iso F.mapDerivedCategoryFactorsh",
      "suggestion": "\r\n/-- `DerivedCategory.singleFunctor` commutes with `F` and `F.mapDerivedCategory`. -/\r\n",
      "body": "```suggestion\r\n/-- `DerivedCategory.singleFunctor` commutes with `F` and `F.mapDerivedCategory`. -/\r\n```\r\nCommute is not a noun. This is one fix but there might be better ones. Same for the other docstrings.",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/ExactFunctor.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "assoc",
          "Functor",
          "mapDerivedCategory",
          "comp_id",
          "inv_hom_id_app",
          "IsTriangulated",
          "id_comp",
          "mapDerivedCategoryFactorsh_hom_app",
          "simp",
          "map_id",
          "comp_obj",
          "Iso",
          "instance",
          "mapDerivedCategoryFactorsh",
          "only",
          "map_comp_assoc",
          "isTriangulated_of_precomp_iso"
        ]
      }
    },
    {
      "id": 1844,
      "before_code": "(isMulCocycle\u2081_of_mem_cocycles\u2081 _ x.2) with \u27e8\u03b2, h\u03b2\u27e9\n    use \u03b2",
      "suggestion": "  have := FiniteCyclicGroup.groupCohomology\u03c0Odd_eq_zero_iff (ofAlgebraAutOnUnits K L) g hg\n",
      "body": "There are two consecutive spaces between `groupCohomology\u03c0Odd_eq_zero_iff` and `(ofAlgebraAutOnUnits K L)`. This should be a single space for consistent formatting.\n```suggestion\n  have := FiniteCyclicGroup.groupCohomology\u03c0Odd_eq_zero_iff (ofAlgebraAutOnUnits K L) g hg\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/Hilbert90.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "use"
        ]
      }
    },
    {
      "id": 1845,
      "before_code": "(isMulCocycle\u2081_of_mem_cocycles\u2081 _ x.2) with \u27e8\u03b2, h\u03b2\u27e9\n    use \u03b2",
      "suggestion": "    have hxinv : Algebra.norm K x\u207b\u00b9 = 1 := by simp [Algebra.norm_inv, hx]\n    obtain \u27e8y, hy\u27e9 := H _ hxinv\n    use y\n    rw [IsUnit.div_eq_iff y.isUnit] at hy\n    rw [hy]\n    field_simp\n",
      "body": "```suggestion\n    have hxinv : Algebra.norm K x\u207b\u00b9 = 1 := by simp [Algebra.norm_inv, hx]\n    obtain \u27e8y, hy\u27e9 := H _ hxinv\n    use y\n    rw [IsUnit.div_eq_iff y.isUnit] at hy\n    rw [hy]\n    field_simp\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/Hilbert90.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "field_simp",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "field_simp",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "field_simp",
          "rw",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "use"
        ]
      }
    },
    {
      "id": 1848,
      "before_code": "conv_lhs => intro _ _; rw [ite_mem]\n  simp [hS]",
      "suggestion": "\r\n@[simp]\r\ntheorem submatrix_single_equiv\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem submatrix_single_equiv\r\n```",
      "path": "Mathlib/Data/Matrix/Basis.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "intro"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "conv_lhs",
          "simp",
          "ite_mem",
          "intro"
        ]
      }
    },
    {
      "id": 1851,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "\r\n@[simp]\r\ntheorem T_eval_zero_of_even {n : \u2124} (hn : Even n) : (T R n).eval 0 = (n / 2).negOnePow := by\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem T_eval_zero_of_even {n : \u2124} (hn : Even n) : (T R n).eval 0 = (n / 2).negOnePow := by\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 1853,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "\r\n@[simp]\r\ntheorem T_eval_zero_of_odd {n : \u2124} (hn : Odd n) : (T R n).eval 0 = 0 := by\r\n  simp [T_eval_zero, \u2190 Int.not_odd_iff_even, hn]\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem T_eval_zero_of_odd {n : \u2124} (hn : Odd n) : (T R n).eval 0 = 0 := by\r\n  simp [T_eval_zero, \u2190 Int.not_odd_iff_even, hn]\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 1854,
      "before_code": "norm_num\n    ring",
      "suggestion": "\r\n@[simp]\r\ntheorem U_eval_zero_of_even {n : \u2124} (hn : Even n) : (U R n).eval 0 = (n / 2).negOnePow := by\r\n  simp [U_eval_zero, hn]\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem U_eval_zero_of_even {n : \u2124} (hn : Even n) : (U R n).eval 0 = (n / 2).negOnePow := by\r\n  simp [U_eval_zero, hn]\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "norm_num",
          "ring"
        ],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "norm_num",
          "ring"
        ]
      }
    },
    {
      "id": 1855,
      "before_code": "norm_num\n    ring",
      "suggestion": "\r\n@[simp]\r\ntheorem U_eval_zero_of_odd {n : \u2124} (hn : Odd n) : (U R n).eval 0 = 0 := by\r\n  simp [U_eval_zero, \u2190 Int.not_odd_iff_even, hn]\r\n",
      "body": "```suggestion\r\n@[simp]\r\ntheorem U_eval_zero_of_odd {n : \u2124} (hn : Odd n) : (U R n).eval 0 = 0 := by\r\n  simp [U_eval_zero, \u2190 Int.not_odd_iff_even, hn]\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "norm_num",
          "ring"
        ],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "norm_num",
          "ring"
        ]
      }
    },
    {
      "id": 1856,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9",
      "suggestion": "lemma tendsto_nhds_top_iff {\u03b1 : Type*} {f : Filter \u03b1} (x : \u03b1 \u2192 WithTop \u03b9) :\n    Tendsto x f (\ud835\udcdd \u22a4) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (a : \u03b1) in f, i < x a := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using .of_forall fun _ \u21a6 Subsingleton.elim ..\n  refine nhds_top_basis.tendsto_right_iff.trans ?_\n  rw [\u2190 Set.forall_mem_range (p := (\u2200\u1da0 a in f, \u00b7 < x a)), WithTop.range_coe]\n  simp\n",
      "body": "You can avoid the `Nonempty` hypothesis and simplify the proof like so:\n```suggestion\nlemma tendsto_nhds_top_iff {\u03b1 : Type*} {f : Filter \u03b1} (x : \u03b1 \u2192 WithTop \u03b9) :\n    Tendsto x f (\ud835\udcdd \u22a4) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (a : \u03b1) in f, i < x a := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using .of_forall fun _ \u21a6 Subsingleton.elim ..\n  refine nhds_top_basis.tendsto_right_iff.trans ?_\n  rw [\u2190 Set.forall_mem_range (p := (\u2200\u1da0 a in f, \u00b7 < x a)), WithTop.range_coe]\n  simp\n```",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 1857,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9",
      "suggestion": "",
      "body": "This can be proven by `simp_rw [WithTop.tendsto_nhds_top_iff, eventually_atTop]`, so I think it's not really necessary.\n```suggestion\n```",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 1858,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9\n\nend WithTop",
      "suggestion": "",
      "body": "If you add this lemma (in the `WithTop` namespace):\n```lean\nlemma tendsto_coe_atTop [NoMaxOrder \u03b9] :\n    Tendsto ((\u2191) : \u03b9 \u2192 WithTop \u03b9) atTop (\ud835\udcdd \u22a4) := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using Subsingleton.elim ..\n  rw [tendsto_nhds_top_iff]\n  intro i\n  filter_upwards [atTop_basis_Ioi.mem_of_mem (i := i) trivial]\n  simp\n```\nThen you can prove the highlighted lemma as simply as:\n```lean\ntheorem Tendsto.tendsto_withTop_atTop_nhds_top {\u03b9 : Type*}\n    [Nonempty \u03b9] [LinearOrder \u03b9] [",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "WithTop",
          "end",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 1864,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "        obtain \u27e8i, hi\u27e9 : \u2203 i, m i > n i := by\n          by_contra! hc\n          exact h_le (Finsupp.coe_le_coe.mp hc)\n",
      "body": "```suggestion\n        obtain \u27e8i, hi\u27e9 : \u2203 i, m i > n i := by\n          by_contra! hc\n          exact h_le (Finsupp.coe_le_coe.mp hc)\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain"
        ],
        "body_tactics": [
          "exact",
          "obtain"
        ],
        "new_tactics": [
          "exact",
          "obtain"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1865,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, n = p \u2022 m :=\n      \u27e8Finsupp.equivFunOnFinite.symm fun i => n i / p, by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, n = p \u2022 m :=\n      \u27e8Finsupp.equivFunOnFinite.symm fun i => n i / p, by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1867,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "@[simp]\ntheorem expand_eq_expand {\u03c6 : MvPolynomial \u03c3 R} :\n",
      "body": "Do you want to make this a simp lemma?\n```suggestion\n@[simp]\ntheorem expand_eq_expand {\u03c6 : MvPolynomial \u03c3 R} :\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1868,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8i, hi\u27e9 := h\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8i, hi\u27e9 := h\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1869,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8i, hi\u27e9 := h\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8i, hi\u27e9 := h\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1870,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, d = p \u2022 m := \u27e8Finsupp.equivFunOnFinite.symm fun i => d i / p,\n      by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, d = p \u2022 m := \u27e8Finsupp.equivFunOnFinite.symm fun i => d i / p,\n      by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n```\nAre there more examples of this pattern?",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 1872,
      "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
      "suggestion": "theorem G\u2082_det : G\u2082.det = 1 := by decide\n\ntheorem F\u2084_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2086_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2087_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2088_det : F\u2084.det = 1 := by decide\n",
      "body": "It looks to me like there is no need to tinker with `maxRecDepth` or to exclude the higher rank cases:\n```suggestion\ntheorem G\u2082_det : G\u2082.det = 1 := by decide\n\ntheorem F\u2084_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2086_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2087_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2088_det : F\u2084.det = 1 := by decide\n```\nI'd also add that proving these `by decide` is a bit of a last resort and if we had needed to bump `maxRecDepth`, then I would not be in favour.\n\nI'm slightly surprised t",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "decide",
          "simp"
        ],
        "suggestion_tactics": [
          "decide"
        ],
        "body_tactics": [
          "decide",
          "cases",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "decide",
          "transpose",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1873,
      "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
      "suggestion": "/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced := by\n  rw [IsSimplyLaced, IsSimplyLaced, Pairwise, Pairwise, forall_comm]\n  aesop\n\ntheorem isSimplyLaced_A (n : \u2115) : IsSimplyLaced (A n) := by\n  intro i j h\n  simp only [A, of_apply]\n  grind\n\ntheorem isSimplyLaced_D (n : \u2115) : IsSimplyLaced (D n) := by\n  intro i j h\n  simp only [D, of_apply]\n  grind\n\ntheorem isSimplyLaced_E\u2086 : IsSimplyLaced E\u2086 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2086] at h \u22a2\n\ntheorem isSimplyLaced_E\u2087 : IsSimplyLaced E\u2087 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2087] at h \u22a2\n\ntheorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2\n",
      "body": "I've never seen being symmetric as a definition of begin simply laced before. Where does this come from?\n\nI would have expected something like:\n```suggestion\n/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced :",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "decide",
          "simp"
        ],
        "suggestion_tactics": [
          "aesop",
          "grind",
          "fin_cases",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "aesop",
          "grind",
          "have",
          "fin_cases",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "aesop",
          "grind",
          "fin_cases",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "decide"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "decide",
          "transpose",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1876,
      "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
      "suggestion": "proof_wanted E\u2086_det : E\u2086.det = 3\n\nproof_wanted E\u2087_det : E\u2087.det = 2\n\nproof_wanted E\u2088_det : E\u2088.det = 1\n",
      "body": "Oops, I now see I made a typo in my suggestion: these lemmas all just repeat the statement about `F\u2084`. Checking now I see that my initial surprise was justified: `decide` does fail (without max recursion depth bump) for the larger ones. We _could_ write very disgusting manual proofs (e.g., starting with `rw [det_succ_column_zero, Fin.sum_univ_six]`) but I would not support such an approach. Much better would be for now to write:\n```suggestion\nproof_wanted E\u2086_det : E\u2086.det = 3\n\nproof_wanted E\u2087_det",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "decide",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "decide",
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "decide",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "decide",
          "transpose",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 1887,
      "before_code": "(\u22a4 : NonUnitalSubalgebra R A).toNonUnitalSubring = \u22a4 :=\n  rfl\n\n@[simp]\ntheorem toSubmodule_eq_top {S : NonUnitalSubalgebra R A} : S.toSubmodule = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toSubmodule'.injective.eq_iff' top_toSubmodule\n\n@[simp]\ntheorem toNonUnitalSubsemiring_eq_top {S : NonUnitalSubalgebra R A} :\n    S.toNonUnitalSubsemiring = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toNonUnitalSubsemiring_injective.eq_iff' top_toNonUnitalSubsemiring\n\n@[simp]\ntheorem to_subring_eq_top {R A : Type*} [CommRing R] [Ring A] [Algebra R A]",
      "suggestion": "\r\ntheorem toNonUnitalSubring_eq_top {R A : Type*} [CommRing R] [Ring A] [Algebra R A]\r\n",
      "body": "```suggestion\r\ntheorem toNonUnitalSubring_eq_top {R A : Type*} [CommRing R] [Ring A] [Algebra R A]\r\n```",
      "path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean",
      "tags": {
        "before_tactics": [
          "ring",
          "simp"
        ],
        "suggestion_tactics": [
          "ring"
        ],
        "body_tactics": [
          "ring"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "Ring",
          "Type",
          "toSubmodule_eq_top",
          "toSubmodule",
          "top_toSubmodule",
          "injective",
          "toNonUnitalSubsemiring_eq_top",
          "top_toNonUnitalSubsemiring",
          "toNonUnitalSubsemiring",
          "CommRing",
          "NonUnitalSubalgebra",
          "toNonUnitalSubsemiring_injective",
          "simp",
          "rfl",
          "to_subring_eq_top",
          "theorem",
          "toNonUnitalSubring",
          "eq_iff",
          "Algebra"
        ]
      }
    },
    {
      "id": 1891,
      "before_code": "(\u22a4 : NonUnitalSubalgebra R A).toNonUnitalSubring = \u22a4 :=\n  rfl\n\n@[simp]\ntheorem toSubmodule_eq_top {S : NonUnitalSubalgebra R A} : S.toSubmodule = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toSubmodule'.injective.eq_iff' top_toSubmodule\n\n@[simp]\ntheorem toNonUnitalSubsemiring_eq_top {S : NonUnitalSubalgebra R A} :\n    S.toNonUnitalSubsemiring = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toNonUnitalSubsemiring_injective.eq_iff' top_toNonUnitalSubsemiring",
      "suggestion": "\r\n-- This lemma isn't simp because `NonUnitalSubalgebra.toSubmodule` is a \"fake\" projection,\r\n-- which is syntactically a constructor application.\r\n",
      "body": "Then it is proved by `simp only [Submodule.mk_eq_top, NonUnitalSubsemiring.toAddSubmonoid_eq_top, toNonUnitalSubsemiring_eq_top]`. I guess I should have said\r\n```suggestion\r\n-- This lemma isn't simp because `NonUnitalSubalgebra.toSubmodule` is a \"fake\" projection,\r\n-- which is syntactically a constructor application.\r\n```\r\ninstead",
      "path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "constructor",
          "simp"
        ],
        "body_tactics": [
          "have",
          "constructor",
          "simp"
        ],
        "new_tactics": [
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "use_simp"
        ],
        "keywords": [
          "toNonUnitalSubsemiring",
          "toSubmodule",
          "theorem",
          "top_toSubmodule",
          "NonUnitalSubalgebra",
          "toNonUnitalSubring",
          "eq_iff",
          "toNonUnitalSubsemiring_injective",
          "toSubmodule_eq_top",
          "simp",
          "rfl",
          "injective",
          "toNonUnitalSubsemiring_eq_top",
          "top_toNonUnitalSubsemiring"
        ]
      }
    },
    {
      "id": 1893,
      "before_code": "theorem mul_natCast_floor_div_cancel {n : \u2115} (hn : n \u2260 0) (a : R) : \u230aa * n\u230b / n = \u230aa\u230b := by\n  simpa using mul_cast_floor_div_cancel_of_pos (n := n) (by positivity) a",
      "suggestion": "\r\ntheorem mul_fract_eq_one_iff_exists_int {x : R} {k : R} (hk : 1 < k) :\r\n    k * fract x = 1 \u2194 \u2203 n : \u2124, k * x = k * n + 1 := by\r\n  rw [fract, mul_sub, sub_eq_iff_eq_add']\r\n  refine \u27e8fun hx \u21a6 \u27e8\u230ax\u230b, hx\u27e9, ?_\u27e9\r\n  rintro \u27e8n, hn\u27e9\r\n  convert hn\r\n  have hk0 : 0 < (k : R) := zero_le_one.trans_lt hk\r\n  rw [floor_eq_iff, \u2190 mul_le_mul_iff_right\u2080 hk0, \u2190 mul_lt_mul_iff_right\u2080 hk0, hn]\r\n  simp [mul_add, hk]\r\n",
      "body": "Better I think as\r\n```suggestion\r\ntheorem mul_fract_eq_one_iff_exists_int {x : R} {k : R} (hk : 1 < k) :\r\n    k * fract x = 1 \u2194 \u2203 n : \u2124, k * x = k * n + 1 := by\r\n  rw [fract, mul_sub, sub_eq_iff_eq_add']\r\n  refine \u27e8fun hx \u21a6 \u27e8\u230ax\u230b, hx\u27e9, ?_\u27e9\r\n  rintro \u27e8n, hn\u27e9\r\n  convert hn\r\n  have hk0 : 0 < (k : R) := zero_le_one.trans_lt hk\r\n  rw [floor_eq_iff, \u2190 mul_le_mul_iff_right\u2080 hk0, \u2190 mul_lt_mul_iff_right\u2080 hk0, hn]\r\n  simp [mul_add, hk]\r\n```",
      "path": "Mathlib/Algebra/Order/Floor/Ring.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "positivity"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have",
          "rw",
          "refine"
        ],
        "removed_tactics": [
          "simpa",
          "positivity"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mul_cast_floor_div_cancel_of_pos",
          "positivity",
          "theorem",
          "simpa",
          "mul_natCast_floor_div_cancel",
          "using"
        ]
      }
    },
    {
      "id": 1899,
      "before_code": "protected lemma Preconnected.mono {G G' : SimpleGraph V} (h : G \u2264 G') (hG : G.Preconnected) :\n    G'.Preconnected := fun u v => (hG u v).mono h",
      "suggestion": "  aesop (add simp Preconnected)\n",
      "body": "```suggestion\n  aesop (add simp Preconnected)\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Connected.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "lemma",
          "mono",
          "protected",
          "Preconnected",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1900,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\n  intro u c hc\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\n    have eneq : e \u2260 s(x,y) := fun h => h_bridge.2 c hc (h \u25b8 he)\n    simpa [eneq] using Walk.edges_subset_edgeSet c he)\n",
      "body": "Just style nits. The only one worth highlighting is that the pattern `apply my_lemma.mp` is almost always a synonym for `rw [my_lemma]`:\n```suggestion\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\n  intro u c hc\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\n    have eneq : e \u2260 s(x,y) := fun h => h_bridge.2 c hc (h \u25b8 he)\n    simpa [eneq] using Walk.edges_subset_edgeSet c he)\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "have",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "have",
          "intro"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1901,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "/-- A subgraph is maximal acyclic iff its reachability relation agrees with the larger graph. -/\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G \u2227 F.IsAcyclic) :\n    Maximal (fun H => H \u2264 G \u2227 H.IsAcyclic) F \u2194 F.Reachable = G.Reachable := by\n  refine \u27e8reachable_eq_of_maximal_isAcyclic F, fun h \u21a6 ?_\u27e9\n",
      "body": "We don't need to have both `maximal_isAcyclic_of_reachable_eq` and `maximal_isAcyclic_iff_reachable_eq` since the latter dominates the former so let's just collapse them together like this:\n```suggestion\n/-- A subgraph is maximal acyclic iff its reachability relation agrees with the larger graph. -/\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G \u2227 F.IsAcyclic) :\n    Maximal (fun H => H \u2264 G \u2227 H.IsAcyclic) F \u2194 F.Reachable = G.Reachable := by\n  refine \u27e8reachable_eq_of_ma",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine",
          "have"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1902,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "@[simp] theorem maximal_isAcyclic_iff_isTree [Nonempty V] {T : SimpleGraph V} :\n",
      "body": "```suggestion\n@[simp] theorem maximal_isAcyclic_iff_isTree [Nonempty V] {T : SimpleGraph V} :\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1903,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  simp [\u2190 connected_top.maximal_le_isAcyclic_iff_isTree le_top]\n",
      "body": "```suggestion\n  simp [\u2190 connected_top.maximal_le_isAcyclic_iff_isTree le_top]\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1904,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  have : Nonempty V := hG.nonempty\n  refine \u27e8fun h \u21a6 \u27e8\u27e8fun u v \u21a6 ?_\u27e9, h.1.2\u27e9, fun hT' \u21a6 ?_\u27e9\n  \u00b7 rw [G.reachable_eq_of_maximal_isAcyclic T h]\n    exact hG.preconnected u v\n  \u00b7 rw [maximal_isAcyclic_iff_reachable_eq \u27e8hT, hT'.IsAcyclic\u27e9]\n    replace hT' : T.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hT'.isConnected.preconnected\n    replace hG : G.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hG.preconnected\n    rw [hT', hG]\n",
      "body": "What you have is probably fine but I worry that the call to `grind` is maybe a bit brittle so let's try:\n```suggestion\n  have : Nonempty V := hG.nonempty\n  refine \u27e8fun h \u21a6 \u27e8\u27e8fun u v \u21a6 ?_\u27e9, h.1.2\u27e9, fun hT' \u21a6 ?_\u27e9\n  \u00b7 rw [G.reachable_eq_of_maximal_isAcyclic T h]\n    exact hG.preconnected u v\n  \u00b7 rw [maximal_isAcyclic_iff_reachable_eq \u27e8hT, hT'.IsAcyclic\u27e9]\n    replace hT' : T.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hT'.isConnected.preconnected\n    replace hG : G",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "exact",
          "refine",
          "rw",
          "have"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "rw"
        ],
        "new_tactics": [
          "have",
          "rw",
          "refine"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1905,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "",
      "body": "This looks redundant:\n```suggestion\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1906,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  obtain \u27e8\u27e8hF : F \u2264 G, hF' : F.IsAcyclic\u27e9, h\u27e9 := by simpa [Maximal] using h\n  ext u v\n  refine \u27e8fun h \u21a6 h.mono hF, ?_\u27e9\n  contrapose! h\n  obtain \u27e8\u27e8p : G.Walk u v\u27e9, h : \u00ac F.Reachable u v\u27e9 := h\n  let s : Set V := F.connectedComponentMk u\n  have hus : u \u2208 s := ConnectedComponent.connectedComponentMk_mem\n  have hvs : v \u2209 s := h \u2218 (F.connectedComponentMk u).reachable_of_mem_supp hus\n  obtain \u27e8\u27e8\u27e8u', v'\u27e9, huv : G.Adj u' v'\u27e9, -, hu : u' \u2208 s, hv : v' \u2209 s\u27e9 :=\n    p.exists_boundary_dart s hus hvs\n  suffices (F \u2294 fromEdgeSet {s(u', v')}).IsAcyclic by\n    refine \u27e8F \u2294 fromEdgeSet {s(u', v')}, ?_, this, le_sup_left, ?_\u27e9\n    \u00b7 have : G.Adj v' u' := G.symm huv\n      simp only [sup_le_iff, le_iff_adj, fromEdgeSet_adj, Set.mem_singleton_iff, Sym2.eq,\n        Sym2.rel_iff'] at hF \u22a2\n      grind\n    \u00b7 rw [le_iff_adj]\n      push_neg\n      refine \u27e8u', v', ?_, fun hc \u21a6 ?_\u27e9\n      \u00b7 simpa using Or.inr huv.ne\n      \u00b7 have := (F.connectedComponentMk u).mem_supp_congr_adj hc\n        grind\n  suffices \u00ac F.Reachable u'",
      "body": "The following is a slight golf. I was not trying to make it shorter though: I was trying to make it slightly more idiomatic and readable. I think what I've got is still not great but is acceptable (as was yours already). Two minor points I highlight are:\n\n- I've added various redundant type ascriptions (e.g., to the `obtain`s). These aid readability for a human.\n- I've use the `ext` tactic rather than directly calling the underlying very low-level `funext`, `propext`\n\nI also note that [Maximal](",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "funext",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "remove_redundant",
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1907,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "theorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G) (hF' : F.IsAcyclic) :\n",
      "body": "We prefer to supply multiple named hypotheses in lemmas rather than a conjunction:\n```suggestion\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G) (hF' : F.IsAcyclic) :\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1908,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "\r\n    (G \u2294 fromEdgeSet {s(x, y)}).IsAcyclic \u2194 IsAcyclic G := by\r\n  refine \u27e8fun h \u21a6 h.anti le_sup_left, fun hG \u21a6 ?_\u27e9\r\n  have x_neq_y : x \u2260 y := fun c => (c \u25b8 hxy) (Reachable.refl y)\r\n  have h_add_remove : (G \u2294 fromEdgeSet {s(x, y)}) \\ fromEdgeSet {s(x, y)} = G := by\r\n    simpa using fun h => hxy h.reachable\r\n  have h_bridge : (G \u2294 fromEdgeSet {s(x, y)}).IsBridge s(x, y) := by\r\n    simpa [isBridge_iff, x_neq_y, h_add_remove]\r\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\r\n  intro u c hc\r\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\r\n    have eneq : e \u2260 s(x, y) := fun h => h_bridge.2 c hc (h \u25b8 he)\r\n",
      "body": "```suggestion\r\n    (G \u2294 fromEdgeSet {s(x, y)}).IsAcyclic \u2194 IsAcyclic G := by\r\n  refine \u27e8fun h \u21a6 h.anti le_sup_left, fun hG \u21a6 ?_\u27e9\r\n  have x_neq_y : x \u2260 y := fun c => (c \u25b8 hxy) (Reachable.refl y)\r\n  have h_add_remove : (G \u2294 fromEdgeSet {s(x, y)}) \\ fromEdgeSet {s(x, y)} = G := by\r\n    simpa using fun h => hxy h.reachable\r\n  have h_bridge : (G \u2294 fromEdgeSet {s(x, y)}).IsBridge s(x, y) := by\r\n    simpa [isBridge_iff, x_neq_y, h_add_remove]\r\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 1912,
      "before_code": "open WithZeroMulInt\n\nvariable {R K} in",
      "suggestion": "  exact h_mono <| v.intValuation.map_add x y\n",
      "body": "There are two spaces between `map_add` and `x`. This should be a single space for consistency with the rest of the codebase.\n```suggestion\n  exact h_mono <| v.intValuation.map_add x y\n```",
      "path": "Mathlib/RingTheory/DedekindDomain/AdicValuation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "open",
          "WithZeroMulInt",
          "variable"
        ]
      }
    },
    {
      "id": 1929,
      "before_code": "(x y : R\u27e6\u0393\u27e7) : (x * y).cardSupp \u2264 x.cardSupp * y.cardSupp :=\n  (mk_le_mk_of_subset (support_mul_subset ..)).trans mk_add_le",
      "suggestion": "/-- The `\u03ba`-bounded subring of Hahn series with cardinal less than `\u03ba`. -/\n",
      "body": "Do you mean this?\n```suggestion\n/-- The `\u03ba`-bounded subring of Hahn series with cardinal less than `\u03ba`. -/\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Cardinal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support_mul_subset",
          "mk_le_mk_of_subset",
          "trans",
          "cardSupp",
          "mk_add_le"
        ]
      }
    },
    {
      "id": 1934,
      "before_code": "have : NeZero n := \u27e8hn\u27e9\n  exact nthRoots_one_eq_biUnion_primitiveRoots'",
      "suggestion": "\r\n  have hea (a : R) (ha: a \u2208 primitiveRoots r R) :\r\n      a ^ (e * ((r * e.gcdA r + 1) * e.gcdA r).toNat) = a := by\r\n",
      "body": "```suggestion\r\n  have hea (a : R) (ha: a \u2208 primitiveRoots r R) :\r\n      a ^ (e * ((r * e.gcdA r + 1) * e.gcdA r).toNat) = a := by\r\n```",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "NeZero",
          "have",
          "nthRoots_one_eq_biUnion_primitiveRoots"
        ]
      }
    },
    {
      "id": 1938,
      "before_code": "rcases h\u03be with \u27e8i, hin, hi, H\u27e9\n    exact \u27e8i, \u27e8hin, hi.symm\u27e9, H\u27e9",
      "suggestion": "\r\n@[simps]\r\ndef equivPrimitiveRootsOfCoprimePow' {a b n : \u2115} (h : a * b \u2261 1 [MOD n]) :\r\n",
      "body": "```suggestion\r\n@[simps]\r\ndef equivPrimitiveRootsOfCoprimePow' {a b n : \u2115} (h : a * b \u2261 1 [MOD n]) :\r\n```",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "cases"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "rcases",
          "symm",
          "hin"
        ]
      }
    },
    {
      "id": 1941,
      "before_code": "rcases h\u03be with \u27e8i, hin, hi, H\u27e9\n    exact \u27e8i, \u27e8hin, hi.symm\u27e9, H\u27e9",
      "suggestion": "\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n",
      "body": "```suggestion\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n```\r\nI think it\u2019s better practice to inline the \"haves\" when in term mode with a non-prop goal like this.\r\n\r\nalso, added the `@[simps! apply_coe]` adds the lemma saying that you\u2019re i",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact",
          "cases"
        ],
        "topics": [],
        "transforms": [
          "term_mode",
          "use_grind"
        ],
        "keywords": [
          "exact",
          "rcases",
          "symm",
          "hin"
        ]
      }
    },
    {
      "id": 1942,
      "before_code": "(x * y).leadingCoeff = x.leadingCoeff * y.leadingCoeff := by\n  simp only [leadingCoeff_eq, order_mul_of_nonzero h, coeff_mul_order_add_order]",
      "suggestion": "\r\n  apply leadingCoeff_mul_of_ne_zero\r\n",
      "body": "If you want to fix it, this should be\r\n```suggestion\r\n  apply leadingCoeff_mul_of_ne_zero\r\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "order_mul_of_nonzero",
          "leadingCoeff_eq",
          "simp",
          "leadingCoeff",
          "coeff_mul_order_add_order",
          "only"
        ]
      }
    },
    {
      "id": 1946,
      "before_code": "namespace Filtration",
      "suggestion": "@[simp] lemma rightCont_self (\ud835\udcd5 : Filtration \u03b9 m) : \ud835\udcd5\u208a\u208a = \ud835\udcd5\u208a := by\n",
      "body": "```suggestion\n@[simp] lemma rightCont_self (\ud835\udcd5 : Filtration \u03b9 m) : \ud835\udcd5\u208a\u208a = \ud835\udcd5\u208a := by\n```\nmaybe?",
      "path": "Mathlib/Probability/Process/Filtration.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Filtration",
          "namespace"
        ]
      }
    },
    {
      "id": 1963,
      "before_code": "attribute [symm] Perm.symm\nattribute [trans] Perm.trans\n\ninstance : IsSymm (List \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9",
      "suggestion": "\r\ninstance : Std.Symm (\u03b1 := List \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9\r\n",
      "body": "Well that would have to be a bit longer:\r\n```suggestion\r\ninstance : Std.Symm (\u03b1 := List \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9\r\n```\r\nwhich is why I specified the type in `Perm` instead of in `Std.Symm`, but sure why not",
      "path": "Mathlib/Data/List/Perm/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "trans",
          "Perm",
          "IsSymm",
          "List",
          "attribute",
          "instance"
        ]
      }
    },
    {
      "id": 1967,
      "before_code": "alias \u27e8_, IsIdempotentElem.ext\u27e9 := IsIdempotentElem.ext_iff\n\ntheorem IsIdempotentElem.range_eq_ker {E : Type*} [AddCommGroup E] [Module S E]\n    {p : E \u2192\u2097[S] E} (hp : IsIdempotentElem p) : LinearMap.range p = LinearMap.ker (1 - p) :=\n  le_antisymm\n    (LinearMap.range_le_ker_iff.mpr hp.one_sub_mul_self)\n    fun x hx \u21a6 \u27e8x, by simpa [sub_eq_zero, eq_comm (a := x)] using hx\u27e9\n\nopen LinearMap in\ntheorem IsIdempotentElem.ker_eq_range {E : Type*} [AddCommGroup E] [Module S E]\n    {p : E \u2192\u2097[S] E} (hp : IsIdempotentElem p) : LinearMap.ker p = LinearMap.range (1 - p) := by\n  simpa using hp.one_sub.range_eq_ker.symm",
      "suggestion": "\r\n  simpa using hp.one_sub.range_eq_ker_one_sub.symm\r\n",
      "body": "```suggestion\r\n  simpa using hp.one_sub.range_eq_ker_one_sub.symm\r\n```",
      "path": "Mathlib/LinearAlgebra/Projection.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "range_eq_ker",
          "ker_eq_range",
          "mpr",
          "Module",
          "le_antisymm",
          "Type",
          "open",
          "alias",
          "eq_comm",
          "symm",
          "ext",
          "LinearMap",
          "IsIdempotentElem",
          "AddCommGroup",
          "one_sub_mul_self",
          "ker",
          "range",
          "sub_eq_zero",
          "range_le_ker_iff",
          "ext_iff",
          "theorem",
          "one_sub",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 1977,
      "before_code": "(x y : R\u27e6\u0393\u27e7) : (x * y).cardSupp \u2264 x.cardSupp * y.cardSupp :=\n  (mk_le_mk_of_subset (support_mul_subset ..)).trans mk_add_le",
      "suggestion": "\r\n  obtain rfl | hx := eq_or_ne x 0; \u00b7 simp\r\n",
      "body": "```suggestion\r\n  obtain rfl | hx := eq_or_ne x 0; \u00b7 simp\r\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Cardinal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support_mul_subset",
          "mk_le_mk_of_subset",
          "trans",
          "cardSupp",
          "mk_add_le"
        ]
      }
    },
    {
      "id": 1978,
      "before_code": "(x y : R\u27e6\u0393\u27e7) : (x * y).cardSupp \u2264 x.cardSupp * y.cardSupp :=\n  (mk_le_mk_of_subset (support_mul_subset ..)).trans mk_add_le",
      "suggestion": "    simpa [pow_succ] using (cardSupp_mul_le ..).trans <| mul_le_mul_left IH _\n",
      "body": "```suggestion\n    simpa [pow_succ] using (cardSupp_mul_le ..).trans <| mul_le_mul_left IH _\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Cardinal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "support_mul_subset",
          "mk_le_mk_of_subset",
          "trans",
          "cardSupp",
          "mk_add_le"
        ]
      }
    },
    {
      "id": 1979,
      "before_code": "Cat.Hom.inv_hom_id_toNatTrans_app]\n    simp [D.hom_self _ _ rfl]",
      "suggestion": "        simp_all [map_eq_pullHom] }\n",
      "body": "```suggestion\n        simp_all [map_eq_pullHom] }\n```",
      "path": "Mathlib/CategoryTheory/Sites/Descent/DescentData.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "inv_hom_id_toNatTrans_app",
          "Cat",
          "Hom",
          "simp",
          "rfl",
          "hom_self"
        ]
      }
    },
    {
      "id": 1980,
      "before_code": "Cat.Hom.inv_hom_id_toNatTrans_app]\n    simp [D.hom_self _ _ rfl]",
      "suggestion": "\r\n@[simps!]\r\ndef subtypeCompatibleHomEquiv {M N : F.obj (.mk (op S))} :\r\n",
      "body": "```suggestion\r\n@[simps!]\r\ndef subtypeCompatibleHomEquiv {M N : F.obj (.mk (op S))} :\r\n```\r\nlooks reasonable",
      "path": "Mathlib/CategoryTheory/Sites/Descent/DescentData.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "inv_hom_id_toNatTrans_app",
          "Cat",
          "Hom",
          "simp",
          "rfl",
          "hom_self"
        ]
      }
    },
    {
      "id": 2021,
      "before_code": "section shift_invariance\n\nvariable {\ud835\udd5c F} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\n\n/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (s + z)) = fun t \u21a6 iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (z + s)) = fun t \u21a6 iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s",
      "suggestion": "  simp [sub_eq_add_neg, iteratedDeriv_comp_add_const]\n",
      "body": "```suggestion\n  simp [sub_eq_add_neg, iteratedDeriv_comp_add_const]\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "funext",
          "induction",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "funext",
          "induction"
        ],
        "topics": [
          "norm",
          "list",
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "funext",
          "lemma",
          "deriv_comp_add_const",
          "succ",
          "iterated",
          "iteratedDeriv_succ",
          "commutes",
          "section",
          "right",
          "iteratedDeriv_comp_const_add",
          "NormedAddCommGroup",
          "constant",
          "variable",
          "derivative",
          "shift_invariance",
          "induction",
          "simp",
          "iteratedDeriv_comp_add_const",
          "zero",
          "only",
          "iteratedDeriv",
          "NontriviallyNormedField",
          "deriv_comp_const_add",
          "function",
          "left",
          "NormedSpace",
          "simpa",
          "iteratedDeriv_zero",
          "shifting",
          "using"
        ]
      }
    },
    {
      "id": 2022,
      "before_code": "section shift_invariance\n\nvariable {\ud835\udd5c F} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\n\n/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (s + z)) = fun t \u21a6 iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (z + s)) = fun t \u21a6 iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s",
      "suggestion": "  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n",
      "body": "```suggestion\n  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "funext",
          "induction",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "funext",
          "induction",
          "simp"
        ],
        "topics": [
          "norm",
          "list",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "funext",
          "lemma",
          "deriv_comp_add_const",
          "succ",
          "iterated",
          "iteratedDeriv_succ",
          "commutes",
          "section",
          "right",
          "iteratedDeriv_comp_const_add",
          "NormedAddCommGroup",
          "constant",
          "variable",
          "derivative",
          "shift_invariance",
          "induction",
          "simp",
          "iteratedDeriv_comp_add_const",
          "zero",
          "only",
          "iteratedDeriv",
          "NontriviallyNormedField",
          "deriv_comp_const_add",
          "function",
          "left",
          "NormedSpace",
          "simpa",
          "iteratedDeriv_zero",
          "shifting",
          "using"
        ]
      }
    },
    {
      "id": 2025,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "\r\n    conv_rhs => rw [K.norm_sq_eq_add_norm_sq_starProjection]\r\n    simp [starProjection_apply, orthogonalProjection_eq_linearProjOfIsCompl]\r\n",
      "body": "if you change the definition like I suggested above (and add the suggested lemmas), then the proof of this would be:\r\n```suggestion\r\n    conv_rhs => rw [K.norm_sq_eq_add_norm_sq_starProjection]\r\n    simp [starProjection_apply, orthogonalProjection_eq_linearProjOfIsCompl]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2029,
      "before_code": "@[deprecated (since := \"2025-07-29\")] alias linearProjOfIsCompl_eq_self_iff :=\n  IsCompl.projection_eq_self_iff",
      "suggestion": "\r\ntheorem symm_prodEquivOfIsCompl_apply (hpq : IsCompl p q) (x : E) :\r\n",
      "body": "Are we not trying to move away from `foo_symm`?\r\n```suggestion\r\ntheorem symm_prodEquivOfIsCompl_apply (hpq : IsCompl p q) (x : E) :\r\n```",
      "path": "Mathlib/LinearAlgebra/Projection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "alias",
          "IsCompl",
          "since",
          "linearProjOfIsCompl_eq_self_iff",
          "projection_eq_self_iff",
          "deprecated"
        ]
      }
    },
    {
      "id": 2033,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "@[simp]\ntheorem fst_orthogonalDecomposition_apply :\n",
      "body": "```suggestion\n@[simp]\ntheorem fst_orthogonalDecomposition_apply :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2034,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "@[simp]\ntheorem snd_orthogonalDecomposition_apply :\n",
      "body": "```suggestion\n@[simp]\ntheorem snd_orthogonalDecomposition_apply :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2037,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "@[simp]\ntheorem fstL_comp_coe_orthogonalDecomposition :\n",
      "body": "```suggestion\n@[simp]\ntheorem fstL_comp_coe_orthogonalDecomposition :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2038,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "@[simp]\ntheorem sndL_comp_coe_orthogonalDecomposition :\n",
      "body": "```suggestion\n@[simp]\ntheorem sndL_comp_coe_orthogonalDecomposition :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 2041,
      "before_code": "simp only [bracket_ofTwoCocycle]\n    exact Equiv.congr_arg (by simp [\u2190 smul_add, smul_sub])",
      "suggestion": "\r\n    ofTwoCocycle c \u2243\u2097\u2045R\u2046 ofTwoCocycle c' where\r\n  toFun y :=\r\n    letI z := (ofProd c).symm y\r\n    ofProd c' (z.1, z.2 - x z.1)\r\n  invFun z :=\r\n    letI y := (ofProd c').symm z\r\n    ofProd c (y.1, y.2 + x y.1)\r\n  map_add' _ _ := by simp [\u2190 of_add]; abel\r\n  map_smul' := by simp [\u2190 of_smul, smul_sub]\r\n  map_lie' := ((ofProd c').apply_eq_iff_eq_symm_apply).2 <| by simp [bracket_ofTwoCocycle, h]; abel\r\n",
      "body": "```suggestion\r\n    ofTwoCocycle c \u2243\u2097\u2045R\u2046 ofTwoCocycle c' where\r\n  toFun y :=\r\n    letI z := (ofProd c).symm y\r\n    ofProd c' (z.1, z.2 - x z.1)\r\n  invFun z :=\r\n    letI y := (ofProd c').symm z\r\n    ofProd c (y.1, y.2 + x y.1)\r\n  map_add' _ _ := by simp [\u2190 of_add]; abel\r\n  map_smul' := by simp [\u2190 of_smul, smul_sub]\r\n  map_lie' := ((ofProd c').apply_eq_iff_eq_symm_apply).2 <| by simp [bracket_ofTwoCocycle, h]; abel\r\n```",
      "path": "Mathlib/Algebra/Lie/Extension.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "congr_arg",
          "smul_sub",
          "exact",
          "Equiv",
          "smul_add",
          "simp",
          "bracket_ofTwoCocycle",
          "only"
        ]
      }
    },
    {
      "id": 2042,
      "before_code": "sub_add_cancel_right, map_add, neg_add_rev]\n    abel_nf",
      "suggestion": "    rw [\u2190 map_add, AddMemClass.mk_add_mk, EquivLike.apply_eq_iff_eq, Subtype.mk_eq_mk, map_add,\n      map_add, add_sub_add_comm]\n",
      "body": "Style nit:\n```suggestion\n    rw [\u2190 map_add, AddMemClass.mk_add_mk, EquivLike.apply_eq_iff_eq, Subtype.mk_eq_mk, map_add,\n      map_add, add_sub_add_comm]\n```",
      "path": "Mathlib/Algebra/Lie/Extension.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "neg_add_rev",
          "map_add",
          "abel_nf",
          "sub_add_cancel_right"
        ]
      }
    },
    {
      "id": 2043,
      "before_code": "sub_add_cancel_right, map_add, neg_add_rev]\n    abel_nf",
      "suggestion": "    rw [RingHom.id_apply, \u2190 map_smul, EquivLike.apply_eq_iff_eq, SetLike.mk_smul_of_tower_mk,\n      Subtype.mk_eq_mk, LinearMap.map_smul_of_tower, smul_sub, LinearMap.map_smul_of_tower]\n",
      "body": "```suggestion\n    rw [RingHom.id_apply, \u2190 map_smul, EquivLike.apply_eq_iff_eq, SetLike.mk_smul_of_tower_mk,\n      Subtype.mk_eq_mk, LinearMap.map_smul_of_tower, smul_sub, LinearMap.map_smul_of_tower]\n```",
      "path": "Mathlib/Algebra/Lie/Extension.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "neg_add_rev",
          "map_add",
          "abel_nf",
          "sub_add_cancel_right"
        ]
      }
    },
    {
      "id": 2046,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "theorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 := by\n  rw [Int.floor_eq_iff]\n  grind [pi_gt_three, pi_lt_four]\n",
      "body": "I don't have a strong preference. But would this be a middle ground?\n```suggestion\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 := by\n  rw [Int.floor_eq_iff]\n  grind [pi_gt_three, pi_lt_four]\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "rw"
        ],
        "body_tactics": [
          "grind",
          "rw",
          "have"
        ],
        "new_tactics": [
          "grind",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 2047,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n",
      "body": "We can also\r\n```suggestion\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": []
      }
    },
    {
      "id": 2053,
      "before_code": "end LinearMap\n\nnamespace Equiv\nvariable {R A B : Type*} [CommSemiring R]",
      "suggestion": "\r\nvariable {R A A' B B' C C' : Type*}\r\nvariable [CommSemiring R] [AddCommMonoid A'] [AddCommMonoid B'] [AddCommMonoid C']\r\nvariable [Module R A'] [Module R B'] [Module R C']\r\n",
      "body": "nit:\r\n```suggestion\r\nvariable {R A A' B B' C C' : Type*}\r\nvariable [CommSemiring R] [AddCommMonoid A'] [AddCommMonoid B'] [AddCommMonoid C']\r\nvariable [Module R A'] [Module R B'] [Module R C']\r\n```\r\nfor slightly more semantic line breaks",
      "path": "Mathlib/LinearAlgebra/TensorProduct/Associator.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "end",
          "LinearMap",
          "variable",
          "Type",
          "Equiv",
          "CommSemiring",
          "namespace"
        ]
      }
    },
    {
      "id": 2055,
      "before_code": "linear_combination (norm := (push_cast; ring_nf))\n    h\u2081 + (n + 2) * h\u2082",
      "suggestion": "\r\n  linear_combination (norm := (push_cast; ring_nf)) h\r\n",
      "body": "```suggestion\r\n  linear_combination (norm := (push_cast; ring_nf)) h\r\n```\r\nI personally find this line break a bit weird but if you are attached to this style I don't particular want to block this PR because of it.",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring_nf",
          "push_cast"
        ],
        "suggestion_tactics": [
          "ring_nf",
          "push_cast"
        ],
        "body_tactics": [
          "ring_nf",
          "push_cast"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "push_cast",
          "ring_nf",
          "linear_combination",
          "norm"
        ]
      }
    },
    {
      "id": 2069,
      "before_code": "end card",
      "suggestion": "\r\n",
      "body": "I assume this is test code, and can be removed?\r\n```suggestion\r\n```",
      "path": "Mathlib/Order/Interval/Finset/Fin.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "end",
          "card"
        ]
      }
    },
    {
      "id": 2071,
      "before_code": "theorem intrinsicStar_rTensor (f : E \u2192\u2097[R] F) : star (rTensor G f) = rTensor G (star f) := by\n  simp [rTensor, TensorProduct.intrinsicStar_map]\n\nend TensorProduct",
      "suggestion": "theorem IntrinsicStar.starLinearEquiv_eq_arrowCongr :\n",
      "body": "I like this the best. It's verbose, but I would have trouble guessing what you were going to write on the other side of `eq` without this.\n```suggestion\ntheorem IntrinsicStar.starLinearEquiv_eq_arrowCongr :\n```",
      "path": "Mathlib/Algebra/Star/LinearMap.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "theorem",
          "intrinsicStar_map",
          "rTensor",
          "TensorProduct",
          "simp",
          "intrinsicStar_rTensor",
          "star"
        ]
      }
    },
    {
      "id": 2074,
      "before_code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  \u00b7 exact absurd hf <| h _ _ hxy\n  \u00b7 rfl\n  \u00b7 exact absurd hf.symm <| h _ _ hxy",
      "suggestion": "\r\n  exact injective_of_eq_imp_le f fun {x y} \u21a6\r\n    not_lt (\u03b1 := \u03b1) |>.eq \u25b8 imp_not_comm.mp (eq_comm.eq \u25b8 h y x)\r\n",
      "body": "if you move the new lemma before this one, you could do\r\n```suggestion\r\n  exact injective_of_eq_imp_le f fun {x y} \u21a6\r\n    not_lt (\u03b1 := \u03b1) |>.eq \u25b8 imp_not_comm.mp (eq_comm.eq \u25b8 h y x)\r\n```\r\nor\r\n```suggestion\r\n  grind [injective_of_eq_imp_le]\r\n```",
      "path": "Mathlib/Order/Monotone/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lt_trichotomy",
          "Injective",
          "symm",
          "theorem",
          "exact",
          "rcases",
          "absurd",
          "injective_of_lt_imp_ne",
          "LinearOrder",
          "intro",
          "hxy",
          "rfl"
        ]
      }
    },
    {
      "id": 2075,
      "before_code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  \u00b7 exact absurd hf <| h _ _ hxy\n  \u00b7 rfl\n  \u00b7 exact absurd hf.symm <| h _ _ hxy",
      "suggestion": "\r\n  exact Function.Injective.of_eq_imp_le _ (le_of_not_gt <| Imp.swap.mp (h _ _) \u00b7.symm)\r\n",
      "body": "I know, I had this before:\r\n```suggestion\r\n  exact Function.Injective.of_eq_imp_le _ (le_of_not_gt <| Imp.swap.mp (h _ _) \u00b7.symm)\r\n```\r\nthen I realized I can\r\n```suggestion\r\n  exact Function.Injective.of_eq_imp_le _ <| by grind\r\n```\r\nand then\r\n```suggestion\r\n  grind [Function.Injective.of_eq_imp_le]\r\n```\r\nand finally the current version, which doesn't need the new theorem.\r\nI don't think that going back to the explicit term is better.",
      "path": "Mathlib/Order/Monotone/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lt_trichotomy",
          "Injective",
          "symm",
          "theorem",
          "exact",
          "rcases",
          "absurd",
          "injective_of_lt_imp_ne",
          "LinearOrder",
          "intro",
          "hxy",
          "rfl"
        ]
      }
    },
    {
      "id": 2076,
      "before_code": "(SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n@[to_additive]\nlemma closure_pow_le : \u2200 {n}, n \u2260 0 \u2192 closure (s ^ n) \u2264 closure s\n  | 1, _ => by simp\n  | n + 2, _ =>",
      "suggestion": "\r\n  | 0 => by simp_all\r\n",
      "body": "```suggestion\r\n  | 0 => by simp_all\r\n```",
      "path": "Mathlib/Algebra/Group/Subgroup/Pointwise.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "lemma",
          "SetLike",
          "le_def",
          "subset_closure",
          "closure_pow_le",
          "closure",
          "le_sup_right",
          "simp"
        ]
      }
    },
    {
      "id": 2077,
      "before_code": "le_antisymm ((packingNumber_le_encard_self {x}).trans_eq (by simp)) <|\n    le_iSup_of_le {x} <| le_iSup_of_le (by simp) <| le_iSup_of_le (by simp) (by simp)",
      "suggestion": "lemma minimalCover_subset : minimalCover \u03b5 A \u2286 A := by\n  grind [minimalCover]\n",
      "body": "This and the next three lemmas can be proven with this, although for it to work on `finite_minimalCover`, you have to add\n```lean\nattribute [grind .] finite_empty\n```\nbut I think we should do that anyway.\n```suggestion\nlemma minimalCover_subset : minimalCover \u03b5 A \u2286 A := by\n  grind [minimalCover]\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "le_iSup_of_le",
          "trans_eq",
          "le_antisymm",
          "simp",
          "packingNumber_le_encard_self"
        ]
      }
    },
    {
      "id": 2078,
      "before_code": "le_antisymm ((packingNumber_le_encard_self {x}).trans_eq (by simp)) <|\n    le_iSup_of_le {x} <| le_iSup_of_le (by simp) <| le_iSup_of_le (by simp) (by simp)",
      "suggestion": "lemma maximalSeparatedSet_subset : maximalSeparatedSet \u03b5 A \u2286 A := by\n  by grind [maximalSeparatedSet]\n",
      "body": "This and the next two lemmas can be proven with this, although for it to work on `isSeparated_maximalSeparatedSet`, you have to add\n```lean\nattribute [grind .] IsSeparated.empty\n```\nbut I think we should do that anyway.\n\n```suggestion\nlemma maximalSeparatedSet_subset : maximalSeparatedSet \u03b5 A \u2286 A := by\n  by grind [maximalSeparatedSet]\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "le_iSup_of_le",
          "trans_eq",
          "le_antisymm",
          "simp",
          "packingNumber_le_encard_self"
        ]
      }
    },
    {
      "id": 2079,
      "before_code": "le_antisymm ((packingNumber_le_encard_self {x}).trans_eq (by simp)) <|\n    le_iSup_of_le {x} <| le_iSup_of_le (by simp) <| le_iSup_of_le (by simp) (by simp)",
      "suggestion": "lemma encard_minimalCover (h : coveringNumber \u03b5 A \u2260 \u22a4) :\n",
      "body": "```suggestion\nlemma encard_minimalCover (h : coveringNumber \u03b5 A \u2260 \u22a4) :\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "le_iSup_of_le",
          "trans_eq",
          "le_antisymm",
          "simp",
          "packingNumber_le_encard_self"
        ]
      }
    },
    {
      "id": 2081,
      "before_code": "\u00b7 exact hf' x\n      \u00b7 simpa [edist_comm, hxy] using hf' y",
      "suggestion": "  by_cases! h_top : packingNumber \u03b5 A \u2260 \u22a4\n  \u00b7 rw [\u2190 encard_maximalSeparatedSet h_top]\n    exact isCover_maximalSeparatedSet h_top |>.coveringNumber_le_encard maximalSeparatedSet_subset\n  \u00b7 simp [h_top]\n",
      "body": "We now have `by_cases!` to automatically push your negations in the alternate branch. And we have this nice `IsCover.coveringNumber_le_encard` lemma, we might as well use it. :smiley:\n```suggestion\n  by_cases! h_top : packingNumber \u03b5 A \u2260 \u22a4\n  \u00b7 rw [\u2190 encard_maximalSeparatedSet h_top]\n    exact isCover_maximalSeparatedSet h_top |>.coveringNumber_le_encard maximalSeparatedSet_subset\n  \u00b7 simp [h_top]\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "edist_comm",
          "exact",
          "simpa",
          "hxy",
          "using"
        ]
      }
    },
    {
      "id": 2082,
      "before_code": "\u00b7 exact hf' x\n      \u00b7 simpa [edist_comm, hxy] using hf' y",
      "suggestion": "  rcases Set.eq_empty_or_nonempty A with (rfl | h_nonempty)\n  \u00b7 simp\n",
      "body": "```suggestion\n  rcases Set.eq_empty_or_nonempty A with (rfl | h_nonempty)\n  \u00b7 simp\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "simpa",
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "edist_comm",
          "exact",
          "simpa",
          "hxy",
          "using"
        ]
      }
    },
    {
      "id": 2083,
      "before_code": "\u00b7 exact hf' x\n      \u00b7 simpa [edist_comm, hxy] using hf' y",
      "suggestion": "    coveringNumber \u03b5 A \u2264 coveringNumber (\u03b5 / 2) B := calc\n  coveringNumber \u03b5 A\n",
      "body": "otherwise style guidelines would require to indent all lines below the first `calc` line.\n```suggestion\n    coveringNumber \u03b5 A \u2264 coveringNumber (\u03b5 / 2) B := calc\n  coveringNumber \u03b5 A\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "edist_comm",
          "exact",
          "simpa",
          "hxy",
          "using"
        ]
      }
    },
    {
      "id": 2087,
      "before_code": "rw [stdPart, dif_pos hx, \u2190 OrderRingHom.comp_apply, \u2190 OrderRingHom.comp_assoc,\n    OrderRingHom.comp_apply, OrderRingHom.apply_eq_self]",
      "suggestion": "    exact h\n",
      "body": "```suggestion\n    exact h\n```\nI think it is better to be explicit here, especially when it is not syntactically eq",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "stdPart",
          "OrderRingHom",
          "dif_pos",
          "comp_apply",
          "comp_assoc",
          "apply_eq_self"
        ]
      }
    },
    {
      "id": 2088,
      "before_code": "rw [stdPart, dif_pos hx, \u2190 OrderRingHom.comp_apply, \u2190 OrderRingHom.comp_assoc,\n    OrderRingHom.comp_apply, OrderRingHom.apply_eq_self]",
      "suggestion": "\r\n    exact map_nonneg _ h\r\n",
      "body": "```suggestion\r\n    exact map_nonneg _ h\r\n```",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "stdPart",
          "OrderRingHom",
          "dif_pos",
          "comp_apply",
          "comp_assoc",
          "apply_eq_self"
        ]
      }
    },
    {
      "id": 2091,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by simpa [inverse, H] using hf\n  simp_all [Subsingleton.elim f 0]\n",
      "body": "```suggestion\n  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by simpa [inverse, H] using hf\n  simp_all [Subsingleton.elim f 0]\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "body_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 2092,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M\u2082 \u2227 Subsingleton M := by simpa [inverse, H] using hf\r\n",
      "body": "It's the other way around for some reason, or you can add `and_comm` to the `simpa` I guess:\r\n```suggestion\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M\u2082 \u2227 Subsingleton M := by simpa [inverse, H] using hf\r\n```\r\nor\r\n```suggestion\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by aesop\r\n```\r\nor even better (or change the `M` to `M\u2082`):\r\n```suggestion\r\n  have : Subsingleton M := by aesop\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain"
        ],
        "body_tactics": [
          "simpa",
          "obtain",
          "aesop",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "obtain"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 2093,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "\nprotected theorem inverse_inverse (hf : f.IsInvertible) : f.inverse.inverse = f := by\n  rcases hf with \u27e8e, rfl\u27e9\n  simp\n\n",
      "body": "Do you think it is useful to add\n```suggestion\n\nprotected theorem inverse_inverse (hf : f.IsInvertible) : f.inverse.inverse = f := by\n  rcases hf with \u27e8e, rfl\u27e9\n  simp\n\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 2094,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "\r\n@[simp]\r\nprotected theorem inverse_inverse (hf : f.IsInvertible) : f.inverse.inverse = f := by\r\n",
      "body": "simp?\r\n```suggestion\r\n@[simp]\r\nprotected theorem inverse_inverse (hf : f.IsInvertible) : f.inverse.inverse = f := by\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 2102,
      "before_code": "comap f\u2081 q \u2293 comap f\u2082 q \u2264 comap (f\u2081 + f\u2082) q := by",
      "suggestion": "\r\n    comap f\u2081 q \u2293 comap f\u2082 q \u2264 comap (f\u2081 + f\u2082) q :=\r\n  fun _ h \u21a6 mem_comap.mpr <| add_mem h.1 h.2\r\n",
      "body": "here's an even better golf\r\n```suggestion\r\n    comap f\u2081 q \u2293 comap f\u2082 q \u2264 comap (f\u2081 + f\u2082) q :=\r\n  fun _ h \u21a6 mem_comap.mpr <| add_mem h.1 h.2\r\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Map.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "comap"
        ]
      }
    },
    {
      "id": 2105,
      "before_code": "have ha : a \u2260 \u22a4 := by rintro rfl; simp at h\n    exact left_neg_eq_right_neg (a := a) (by simp [neg_add_cancel_of_ne_top, *]) h\n\nlemma injective_add_left_of_ne_top (b : \u03b1) (h : b \u2260 \u22a4) : Function.Injective (fun x \u21a6 x + b) :=\n  fun x y hxy \u21a6 by simpa [h] using congr($hxy - b)\n\nlemma injective_add_right_of_ne_top (b : \u03b1) (h : b \u2260 \u22a4) : Function.Injective (fun x \u21a6 b + x) := by\n  simpa [add_comm] using injective_add_left_of_ne_top b h\n\nlemma strictMono_add_left_of_ne_top (b : \u03b1) (h : b \u2260 \u22a4) : StrictMono (fun x \u21a6 x + b) := by\n  apply Monotone.strictMono_of_injective\n  \u00b7 apply Monotone.add_const monotone_id\n  \u00b7 apply injective_add_left_of_ne_top _ h\n\nlemma strictMono_add_right_of_ne_top (b : \u03b1) (h : b \u2260 \u22a4) : StrictMono (fun x \u21a6 b + x) := by\n  simpa [add_comm] using strictMono_add_left_of_ne_top b h\n\nlemma sub_pos (a b : \u03b1) : 0 < a - b \u2194 b < a \u2228 b = \u22a4 where\n  mp h := or_iff_not_imp_right.mpr fun hb \u21a6 by\n    simpa [sub_eq_add_neg, add_assoc, hb] using strictMono_add_left_of_ne_top _ hb h\n  mpr := by\n    rintro (h | rfl)\n    \u00b7 simpa [sub_eq_add_neg, h.ne_top]\n        using strictMono_add_left_of_ne_top (-b) (by simp [h.ne_top]) h\n    \u00b7 simp",
      "suggestion": "\r\n@[simp]\r\nlemma add_le_add_iff_left_of_ne_top {a b c : \u03b1} (h : a \u2260 \u22a4) : b + a \u2264 c + a \u2194 b \u2264 c :=\r\n  (add_left_strictMono_of_ne_top _ h).le_iff_le\r\n\r\n@[simp]\r\nlemma add_le_add_iff_right_of_ne_top {a b c : \u03b1} (h : a \u2260 \u22a4) : a + b \u2264 a + c \u2194 b \u2264 c :=\r\n  (add_right_strictMono_of_ne_top _ h).le_iff_le\r\n\r\n@[simp]\r\nlemma add_lt_add_iff_left_of_ne_top {a b c : \u03b1} (h : a \u2260 \u22a4) : b + a < c + a \u2194 b < c :=\r\n  (add_left_strictMono_of_ne_top _ h).lt_iff_lt\r\n\r\n@[simp]\r\nlemma add_lt_add_iff_right_of_ne_top {a b c : \u03b1} (h : a \u2260 \u22a4) : a + b < a + c \u2194 b < c :=\r\n  (add_right_strictMono_of_ne_top _ h).lt_iff_lt\r\n",
      "body": "```suggestion\r\n@[simp]\r\nlemma add_le_add_iff_left_of_ne_top {a b c : \u03b1} (h : a \u2260 \u22a4) : b + a \u2264 c + a \u2194 b \u2264 c :=\r\n  (add_left_strictMono_of_ne_top _ h).le_iff_le\r\n\r\n@[simp]\r\nlemma add_le_add_iff_right_of_ne_top {a b c : \u03b1} (h : a \u2260 \u22a4) : a + b \u2264 a + c \u2194 b \u2264 c :=\r\n  (add_right_strictMono_of_ne_top _ h).le_iff_le\r\n\r\n@[simp]\r\nlemma add_lt_add_iff_left_of_ne_top {a b c : \u03b1} (h : a \u2260 \u22a4) : b + a < c + a \u2194 b < c :=\r\n  (add_left_strictMono_of_ne_top _ h).lt_iff_lt\r\n\r\n@[simp]\r\nlemma add_lt_add_iff_right_of_",
      "path": "Mathlib/Algebra/Order/AddGroupWithTop.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "simp",
          "congr"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "congr"
        ],
        "topics": [
          "list",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "lemma",
          "add_comm",
          "rintro",
          "injective_add_left_of_ne_top",
          "Function",
          "strictMono_add_left_of_ne_top",
          "apply",
          "ne_top",
          "have",
          "neg_add_cancel_of_ne_top",
          "injective_add_right_of_ne_top",
          "hxy",
          "strictMono_add_right_of_ne_top",
          "simp",
          "add_const",
          "left_neg_eq_right_neg",
          "rfl",
          "congr",
          "or_iff_not_imp_right",
          "sub_eq_add_neg",
          "Injective",
          "StrictMono",
          "exact",
          "add_assoc",
          "monotone_id",
          "Monotone",
          "sub_pos",
          "simpa",
          "strictMono_of_injective",
          "using"
        ]
      }
    },
    {
      "id": 2107,
      "before_code": "theorem isNoetherianRing_iff_ideal_fg (R : Type*) [Semiring R] :\n    IsNoetherianRing R \u2194 \u2200 I : Ideal R, I.FG :=\n  isNoetherianRing_iff.trans isNoetherian_def",
      "suggestion": "lemma Ideal.FG_of_isNoetherianRing {R : Type*} [Semiring R] [IsNoetherianRing R] (I : Ideal R) :\n",
      "body": "```suggestion\nlemma Ideal.FG_of_isNoetherianRing {R : Type*} [Semiring R] [IsNoetherianRing R] (I : Ideal R) :\n```",
      "path": "Mathlib/RingTheory/Noetherian/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Ideal",
          "theorem",
          "isNoetherianRing_iff_ideal_fg",
          "Type",
          "Semiring",
          "isNoetherian_def",
          "trans",
          "isNoetherianRing_iff",
          "IsNoetherianRing"
        ]
      }
    },
    {
      "id": 2117,
      "before_code": "/-- If `S` is a multiplicative subset of a ring `R` and `M` an `R`-module, then\nwe can localize `M` by `S`.\n-/\ndef _root_.LocalizedModule : Type max u v :=\n  Quotient (r.setoid S M)\n\nsection\n\nvariable {M S}\n\n/-- The canonical map sending `(m, s) \u21a6 m/s` -/\ndef mk (m : M) (s : S) : LocalizedModule S M :=\n  Quotient.mk' \u27e8m, s\u27e9\n\ntheorem mk_eq {m m' : M} {s s' : S} : mk m s = mk m' s' \u2194 \u2203 u : S, u \u2022 s' \u2022 m = u \u2022 s \u2022 m' :=\n  Quotient.eq'",
      "suggestion": "  exact congr($(oreEqv_iff_r S M) \u27e8m, s\u27e9 \u27e8m', s'\u27e9)\n",
      "body": "```suggestion\n  exact congr($(oreEqv_iff_r S M) \u27e8m, s\u27e9 \u27e8m', s'\u27e9)\n```\nmaybe?",
      "path": "Mathlib/Algebra/Module/LocalizedModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "congr"
        ],
        "body_tactics": [
          "exact",
          "congr"
        ],
        "new_tactics": [
          "exact",
          "congr"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "multiplicative",
          "mk_eq",
          "Type",
          "section",
          "Quotient",
          "_root_",
          "map",
          "max",
          "can",
          "then",
          "def",
          "LocalizedModule",
          "variable",
          "module",
          "sending",
          "ring",
          "setoid",
          "subset",
          "theorem",
          "localize",
          "canonical"
        ]
      }
    },
    {
      "id": 2120,
      "before_code": "-/\ndef liftOn\u2082 {\u03b1 : Type*} (x y : LocalizedModule S M) (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') : \u03b1 :=\n  Quotient.liftOn\u2082 x y f wd\n\ntheorem liftOn\u2082_mk {\u03b1 : Type*} (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') (m m' : M)\n    (s s' : S) : liftOn\u2082 (mk m s) (mk m' s') f wd = f \u27e8m, s\u27e9 \u27e8m', s'\u27e9 := by\n  convert Quotient.liftOn\u2082_mk f wd _ _\n\ninstance : Zero (LocalizedModule S M) :=\n  \u27e8mk 0 1\u27e9\n\n/-- If `S` contains `0` then the localization at `S` is trivial. -/\ntheorem subsingleton (h : 0 \u2208 S) : Subsingleton (LocalizedModule S M) := by\n  refine \u27e8fun a b \u21a6 ?_\u27e9\n  induction a,b using LocalizedModule.induction_on\u2082\n  exact mk_eq.mpr \u27e8\u27e80, h\u27e9, by simp only [Submonoid.mk_smul, zero_smul]\u27e9\n\n@[simp]\ntheorem zero_mk (s : S) : mk (0 : M) s = 0 :=\n  mk_eq.mpr \u27e81, by rw [one_smul, smul_zero, smul_zero, one_smul]\u27e9\n\ninstance : Add (LocalizedModule S M) where\n  add p1 p2 :=\n    liftOn\u2082 p1 p2 (fun x y => mk (y.2 \u2022 x.1 + x.2 \u2022 y.1) (x.2 * y.2)) <|\n      fun \u27e8m1, s1\u27e9 \u27e8m2, s2\u27e9 \u27e8m1', s1'\u27e9 \u27e8m2', s2'\u27e9 \u27e8u1, hu1\u27e9 \u27e8u2, hu2\u27e9 =>\n          mk_eq.mpr\n            \u27e8u1 * u2, by\n              -- Put everything in the same shape, sorting the terms using `simp`\n              have hu1' := congr_arg ((u2 * s2 * s2') \u2022 \u00b7) hu1\n              have hu2' := congr_arg ((u1 * s1 * s1') \u2022 \u00b7) hu2\n              simp only [smul_add, \u2190 mul_smul, mul_comm,\n                mul_left_comm] at hu1' hu2' \u22a2\n              rw [hu1', hu2']\u27e9\n\ntheorem mk_add_mk {m1 m2 : M} {s1 s2 : S} :\n    mk m1 s1 + mk m2 s2 = mk (s2 \u2022 m1 + s1 \u2022 m2) (s1 * s2) :=\n  mk_eq.mpr <| \u27e81, rfl\u27e9\n\nprivate theorem add_assoc' (x y z : LocalizedModule S M) : x + y + z = x + (y + z) := by\n  induction x with | _ mx sx\n  induction y with | _ my sy\n  induction z with | _ mz sz\n  simp only [mk_add_mk, smul_add]\n  refine mk_eq.mpr \u27e81, ?_\u27e9\n  rw [one_smul, one_smul]\n  congr 1\n  \u00b7 rw [mul_assoc]\n  \u00b7 rw [eq_comm, mul_comm, add_assoc, mul_smul, mul_smul, \u2190 mul_smul sx sz, mul_comm,",
      "suggestion": "instance (priority := 900) {A : Type*} [Semiring A] [Algebra R A] {S : Submonoid R} :\n    Monoid (LocalizedModule S A) :=\n  fast_instance%\n  { __ := inferInstanceAs (One (LocalizedModule S A))\n    mul := LocalizedModule.mul\n    one_mul := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [one_mul, mul_one, one_smul]\u27e9\n    mul_one := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [mul_one, one_smul, one_mul]\u27e9\n    mul_assoc := by with_unfolding_all\n      rintro \u27e8a\u2081, s\u2081\u27e9 \u27e8a\u2082, s\u2082\u27e9 \u27e8a\u2083, s\u2083\u27e9\n      apply mk_eq.mpr _\n      use 1\n      simp only [one_mul, smul_smul, \u2190 mul_assoc, mul_right_comm] }\n",
      "body": "```suggestion\ninstance (priority := 900) {A : Type*} [Semiring A] [Algebra R A] {S : Submonoid R} :\n    Monoid (LocalizedModule S A) :=\n  fast_instance%\n  { __ := inferInstanceAs (One (LocalizedModule S A))\n    mul := LocalizedModule.mul\n    one_mul := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [one_mul, mul_one, one_smul]\u27e9\n    mul_one := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [mul_one, one_smul, one_mul]\u27e9\n    mul_as",
      "path": "Mathlib/Algebra/Module/LocalizedModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "simpa",
          "rw",
          "simp",
          "induction",
          "congr",
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "induction",
          "congr",
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Module",
          "mpr",
          "Monoid",
          "neg",
          "zero_add",
          "hasNatSMul",
          "Type",
          "succ",
          "mul_smul_comm",
          "terms",
          "mul",
          "add",
          "eq_comm",
          "mul_right_comm",
          "Neg",
          "Quotient",
          "private",
          "liftOn",
          "zero_mk",
          "neg_add_cancel",
          "hu1",
          "have",
          "smul_smul",
          "hu2",
          "CommSemiring",
          "fix",
          "CommRing",
          "trivial",
          "def",
          "mul_comm",
          "mul_one",
          "simp",
          "rfl",
          "Add",
          "theorem",
          "add_assoc",
          "trans",
          "localization",
          "smul_smul_smul_comm",
          "SMul",
          "mul_smul",
          "sorting",
          "Zero",
          "smul",
          "show",
          "mk_eq",
          "induction_on",
          "TODO",
          "mk_add_mk",
          "apply"
        ]
      }
    },
    {
      "id": 2131,
      "before_code": "LinearMap.coe_mk, AddHom.coe_mk, algebraMap_matrix_apply]\n    split_ifs <;> rfl",
      "suggestion": "\r\n/-- `Module.End.injective_of_surjective` is the more general version for finite free `A`-modules\r\nnot necessarily of the form `Fin n \u2192 A`, but this version requires less imports. -/\r\ntheorem Module.End.injective_of_surjective_fin [IsStablyFiniteRing A] {n}\r\n",
      "body": "```suggestion\r\n/-- `Module.End.injective_of_surjective` is the more general version for finite free `A`-modules\r\nnot necessarily of the form `Fin n \u2192 A`, but this version requires less imports. -/\r\ntheorem Module.End.injective_of_surjective_fin [IsStablyFiniteRing A] {n}\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "LinearMap",
          "AddHom",
          "coe_mk",
          "rfl",
          "algebraMap_matrix_apply",
          "split_ifs"
        ]
      }
    },
    {
      "id": 2133,
      "before_code": "rw [ShortComplex.ab_exact_iff] at this\n  exact this x\u2083 hx\u2083",
      "suggestion": "  rw [\u2190 AddMonoidHom.ker_eq_bot_iff, AddSubgroup.eq_bot_iff_forall]\n  intro x hx\n  obtain \u27e8f, rfl\u27e9 := Ext.addEquiv\u2080.symm.surjective x\n  simpa [\u2190 cancel_epi g] using hx\n",
      "body": "```suggestion\n  rw [\u2190 AddMonoidHom.ker_eq_bot_iff, AddSubgroup.eq_bot_iff_forall]\n  intro x hx\n  obtain \u27e8f, rfl\u27e9 := Ext.addEquiv\u2080.symm.surjective x\n  simpa [\u2190 cancel_epi g] using hx\n```",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "ext",
          "simpa",
          "obtain",
          "rw",
          "intro"
        ],
        "body_tactics": [
          "ext",
          "simpa",
          "obtain",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "intro",
          "ext"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "ShortComplex",
          "exact",
          "this",
          "ab_exact_iff"
        ]
      }
    },
    {
      "id": 2141,
      "before_code": "simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_iff_left_iff_imp]\n  exact fun hz \u21a6 UpperHalfPlane.coe_mem_integerComplement \u27e8z, hz\u27e9",
      "suggestion": "\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n",
      "body": "If you put this in `UpperHalfPlane` then you can dot-notate. Also `n` can be implicit since you have `hm`. \r\n```suggestion\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n```",
      "path": "Mathlib/Analysis/Complex/IntegerCompl.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mem_setOf_eq",
          "exact",
          "Set",
          "mem_inter_iff",
          "UpperHalfPlane",
          "coe_mem_integerComplement",
          "simp",
          "and_iff_left_iff_imp",
          "only"
        ]
      }
    },
    {
      "id": 2142,
      "before_code": "@[simp, norm_cast]\nlemma coe_I : I = Complex.I := rfl",
      "suggestion": "\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffices 0 < n * z.im / Complex.normSq z by simpa [Complex.div_im, neg_div]\r\n  positivity [NeZero.ne n, z.normSq_pos]\r\n",
      "body": "This is in the `UpperHalfPlane` namespace so you don't really need `UpperHalfPlane` in the statment. My instinct would be to formulate using `Nat` with a `[NeZero]` typeclass assumption, rather than `PNat`, but I haven't checked how that plays together with the usage of this lemma later. \r\n\r\nIf you move this to a few lines later in the file (maybe after `ne_int`) then you can do the following:\r\n```suggestion\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffi",
      "path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa",
          "positivity"
        ],
        "body_tactics": [
          "simpa",
          "positivity"
        ],
        "new_tactics": [
          "simpa",
          "positivity"
        ],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "complex",
          "norm"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "coe_I",
          "lemma",
          "Complex",
          "simp",
          "rfl",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2143,
      "before_code": "exact Real.rpow_le_rpow_of_nonpos (r_pos _) (r_lower_bound_on_verticalStrip z hB hz)\n    (neg_nonpos.mpr hk)\n\nlemma linear_isTheta_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\n  refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real)\n  rw [isLittleO_const_left]\n  exact Or.inr\n    (tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real)",
      "suggestion": "\r\nlemma linear_isTheta_right_add (c e : \u2124) (z : \u2102) :\r\n    (fun d : \u2124 \u21a6 c * z + d + e) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\r\n  apply IsTheta.add_isLittleO <;>\r\n  [refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real); skip] <;>\r\n  simpa [-Int.cofinite_eq] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real\r\n",
      "body": "optional golf (might be a bit convoluted):\r\n```suggestion\r\nlemma linear_isTheta_right_add (c e : \u2124) (z : \u2102) :\r\n    (fun d : \u2124 \u21a6 c * z + d + e) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\r\n  apply IsTheta.add_isLittleO <;>\r\n  [refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real); skip] <;>\r\n  simpa [-Int.cofinite_eq] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real\r\n```\r\n(This makes me wonder if `Int.cofinite_eq` should not",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "apply"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "lemma",
          "neg_nonpos",
          "cofinite",
          "isLittleO_const_left",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "refine",
          "rpow_le_rpow_of_nonpos",
          "isClosedEmbedding_coe_real",
          "add_isTheta",
          "linear_isTheta_right",
          "Int",
          "IsLittleO",
          "Real",
          "r_pos",
          "r_lower_bound_on_verticalStrip",
          "Asymptotics",
          "exact",
          "cast_complex_isTheta_cast_real",
          "inr"
        ]
      }
    },
    {
      "id": 2144,
      "before_code": "\u00b7 simp only [isLittleO_const_left, Int.cast_eq_zero,\n      tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real, or_true]\n\nlemma linear_inv_isBigO_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_right c z).inv.isBigO\n\nlemma linear_inv_isBigO_left (d : \u2124) {z : \u2102} (hz : z \u2260 0) :\n    (fun (c : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_left d hz).inv.isBigO",
      "suggestion": "\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n",
      "body": "`Asymptotics` is already open, and `simpa` uses `this` by default:\r\n```suggestion\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigO",
          "cast_eq_zero",
          "lemma",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "linear_isTheta_right",
          "Int",
          "linear_inv_isBigO_left",
          "or_true",
          "inv",
          "linear_isTheta_left",
          "simp",
          "cofinite",
          "isClosedEmbedding_coe_real",
          "isLittleO_const_left",
          "only",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2146,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]",
      "suggestion": "\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul\r\n      (linear_inv_isBigO_right_add c\u2081 0 z).comp_neg_int\r\n",
      "body": "```suggestion\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul\r\n      (linear_inv_isBigO_right_add c\u2081 0 z).comp_neg_int\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "pow_two",
          "Real",
          "abs_mul_abs_self",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "only",
          "rpow_two",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2147,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul \r\n    (linear_inv_isBigO_right_add c\u2081 1 z)\r\n",
      "body": "```suggestion\r\n  simpa [pow_two] using (linear_inv_isBigO_right_add c\u2082 0 z).mul \r\n    (linear_inv_isBigO_right_add c\u2081 1 z)\r\n```\r\n(It's a pity we don't have an automatic way to \"anti-squeeze\" a simp, i.e. remove explicitly-listed lemmas where they aren't needed.) Ditto in the next lemma.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2148,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _)]\r\n  aesop\r\n",
      "body": "I'm not a fan of `simp only [massive list of stuff] at *`, it seems a bit of a \"scattergun\" approach. Here's a shorter and cleaner version:\r\n```suggestion\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "aesop",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp",
          "use_aesop"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2149,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n",
      "body": "```suggestion\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n```\r\nThe statement can be made far more general, you could do e.g.\r\n```\r\nlemma isLittleO_const_left_of_properSpace_of_discreteTopology\r\n    {\u03b1 : Type*} (a : \u03b1) [NormedAddCommGroup \u03b1] [DiscreteTopology \u03b1]\r\n    [ProperSpace \u03b1] : (fun _ : \u03b1 \u21a6 a) =",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2150,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n",
      "body": "```suggestion\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2151,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n/-- If a function `\u2124\u00b2 \u2192 \u2102` is `O (\u2016n\u2016 ^ a)\u207b\u00b9` for `2 < a`, then the function is summable. -/\r\nlemma summable_of_isBigO_rpow_norm {E : Type*} [NormedAddCommGroup E] [CompleteSpace E]\r\n    {f : (Fin 2 \u2192 \u2124) \u2192 E} {a : \u211d} (hab : 2 < a)\r\n    (hf : f =O[cofinite] fun n \u21a6 (\u2016n\u2016 ^ a)\u207b\u00b9) : Summable f :=\r\n",
      "body": "The inverse isn't doing anything here, is it? And it works for more general coefficients. The exact same proof proves the following statement:\r\n```suggestion\r\n/-- If a function `\u2124\u00b2 \u2192 \u2102` is `O (\u2016n\u2016 ^ a)\u207b\u00b9` for `2 < a`, then the function is summable. -/\r\nlemma summable_of_isBigO_rpow_norm {E : Type*} [NormedAddCommGroup E] [CompleteSpace E]\r\n    {f : (Fin 2 \u2192 \u2124) \u2192 E} {a : \u211d} (hab : 2 < a)\r\n    (hf : f =O[cofinite] fun n \u21a6 (\u2016n\u2016 ^ a)\u207b\u00b9) : Summable f :=\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 2152,
      "before_code": "rw [modular_T_zpow_smul z (N * n)]\n  simpa only [Int.cast_mul, Int.cast_natCast] using vAdd_width_periodic N k n f z",
      "suggestion": "\r\n    (f \u2223[k] ModularGroup.S) z = f (.mk _ z.im_inv_neg_coe_pos) * z ^ (-k) := by\r\n  rw [SL_slash_apply, modular_S_smul]\r\n  simp [ModularGroup.S, denom]\r\n",
      "body": "```suggestion\r\n    (f \u2223[k] ModularGroup.S) z = f (.mk _ z.im_inv_neg_coe_pos) * z ^ (-k) := by\r\n  rw [SL_slash_apply, modular_S_smul]\r\n  simp [ModularGroup.S, denom]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/Identities.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "modular_T_zpow_smul",
          "Int",
          "simpa",
          "cast_natCast",
          "cast_mul",
          "vAdd_width_periodic",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 2153,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "simpa",
          "exact"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 2155,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  have := tendsto_tsum_of_dominated_convergence (\ud835\udcd5 := atTop) (g := fun _ \u21a6 0)\r\n    (f := fun d n : \u2115+ \u21a6 r ^ (n * d : \u2115)) (bound := fun n \u21a6 (\u2016r ^ (n : \u2115)\u2016))\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  have := tendsto_tsum_of_dominated_convergence (\ud835\udcd5 := atTop) (g := fun _ \u21a6 0)\r\n    (f := fun d n : \u2115+ \u21a6 r ^ (n * d : \u2115)) (bound := fun n \u21a6 (\u2016r ^ (n : \u2115)\u2016))\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 2156,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n```\r\n(It's a pity that none of the auto-tactics seem to work on the last line.)",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 2157,
      "before_code": "@[deprecated (since := \"2025-09-31\")]\nalias pnat_multipliable_iff_multipliable_succ := multipliable_pnat_iff_multipliable_succ",
      "suggestion": "\r\n  rw [multipliable_pnat_iff_multipliable_succ, multipliable_nat_add_iff]\r\n",
      "body": "```suggestion\r\n  rw [multipliable_pnat_iff_multipliable_succ, multipliable_nat_add_iff]\r\n```\r\nWe should have a text-level linter against \"[space]+[comma]\".",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "alias",
          "pnat_multipliable_iff_multipliable_succ",
          "since",
          "multipliable_pnat_iff_multipliable_succ",
          "deprecated"
        ]
      }
    },
    {
      "id": 2158,
      "before_code": "f 0 * \u220f' n : \u2115+, f \u2191n = \u220f' n, f n := by\n  simpa [hf.tprod_eq_zero_mul] using tprod_pnat_eq_tprod_succ\n\n@[to_additive tsum_int_eq_zero_add_two_mul_tsum_pnat]\ntheorem tprod_int_eq_zero_mul_tprod_pnat_sq [UniformSpace G] [IsUniformGroup G] [CompleteSpace G]\n    [T2Space G] {f : \u2124 \u2192 G} (hf : \u2200 n : \u2124, f (-n) = f n) (hf2 : Multipliable f) :\n    \u220f' n, f n = f 0 * (\u220f' n : \u2115+, f n) ^ 2 := by\n  have hf3 : Multipliable fun n : \u2115 \u21a6 f n :=\n    (multipliable_int_iff_multipliable_nat_and_neg.mp hf2).1\n  have hf4 : Multipliable fun n : \u2115+ \u21a6 f n := by\n    rwa [multipliable_pnat_iff_multipliable_succ (f := (f \u00b7)),\n      multipliable_nat_add_iff 1 (f := (f \u00b7))]\n  have := tprod_nat_mul_neg hf2\n  rw [\u2190 tprod_zero_pnat_eq_tprod_nat (by simpa [hf] using hf3.mul hf3), mul_comm _ (f 0)] at this\n  simp only [hf, Nat.cast_zero, mul_assoc, mul_right_inj] at this\n  rw [\u2190 this, mul_right_inj, hf4.tprod_mul hf4, sq]",
      "suggestion": "\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n",
      "body": "Indentation is off here. But the proof can also be hugely shortened:\r\n```suggestion\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n```\r\nYou could also use `Function.Even` as the hypothesis, at the cost of an extra import; note that if you do `(hf : Function.Even f)` then you need `hf _` in the simp call, not just `hf`.",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "topics": [
          "int",
          "finset",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "CompleteSpace",
          "rwa",
          "Multipliable",
          "multipliable_nat_add_iff",
          "tsum_int_eq_zero_add_two_mul_tsum_pnat",
          "mul",
          "to_additive",
          "IsUniformGroup",
          "multipliable_int_iff_multipliable_nat_and_neg",
          "hf4",
          "Nat",
          "cast_zero",
          "have",
          "tprod_zero_pnat_eq_tprod_nat",
          "hf3",
          "mul_right_inj",
          "multipliable_pnat_iff_multipliable_succ",
          "tprod_pnat_eq_tprod_succ",
          "T2Space",
          "mul_comm",
          "simp",
          "tprod_eq_zero_mul",
          "only",
          "mul_assoc",
          "theorem",
          "UniformSpace",
          "hf2",
          "tprod_nat_mul_neg",
          "tprod_mul",
          "this",
          "simpa",
          "tprod_int_eq_zero_mul_tprod_pnat_sq",
          "using"
        ]
      }
    },
    {
      "id": 2163,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  \u00b7 have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -(y * log y ^ 2)\u207b\u00b9 := by\n",
      "body": "```suggestion\n  \u00b7 have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -(y * log y ^ 2)\u207b\u00b9 := by\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2166,
      "before_code": "convert sum_mul_eq_sub_integral_mul\u2080 c hc m hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]",
      "suggestion": "    have H\u2081 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, c n = 0 := by grind [(Nat.floor_lt' two_ne_zero).mpr hb]\n    have H\u2082 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, f n * c n = 0 := by grind\n    simp [sum_eq_zero H\u2081, sum_eq_zero H\u2082, Set.Ioc_eq_empty_of_le hb.le]\n  --Split off the first two terms of the sum\n  have : 2 \u2264 \u230ab\u230b\u208a := Nat.le_floor hb\n  have H : \u2211 k \u2208 Icc 0 \u230ab\u230b\u208a, f \u2191k * c k = f (2 :) * c 2 + \u2211 k \u2208 Ioc 2 \u230ab\u230b\u208a, f \u2191k * c k := by\n    rw [add_sum_Ioc_eq_sum_Icc (f := fun (k : \u2115) \u21a6 f k * c k) this,\n      show Icc 0 \u230ab\u230b\u208a = {0, 1} \u222a Icc 2 \u230ab\u230b\u208a by grind]\n    exact sum_union_eq_right fun k hk hk' \u21a6 by grind\n  rw [H]\n  --Apply Abel summation to the remainder\n  nth_rewrite 3 [show 2 = \u230a(2 : \u211d)\u230b\u208a by simp]\n  rw [sum_mul_eq_sub_sub_integral_mul c zero_le_two hb hf_diff hf_int]\n  simp [show Icc 0 2 = {0, 1, 2} by rfl, hc, hc1]\n  grind\n",
      "body": "```suggestion\n    have H\u2081 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, c n = 0 := by grind [(Nat.floor_lt' two_ne_zero).mpr hb]\n    have H\u2082 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, f n * c n = 0 := by grind\n    simp [sum_eq_zero H\u2081, sum_eq_zero H\u2082, Set.Ioc_eq_empty_of_le hb.le]\n  --Split off the first two terms of the sum\n  have : 2 \u2264 \u230ab\u230b\u208a := Nat.le_floor hb\n  have H : \u2211 k \u2208 Icc 0 \u230ab\u230b\u208a, f \u2191k * c k = f (2 :) * c 2 + \u2211 k \u2208 Ioc 2 \u230ab\u230b\u208a, f \u2191k * c k := by\n    rw [add_sum_Ioc_eq_sum_Icc (f := fun (k : \u2115) \u21a6 f k * c k) this,\n      show Icc 0 \u230ab\u230b\u208a = ",
      "path": "Mathlib/NumberTheory/AbelSummation.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "all_goals",
          "convert",
          "Nat",
          "floor_natCast",
          "hf_int",
          "hf_diff"
        ]
      }
    },
    {
      "id": 2167,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have : x * log x ^ 2 \u2260 0 := mul_ne_zero this <| by simp; grind\n",
      "body": "```suggestion\n  have : x * log x ^ 2 \u2260 0 := mul_ne_zero this <| by simp; grind\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "have",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "have",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2168,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  -- Rewrite in a form to which Abel summation can be applied\n",
      "body": "```suggestion\n  -- Rewrite in a form to which Abel summation can be applied\n```\netc.",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2169,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  \u00b7 refine sum_congr rfl fun n hn \u21a6 ?_\n    split_ifs with h\n    \u00b7 have : log n \u2260 0 := log_ne_zero_of_pos_of_ne_one (mod_cast h.pos) (mod_cast h.ne_one)\n      simp [a, h, field]\n    \u00b7 simp [a, h]\n",
      "body": "```suggestion\n  \u00b7 refine sum_congr rfl fun n hn \u21a6 ?_\n    split_ifs with h\n    \u00b7 have : log n \u2260 0 := log_ne_zero_of_pos_of_ne_one (mod_cast h.pos) (mod_cast h.ne_one)\n      simp [a, h, field]\n    \u00b7 simp [a, h]\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "new_tactics": [
          "have",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2170,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "      replace hu : 2 \u2264 u := ((Set.uIcc_of_le hx) \u25b8 hu).1\n      simp [deriv_log_inv (by linarith) (by linarith) (by linarith), field]\n",
      "body": "```suggestion\n      replace hu : 2 \u2264 u := ((Set.uIcc_of_le hx) \u25b8 hu).1\n      simp [deriv_log_inv (by linarith) (by linarith) (by linarith), field]\n```\nNote that this is one of the places where `deric_log_inv` without side conditions would simplify things.",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "linarith"
        ],
        "body_tactics": [
          "simp",
          "linarith"
        ],
        "new_tactics": [
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2172,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
      "body": "```suggestion\n    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "exact",
          "have",
          "fun_prop",
          "linarith",
          "congr"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "have",
          "fun_prop",
          "linarith",
          "congr"
        ],
        "new_tactics": [
          "refine",
          "exact",
          "congr",
          "have",
          "linarith",
          "fun_prop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_linarith",
          "use_fun_prop"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2173,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  calc\n  _ \u2264 \u222b x in a..b, 1 / log a ^ 2 := by\n      refine intervalIntegral.integral_mono_on hab ?_ (by simp) fun x \u27e8hx, _\u27e9 \u21a6 by gcongr <;> bound\n      apply intervalIntegrable_one_div_log_sq <;> linarith\n  _ \u2264 _ := by simp [field]\n",
      "body": "```suggestion\n  calc\n  _ \u2264 \u222b x in a..b, 1 / log a ^ 2 := by\n      refine intervalIntegral.integral_mono_on hab ?_ (by simp) fun x \u27e8hx, _\u27e9 \u21a6 by gcongr <;> bound\n      apply intervalIntegrable_one_div_log_sq <;> linarith\n  _ \u2264 _ := by simp [field]\n```\n* `calc` proofs are usually easier to read than proofs using `trans`\n* `refine` allows to fold `intro` (or `use`, ...)",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "simp",
          "linarith"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "simp",
          "intro",
          "linarith"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2174,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have two_le_sqrt : 2 \u2264 x.sqrt := Real.le_sqrt_of_sq_le <| by norm_num [hx]\n",
      "body": "```suggestion\n  have two_le_sqrt : 2 \u2264 x.sqrt := Real.le_sqrt_of_sq_le <| by norm_num [hx]\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "norm_num",
          "have"
        ],
        "body_tactics": [
          "norm_num",
          "have"
        ],
        "new_tactics": [
          "norm_num",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2175,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have sqrt_le_x : x.sqrt \u2264 x := sqrt_le_left (by linarith) |>.mpr (by bound)\n",
      "body": "```suggestion\n  have sqrt_le_x : x.sqrt \u2264 x := sqrt_le_left (by linarith) |>.mpr (by bound)\n```\n(Same proofs, only a bit more condensed.)",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have",
          "linarith"
        ],
        "body_tactics": [
          "have",
          "linarith"
        ],
        "new_tactics": [
          "have",
          "linarith"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 2178,
      "before_code": "\u220f' i, (1 + f i) = \u2211' s, \u220f i \u2208 s, f i :=\n  HasProd.tprod_eq <| hasProd_one_add_of_hasSum_prod h.hasSum",
      "suggestion": "  exact tprod_one_add_ordered hsum' hprod\n",
      "body": "```suggestion\n  exact tprod_one_add_ordered hsum' hprod\n```",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/Ring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "HasProd",
          "tprod_eq",
          "hasProd_one_add_of_hasSum_prod",
          "hasSum"
        ]
      }
    },
    {
      "id": 2180,
      "before_code": "rw [\u2190 h\u03c3]\n      convert le_ciSup (Finite.bddAbove_range _) \u03c3",
      "suggestion": "\r\n      apply le_ciSup (Finite.bddAbove_range _) \u03c3\r\n",
      "body": "```suggestion\r\n      apply le_ciSup (Finite.bddAbove_range _) \u03c3\r\n```\r\nIf you're already golfing this random proof, may as well to it properly. This `apply` closes the goal (and `exact` doesn't, somehow because of elaboration order)",
      "path": "Mathlib/Analysis/Normed/Unbundled/SpectralNorm.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "exact",
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finite",
          "le_ciSup",
          "bddAbove_range",
          "convert"
        ]
      }
    },
    {
      "id": 2187,
      "before_code": "end Colex",
      "suggestion": "\r\ntheorem apply_le_of_toColex (hxy : toColex x \u2264 toColex y) (h : \u2200 j > i, x j = y j) :\r\n",
      "body": "```suggestion\r\ntheorem apply_le_of_toColex (hxy : toColex x \u2264 toColex y) (h : \u2200 j > i, x j = y j) :\r\n```\r\nmaybe?",
      "path": "Mathlib/Order/PiLex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Colex",
          "end"
        ]
      }
    },
    {
      "id": 2189,
      "before_code": "hW := .sup D\u2081.hW D\u2082.hW (Cardinal.IsRegular.aleph0_le Fact.out)\n  hP := .sup D\u2081.hP D\u2082.hP (Cardinal.IsRegular.aleph0_le Fact.out)",
      "suggestion": "@[simps!]\ndef D\u2080 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) :\n    Diagram J \u03ba :=\n  Diagram.iSup (fun i \u21a6 (D i).toDiagram) h\u03b9\n\n@[simps!]\ndef D\u2081 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) (m : J) :\n    Diagram J \u03ba :=\n  (D\u2080 J \u03ba D h\u03b9).sup (.single m)\n\n@[simps!]\ndef D\u2082 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba)\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) (m : J) (u : (i : \u03b9) \u2192 (D i).top \u27f6 m) :\n    Diagram J \u03ba where\n  W := (D\u2081 J \u03ba D h\u03b9 m).W \u2294 MorphismProperty.ofHoms\n    fun (x : (\u03a3 (i : \u03b9), (Subtype (D i).P))) \u21a6 (D x.1).isTerminal.lift x.2.2 \u226b u x.1\n  P := (D\u2081 J \u03ba D h\u03b9 m).P\n  src := by\n    simp only [D\u2081_W, D\u2081_P]\n    rintro _ _ _ ((hf | \u27e8\u27e8\u27e9\u27e9) | \u27e8i, j, hj\u27e9)\n    \u00b7 simp only [MorphismProperty.iSup_iff] at hf\n      obtain \u27e8i, hf\u27e9 := hf\n      exact Or.inl \u27e8i, (D i).src hf\u27e9\n    \u00b7 exact Or.inr rfl\n    \u00b7 exact Or.inl \u27e8i, hj\u27e9\n  tgt := by\n    simp only [D\u2081_W, D\u2081_P]\n    rintro _ _ _ ((hf | \u27e8\u27e8\u27e9\u27e9) | \u27e8i, j, hj\u27e9)\n   ",
      "body": "```suggestion\n@[simps!]\ndef D\u2080 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) :\n    Diagram J \u03ba :=\n  Diagram.iSup (fun i \u21a6 (D i).toDiagram) h\u03b9\n\n@[simps!]\ndef D\u2081 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) (m : J) :\n    Diagram J \u03ba :=\n  (D\u2080 J \u03ba D h\u03b9).sup (.single m)\n\n@[simps!]\ndef D\u2082 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba)\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) (m : J) (u : (i : \u03b9) \u2192 (D i).top \u27f6 m) :\n  ",
      "path": "Mathlib/CategoryTheory/Presentable/Directed.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "out",
          "aleph0_le",
          "Fact",
          "sup",
          "IsRegular",
          "Cardinal"
        ]
      }
    },
    {
      "id": 2207,
      "before_code": "end",
      "suggestion": "\r\ninstance (X : Truncated.{u} 2) [Unique (X _\u298b0\u298c\u2082)] : Unique X.HomotopyCategory := \r\n  letI : Unique (OneTruncation\u2082 X) := inferInstanceAs (Unique (X _\u298b0\u298c\u2082))\r\n  CategoryTheory.Quotient.instUnique _\r\n\r\n/-- If `X : Truncated 2` has a unique `0`-simplex and (at most) one `1`-simplex,\r\nthen `X.HomotopyCategory` is a terminal object in `Cat`. -/\r\ndef isTerminal (X : Truncated.{u} 2) [Unique (X _\u298b0\u298c\u2082)] [Subsingleton (X _\u298b1\u298c\u2082)] :\r\n    IsTerminal (Cat.of X.HomotopyCategory) :=\r\n  letI : IsDiscrete (X.HomotopyCategory) := { eq_of_hom := by subsingleton }\r\n  Cat.isTerminalOfUniqueOfIsDiscrete\r\n",
      "body": "Same here: we already have `Cat.isTerminalOfUniqueOfIsDiscrete`:\r\n```suggestion\r\ninstance (X : Truncated.{u} 2) [Unique (X _\u298b0\u298c\u2082)] : Unique X.HomotopyCategory := \r\n  letI : Unique (OneTruncation\u2082 X) := inferInstanceAs (Unique (X _\u298b0\u298c\u2082))\r\n  CategoryTheory.Quotient.instUnique _\r\n\r\n/-- If `X : Truncated 2` has a unique `0`-simplex and (at most) one `1`-simplex,\r\nthen `X.HomotopyCategory` is a terminal object in `Cat`. -/\r\ndef isTerminal (X : Truncated.{u} 2) [Unique (X _\u298b0\u298c\u2082)] [Subsingleton (X _\u298b1\u298c",
      "path": "Mathlib/AlgebraicTopology/SimplicialSet/HomotopyCat.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2210,
      "before_code": "(fun i j Z gi gj \u21a6 hx gi gj (ofArrows.mk _) (ofArrows.mk _))\n    exact \u27e8t, fun Y f \u27e8i\u27e9 \u21a6 hA i, fun y hy \u21a6 ht y (fun i \u21a6 hy (\u03c0 i) (ofArrows.mk _))\u27e9",
      "suggestion": "\r\n  property i j Z gi gj h := by\r\n    simp [\u2190 FunctorToTypes.map_comp_apply, \u2190 op_comp, h]\r\n",
      "body": "```suggestion\r\n  property i j Z gi gj h := by\r\n    simp [\u2190 FunctorToTypes.map_comp_apply, \u2190 op_comp, h]\r\n```",
      "path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "ofArrows"
        ]
      }
    },
    {
      "id": 2213,
      "before_code": "IsStableUnderBaseChange @FinitePresentation := by\n  apply IsStableUnderBaseChange.mk\n  \u00b7 exact finitePresentation_respectsIso\n  \u00b7 introv h\n    rw [finitePresentation_algebraMap] at h\n    suffices Algebra.FinitePresentation S (S \u2297[R] T) by\n      rw [RingHom.FinitePresentation]; convert this; ext; simp_rw [Algebra.smul_def]; rfl\n    infer_instance",
      "suggestion": "\r\n    exact fun _ S _ _ _ _ _ _ _ \u21a6 Algebra.FinitePresentation.baseChange S\r\n",
      "body": "```suggestion\r\n    exact fun _ S _ _ _ _ _ _ _ \u21a6 Algebra.FinitePresentation.baseChange S\r\n```",
      "path": "Mathlib/RingTheory/RingHom/FinitePresentation.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "rw",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "introv",
          "apply",
          "finitePresentation_respectsIso",
          "convert",
          "ext",
          "infer_instance",
          "exact",
          "smul_def",
          "IsStableUnderBaseChange",
          "suffices",
          "this",
          "finitePresentation_algebraMap",
          "RingHom",
          "FinitePresentation",
          "simp_rw",
          "Algebra",
          "rfl"
        ]
      }
    },
    {
      "id": 2214,
      "before_code": "theorem finite_isStableUnderBaseChange : IsStableUnderBaseChange @Finite := by\n  refine IsStableUnderBaseChange.mk finite_respectsIso ?_\n  classical\n  introv h\n  replace h : Module.Finite R T := by\n    rw [RingHom.Finite] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl\n  suffices Module.Finite S (S \u2297[R] T) by\n    rw [RingHom.Finite]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl\n  exact inferInstance",
      "suggestion": "\r\n  exact fun R S T _ _ _ _ _ _ \u21a6 Module.Finite.base_change R S T\r\n",
      "body": "```suggestion\r\n  exact fun R S T _ _ _ _ _ _ \u21a6 Module.Finite.base_change R S T\r\n```",
      "path": "Mathlib/RingTheory/RingHom/Finite.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "ext",
          "exact",
          "rw",
          "congr"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "congr",
          "rw",
          "refine",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "convert",
          "finite_respectsIso",
          "IsStableUnderBaseChange",
          "classical",
          "introv",
          "refine",
          "ext",
          "finite_isStableUnderBaseChange",
          "RingHom",
          "simp_rw",
          "rfl",
          "congr",
          "Finite",
          "theorem",
          "exact",
          "replace",
          "smul_def",
          "suffices",
          "this",
          "Algebra"
        ]
      }
    },
    {
      "id": 2215,
      "before_code": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]",
      "suggestion": "\r\n  exact Iff.symm e.forall_congr_left\r\n",
      "body": "```suggestion\r\n  exact Iff.symm e.forall_congr_left\r\n```",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "Basis",
          "fundamentalDomain_reindex",
          "ext",
          "theorem",
          "fundamentalDomain",
          "forall_congr",
          "Type",
          "reindex",
          "implies_true",
          "Equiv",
          "mem_fundamentalDomain",
          "simp_rw",
          "repr_reindex_apply"
        ]
      }
    },
    {
      "id": 2216,
      "before_code": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]",
      "suggestion": "simpa using e.forall_congr_left.symm\n",
      "body": "````suggestion\nsimpa using e.forall_congr_left.symm\n````\n(haven't tested but this is the idiomatic way to write this)",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Basis",
          "fundamentalDomain_reindex",
          "ext",
          "theorem",
          "fundamentalDomain",
          "forall_congr",
          "Type",
          "reindex",
          "implies_true",
          "Equiv",
          "mem_fundamentalDomain",
          "simp_rw",
          "repr_reindex_apply"
        ]
      }
    },
    {
      "id": 2219,
      "before_code": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]",
      "suggestion": "\r\n  simp [e.forall_congr_left]\r\n",
      "body": "yeah it's having trouble unifying because `e.symm.symm` looks different to `e`\r\n\r\nI found a fix though; `exact` followed by an iff statement is generally a sign that `simp` or `rw` will work\r\n\r\n````suggestion\r\n  simp [e.forall_congr_left]\r\n````",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "Basis",
          "fundamentalDomain_reindex",
          "ext",
          "theorem",
          "fundamentalDomain",
          "forall_congr",
          "Type",
          "reindex",
          "implies_true",
          "Equiv",
          "mem_fundamentalDomain",
          "simp_rw",
          "repr_reindex_apply"
        ]
      }
    },
    {
      "id": 2222,
      "before_code": "theorem finite_isStableUnderBaseChange : IsStableUnderBaseChange @Finite := by\n  refine IsStableUnderBaseChange.mk finite_respectsIso ?_\n  classical\n  introv h\n  replace h : Module.Finite R T := by\n    rw [RingHom.Finite] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl\n  suffices Module.Finite S (S \u2297[R] T) by\n    rw [RingHom.Finite]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl\n  exact inferInstance",
      "suggestion": "  intros\n  infer_instance\n",
      "body": "What's the tactic state here? Does this work?\n```suggestion\n  intros\n  infer_instance\n```",
      "path": "Mathlib/RingTheory/RingHom/Finite.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "ext",
          "exact",
          "rw",
          "congr"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "refine",
          "ext",
          "exact",
          "congr"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "convert",
          "finite_respectsIso",
          "IsStableUnderBaseChange",
          "classical",
          "introv",
          "refine",
          "ext",
          "finite_isStableUnderBaseChange",
          "RingHom",
          "simp_rw",
          "rfl",
          "congr",
          "Finite",
          "theorem",
          "exact",
          "replace",
          "smul_def",
          "suffices",
          "this",
          "Algebra"
        ]
      }
    },
    {
      "id": 2226,
      "before_code": "-FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=\n  rfl",
      "suggestion": "\r\ntheorem mk_le_mk {x y : K} {hx : 0 \u2264 mk x} {hy : 0 \u2264 mk y} :\r\n    FiniteElement.mk x hx \u2264 .mk y hy \u2194 x \u2264 y :=\r\n  .rfl\r\n",
      "body": "Do we really need the `_iff` here?\r\n```suggestion\r\ntheorem mk_le_mk {x y : K} {hx : 0 \u2264 mk x} {hy : 0 \u2264 mk y} :\r\n    FiniteElement.mk x hx \u2264 .mk y hy \u2194 x \u2264 y :=\r\n  .rfl\r\n```",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "mk_neg",
          "rwa",
          "FiniteElement"
        ]
      }
    },
    {
      "id": 2227,
      "before_code": "-FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=\n  rfl\n\ntheorem not_isUnit_iff_mk_pos {x : FiniteElement K} : \u00ac IsUnit x \u2194 0 < mk x.1 :=\n  Valuation.Integer.not_isUnit_iff_valuation_lt_one\n\ntheorem isUnit_iff_mk_eq_zero {x : FiniteElement K} : IsUnit x \u2194 mk x.1 = 0 := by\n  rw [\u2190 not_iff_not, not_isUnit_iff_mk_pos, lt_iff_not_ge, x.2.ge_iff_eq']",
      "suggestion": "\r\n@[simp] theorem mk_ratCast (q : \u211a) : FiniteElement.mk (q : K) (mk_ratCast_nonneg q) = q := rfl\r\n",
      "body": "```suggestion\r\n@[simp] theorem mk_ratCast (q : \u211a) : FiniteElement.mk (q : K) (mk_ratCast_nonneg q) = q := rfl\r\n```\r\nthen your users don't have any proof obligation when rewriting backwards",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "ge_iff_eq",
          "lt_iff_not_ge",
          "IsUnit",
          "rwa",
          "Integer",
          "isUnit_iff_mk_eq_zero",
          "FiniteElement",
          "not_iff_not",
          "not_isUnit_iff_valuation_lt_one",
          "Valuation",
          "theorem",
          "mk_neg",
          "not_isUnit_iff_mk_pos",
          "rfl"
        ]
      }
    },
    {
      "id": 2228,
      "before_code": "/-- The constructor for `FiniteElement`. -/\nprotected def mk (x : K) (h : 0 \u2264 mk x) : FiniteElement K := \u27e8x, h\u27e9\n\n@[simp] theorem mk_zero (h : 0 \u2264 mk (0 : K)) : FiniteElement.mk 0 h = 0 := rfl\n@[simp] theorem mk_one (h : 0 \u2264 mk (1 : K)) : FiniteElement.mk 1 h = 1 := rfl\n@[simp] theorem mk_natCast {n : \u2115} (h : 0 \u2264 mk (n : K)) : FiniteElement.mk (n : K) h = n := rfl\n@[simp] theorem mk_intCast {n : \u2124} (h : 0 \u2264 mk (n : K)) : FiniteElement.mk (n : K) h = n := rfl\n\n@[simp]\ntheorem mk_neg {x : K} (h : 0 \u2264 mk x) :\n    -FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=\n  rfl",
      "suggestion": "\r\ntheorem mk_add_mk (x y : K) (hx hy) :\r\n",
      "body": "I would make `x` and `y` explicit since `hx` and `hy` can be inferred from the LHS\r\n```suggestion\r\ntheorem mk_add_mk (x y : K) (hx hy) :\r\n```",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "constructor",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "constructor",
          "simp"
        ],
        "topics": [
          "list",
          "nat",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "rwa",
          "FiniteElement",
          "def",
          "mk_zero",
          "theorem",
          "protected",
          "mk_one",
          "mk_neg",
          "constructor",
          "simp",
          "mk_natCast",
          "rfl",
          "mk_intCast",
          "for"
        ]
      }
    },
    {
      "id": 2229,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "  have pow_ne_zero : p ^ k \u2260 0 := pow_ne_zero k hp.ne_zero\n",
      "body": "```suggestion\n  have pow_ne_zero : p ^ k \u2260 0 := pow_ne_zero k hp.ne_zero\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 2230,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "  apply Nat.eq_of_factorization_eq\n  \u00b7 exact pos_iff_ne_zero.mp (ordProj_pos (p ^ k) p)\n  \u00b7 exact pow_ne_zero k hp.ne_zero\n  \u00b7 simp [Prime.factorization_pow hp]\n",
      "body": "```suggestion\n  apply Nat.eq_of_factorization_eq\n  \u00b7 exact pos_iff_ne_zero.mp (ordProj_pos (p ^ k) p)\n  \u00b7 exact pow_ne_zero k hp.ne_zero\n  \u00b7 simp [Prime.factorization_pow hp]\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "apply"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 2231,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "  apply Nat.eq_of_factorization_eq\n  \u00b7 exact pos_iff_ne_zero.mp (ordCompl_pos p (pow_ne_zero k hp.ne_zero))\n",
      "body": "```suggestion\n  apply Nat.eq_of_factorization_eq\n  \u00b7 exact pos_iff_ne_zero.mp (ordCompl_pos p (pow_ne_zero k hp.ne_zero))\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "apply"
        ],
        "body_tactics": [
          "exact",
          "apply"
        ],
        "new_tactics": [
          "exact",
          "apply"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 2232,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "    \u00b7 simp [Nat.factorization_eq_zero_of_not_dvd not_dvd]\n",
      "body": "```suggestion\n    \u00b7 simp [Nat.factorization_eq_zero_of_not_dvd not_dvd]\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 2245,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n",
      "body": "It's easier if you case split on whether the range of the function from the subtype is bounded above or not.\n```suggestion\n  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "exact",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "exact",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "aesop",
          "refine",
          "simp",
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 2246,
      "before_code": "{ a : \u0393' | (VAddAntidiagonal x.isPWO_support\n              ((of R).symm y).isPWO_support a).Nonempty } := by\n          intro a ha\n          simp only [Set.mem_setOf_eq]\n          contrapose! ha\n          simp [ha]",
      "suggestion": "\r\n          simp only [Set.mem_setOf_eq]\r\n          contrapose! ha\r\n          simp [ha]\r\n",
      "body": "```suggestion\r\n          simp only [Set.mem_setOf_eq]\r\n          contrapose! ha\r\n          simp [ha]\r\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "contrapose",
          "symm",
          "Nonempty",
          "mem_setOf_eq",
          "Set",
          "simp",
          "intro",
          "isPWO_support",
          "VAddAntidiagonal",
          "only"
        ]
      }
    },
    {
      "id": 2249,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    toEuclidean '' Euclidean.closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [Euclidean.closedBall, Euclidean.dist]\r\n",
      "body": "```suggestion\r\n    toEuclidean '' Euclidean.closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [Euclidean.closedBall, Euclidean.dist]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "new_tactics": [
          "simpa",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2250,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n  \u00b7 norm_num [dist_eq_norm, EuclideanSpace.norm_eq]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9]\r\n    \u00b7 simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n    \u00b7 intro b _ hnb\r\n      simp [hnb, x\u2081, x\u2082]\r\n    \u00b7 simp\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n  \u00b7 norm_num [dist_eq_norm, EuclideanSpace.norm_eq]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9]\r\n    \u00b7 simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n    \u00b7 intro b _ hnb\r\n      simp [hnb, x\u2081, x\u2082]\r\n    \u00b7 simp\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "norm_num",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "norm_num",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "norm_num",
          "rw",
          "simp",
          "intro"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2251,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  by_cases hr : r = 0 <;> simp [\u2190 _root_.closure_ball, hr]\r\n",
      "body": "```suggestion\r\n  by_cases hr : r = 0 <;> simp [\u2190 _root_.closure_ball, hr]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2254,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 ((by simp_all [x\u2081, x\u2082])) (by simp)]\r\n    simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n  \u00b7 simp [x\u2081, abs_of_nonneg, hr]\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n",
      "body": "More compact this way:\r\n```suggestion\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 ((by simp_all [x\u2081, x\u2082])) (by simp)]\r\n    simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n  \u00b7 simp [x\u2081, abs_of_nonneg, hr]\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine",
          "rw",
          "simp_all"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2256,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  let x\u2081 := toEuclidean x + EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  let x\u2082 := toEuclidean x - EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 (by simp_all [x\u2081, x\u2082]) (by simp)]\r\n",
      "body": "```suggestion\r\n  let x\u2081 := toEuclidean x + EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  let x\u2082 := toEuclidean x - EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 (by simp_all [x\u2081, x\u2082]) (by simp)]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine",
          "rw",
          "simp_all"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2257,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    toEuclidean '' closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [closedBall, dist]\r\n",
      "body": "```suggestion\r\n    toEuclidean '' closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [closedBall, dist]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "new_tactics": [
          "simpa",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 2261,
      "before_code": "theorem convex_closedBall (a : E) (r : \u211d) : Convex \u211d (Metric.closedBall a r) := by\n  simpa only [Metric.closedBall, sep_univ] using (convexOn_univ_dist a).convex_le r\n\nvariable {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F]",
      "suggestion": "\r\nlemma Metric.diam_ball_eq (x : F) {r : \u211d} (hr : 0 \u2264 r) :\r\n    diam (ball x r) = 2 * r := by\r\n  if hr' : r = 0 then simp [hr'] else\r\n  rw [\u2190 diam_closure, closure_ball _ hr', diam_closedBall_eq _ hr]\r\n",
      "body": "```suggestion\r\nlemma Metric.diam_ball_eq (x : F) {r : \u211d} (hr : 0 \u2264 r) :\r\n    diam (ball x r) = 2 * r := by\r\n  if hr' : r = 0 then simp [hr'] else\r\n  rw [\u2190 diam_closure, closure_ball _ hr', diam_closedBall_eq _ hr]\r\n```",
      "path": "Mathlib/Analysis/Normed/Module/Convex.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "norm",
          "real",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "convex_closedBall",
          "variable",
          "theorem",
          "Type",
          "Metric",
          "NormedSpace",
          "simpa",
          "closedBall",
          "Convex",
          "sep_univ",
          "convexOn_univ_dist",
          "NormedAddCommGroup",
          "convex_le",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 2264,
      "before_code": "@[deprecated (since := \"2025-12-05\")] alias toSpanSingleton_one := toSpanSingleton_apply_one",
      "suggestion": "\r\n@[simp] theorem toSpanSingleton_map_one (c : R\u2081 \u2192L[R\u2081] M\u2082) : toSpanSingleton R\u2081 (c 1) = c :=\r\n",
      "body": "wait... this or?\r\n```suggestion\r\n@[simp] theorem toSpanSingleton_map_one (c : R\u2081 \u2192L[R\u2081] M\u2082) : toSpanSingleton R\u2081 (c 1) = c :=\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/LinearMap.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "alias",
          "since",
          "toSpanSingleton_apply_one",
          "deprecated",
          "toSpanSingleton_one"
        ]
      }
    },
    {
      "id": 2268,
      "before_code": "instance instFourierPairInv : FourierInvPair \ud835\udce2'(E, F) \ud835\udce2'(E, F) where\n  fourier_fourierInv_eq f := by ext; simp",
      "suggestion": "    \ud835\udcd5\u207b (f : \ud835\udce2'(E, F)) = \ud835\udcd5\u207b f := calc\n  _ = \ud835\udcd5\u207b (toTemperedDistributionCLM E F volume (\ud835\udcd5 (\ud835\udcd5\u207b f))) := by\n    congr; exact (fourier_fourierInv_eq f).symm\n  _ = \ud835\udcd5\u207b (\ud835\udcd5 (toTemperedDistributionCLM E F volume (\ud835\udcd5\u207b f))) := by\n    rw [fourierTransform_toTemperedDistributionCLM_eq]\n  _ = _ := fourierInv_fourier_eq _\n",
      "body": "style nit. I didn't actually test that it still elaborates properly with the starting and ending `_`, but I don't see which it shouldn't.\n```suggestion\n    \ud835\udcd5\u207b (f : \ud835\udce2'(E, F)) = \ud835\udcd5\u207b f := calc\n  _ = \ud835\udcd5\u207b (toTemperedDistributionCLM E F volume (\ud835\udcd5 (\ud835\udcd5\u207b f))) := by\n    congr; exact (fourier_fourierInv_eq f).symm\n  _ = \ud835\udcd5\u207b (\ud835\udcd5 (toTemperedDistributionCLM E F volume (\ud835\udcd5\u207b f))) := by\n    rw [fourierTransform_toTemperedDistributionCLM_eq]\n  _ = _ := fourierInv_fourier_eq _\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "exact",
          "congr",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "congr",
          "rw"
        ],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "instFourierPairInv",
          "ext",
          "fourier_fourierInv_eq",
          "simp",
          "instance",
          "FourierInvPair"
        ]
      }
    },
    {
      "id": 2283,
      "before_code": "J.yoneda \u22d9 sheafToPresheaf J (Type v) \u2245 CategoryTheory.yoneda :=\n  Iso.refl _",
      "suggestion": "@[simps!]\ndef uliftYonedaCompSheafToPresheaf :\n",
      "body": "```suggestion\n@[simps!]\ndef uliftYonedaCompSheafToPresheaf :\n```",
      "path": "Mathlib/CategoryTheory/Sites/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Type",
          "CategoryTheory",
          "sheafToPresheaf",
          "refl",
          "yoneda",
          "Iso"
        ]
      }
    },
    {
      "id": 2288,
      "before_code": "simpa only [yonedaEquiv_comp, Equiv.apply_symm_apply]\n    using congr_arg (J.yonedaEquiv) (h _ (J.yonedaEquiv.symm x))",
      "suggestion": "@[simps! hom_app_app_down]\ndef yonedaOpCompCoyoneda :\n",
      "body": "```suggestion\n@[simps! hom_app_app_down]\ndef yonedaOpCompCoyoneda :\n```",
      "path": "Mathlib/CategoryTheory/Sites/Subcanonical.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "congr_arg",
          "apply_symm_apply",
          "symm",
          "simpa",
          "Equiv",
          "yonedaEquiv",
          "yonedaEquiv_comp",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 2304,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "  rw [Nat.le_div_iff_mul_le (by positivity), Nat.mul_comm,\n    \u2190 Nat.add_mul_div_right _ _ (by positivity),\n    Nat.le_div_iff_mul_le (by positivity)]\n  have := (Commute.all (b : \u2124) (a - b)).pow_add_mul_le_add_pow_of_sq_nonneg\n    (by positivity) (sq_nonneg _) (sq_nonneg _) (by grind) (n + 1)\n  -- `grind` should solve this, but:  https://github.com/leanprover/lean4/issues/11539\n  simp [mul_sub, \u2190 add_sub_assoc] at this\n  norm_cast at this\n  grind \n",
      "body": "This worked last week\n```suggestion\n  rw [Nat.le_div_iff_mul_le (by positivity), Nat.mul_comm,\n    \u2190 Nat.add_mul_div_right _ _ (by positivity),\n    Nat.le_div_iff_mul_le (by positivity)]\n  have := (Commute.all (b : \u2124) (a - b)).pow_add_mul_le_add_pow_of_sq_nonneg\n    (by positivity) (sq_nonneg _) (sq_nonneg _) (by grind) (n + 1)\n  -- `grind` should solve this, but:  https://github.com/[user]r/lean4/issues/11539\n  simp [mul_sub, \u2190 add_sub_assoc] at this\n  norm_cast at this\n  grind \n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "grind",
          "have",
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "positivity",
          "grind",
          "have",
          "rw",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "positivity",
          "rw",
          "simp",
          "grind",
          "have",
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 2305,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "  have H : \u2203 c, a < (c + 1) ^ (n + 1) := \u27e8a, Nat.le_self_pow (by positivity) (a + 1)\u27e9\n  let +nondep (eq := hc) c := Nat.find H\n  refine \u27e8c, ?_, hc \u25b8 Nat.find_spec H\u27e9\n  cases c with\n  | zero => simp\n  | succ k => simpa using Nat.find_min H hc.le\n",
      "body": "Here's a nice little trick for you. This introduces a new name `c` which is equal (propositionally) to `Nat.find H`, but it doesn't reduce to that. This allows us to perform a nice case split on `c` which simplifies the argument.\n```suggestion\n  have H : \u2203 c, a < (c + 1) ^ (n + 1) := \u27e8a, Nat.le_self_pow (by positivity) (a + 1)\u27e9\n  let +nondep (eq := hc) c := Nat.find H\n  refine \u27e8c, ?_, hc \u25b8 Nat.find_spec H\u27e9\n  cases c with\n  | zero => simp\n  | succ k => simpa using Nat.find_min H hc.le\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "refine",
          "cases",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "positivity",
          "refine",
          "cases",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "positivity",
          "refine",
          "simp",
          "cases",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 2306,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff\n\n/--\nAn auxiliary lemma saying that if `b \u2260 0`,\nthen `(a / b ^ n + n * b) / (n + 1) + 1` is a strict upper estimate on `\u221a[n + 1] a`.\n\nCurrently, the proof relies on the weighted AM-GM inequality,\nwhich increases the dependency closure of this file by a lot.\n\nA PR proving this inequality by more elementary means is very welcome.\n-/\ntheorem nthRoot.lt_pow_go_succ_aux (hb : b \u2260 0) :\n    a < ((a / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n  rcases Nat.eq_zero_or_pos n with rfl | hn; \u00b7 simp\n  rw [\u2190 Nat.add_mul_div_left a, Nat.div_div_eq_div_mul] <;> try positivity\n  rify\n  calc\n    (a : \u211d) = ((a / b ^ n) ^ (1 / (n + 1) : \u211d) * b ^ (n / (n + 1) : \u211d)) ^ (n + 1) := by\n      rw [mul_pow, \u2190 Real.rpow_mul_natCast, \u2190 Real.rpow_mul_natCast] <;> try positivity\n      simp (disch := positivity) [div_mul_cancel\u2080]\n    _ \u2264 ((1 / (n + 1)) * (a / b ^ n) + (n / (n + 1)) * b) ^ (n + 1) := by\n      gcongr\n      apply Real.geom_mean_le_arith_mean2_weighted <;> try positivity\n      simp [field, add_comm]\n    _ = ((a + b ^ n * (n * b)) / (b ^ n * (n + 1))) ^ (n + 1) := by\n      congr 1\n      field\n    _ < _ := by\n      gcongr ?_ ^ _\n      convert lt_floor_add_one (R := \u211d) _ using 1\n      norm_cast\n      rw [Nat.floor_div_natCast, Nat.floor_natCast]",
      "suggestion": "    _ \u2264 ((c ^ (n + 1) / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n      gcongr\n      exact nthRoot.lt_pow_go_succ_aux0 hb\n    _ \u2264 ((a / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n      gcongr\n",
      "body": "style nit\n```suggestion\n    _ \u2264 ((c ^ (n + 1) / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n      gcongr\n      exact nthRoot.lt_pow_go_succ_aux0 hb\n    _ \u2264 ((a / b ^ n + n * b) / (n + 1) + 1) ^ (n + 1) := by\n      gcongr\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "positivity",
          "gcongr",
          "cases",
          "rw",
          "simp",
          "congr",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "exact",
          "gcongr"
        ],
        "body_tactics": [
          "exact",
          "gcongr"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "apply",
          "positivity",
          "cases",
          "rw",
          "simp",
          "congr",
          "norm_cast"
        ],
        "topics": [
          "real",
          "order",
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "add_mul_div_left",
          "file",
          "lemma",
          "Currently",
          "calc",
          "lt_pow_go_succ_aux",
          "convert",
          "try",
          "closure",
          "which",
          "increases",
          "eq_zero_or_pos",
          "relies",
          "proving",
          "elementary",
          "add_comm",
          "floor_natCast",
          "estimate",
          "floor_div_natCast",
          "rcases",
          "strict",
          "field",
          "rify",
          "pow_nthRoot_le_iff",
          "alias",
          "welcome",
          "geom_mean_le_arith_mean2_weighted",
          "apply",
          "positivity",
          "gcongr",
          "pow_nthRoot_le",
          "Nat",
          "more",
          "disch",
          "norm_cast",
          "div_div_eq_div_mul",
          "then",
          "inequality",
          "Real",
          "that",
          "simp",
          "lt_floor_add_one",
          "upper",
          "rfl",
          "congr",
          "mul_pow",
          "nthRoot",
          "lot",
          "theorem",
          "auxiliary"
        ]
      }
    },
    {
      "id": 2310,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n  have {x} (hx : x \u2208 s) : \u2203 K' : \u211d\u22650, \u2200 y \u2208 s.diff (ball x (\u03b5 x hx)),\r\n",
      "body": "Should this be stated as\r\n```suggestion\r\n  have {x} (hx : x \u2208 s) : \u2203 K' : \u211d\u22650, \u2200 y \u2208 s.diff (ball x (\u03b5 x hx)),\r\n```\r\nso you can avoid the `fun x hx` at the beginning of hte proof?",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 2311,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n    simp_rw [edist_nndist, \u2190 ENNReal.coe_mul, ENNReal.coe_le_coe]\r\n",
      "body": "```suggestion\r\n    simp_rw [edist_nndist, \u2190 ENNReal.coe_mul, ENNReal.coe_le_coe]\r\n```",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 2312,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n      gcongr\r\n      exact (add_le_add_left (mul_le_mul_of_nonneg_left h (by positivity)) _).trans (by linarith)\r\n",
      "body": "```suggestion\r\n      gcongr\r\n      exact (add_le_add_left (mul_le_mul_of_nonneg_left h (by positivity)) _).trans (by linarith)\r\n```",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "body_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "new_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 2315,
      "before_code": "(by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n\nend MeromorphicOn",
      "suggestion": "@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3)) :\n    Meromorphic (\u2211 n \u2208 s, G n) := fun x \u21a6 MeromorphicAt.sum (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma sub (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f - g) := fun x \u21a6 (hf x).sub (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma mul {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f * g) := fun x \u21a6 (hf x).mul (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem prod (h : \u2200 \u03c3, Meromorphic (F \u03c3)) :\n    Meromorphic (\u220f n \u2208 s, F n) := fun x \u21a6 MeromorphicAt.prod (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma div {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f / g) := fun x \u21a6 (hf x).div (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma pow",
      "body": "There is some new metaprogramming that can help here: the `to_fun` attribute.\nTo get access, you need to add `import Mathlib.Tactic.ToFun` to the imports (doesn't need `public`).\n\n```suggestion\n@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "restrict",
          "measurable_of_countable",
          "end",
          "mem_compl_iff",
          "simp",
          "MeromorphicOn",
          "measurable"
        ]
      }
    },
    {
      "id": 2316,
      "before_code": "rintro x rfl\n  exact heval _",
      "suggestion": "  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero _ hf\n",
      "body": "only because I was confused why `hf` wasn't an explicit argument, and then after looking above, I realized it is.\n```suggestion\n  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero _ hf\n```",
      "path": "Mathlib/Algebra/Polynomial/Roots.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "rfl",
          "heval",
          "rintro"
        ]
      }
    },
    {
      "id": 2334,
      "before_code": "n.totient_eq_card_lt_and_coprime]\n    simp only [Nat.gcd_comm]",
      "suggestion": "\r\n  wlog hp : 0 < p generalizing p; swap\r\n  \u00b7 have := Fact.mk hp\r\n",
      "body": "Here's how I'd write this. This is subjective, so feel free to accept or reject this as you choose.\r\n```suggestion\r\n  wlog hp : 0 < p generalizing p; swap\r\n  \u00b7 have := Fact.mk hp\r\n```",
      "path": "Mathlib/Topology/Instances/AddCircle/Defs.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "nat",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "gcd_comm",
          "totient_eq_card_lt_and_coprime",
          "Nat",
          "simp",
          "only"
        ]
      }
    },
    {
      "id": 2335,
      "before_code": "n.totient_eq_card_lt_and_coprime]\n    simp only [Nat.gcd_comm]",
      "suggestion": "\r\n  convert \u2190 this (-p) (neg_pos.mpr hp) using 1\r\n  \u00b7 simp [AddCircle, zmultiples_neg]\r\n",
      "body": "Small golf\r\n```suggestion\r\n  convert \u2190 this (-p) (neg_pos.mpr hp) using 1\r\n  \u00b7 simp [AddCircle, zmultiples_neg]\r\n```",
      "path": "Mathlib/Topology/Instances/AddCircle/Defs.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "gcd_comm",
          "totient_eq_card_lt_and_coprime",
          "Nat",
          "simp",
          "only"
        ]
      }
    },
    {
      "id": 2338,
      "before_code": "[DiscreteTopology F] [TopologicalSpace (Bundle.TotalSpace F E)] [\u2200 x, TopologicalSpace (E x)]\n    [FiberBundle F E] : IsCoveringMap (\u03c0 F E) :=\n  IsFiberBundle.isCoveringMap fun x => \u27e8trivializationAt F E x, mem_baseSet_trivializationAt F E x\u27e9",
      "suggestion": "noncomputable def IsOpen.trivialization_discrete [Nonempty E] (hE : f.Surjective)\n",
      "body": "How about:\n```suggestion\nnoncomputable def IsOpen.trivialization_discrete [Nonempty E] (hE : f.Surjective)\n```\nand if necessary have a separate `def` (with much fewer assumptions) for the case that `E` is empty?",
      "path": "Mathlib/Topology/Covering/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "isCoveringMap",
          "TopologicalSpace",
          "Bundle",
          "IsFiberBundle",
          "trivializationAt",
          "FiberBundle",
          "mem_baseSet_trivializationAt",
          "IsCoveringMap",
          "TotalSpace",
          "DiscreteTopology"
        ]
      }
    },
    {
      "id": 2340,
      "before_code": "_ \u2286 V * V := mul_subset_mul hW hW\n  _ \u2286 U := hV",
      "suggestion": "    \u2203 U \u2208 \ud835\udcdd (1 : G), U\u207b\u00b9 = U \u2227 \u2200 g \u2208 S,\n      ((g * \u00b7) '' U \u2229 U).Nonempty \u2192 g = 1 := by\n",
      "body": "How about we strengthen this to:\n```suggestion\n    \u2203 U \u2208 \ud835\udcdd (1 : G), U\u207b\u00b9 = U \u2227 \u2200 g \u2208 S,\n      ((g * \u00b7) '' U \u2229 U).Nonempty \u2192 g = 1 := by\n```\nand add a lemma capturing:\n```lean\nexample (U : Set G) (hU : U = U\u207b\u00b9) (g : G) :\n    ((g * \u00b7) '' U \u2229 U).Nonempty \u2194 ((\u00b7 * g\u207b\u00b9) '' U \u2229 U).Nonempty := by\n  sorry\n```\nsomewhere, potentially with a reference to it from the doc string of this lemma.",
      "path": "Mathlib/Topology/Algebra/Group/Pointwise.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mul_subset_mul"
        ]
      }
    },
    {
      "id": 2346,
      "before_code": "Released under Apache 2.0 license as described in the file LICENSE.\nAuthors: Antoine Chambert-Loir\n-/\nmodule",
      "suggestion": "",
      "body": "This is already imported three lines below:\n```suggestion\n```\nI suggest ordering the imports alphabetically to make this sort of thing easier to spot.",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "file",
          "Loir",
          "Released",
          "Chambert",
          "LICENSE",
          "under",
          "module",
          "license",
          "described",
          "Apache",
          "Antoine",
          "Authors"
        ]
      }
    },
    {
      "id": 2347,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "  rcases (by lia : finrank R V = 0 \u2228 finrank R V = 1) with h0 | h1\n  \u00b7 have : Subsingleton V := (finrank_eq_zero_iff_of_free R V).mp h0\n    simp [Subsingleton.eq_zero v]\n",
      "body": "```suggestion\n  rcases (by lia : finrank R V = 0 \u2228 finrank R V = 1) with h0 | h1\n  \u00b7 have : Subsingleton V := (finrank_eq_zero_iff_of_free R V).mp h0\n    simp [Subsingleton.eq_zero v]\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "have"
        ],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 2348,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "      rw [this v, map_smul, smul_eq_mul, mul_comm] at hfv\n      rw [this x, this v, map_smul, smul_eq_mul, \u2190 mul_smul, mul_assoc, hfv, mul_zero, zero_smul]\n",
      "body": "These are just nitpicks but I think it does make it easier to glance over the proof:\n```suggestion\n      rw [this v, map_smul, smul_eq_mul, mul_comm] at hfv\n      rw [this x, this v, map_smul, smul_eq_mul, \u2190 mul_smul, mul_assoc, hfv, mul_zero, zero_smul]\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 2351,
      "before_code": "ext i\n  simp [basis_repr_comp_apply]\n\nvariable [Module.Free R V]\n\ninclude ibc in\ntheorem free : Module.Free S W :=\n  Module.Free.of_basis (ibc.basis (Module.Free.chooseBasis R V))\n\nend IsBaseChange",
      "suggestion": "    suffices (j (1 \u2297\u209c[A] x)) = x.mapRange (algebraMap A R) (by simp) by\n      simp [this, Finsupp.linearCombination_apply, Finsupp.sum_mapRange_index]\n",
      "body": "```suggestion\n    suffices (j (1 \u2297\u209c[A] x)) = x.mapRange (algebraMap A R) (by simp) by\n      simp [this, Finsupp.linearCombination_apply, Finsupp.sum_mapRange_index]\n```",
      "path": "Mathlib/RingTheory/TensorProduct/IsBaseChangeFree.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "Free",
          "end",
          "ext",
          "basis_repr_comp_apply",
          "variable",
          "IsBaseChange",
          "theorem",
          "include",
          "chooseBasis",
          "of_basis",
          "simp",
          "ibc",
          "free",
          "basis"
        ]
      }
    },
    {
      "id": 2352,
      "before_code": "ext i\n  simp [basis_repr_comp_apply]\n\nvariable [Module.Free R V]\n\ninclude ibc in\ntheorem free : Module.Free S W :=\n  Module.Free.of_basis (ibc.basis (Module.Free.chooseBasis R V))\n\nend IsBaseChange",
      "suggestion": "    -- simp? [Fintype.linearCombination_apply] says:\n    simp only [LinearEquiv.ofBijective_apply, LinearMap.coe_comp, LinearEquiv.coe_coe,\n      Function.comp_apply, Fintype.linearCombination_apply]\n",
      "body": "```suggestion\n    -- simp? [Fintype.linearCombination_apply] says:\n    simp only [LinearEquiv.ofBijective_apply, LinearMap.coe_comp, LinearEquiv.coe_coe,\n      Function.comp_apply, Fintype.linearCombination_apply]\n```\n\nThis is up to you, and some people disagree with me, but I prefer (mostly) auto-generated simp only blocks to rw blocks, because it makes the proof more maintainable (if the proof breaks in the future, the `simp?` statement that generated it can sometimes help fix it (which is why",
      "path": "Mathlib/RingTheory/TensorProduct/IsBaseChangeFree.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "use_simp",
          "line_break"
        ],
        "keywords": [
          "Module",
          "Free",
          "end",
          "ext",
          "basis_repr_comp_apply",
          "variable",
          "IsBaseChange",
          "theorem",
          "include",
          "chooseBasis",
          "of_basis",
          "simp",
          "ibc",
          "free",
          "basis"
        ]
      }
    },
    {
      "id": 2353,
      "before_code": "ext i\n  simp [basis_repr_comp_apply]\n\nvariable [Module.Free R V]\n\ninclude ibc in\ntheorem free : Module.Free S W :=\n  Module.Free.of_basis (ibc.basis (Module.Free.chooseBasis R V))\n\nend IsBaseChange",
      "suggestion": "  simp\n",
      "body": "```suggestion\n  simp\n```",
      "path": "Mathlib/RingTheory/TensorProduct/IsBaseChangeFree.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "Free",
          "end",
          "ext",
          "basis_repr_comp_apply",
          "variable",
          "IsBaseChange",
          "theorem",
          "include",
          "chooseBasis",
          "of_basis",
          "simp",
          "ibc",
          "free",
          "basis"
        ]
      }
    },
    {
      "id": 2354,
      "before_code": "def toGeneralLinearGroup : SpecialLinearGroup R V \u2192* LinearMap.GeneralLinearGroup R V :=\n  (LinearMap.GeneralLinearGroup.generalLinearEquiv R V).symm.toMonoidHom.comp toLinearEquiv\n\nlemma toGeneralLinearGroup_toLinearEquiv_apply (u : SpecialLinearGroup R V) :",
      "suggestion": "\r\nlemma toGeneralLinearGroup_toLinearEquiv_apply (u : SpecialLinearGroup R V) :\r\n",
      "body": "```suggestion\r\nlemma toGeneralLinearGroup_toLinearEquiv_apply (u : SpecialLinearGroup R V) :\r\n```",
      "path": "Mathlib/LinearAlgebra/SpecialLinearGroup.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "generalLinearEquiv",
          "symm",
          "lemma",
          "LinearMap",
          "def",
          "toMonoidHom",
          "SpecialLinearGroup",
          "comp",
          "toGeneralLinearGroup",
          "GeneralLinearGroup",
          "toLinearEquiv",
          "toGeneralLinearGroup_toLinearEquiv_apply"
        ]
      }
    },
    {
      "id": 2355,
      "before_code": "def toGeneralLinearGroup : SpecialLinearGroup R V \u2192* LinearMap.GeneralLinearGroup R V :=\n  (LinearMap.GeneralLinearGroup.generalLinearEquiv R V).symm.toMonoidHom.comp toLinearEquiv\n\nlemma toGeneralLinearGroup_toLinearEquiv_apply (u : SpecialLinearGroup R V) :\n    u.toGeneralLinearGroup.toLinearEquiv = u.toLinearEquiv := rfl\n\nlemma coe_toGeneralLinearGroup_apply (u : SpecialLinearGroup R V) :",
      "suggestion": "\r\nlemma coe_toGeneralLinearGroup_apply (u : SpecialLinearGroup R V) :\r\n",
      "body": "```suggestion\r\nlemma coe_toGeneralLinearGroup_apply (u : SpecialLinearGroup R V) :\r\n```",
      "path": "Mathlib/LinearAlgebra/SpecialLinearGroup.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "coe_toGeneralLinearGroup_apply",
          "generalLinearEquiv",
          "symm",
          "lemma",
          "def",
          "LinearMap",
          "toMonoidHom",
          "SpecialLinearGroup",
          "comp",
          "toGeneralLinearGroup",
          "GeneralLinearGroup",
          "toLinearEquiv",
          "toGeneralLinearGroup_toLinearEquiv_apply",
          "rfl"
        ]
      }
    },
    {
      "id": 2357,
      "before_code": "/-! ### The first infinite ordinal \u03c9 -/\n\n\n/-- `\u03c9` is the first infinite ordinal, defined as the order type of `\u2115`. -/\ndef omega0 : Ordinal.{u} :=\n  lift (typeLT \u2115)\n\n@[inherit_doc]\nscoped notation \"\u03c9\" => Ordinal.omega0",
      "suggestion": "\r\nrecommended_spelling \"omega0\" for \"\u03c9\" in [omega0, \u00abterm\u03c9\u00bb]\r\n",
      "body": "Silly me.\r\n```suggestion\r\nrecommended_spelling \"omega0\" for \"\u03c9\" in [omega0, \u00abterm\u03c9\u00bb]\r\n```",
      "path": "Mathlib/SetTheory/Ordinal/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "infinite",
          "omega0",
          "def",
          "scoped",
          "Ordinal",
          "ordinal",
          "lift",
          "typeLT",
          "order",
          "inherit_doc",
          "notation",
          "type",
          "first",
          "defined"
        ]
      }
    },
    {
      "id": 2358,
      "before_code": "intro B n\n  induction n with\n  | zero => simp only [zpow_zero, one_smul]\n  | succ n hn =>\n    simpa only [add_comm (n:\u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc, prop_red_T hS hT]",
      "suggestion": "\r\n  | succ n hn =>\r\n    simpa only [add_comm (n : \u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc,\r\n      prop_red_T hS hT]\r\n",
      "body": "```suggestion\r\n  | succ n hn =>\r\n    simpa only [add_comm (n : \u2124), zpow_add _ 1, \u2190 smul_eq_mul, zpow_one, smul_assoc,\r\n      prop_red_T hS hT]\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/FixedDetMatrices.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "induction",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "induction",
          "simp",
          "intro"
        ],
        "topics": [
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "zpow_add",
          "add_comm",
          "one_smul",
          "prop_red_T",
          "succ",
          "zpow_zero",
          "simpa",
          "zpow_one",
          "induction",
          "simp",
          "intro",
          "zero",
          "smul_eq_mul",
          "only",
          "smul_assoc"
        ]
      }
    },
    {
      "id": 2372,
      "before_code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible",
      "suggestion": "    obtain \u27e8u, -, h\u27e9 := isUnit_iff.mp h\n    apply ha\n    simpa using congr(coeff $h 1).symm\n",
      "body": "```suggestion\n    obtain \u27e8u, -, h\u27e9 := isUnit_iff.mp h\n    apply ha\n    simpa using congr(coeff $h 1).symm\n```",
      "path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "obtain",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "obtain",
          "congr"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "obtain",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Monic",
          "irreducible",
          "theorem",
          "Irreducible",
          "hp1",
          "prime_of_degree_eq_one",
          "irreducible_of_degree_eq_one",
          "degree"
        ]
      }
    },
    {
      "id": 2373,
      "before_code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible",
      "suggestion": "    \u00b7 push_neg at H\n      rw [mul_comm] at h\n      exact exact (this g f h H.le).symm\n",
      "body": "```suggestion\n    \u00b7 push_neg at H\n      rw [mul_comm] at h\n      exact exact (this g f h H.le).symm\n```",
      "path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Monic",
          "irreducible",
          "theorem",
          "Irreducible",
          "hp1",
          "prime_of_degree_eq_one",
          "irreducible_of_degree_eq_one",
          "degree"
        ]
      }
    },
    {
      "id": 2374,
      "before_code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible",
      "suggestion": "    have hd := congr(degree $h)\n    have aux : (a \u2022 (X : R[X]) + C b).degree = 1 := by compute_degree!\n    rw [degree_mul, aux, eq_comm, Nat.WithBot.add_eq_one_iff] at hd\n    obtain \u27e8hf, -\u27e9 : f.degree = 0 \u2227 g.degree = 1 := by\n      apply hd.resolve_right\n      rintro \u27e8hf0, hfg\u27e9\n      simp_all [(zero_lt_one' (WithBot \u2115)).not_ge]\n    left\n    replace hf := f.eq_C_of_degree_eq_zero hf\n    suffices IsUnit (f.coeff 0) by\n      rw [isUnit_iff]\n      exact \u27e8f.coeff 0, this, hf.symm\u27e9\n    rw [hf, \u2190 smul_eq_C_mul] at h\n    apply hab\n    \u00b7 use g.coeff 1\n      simpa using congr(coeff $h 1)\n    \u00b7 use g.coeff 0\n      simpa using congr(coeff $h 0)\n",
      "body": "```suggestion\n    have hd := congr(degree $h)\n    have aux : (a \u2022 (X : R[X]) + C b).degree = 1 := by compute_degree!\n    rw [degree_mul, aux, eq_comm, Nat.WithBot.add_eq_one_iff] at hd\n    obtain \u27e8hf, -\u27e9 : f.degree = 0 \u2227 g.degree = 1 := by\n      apply hd.resolve_right\n      rintro \u27e8hf0, hfg\u27e9\n      simp_all [(zero_lt_one' (WithBot \u2115)).not_ge]\n    left\n    replace hf := f.eq_C_of_degree_eq_zero hf\n    suffices IsUnit (f.coeff 0) by\n      rw [isUnit_iff]\n      exact \u27e8f.coeff 0, this, hf.symm\u27e9\n    r",
      "path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Monic",
          "irreducible",
          "theorem",
          "Irreducible",
          "hp1",
          "prime_of_degree_eq_one",
          "irreducible_of_degree_eq_one",
          "degree"
        ]
      }
    },
    {
      "id": 2380,
      "before_code": "theorem log_exp (x : \u211d) : log (exp x) = x :=\n  exp_injective <| exp_log (exp_pos x)",
      "suggestion": "@[simp] theorem log_comp_exp : log \u2218 exp = id := funext log_exp\n",
      "body": "```suggestion\n@[simp] theorem log_comp_exp : log \u2218 exp = id := funext log_exp\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "funext",
          "simp"
        ],
        "body_tactics": [
          "funext",
          "simp"
        ],
        "new_tactics": [
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "exp",
          "log",
          "theorem",
          "exp_injective",
          "exp_log",
          "log_exp",
          "exp_pos"
        ]
      }
    },
    {
      "id": 2382,
      "before_code": "end Semiring",
      "suggestion": "\r\ntheorem map_toSubring : (p.toSubring T hp).map T.subtype = p := by\r\n",
      "body": "```suggestion\r\ntheorem map_toSubring : (p.toSubring T hp).map T.subtype = p := by\r\n```",
      "path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Semiring"
        ]
      }
    },
    {
      "id": 2383,
      "before_code": "end Semiring",
      "suggestion": "\r\ndef toSubring : PowerSeries T := mk fun n => \u27e8p.coeff n, hp n\u27e9\r\n",
      "body": "```suggestion\r\ndef toSubring : PowerSeries T := mk fun n => \u27e8p.coeff n, hp n\u27e9\r\n```",
      "path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Semiring"
        ]
      }
    },
    {
      "id": 2392,
      "before_code": "\u00b7 exact hpn.symm\n  simpa [\u2190 ZMod.intCast_eq_intCast_iff] using ZMod.pow_card_sub_one_eq_one this",
      "suggestion": "\r\ntheorem Int.prime_dvd_pow_sub_one {p : \u2115} (hp : Nat.Prime p) {n : \u2124} (hpn : IsCoprime n p) :\r\n",
      "body": "```suggestion\r\ntheorem Int.prime_dvd_pow_sub_one {p : \u2115} (hp : Nat.Prime p) {n : \u2124} (hpn : IsCoprime n p) :\r\n```\r\nThe spelling \"card\" here is weird... I think the \"card\" throughout the file is referring to the cardinality of the `ZMod` type, or at least about `ZMOD`, but this theorem has neither.",
      "path": "Mathlib/FieldTheory/Finite/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "exact"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "hpn",
          "exact",
          "ZMod",
          "pow_card_sub_one_eq_one",
          "this",
          "simpa",
          "intCast_eq_intCast_iff",
          "using"
        ]
      }
    },
    {
      "id": 2399,
      "before_code": "grw [\u2190 H2]\n  ring_nf; rfl",
      "suggestion": "\r\n  grind [abs, norm_smul, Real.norm_eq_abs, norm_zero, inner_eq_mul_norm_iff_angle_eq_zero, inner_eq_neg_mul_norm_iff_angle_eq_pi]\r\n",
      "body": "```suggestion\r\n  grind [abs, norm_smul, Real.norm_eq_abs, norm_zero, inner_eq_mul_norm_iff_angle_eq_zero, inner_eq_neg_mul_norm_iff_angle_eq_pi]\r\n```\r\n(there's an open PR tagging `abs` with `grind`, so that will soon be a redundant argument.",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "ring_nf"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "ring_nf"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "remove_redundant",
          "use_grind"
        ],
        "keywords": [
          "rfl",
          "grw",
          "ring_nf"
        ]
      }
    },
    {
      "id": 2401,
      "before_code": "simpa using angle_le_angle_add_angle_of_norm_eq_one (norm_normalize_eq_one_iff.mpr hx)\n    (norm_normalize_eq_one_iff.mpr hy) (norm_normalize_eq_one_iff.mpr hz)",
      "suggestion": "\r\n      obtain \u27e8_, \u27e8r2, \u27e8H5, rfl\u27e9\u27e9\u27e9 := H2\r\n      lift r2 to \u211d\u22650 using H5.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n    have H2 : Real.sin (angle x z) \u2260 0 := by\r\n      grind [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi]\r\n    obtain hx | hx := eq_or_ne x 0\r\n    \u00b7 subst x; simp only [angle_zero_left, left_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H3, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H3.le\r\n      rw [\u2190 NNReal.smul_def, Submodule.span_insert_zero, Submodule.span_singleton_smul_eq]\r\n      \u00b7 simp\r\n      norm_cast at H3\r\n      grind [isUnit_iff_ne_zero]\r\n    obtain hz | hz := eq_or_ne z 0\r\n    \u00b7 subst z; simp only [angle_zero_right, right_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H1, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H1.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n",
      "body": "```suggestion\r\n      obtain \u27e8_, \u27e8r2, \u27e8H5, rfl\u27e9\u27e9\u27e9 := H2\r\n      lift r2 to \u211d\u22650 using H5.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n    have H2 : Real.sin (angle x z) \u2260 0 := by\r\n      grind [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi]\r\n    obtain hx | hx := eq_or_ne x 0\r\n    \u00b7 subst x; simp only [angle_zero_left, left_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H3, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H3.le\r\n      rw [\u2190 NNReal.smul_d",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp_all",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp",
          "norm_cast"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "simpa",
          "angle_le_angle_add_angle_of_norm_eq_one",
          "using",
          "norm_normalize_eq_one_iff"
        ]
      }
    },
    {
      "id": 2409,
      "before_code": "lemma pow_toEnd_f_eq_zero_of_eq_nat\n    [IsNoetherian R M] [NoZeroSMulDivisors R M] [IsDomain R] [CharZero R]\n    {n : \u2115} (hn : \u03bc = n) : (\u03c8 (n + 1)) = 0 := by\n  by_contra h\n  have : t.HasPrimitiveVectorWith (\u03c8 (n + 1)) (n - 2 * (n + 1) : R) :=",
      "suggestion": "  have : t.HasPrimitiveVectorWith (\u03c8 (n + 1)) (n - 2 * (n + 1) : R) :=\n",
      "body": "Same issue with outer parens too.\n```suggestion\n  have : t.HasPrimitiveVectorWith (\u03c8 (n + 1)) (n - 2 * (n + 1) : R) :=\n```",
      "path": "Mathlib/Algebra/Lie/Sl2.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "pow_toEnd_f_eq_zero_of_eq_nat",
          "lemma",
          "HasPrimitiveVectorWith",
          "have",
          "IsNoetherian",
          "IsDomain",
          "NoZeroSMulDivisors",
          "by_contra",
          "CharZero"
        ]
      }
    },
    {
      "id": 2415,
      "before_code": "exact \u27e8_, inferInstance, inferInstance,\n    (pres.bind pres').reindex (ShrinkHoms.equivalence _).inverse, fun k \u21a6 by simp [hp]\u27e9",
      "suggestion": "\r\nlemma of_colimitPresentation_of_essentiallySmall {X : C} {J : Type*} [Category* J] [EssentiallySmall.{w} J]\r\n",
      "body": "```suggestion\r\nlemma of_colimitPresentation_of_essentiallySmall {X : C} {J : Type*} [Category* J] [EssentiallySmall.{w} J]\r\n```\r\nI know this name is a bit ugly, but I think it\u2019s important to have a name with `colimitPresentation` in it.",
      "path": "Mathlib/CategoryTheory/ObjectProperty/Ind.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp"
        ],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "inferInstance",
          "bind",
          "exact",
          "ShrinkHoms",
          "equivalence",
          "reindex",
          "pres",
          "simp",
          "inverse"
        ]
      }
    },
    {
      "id": 2416,
      "before_code": "exact \u27e8_, inferInstance, inferInstance,\n    (pres.bind pres').reindex (ShrinkHoms.equivalence _).inverse, fun k \u21a6 by simp [hp]\u27e9",
      "suggestion": "\r\n      exact \u27e8CostructuredArrow.mk (Y := FullSubcategory.mk _ hW) v,\r\n        \u27e8CostructuredArrow.homMk \u27e8u\u27e9 huv\u27e9\u27e9\r\n",
      "body": "```suggestion\r\n      exact \u27e8CostructuredArrow.mk (Y := FullSubcategory.mk _ hW) v,\r\n        \u27e8CostructuredArrow.homMk \u27e8u\u27e9 huv\u27e9\u27e9\r\n```\r\nThe full subcategory refactor (#26446) broke this line, this suggestion fixes it against latest master.",
      "path": "Mathlib/CategoryTheory/ObjectProperty/Ind.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "inferInstance",
          "bind",
          "exact",
          "ShrinkHoms",
          "equivalence",
          "reindex",
          "pres",
          "simp",
          "inverse"
        ]
      }
    },
    {
      "id": 2420,
      "before_code": "(Set.univ : Set (G.Walk u v)).Nonempty :=\n  hconn.preconnected.set_univ_walk_nonempty u v",
      "suggestion": "\r\n  obtain \u27e8u, huv\u27e9 := exists_ne v\r\n  obtain \u27e8w\u27e9 := h v u\r\n  exact \u27e8w.snd, w.adj_snd (w.not_nil_of_ne huv.symm)\u27e9\r\n",
      "body": "```suggestion\r\n  obtain \u27e8u, huv\u27e9 := exists_ne v\r\n  obtain \u27e8w\u27e9 := h v u\r\n  exact \u27e8w.snd, w.adj_snd (w.not_nil_of_ne huv.symm)\u27e9\r\n```\r\nPersonally I prefer this version but these are style choices and are up to you:\r\n```suggestion\r\n  have \u27e8u, huv\u27e9 := exists_ne v\r\n  have \u27e8w\u27e9 := h v u\r\n  exact \u27e8_, w.adj_snd <| w.not_nil_of_ne huv.symm\u27e9\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Connected.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "obtain"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "exact",
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "Walk",
          "Nonempty",
          "univ",
          "hconn",
          "Set",
          "set_univ_walk_nonempty",
          "preconnected"
        ]
      }
    },
    {
      "id": 2421,
      "before_code": "(H \u2294 K).Connected :=\n  Subgraph.connected_sup hH.preconnected hK.preconnected hn",
      "suggestion": "\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degree_pos_of_nontrivial v\r\n",
      "body": "Even though you know the graph is nonempty I think it's better to assume the weaker `Preconnected` instead of `Connected`.\r\nAlso, the `by_contra` is redundant here.\r\n```suggestion\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degre",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa",
          "remove_redundant"
        ],
        "keywords": [
          "Connected",
          "connected_sup",
          "Subgraph",
          "preconnected"
        ]
      }
    },
    {
      "id": 2422,
      "before_code": "(H \u2294 K).Connected :=\n  Subgraph.connected_sup hH.preconnected hK.preconnected hn",
      "suggestion": "\r\nlemma Preconnected.exists_adj_of_nontrivial {H : G.Subgraph} [Nontrivial H.verts]\r\n    (h : H.Preconnected) (v : H.verts) : \u2203 u, H.Adj v u := by\r\n  have := h.coe.exists_adj_of_nontrivial v\r\n",
      "body": "```suggestion\r\nlemma Preconnected.exists_adj_of_nontrivial {H : G.Subgraph} [Nontrivial H.verts]\r\n    (h : H.Preconnected) (v : H.verts) : \u2203 u, H.Adj v u := by\r\n  have := h.coe.exists_adj_of_nontrivial v\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Connected",
          "connected_sup",
          "Subgraph",
          "preconnected"
        ]
      }
    },
    {
      "id": 2425,
      "before_code": "have h2 : 0 \u2264 r := nonneg_of_mul_nonneg_left h1 (dist_pos.mpr hab\u2081)\n    exact (sq_eq_sq\u2080 dist_nonneg (mul_nonneg h2 dist_nonneg)).mp h'",
      "suggestion": "\r\ntheorem exterior_angle_eq_angle_add_angle {p\u2081 p\u2082 p\u2083 : P} (p : P) (h : Sbtw \u211d p p\u2081 p\u2082) :\r\n    \u2220 p\u2083 p\u2081 p = \u2220 p\u2081 p\u2083 p\u2082 + \u2220 p\u2083 p\u2082 p\u2081 := by\r\n  have H := (EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n  rw [show \u2220 p\u2083 p\u2081 p\u2082 = \u2220 p\u2082 p\u2081 p\u2083 by simp only [angle_comm],\r\n      add_comm,\r\n      \u2190 angle_add_angle_add_angle_eq_pi p\u2083 ((Sbtw.right_ne h).symm),\r\n      add_assoc] at H\r\n  simp only [add_right_inj] at H\r\n  rw [H]\r\n",
      "body": "Thanks for the PR! I think we can shorten this proof. Here is a suggestion: \r\n```suggestion\r\ntheorem exterior_angle_eq_angle_add_angle {p\u2081 p\u2082 p\u2083 : P} (p : P) (h : Sbtw \u211d p p\u2081 p\u2082) :\r\n    \u2220 p\u2083 p\u2081 p = \u2220 p\u2081 p\u2083 p\u2082 + \u2220 p\u2083 p\u2082 p\u2081 := by\r\n  have H := (EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n  rw [show \u2220 p\u2083 p\u2081 p\u2082 = \u2220 p\u2082 p\u2081 p\u2083 by simp only [angle_comm],\r\n      add_comm,\r\n      \u2190 angle_add_angle_add_angle_eq_pi p\u2083 ((Sbtw.right_ne h).symm),\r\n      add_assoc] at",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "mpr",
          "nonneg_of_mul_nonneg_left",
          "exact",
          "have",
          "dist_pos",
          "dist_nonneg",
          "mul_nonneg"
        ]
      }
    },
    {
      "id": 2426,
      "before_code": "vsub_sub_vsub_cancel_right p\u2083 p\u2082 p\u2081, \u2190 vsub_sub_vsub_cancel_right p\u2082 p\u2083 p\u2081]\n  exact angle_add_angle_sub_add_angle_sub_eq_pi _ fun he => h (vsub_eq_zero_iff_eq.1 he)",
      "suggestion": "\r\n  have H := (angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n",
      "body": "This works, right?\r\n```suggestion\r\n  have H := (angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "vsub_eq_zero_iff_eq",
          "vsub_sub_vsub_cancel_right",
          "angle_add_angle_sub_add_angle_sub_eq_pi"
        ]
      }
    },
    {
      "id": 2427,
      "before_code": "vsub_sub_vsub_cancel_right p\u2083 p\u2082 p\u2081, \u2190 vsub_sub_vsub_cancel_right p\u2082 p\u2083 p\u2081]\n  exact angle_add_angle_sub_add_angle_sub_eq_pi _ fun he => h (vsub_eq_zero_iff_eq.1 he)",
      "suggestion": "\r\n  rw [angle_comm p\u2083 p\u2081 p\u2082, add_comm, \u2190 angle_add_angle_add_angle_eq_pi p\u2083 h.ne_right]\r\n",
      "body": "Please also use dot notation here. In fact, `ne_right` is shorter than `.right_ne.symm`:\r\n```suggestion\r\n  rw [angle_comm p\u2083 p\u2081 p\u2082, add_comm, \u2190 angle_add_angle_add_angle_eq_pi p\u2083 h.ne_right]\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "vsub_eq_zero_iff_eq",
          "vsub_sub_vsub_cancel_right",
          "angle_add_angle_sub_add_angle_sub_eq_pi"
        ]
      }
    },
    {
      "id": 2428,
      "before_code": "vsub_sub_vsub_cancel_right p\u2083 p\u2082 p\u2081, \u2190 vsub_sub_vsub_cancel_right p\u2082 p\u2083 p\u2081]\n  exact angle_add_angle_sub_add_angle_sub_eq_pi _ fun he => h (vsub_eq_zero_iff_eq.1 he)",
      "suggestion": "\r\n  linarith [angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 h.angle\u2081\u2082\u2083_eq_pi,\r\n    angle_add_angle_add_angle_eq_pi p\u2083 h.right_ne.symm, angle_comm p\u2083 p\u2081 p\u2082]\r\n",
      "body": "here is a golf\r\n```suggestion\r\n  linarith [angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 h.angle\u2081\u2082\u2083_eq_pi,\r\n    angle_add_angle_add_angle_eq_pi p\u2083 h.right_ne.symm, angle_comm p\u2083 p\u2081 p\u2082]\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "linarith"
        ],
        "body_tactics": [
          "linarith"
        ],
        "new_tactics": [
          "linarith"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "exact",
          "vsub_eq_zero_iff_eq",
          "vsub_sub_vsub_cancel_right",
          "angle_add_angle_sub_add_angle_sub_eq_pi"
        ]
      }
    },
    {
      "id": 2441,
      "before_code": "simp [sub_val_of_le hij, Nat.sub_lt_sub_right hij j.isLt]\n\nlemma castLT_sub_nezero {n : \u2115} {i j : Fin n} (hij : i < j) :\n    letI : NeZero (n - i.1) := neZero_iff.mpr (by lia)\n    (j - i).castLT (sub_val_lt_sub (Fin.le_of_lt hij)) \u2260 0 := by\n  refine Ne.symm (ne_of_val_ne ?_)\n  simpa [coe_sub_iff_le.mpr (Fin.le_of_lt hij)] using by lia\n\nlemma one_le_of_ne_zero {n : \u2115} [NeZero n] {k : Fin n} (hk : k \u2260 0) : 1 \u2264 k := by",
      "suggestion": "\r\n    haveI := k.neZero\r\n",
      "body": "Don't need type annotations.\r\n```suggestion\r\n    haveI := k.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "simp",
          "refine"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "lemma",
          "hij",
          "sub_val_lt_sub",
          "castLT",
          "le_of_lt",
          "symm",
          "refine",
          "Nat",
          "sub_lt_sub_right",
          "sub_val_of_le",
          "castLT_sub_nezero",
          "lia",
          "neZero_iff",
          "isLt",
          "simp",
          "letI",
          "NeZero",
          "ne_of_val_ne",
          "simpa",
          "one_le_of_ne_zero",
          "Fin",
          "coe_sub_iff_le",
          "using"
        ]
      }
    },
    {
      "id": 2442,
      "before_code": "simp [sub_val_of_le hij, Nat.sub_lt_sub_right hij j.isLt]\n\nlemma castLT_sub_nezero {n : \u2115} {i j : Fin n} (hij : i < j) :\n    letI : NeZero (n - i.1) := neZero_iff.mpr (by lia)\n    (j - i).castLT (sub_val_lt_sub (Fin.le_of_lt hij)) \u2260 0 := by\n  refine Ne.symm (ne_of_val_ne ?_)\n  simpa [coe_sub_iff_le.mpr (Fin.le_of_lt hij)] using by lia\n\nlemma one_le_of_ne_zero {n : \u2115} [NeZero n] {k : Fin n} (hk : k \u2260 0) : 1 \u2264 k := by\n  obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_succ_of_ne_zero (NeZero.ne n)\n  cases n with\n  | zero => simp only [Fin.isValue, Fin.zero_le]\n  | succ n => rwa [Fin.le_iff_val_le_val, Fin.val_one, Nat.one_le_iff_ne_zero, val_ne_zero_iff]\n\nlemma val_sub_one_of_ne_zero [NeZero n] {i : Fin n} (hi : i \u2260 0) : (i - 1).val = i - 1 := by",
      "suggestion": "\r\n    haveI := i.neZero\r\n",
      "body": "```suggestion\r\n    haveI := i.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "obtain",
          "refine",
          "simp",
          "cases"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "lemma",
          "rwa",
          "hij",
          "zero_le",
          "succ",
          "obtain",
          "sub_val_lt_sub",
          "castLT",
          "le_iff_val_le_val",
          "le_of_lt",
          "symm",
          "refine",
          "val_one",
          "Nat",
          "cases",
          "sub_lt_sub_right",
          "sub_val_of_le",
          "castLT_sub_nezero",
          "lia",
          "val_ne_zero_iff",
          "neZero_iff",
          "isLt",
          "isValue",
          "simp",
          "rfl",
          "zero",
          "val",
          "only",
          "letI",
          "one_le_iff_ne_zero",
          "val_sub_one_of_ne_zero",
          "NeZero",
          "ne_of_val_ne",
          "simpa",
          "one_le_of_ne_zero",
          "Fin",
          "exists_eq_succ_of_ne_zero",
          "coe_sub_iff_le",
          "using"
        ]
      }
    },
    {
      "id": 2443,
      "before_code": "simp [sub_val_of_le hij, Nat.sub_lt_sub_right hij j.isLt]\n\nlemma castLT_sub_nezero {n : \u2115} {i j : Fin n} (hij : i < j) :\n    letI : NeZero (n - i.1) := neZero_iff.mpr (by lia)\n    (j - i).castLT (sub_val_lt_sub (Fin.le_of_lt hij)) \u2260 0 := by\n  refine Ne.symm (ne_of_val_ne ?_)\n  simpa [coe_sub_iff_le.mpr (Fin.le_of_lt hij)] using by lia\n\nlemma one_le_of_ne_zero {n : \u2115} [NeZero n] {k : Fin n} (hk : k \u2260 0) : 1 \u2264 k := by\n  obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_succ_of_ne_zero (NeZero.ne n)\n  cases n with\n  | zero => simp only [Fin.isValue, Fin.zero_le]\n  | succ n => rwa [Fin.le_iff_val_le_val, Fin.val_one, Nat.one_le_iff_ne_zero, val_ne_zero_iff]\n\nlemma val_sub_one_of_ne_zero [NeZero n] {i : Fin n} (hi : i \u2260 0) : (i - 1).val = i - 1 := by",
      "suggestion": "\r\n  have := i.neZero\r\n",
      "body": "```suggestion\r\n  have := i.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "refine",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "lemma",
          "rwa",
          "hij",
          "zero_le",
          "succ",
          "obtain",
          "sub_val_lt_sub",
          "castLT",
          "le_iff_val_le_val",
          "le_of_lt",
          "symm",
          "refine",
          "val_one",
          "Nat",
          "cases",
          "sub_lt_sub_right",
          "sub_val_of_le",
          "castLT_sub_nezero",
          "lia",
          "val_ne_zero_iff",
          "neZero_iff",
          "isLt",
          "isValue",
          "simp",
          "rfl",
          "zero",
          "val",
          "only",
          "letI",
          "one_le_iff_ne_zero",
          "val_sub_one_of_ne_zero",
          "NeZero",
          "ne_of_val_ne",
          "simpa",
          "one_le_of_ne_zero",
          "Fin",
          "exists_eq_succ_of_ne_zero",
          "coe_sub_iff_le",
          "using"
        ]
      }
    },
    {
      "id": 2444,
      "before_code": "theorem val_cast_of_lt {n : \u2115} [NeZero n] {a : \u2115} (h : a < n) : (a : Fin n).val = a :=\n  Nat.mod_eq_of_lt h\n\n/-- If `n` is non-zero, converting the value of a `Fin n` to `Fin n` results\nin the same value. -/\n@[simp, norm_cast] theorem cast_val_eq_self {n : \u2115} [NeZero n] (a : Fin n) : (a.val : Fin n) = a :=",
      "suggestion": "\r\n    have := a.neZero\r\n",
      "body": "```suggestion\r\n    have := a.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "mod_eq_of_lt",
          "converting",
          "val_cast_of_lt",
          "theorem",
          "Nat",
          "results",
          "value",
          "NeZero",
          "same",
          "cast_val_eq_self",
          "non",
          "simp",
          "Fin",
          "zero",
          "val",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2445,
      "before_code": "theorem val_cast_of_lt {n : \u2115} [NeZero n] {a : \u2115} (h : a < n) : (a : Fin n).val = a :=\n  Nat.mod_eq_of_lt h\n\n/-- If `n` is non-zero, converting the value of a `Fin n` to `Fin n` results\nin the same value. -/\n@[simp, norm_cast] theorem cast_val_eq_self {n : \u2115} [NeZero n] (a : Fin n) : (a.val : Fin n) = a :=",
      "suggestion": "\r\n  have := a.neZero\r\n",
      "body": "```suggestion\r\n  have := a.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "mod_eq_of_lt",
          "converting",
          "val_cast_of_lt",
          "theorem",
          "Nat",
          "results",
          "value",
          "NeZero",
          "same",
          "cast_val_eq_self",
          "non",
          "simp",
          "Fin",
          "zero",
          "val",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2446,
      "before_code": "((ofNat(n) : Fin m) : \u2115) = ofNat(n) % m :=\n  rfl\n\ntheorem val_add_one_of_lt' {n : \u2115} [NeZero n] {i : Fin n} (h : i + 1 < n) :",
      "suggestion": "\r\n    haveI := i.neZero\r\n",
      "body": "```suggestion\r\n    haveI := i.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "ofNat",
          "NeZero",
          "Fin",
          "rfl",
          "val_add_one_of_lt"
        ]
      }
    },
    {
      "id": 2447,
      "before_code": "theorem val_cast_of_lt {n : \u2115} [NeZero n] {a : \u2115} (h : a < n) : (a : Fin n).val = a :=\n  Nat.mod_eq_of_lt h\n\n/-- If `n` is non-zero, converting the value of a `Fin n` to `Fin n` results\nin the same value. -/\n@[simp, norm_cast] theorem cast_val_eq_self {n : \u2115} [NeZero n] (a : Fin n) : (a.val : Fin n) = a :=",
      "suggestion": "\r\n    haveI := a.neZero\r\n",
      "body": "```suggestion\r\n    haveI := a.neZero\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "mod_eq_of_lt",
          "converting",
          "val_cast_of_lt",
          "theorem",
          "Nat",
          "results",
          "value",
          "NeZero",
          "same",
          "cast_val_eq_self",
          "non",
          "simp",
          "Fin",
          "zero",
          "val",
          "norm_cast"
        ]
      }
    },
    {
      "id": 2460,
      "before_code": "end Northcott",
      "suggestion": "  have : NeZero n := \u27e8hn\u27e9\n  suffices \u220f x \u2208 primitiveRoots n \u2102, max 1 \u2016x\u2016 = 1 by\n    simpa [mahlerMeasure_eq_leadingCoeff_mul_prod_roots, cyclotomic.monic n \u2102,\n      Polynomial.cyclotomic.roots_eq_primitiveRoots_val]\n  suffices \u2200 a \u2208 primitiveRoots n \u2102, \u2016a\u2016 \u2264 1 from Multiset.prod_eq_one (by simpa)\n  intro z hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le\n",
      "body": "```suggestion\n  have : NeZero n := \u27e8hn\u27e9\n  suffices \u220f x \u2208 primitiveRoots n \u2102, max 1 \u2016x\u2016 = 1 by\n    simpa [mahlerMeasure_eq_leadingCoeff_mul_prod_roots, cyclotomic.monic n \u2102,\n      Polynomial.cyclotomic.roots_eq_primitiveRoots_val]\n  suffices \u2200 a \u2208 primitiveRoots n \u2102, \u2016a\u2016 \u2264 1 from Multiset.prod_eq_one (by simpa)\n  intro z hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Northcott",
          "end"
        ]
      }
    },
    {
      "id": 2465,
      "before_code": "rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h",
      "suggestion": "\r\n  refine \u27e8fun h hn' \u21a6 ?_, fun h => separable_X_pow_sub_C_unit (Units.mk0 x hx) (IsUnit.mk0 _ h)\u27e9\r\n  exact not_isUnit_of_natDegree_pos (X ^ n - C x) (by simp [hn]) <| by\r\n    simpa [separable_def, derivative_X_pow, hn', isCoprime_zero_right] using h\r\n",
      "body": "````suggestion\r\n  refine \u27e8fun h hn' \u21a6 ?_, fun h => separable_X_pow_sub_C_unit (Units.mk0 x hx) (IsUnit.mk0 _ h)\u27e9\r\n  exact not_isUnit_of_natDegree_pos (X ^ n - C x) (by simp [hn]) <| by\r\n    simpa [separable_def, derivative_X_pow, hn', isCoprime_zero_right] using h\r\n````\r\nI know you copied the proof from the previous lemma, but that old proof is honestly pretty bizzare. Here's a shorter version doing exactly the same steps.",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "exact",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "exact",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "C_0",
          "isCoprime_zero_right",
          "not_isUnit_X_pow_sub_one",
          "zero_mul"
        ]
      }
    },
    {
      "id": 2466,
      "before_code": "rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h",
      "suggestion": "theorem X_pow_sub_C_separable_iff {n : \u2115} {x : F} (hn : 0 < n) (hx : x \u2260 0) :\n",
      "body": "````suggestion\ntheorem X_pow_sub_C_separable_iff {n : \u2115} {x : F} (hn : 0 < n) (hx : x \u2260 0) :\n````\nx can be inferred from both the goal and the other arguments.",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "C_0",
          "isCoprime_zero_right",
          "not_isUnit_X_pow_sub_one",
          "zero_mul"
        ]
      }
    },
    {
      "id": 2468,
      "before_code": "Separable (X ^ n - C a) :=\n  separable_X_pow_sub_C a (by rwa [\u2190 CharP.cast_eq_zero_iff F p n] at hn) ha",
      "suggestion": "\r\n/-- In a field `F`, for any `t \u2208 F` and `n > 0`, the polynomial `X ^ n - t` is separable\r\niff `\u2191n \u2260 0`. The assumption `n > 0` is needed, since for `n = 0` the polynomial `X ^ n - t`\r\nis separable iff `t \u2260 1`. -/\r\n",
      "body": "```suggestion\r\n/-- In a field `F`, for any `t \u2208 F` and `n > 0`, the polynomial `X ^ n - t` is separable\r\niff `\u2191n \u2260 0`. The assumption `n > 0` is needed, since for `n = 0` the polynomial `X ^ n - t`\r\nis separable iff `t \u2260 1`. -/\r\n```\r\nOther docstrings in the file don\u2019t align so I guess it\u2019s better to keep things consistent.",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rwa",
          "CharP",
          "separable_X_pow_sub_C",
          "cast_eq_zero_iff",
          "Separable"
        ]
      }
    },
    {
      "id": 2469,
      "before_code": "We apply it to both declarations, to have the same behavior as `to_additive`, and to shorten some\n  attribute commands. Note that `@[elementwise (attr := simp), reassoc (attr := simp)]` will try\n  to apply `simp` twice to the current declaration, but that causes no issues.",
      "suggestion": "\r\n* `docstringPrefix` will be prepended to the doc-string of `src` to form the doc-string of `tgt`.\r\n",
      "body": "```suggestion\r\n* `docstringPrefix` will be prepended to the doc-string of `src` to form the doc-string of `tgt`.\r\n```",
      "path": "Mathlib/Util/AddRelatedDecl.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp",
          "have"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "current",
          "try",
          "but",
          "shorten",
          "apply",
          "to_additive",
          "behavior",
          "Note",
          "have",
          "declarations",
          "causes",
          "elementwise",
          "attr",
          "both",
          "twice",
          "issues",
          "that",
          "simp",
          "will",
          "attribute",
          "same",
          "reassoc",
          "declaration",
          "commands",
          "some"
        ]
      }
    },
    {
      "id": 2472,
      "before_code": "rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]\n  grw [\u2190 le_max_left]",
      "suggestion": "  intro \u03b5 h\u03b5\n",
      "body": "You can also just use `intro` here if you want. Same below.\n```suggestion\n  intro \u03b5 h\u03b5\n```\nThanks!\nmaintainer delegate",
      "path": "Mathlib/MeasureTheory/Function/UniformIntegrable.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "intro"
        ],
        "body_tactics": [
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "norm_indicator_eq_indicator_norm",
          "grw",
          "le_max_left"
        ]
      }
    },
    {
      "id": 2473,
      "before_code": "\u00b7 rw [\u2190 ENNReal.tendsto_toNNReal_iff ENNReal.zero_ne_top (hfin \u03b5)]\n    exact h \u03b5 h\u03b5\n\nlemma TendstoInMeasure.mono [EDist E] {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E} {u v : Filter \u03b9} (huv : v \u2264 u)\n    (hg : TendstoInMeasure \u03bc f u g) : TendstoInMeasure \u03bc f v g :=\n  fun \u03b5 h\u03b5 => (hg \u03b5 h\u03b5).mono_left huv\n\nlemma TendstoInMeasure.comp [EDist E] {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E} {u : Filter \u03b9}\n    {v : Filter \u03ba} {ns : \u03ba \u2192 \u03b9} (hg : TendstoInMeasure \u03bc f u g) (hns : Tendsto ns v u) :\n    TendstoInMeasure \u03bc (f \u2218 ns) v g := fun \u03b5 h\u03b5 \u21a6 (hg \u03b5 h\u03b5).comp hns\n\nnamespace TendstoInMeasure\n\nvariable [EDist E] {l : Filter \u03b9} {f f' : \u03b9 \u2192 \u03b1 \u2192 E} {g g' : \u03b1 \u2192 E}",
      "suggestion": "    by_cases x \u2208 s <;> simp_all\n",
      "body": "```suggestion\n    by_cases x \u2208 s <;> simp_all\n```\nThis is a more standard spelling than `repeat`",
      "path": "Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "ENNReal",
          "lemma",
          "huv",
          "mono",
          "hfin",
          "variable",
          "exact",
          "Tendsto",
          "TendstoInMeasure",
          "mono_left",
          "Filter",
          "comp",
          "EDist",
          "hns",
          "zero_ne_top",
          "tendsto_toNNReal_iff",
          "namespace"
        ]
      }
    },
    {
      "id": 2478,
      "before_code": "| refl => exact hr _\n  | tail _ hbc ih => exact ht ih (h _ _ hbc)",
      "suggestion": "  simpa [reflTransGen_eq_self hr ht] using ReflTransGen.mono h h'\n",
      "body": "```suggestion\n  simpa [reflTransGen_eq_self hr ht] using ReflTransGen.mono h h'\n```\nThis is the proof that the lemma you removed used.",
      "path": "Mathlib/Logic/Relation.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "refl",
          "hbc",
          "tail"
        ]
      }
    },
    {
      "id": 2479,
      "before_code": "simp [LinearMap.comp_assoc]\n\nend Finsupp",
      "suggestion": "    coassoc := by ext; simp [coalgebraStruct] }\n",
      "body": "```suggestion\n    coassoc := by ext; simp [coalgebraStruct] }\n```",
      "path": "Mathlib/RingTheory/Coalgebra/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "end",
          "LinearMap",
          "comp_assoc",
          "simp"
        ]
      }
    },
    {
      "id": 2513,
      "before_code": "inf_iInf_nat_succ u\n\ntheorem iUnion_le_nat : \u22c3 n : \u2115, {i | i \u2264 n} = Set.univ :=\n subset_antisymm (Set.subset_univ _)\n   (fun i _ \u21a6 Set.mem_iUnion_of_mem i (Set.mem_setOf.mpr (le_refl _)))",
      "suggestion": "\r\n    fun i _ \u21a6 Set.mem_iUnion_of_mem i (Set.mem_setOf.mpr le_rfl)\r\n",
      "body": "```suggestion\r\n    fun i _ \u21a6 Set.mem_iUnion_of_mem i (Set.mem_setOf.mpr le_rfl)\r\n```",
      "path": "Mathlib/Data/Set/Lattice.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "theorem",
          "univ",
          "inf_iInf_nat_succ",
          "Set",
          "iUnion_le_nat",
          "subset_antisymm",
          "subset_univ",
          "le_refl",
          "mem_setOf",
          "mem_iUnion_of_mem"
        ]
      }
    },
    {
      "id": 2517,
      "before_code": "exactAt i' hi' :=\n    (K.exactAt_of_isSupported e i' hi').of_iso e'",
      "suggestion": "\r\n  simp [isSupported_iff, exactAt_iff_of_quasiIsoAt \u03c6]\r\n",
      "body": "```suggestion\r\n  simp [isSupported_iff, exactAt_iff_of_quasiIsoAt \u03c6]\r\n```",
      "path": "Mathlib/Algebra/Homology/Embedding/IsSupported.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exactAt",
          "of_iso",
          "exactAt_of_isSupported"
        ]
      }
    },
    {
      "id": 2518,
      "before_code": "end Zero",
      "suggestion": "    (ne : (proj \u207b\u00b9' s).Nonempty) : Pretrivialization F (s.restrictPreimage proj) where\n",
      "body": "Do we really want to have the power to control the junk values? If not, how about just:\n```suggestion\n    (ne : (proj \u207b\u00b9' s).Nonempty) : Pretrivialization F (s.restrictPreimage proj) where\n```\nand then `else \u27e8ne.some, Nonempty.some_mem ne\u27e9` instead of `else c x` below?",
      "path": "Mathlib/Topology/FiberBundle/Trivialization.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Zero",
          "end"
        ]
      }
    },
    {
      "id": 2523,
      "before_code": "end",
      "suggestion": "    refine J.superset_covering ?_ hs\n    dsimp [Sieve.overEquiv]\n    simp only [\u2190 Sieve.functorPushforward_comp, \u2190 Over.iteratedSliceForward_forget]\n    have := (Sieve.essSurjFullFunctorGaloisInsertion f.iteratedSliceEquiv.functor _).l_u_eq s\n    dsimp at this\n    simp only [Sieve.functorPushforward_comp]\n    rw [this]\n",
      "body": "```suggestion\n    refine J.superset_covering ?_ hs\n    dsimp [Sieve.overEquiv]\n    simp only [\u2190 Sieve.functorPushforward_comp, \u2190 Over.iteratedSliceForward_forget]\n    have := (Sieve.essSurjFullFunctorGaloisInsertion f.iteratedSliceEquiv.functor _).l_u_eq s\n    dsimp at this\n    simp only [Sieve.functorPushforward_comp]\n    rw [this]\n```\n\nA similar golf to the one above works here as well.",
      "path": "Mathlib/CategoryTheory/Sites/Over.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2525,
      "before_code": "PreservesSheafification.transport (A := A) J\n    ((equivSmallModel C).inverse.inducedTopology J) (equivSmallModel C).inverse B F",
      "suggestion": "    constructor\n    \u00b7 intro H\n      refine J.superset_covering ?_ (e.functor.cover_lift J K H)\n      rw [(Sieve.fullyFaithfulFunctorGaloisCoinsertion e.functor X).u_l_eq S]\n    \u00b7 intro H\n      refine K.superset_covering ?_\n        (e.inverse.cover_lift K J (J.pullback_stable (inv <| e.unit.app X) H))\n      intro Y f (H : S _)\n      refine \u27e8_, _, inv (e.counit.app Y), H, ?_\u27e9\n      simp only [comp_obj, id_obj, map_comp, Equivalence.fun_inv_map, \u2190 Category.assoc,\n        Functor.map_inv, IsIso.inv_hom_id, Category.id_comp, \u2190 IsIso.comp_inv_eq, IsIso.inv_inv,\n        NatIso.inv_inv_app]\n      simp\n",
      "body": "```suggestion\n    constructor\n    \u00b7 intro H\n      refine J.superset_covering ?_ (e.functor.cover_lift J K H)\n      rw [(Sieve.fullyFaithfulFunctorGaloisCoinsertion e.functor X).u_l_eq S]\n    \u00b7 intro H\n      refine K.superset_covering ?_\n        (e.inverse.cover_lift K J (J.pullback_stable (inv <| e.unit.app X) H))\n      intro Y f (H : S _)\n      refine \u27e8_, _, inv (e.counit.app Y), H, ?_\u27e9\n      simp only [comp_obj, id_obj, map_comp, Equivalence.fun_inv_map, \u2190 Category.assoc,\n        Functor.map_i",
      "path": "Mathlib/CategoryTheory/Sites/Equivalence.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "constructor"
        ],
        "body_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "constructor"
        ],
        "new_tactics": [
          "rw",
          "refine",
          "simp",
          "intro",
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "inducedTopology",
          "PreservesSheafification",
          "transport",
          "equivSmallModel",
          "inverse"
        ]
      }
    },
    {
      "id": 2529,
      "before_code": "(h : \u2200 F : Set \u03a9, IsClosed F \u2192\n      limsup (fun i \u21a6 (\u03bcs i : Measure \u03a9).real F) L \u2264 (\u03bc : Measure \u03a9).real F) :\n    Tendsto \u03bcs L (\ud835\udcdd \u03bc) := by\n  refine tendsto_of_forall_isClosed_limsup_le' fun F hF \u21a6 ?_\n  rcases L.eq_or_neBot with rfl | hne\n  \u00b7 simp\n  specialize h F hF\n  simp only [Measure.real_def] at h\n  rwa [ENNReal.limsup_toReal_eq (b := 1) (by simp) (.of_forall fun i \u21a6 prob_le_one),\n    ENNReal.toReal_le_toReal _ (by finiteness)] at h\n  refine ne_top_of_le_ne_top (b := 1) (by simp) ?_\n  refine limsup_le_of_le ?_ (.of_forall fun i \u21a6 prob_le_one)\n  exact isCoboundedUnder_le_of_le L (x := 0) (by simp)",
      "suggestion": "Tendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n",
      "body": "````suggestion\nTendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n````",
      "path": "Mathlib/MeasureTheory/Measure/Portmanteau.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "simp",
          "refine"
        ],
        "topics": [
          "measurability",
          "order",
          "topology"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "of_forall",
          "rwa",
          "real",
          "rcases",
          "limsup_le_of_le",
          "finiteness",
          "refine",
          "specialize",
          "real_def",
          "Measure",
          "isCoboundedUnder_le_of_le",
          "limsup",
          "eq_or_neBot",
          "hne",
          "Tendsto",
          "simp",
          "prob_le_one",
          "rfl",
          "IsClosed",
          "only",
          "ne_top_of_le_ne_top",
          "ENNReal",
          "exact",
          "Set",
          "tendsto_of_forall_isClosed_limsup_le",
          "limsup_toReal_eq",
          "toReal_le_toReal"
        ]
      }
    },
    {
      "id": 2530,
      "before_code": "\u222b\u207b b in s, Kernel.condKernel \u03ba (a, b) t \u2202(Kernel.fst \u03ba a) = \u03ba a (s \u00d7\u02e2 t) := by\n  have : \u03ba a (s \u00d7\u02e2 t) = (Kernel.fst \u03ba \u2297\u2096 Kernel.condKernel \u03ba) a (s \u00d7\u02e2 t) := by\n    congr; exact (\u03ba.disintegrate _).symm\n  rw [this, Kernel.compProd_apply (hs.prod ht)]\n  classical\n  have : \u2200 b, Kernel.condKernel \u03ba (a, b) {c | (b, c) \u2208 s \u00d7\u02e2 t}\n      = s.indicator (fun b \u21a6 Kernel.condKernel \u03ba (a, b) t) b := by\n    intro b\n    by_cases hb : b \u2208 s <;> simp [hb]\n  simp_rw [Set.preimage, this]\n  rw [lintegral_indicator hs]",
      "suggestion": "simpa [this] using (Kernel.compProd_apply_prod hs ht).symm\n",
      "body": "````suggestion\nsimpa [this] using (Kernel.compProd_apply_prod hs ht).symm\n````",
      "path": "Mathlib/Probability/Kernel/Disintegration/Integral.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "have",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "compProd_apply",
          "classical",
          "condKernel",
          "symm",
          "by_cases",
          "fst",
          "have",
          "lintegral_indicator",
          "intro",
          "preimage",
          "simp_rw",
          "prod",
          "Kernel",
          "disintegrate",
          "simp",
          "congr",
          "indicator",
          "exact",
          "Set",
          "this"
        ]
      }
    },
    {
      "id": 2532,
      "before_code": "refine (e.forall_congr ?_).symm\n    intro i\n    rw [MeasurableEquiv.piCongrLeft_apply_apply e x i]\n  rw [this, pi_pi, Finset.prod_equiv e.symm]\n  \u00b7 simp only [Finset.mem_univ, implies_true]\n  intro i _\n  simp only [s']\n  congr\n  all_goals rw [e.apply_symm_apply]",
      "suggestion": "\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n",
      "body": "````suggestion\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n````",
      "path": "Mathlib/MeasureTheory/Constructions/Pi.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "topics": [
          "measurability",
          "set_theory",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply_symm_apply",
          "symm",
          "refine",
          "all_goals",
          "mem_univ",
          "forall_congr",
          "piCongrLeft_apply_apply",
          "Finset",
          "implies_true",
          "pi_pi",
          "congr",
          "this",
          "simp",
          "intro",
          "MeasurableEquiv",
          "prod_equiv",
          "only"
        ]
      }
    },
    {
      "id": 2535,
      "before_code": "def restr {k n : \u2115} (f : MultilinearMap R (fun _ : Fin n => M') M\u2082) (s : Finset (Fin n))\n    (hk : #s = k) (z : M') : MultilinearMap R (fun _ : Fin k => M') M\u2082 where\n  toFun v := f fun j => if h : j \u2208 s then v ((s.orderIsoOfFin hk).symm \u27e8j, h\u27e9) else z\n  map_update_add' v i x y := by\n    erw [dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv]\n    simp\n  map_update_smul' v i c x := by\n    erw [dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv]\n    simp",
      "suggestion": "    rw [OrderIso.coe_symm_toEquiv] at this\n    simp [this]\n",
      "body": "Noting that here and below one could also write:\n```suggestion\n    rw [OrderIso.coe_symm_toEquiv] at this\n    simp [this]\n```\nthough personally I prefer the `simp_all`",
      "path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "erw",
          "restr",
          "MultilinearMap",
          "symm",
          "else",
          "def",
          "then",
          "Finset",
          "toFun",
          "map_update_smul",
          "orderIsoOfFin",
          "map_update_add",
          "simp",
          "toEquiv",
          "Fin",
          "dite_comp_equiv_update"
        ]
      }
    },
    {
      "id": 2538,
      "before_code": "eq_of_fin_equiv e := le_antisymm (le_of_fin_surjective R e.symm.toLinearMap e.symm.surjective)\n    (le_of_fin_surjective R e.toLinearMap e.surjective)",
      "suggestion": "/-- A semiring `R` satisfies the strong rank condition, iff we cannot embed `R^(\u2115)` in some `R\u207f`. -/\ntheorem strongRankCondition_iff_forall_not_injective :\n    StrongRankCondition R \u2194 \u2200 n (f : (\u2115 \u2192\u2080 R) \u2192\u2097[R] Fin n \u2192 R), \u00ac Injective f := by\n",
      "body": "```suggestion\n/-- A semiring `R` satisfies the strong rank condition, iff we cannot embed `R^(\u2115)` in some `R\u207f`. -/\ntheorem strongRankCondition_iff_forall_not_injective :\n    StrongRankCondition R \u2194 \u2200 n (f : (\u2115 \u2192\u2080 R) \u2192\u2097[R] Fin n \u2192 R), \u00ac Injective f := by\n```",
      "path": "Mathlib/LinearAlgebra/InvariantBasisNumber.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "le_antisymm",
          "eq_of_fin_equiv",
          "le_of_fin_surjective",
          "toLinearMap",
          "surjective"
        ]
      }
    },
    {
      "id": 2539,
      "before_code": "dualDistrib R M N (f \u2297\u209c g) (m \u2297\u209c n) = f m * g n :=\n  rfl",
      "suggestion": "lemma dualDistrib_apply_comm (w : Dual R N \u2297[R] Dual R M) (z : M \u2297[R] N) :\n    dualDistrib R N M w (TensorProduct.comm R M N z) =\n       dualDistrib R M N (TensorProduct.comm R _ _ w) z := by\n  induction w <;> induction z <;> simp_all [mul_comm]\n",
      "body": "How about:\n```suggestion\nlemma dualDistrib_apply_comm (w : Dual R N \u2297[R] Dual R M) (z : M \u2297[R] N) :\n    dualDistrib R N M w (TensorProduct.comm R M N z) =\n       dualDistrib R M N (TensorProduct.comm R _ _ w) z := by\n  induction w <;> induction z <;> simp_all [mul_comm]\n```",
      "path": "Mathlib/LinearAlgebra/Dual/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "induction",
          "simp_all"
        ],
        "body_tactics": [
          "induction",
          "simp_all"
        ],
        "new_tactics": [
          "induction",
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "dualDistrib"
        ]
      }
    },
    {
      "id": 2549,
      "before_code": "end IsTightMeasureSet",
      "suggestion": "  rw [\u2190 coe_ofNat, \u2190 ENNReal.coe_zpow (by simp), \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n",
      "body": "Please mind the spacing. You can put the `simp` inside the `rw`. Also you don't need the `ENNReal` namespace.\n```suggestion\n  rw [\u2190 coe_ofNat, \u2190 ENNReal.coe_zpow (by simp), \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsTightMeasureSet",
          "end"
        ]
      }
    },
    {
      "id": 2552,
      "before_code": "end IsTightMeasureSet",
      "suggestion": "    simp [add_comm]\n",
      "body": "```suggestion\n    simp [add_comm]\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsTightMeasureSet",
          "end"
        ]
      }
    },
    {
      "id": 2556,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "private lemma lt_geom_series {D : \u2115 \u2192 \ud835\udce7} {\u03b5 : \u211d\u22650\u221e} {\u03bc : ProbabilityMeasure \ud835\udce7} {km : \u2115 \u2192 \u2115}\n    {u : \u2115 \u2192 \u211d} (hu_anti : Antitone u)\n    (hbound : \u2200 k : \u2115, 1 - \u03b5 * 2 ^ (-k : \u2124) < \u03bc (\u22c3 i \u2264 km k, ball (D i) (u k))) :\n    \u2211' (m : \u2115), (1 - \u03bc.toMeasure (\u22c3 i \u2264 km (m + 1), closure (ball (D i) (u m)))) \u2264\n    \u2211' (m : \u2115), (\u03b5 : \u211d\u22650\u221e) * 2 ^ (-((m : \u2124) + 1)) := by\n  refine ENNReal.tsum_le_tsum fun m \u21a6 tsub_le_iff_tsub_le.mp ?_\n  specialize hbound (m+1)\n  apply le_of_lt at hbound\n  simp_all only [neg_add_rev, Int.reduceNeg, tsub_le_iff_right, Nat.cast_add, Nat.cast_one,\n      \u2190 coe_ofNat, \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n  grw [hbound]\n  gcongr\n  \u00b7 refine apply_mono \u03bc <| iUnion\u2082_mono <| fun i hi \u21a6 ?_\n    grw [\u2190 subset_closure (s := ball (D i) (u m)), ball_subset_ball]\n    exact hu_anti (by grind)\n",
      "body": "Changes:\n- use a generic antitone sequence `u` instead of `1/(m+1)`\n- spacing of the statement\n- some spaces added (after `\u2190`, before `:=`)\n```suggestion\nprivate lemma lt_geom_series {D : \u2115 \u2192 \ud835\udce7} {\u03b5 : \u211d\u22650\u221e} {\u03bc : ProbabilityMeasure \ud835\udce7} {km : \u2115 \u2192 \u2115}\n    {u : \u2115 \u2192 \u211d} (hu_anti : Antitone u)\n    (hbound : \u2200 k : \u2115, 1 - \u03b5 * 2 ^ (-k : \u2124) < \u03bc (\u22c3 i \u2264 km k, ball (D i) (u k))) :\n    \u2211' (m : \u2115), (1 - \u03bc.toMeasure (\u22c3 i \u2264 km (m + 1), closure (ball (D i) (u m)))) \u2264\n    \u2211' (m : \u2115), (\u03b5 : \u211d\u22650\u221e) * 2 ^ (-((m : \u2124) + 1)) ",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "grind",
          "simp_all"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "grind",
          "simp_all"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "grind",
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2557,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "theorem isTightMeasureSet_of_isCompact_closure (hcomp : IsCompact (closure S)) :\n    IsTightMeasureSet {((\u03bc : ProbabilityMeasure \ud835\udce7) : Measure \ud835\udce7) | \u03bc \u2208 S} := by\n  rw [IsTightMeasureSet_iff_exists_isCompact_measure_compl_le]\n  rcases isEmpty_or_nonempty \ud835\udce7 with hempty | hempty\n  \u00b7 intro \u03b5 \u03b5pos\n    use \u2205\n    constructor\n    \u00b7 exact isCompact_empty\n    rw [\u2190 univ_eq_empty_iff] at hempty\n    simp only [mem_setOf_eq, compl_empty, hempty, measure_empty, zero_le, implies_true]\n  obtain \u27e8D, hD\u27e9 := exists_dense_seq \ud835\udce7\n  obtain \u27e8u, hu_anti, hu_pos, hu\u27e9 : \u2203 u, StrictAnti u \u2227 (\u2200 n, 0 < u n) \u2227 Tendsto u atTop (\ud835\udcdd 0) :=\n    exists_seq_strictAnti_tendsto (0 : \u211d)\n  have hcov (m : \u2115) : \u22c3 i, ball (D i) (u m) = univ := by\n    rw [denseRange_iff] at hD\n    ext p\n    exact \u27e8fun a \u21a6 trivial, fun _ \u21a6 mem_iUnion.mpr <| hD p (u m) (hu_pos m)\u27e9\n  intro \u03b5 \u03b5pos\n  by_cases h\u03b5bound : 1 < \u03b5\n  \u00b7 use \u2205\n    constructor\n    \u00b7 exact isCompact_empty\n    intro \u03bc h\u03bc\n    simp only [mem_setOf_eq] at h\u03bc\n    obtain \u27e8\u03bc', h\u03bc', rfl\u27e9 :=",
      "body": "Changes:\n- use a generic sequence `u` with `StrictAnti u \u2227 (\u2200 n, 0 < u n) \u2227 Tendsto u atTop (\ud835\udcdd 0)` instead of `1/(m+1)`. It leads to shorter expressions and makes it easier to see what are the properties used. Also replace the inverse of delta by `have \u27e8\u03b4_inv, h\u03b4_inv\u27e9 : \u2203 x, u x < \u03b4`.\n- use `simpa` more\n- fix spaces here and there\n- replace instances of `use x; constructor; intro y`... on multiple lines by a one-line `refine`\n```suggestion\ntheorem isTightMeasureSet_of_isCompact_closure (hcomp : ",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "ext",
          "exact",
          "cases",
          "linarith",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "constructor",
          "intro",
          "congr",
          "measurability",
          "ring_nf"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "ext",
          "exact",
          "cases",
          "linarith",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "constructor",
          "intro",
          "congr",
          "measurability",
          "ring_nf"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "simp",
          "congr",
          "measurability",
          "ring_nf",
          "apply",
          "gcongr",
          "refine",
          "ext",
          "cases",
          "have",
          "simpa",
          "constructor",
          "intro",
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_simpa",
          "use_linarith",
          "cleanup_simp"
        ],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2558,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "variable [PseudoMetricSpace \ud835\udce7] [OpensMeasurableSpace \ud835\udce7] [SeparableSpace \ud835\udce7]\n  (S : Set (ProbabilityMeasure \ud835\udce7))\n",
      "body": "We can delete that auxiliary lemma and inline it in the bigger proof. It's small enough and it brings nothing on its own.\n\nLet's also remove the `noncomputable section`. There is no definition here, so the `noncomputable` does nothing.\n\nThe docstring of `SeparableSpace` says we should use `SecondCountableTopology` instead when they are equivalent. Is it the case here?\n\n```suggestion\nvariable [PseudoMetricSpace \ud835\udce7] [OpensMeasurableSpace \ud835\udce7] [SeparableSpace \ud835\udce7]\n  (S : Set (ProbabilityMeasure \ud835\udce7))\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2559,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  have \u03b5fin : \u03b5 \u2260 \u221e := ne_top_of_le_ne_top (by simp) h\u03b5bound\n",
      "body": "- use `\u221e` for top in ENNReal\n- shorter proof\n```suggestion\n  have \u03b5fin : \u03b5 \u2260 \u221e := ne_top_of_le_ne_top (by simp) h\u03b5bound\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2560,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  obtain \u27e8\u03b5, h\u03b5'\u27e9 := \u03b5\n",
      "body": "```suggestion\n  obtain \u27e8\u03b5, h\u03b5'\u27e9 := \u03b5\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2561,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  have Measurebound n : (\u03bclim (\u22c3 (i \u2264 n), U i) : \u211d) \u2264 1 - \u03b5 := calc\n",
      "body": "For readability, let's add the type.\n```suggestion\n  have Measurebound n : (\u03bclim (\u22c3 (i \u2264 n), U i) : \u211d) \u2264 1 - \u03b5 := calc\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2562,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "            fun _ d hyp \u21a6 (hyp d (by simp)).trans (by simp)\n",
      "body": "```suggestion\n            fun _ d hyp \u21a6 (hyp d (by simp)).trans (by simp)\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2563,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "    simp_rw [\u2190 Set.accumulate_def, ProbabilityMeasure.tendsto_measure_iUnion_accumulate]\n",
      "body": "```suggestion\n    simp_rw [\u2190 Set.accumulate_def, ProbabilityMeasure.tendsto_measure_iUnion_accumulate]\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2564,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "      Tendsto.eventually_const_le (v := 1) (by simp; positivity) accumulation\n",
      "body": "```suggestion\n      Tendsto.eventually_const_le (v := 1) (by simp; positivity) accumulation\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "positivity",
          "simp"
        ],
        "body_tactics": [
          "positivity",
          "simp"
        ],
        "new_tactics": [
          "positivity",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2566,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  \u00b7 rw [\u2190 univ_eq_empty_iff] at hempty\n    exact fun \u03b5 \u03b5pos \u21a6 \u27e8\u2205, isCompact_empty, by simp [hempty]\u27e9\n",
      "body": "```suggestion\n  \u00b7 rw [\u2190 univ_eq_empty_iff] at hempty\n    exact fun \u03b5 \u03b5pos \u21a6 \u27e8\u2205, isCompact_empty, by simp [hempty]\u27e9\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 2588,
      "before_code": "@[inherit_doc] infixl:50 \" \u21aag \" => Embedding\n@[inherit_doc] infixl:50 \" \u2243g \" => Iso",
      "suggestion": "\r\nabbrev HomClass (F : Type*) (G : SimpleGraph V) (H : SimpleGraph W) [FunLike F V W] :=\r\n",
      "body": "```suggestion\r\nabbrev HomClass (F : Type*) (G : SimpleGraph V) (H : SimpleGraph W) [FunLike F V W] :=\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Maps.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "infixl",
          "Iso",
          "Embedding",
          "inherit_doc"
        ]
      }
    },
    {
      "id": 2589,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "theorem continuousOn_arcosh : ContinuousOn arcosh (Ici 1) :=\n  have {x : \u211d} (hx : x \u2208 Ici 1) : 0 < x + \u221a(x ^ 2 - 1) :=\n    add_pos_of_pos_of_nonneg (show 0 < x by grind) (sqrt_nonneg _)\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (fun _ _ => by grind)\n",
      "body": "It's very minor, but why not?\n\n```suggestion\ntheorem continuousOn_arcosh : ContinuousOn arcosh (Ici 1) :=\n  have {x : \u211d} (hx : x \u2208 Ici 1) : 0 < x + \u221a(x ^ 2 - 1) :=\n    add_pos_of_pos_of_nonneg (show 0 < x by grind) (sqrt_nonneg _)\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (fun _ _ => by grind)\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "body_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "new_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 2591,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "\r\n  rw [\u2190 sinh_arcosh (le_of_lt hx)]\r\n  refine coshOpenPartialHomeomorph.hasStrictDerivAt_symm hx ?_ (hasStrictDerivAt_cosh _)\r\n  rw [ne_eq, sinh_eq_zero]\r\n  exact ne_of_gt (arcosh_pos hx)\r\n",
      "body": "I really like `convert`, but AFAIK it's usually considered brittle and Mathlib prefers to avoid it if it's not too difficult.\r\n```suggestion\r\n  rw [\u2190 sinh_arcosh (le_of_lt hx)]\r\n  refine coshOpenPartialHomeomorph.hasStrictDerivAt_symm hx ?_ (hasStrictDerivAt_cosh _)\r\n  rw [ne_eq, sinh_eq_zero]\r\n  exact ne_of_gt (arcosh_pos hx)\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "new_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 2592,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "\r\n  exact (arcosh_pos hx).ne'\r\n",
      "body": "```suggestion\r\n  exact (arcosh_pos hx).ne'\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 2597,
      "before_code": "theorem degree_add (a b : \u03c3 \u2192\u2080 R) : (a + b).degree = a.degree + b.degree :=\n  sum_add_index' (h := fun _ \u21a6 id) (congrFun rfl) fun _ _ \u21a6 congrFun rfl",
      "suggestion": "  refine s.induction rfl ?_\n",
      "body": "```suggestion\n  refine s.induction rfl ?_\n```",
      "path": "Mathlib/Data/Finsupp/Weight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "induction",
          "refine"
        ],
        "body_tactics": [
          "induction",
          "refine"
        ],
        "new_tactics": [
          "induction",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "degree_add",
          "theorem",
          "sum_add_index",
          "congrFun",
          "rfl",
          "degree"
        ]
      }
    },
    {
      "id": 2602,
      "before_code": "variable {R : Type*} [AddCommMonoid R]\n\n/-- The degree of a finsupp function. -/\ndef degree (d : \u03c3 \u2192\u2080 R) : R := \u2211 i \u2208 d.support, d i\n\ntheorem degree_eq_sum [Fintype \u03c3] (f : \u03c3 \u2192\u2080 R) : f.degree = \u2211 i, f i := by\n  rw [degree, Finset.sum_subset] <;> simp",
      "suggestion": "  rw [degree_def, Finset.sum_subset] <;> simp\n",
      "body": "```suggestion\n  rw [degree_def, Finset.sum_subset] <;> simp\n```",
      "path": "Mathlib/Data/Finsupp/Weight.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "support",
          "AddCommMonoid",
          "function",
          "def",
          "variable",
          "theorem",
          "Finset",
          "sum_subset",
          "Type",
          "degree_eq_sum",
          "Fintype",
          "simp",
          "degree",
          "finsupp"
        ]
      }
    },
    {
      "id": 2603,
      "before_code": "theorem isHomogeneous_C (r : R) : IsHomogeneous (C r : MvPolynomial \u03c3 R) 0 := by\n  apply isHomogeneous_monomial\n  simp only [Finsupp.degree, Finsupp.zero_apply, Finset.sum_const_zero]",
      "suggestion": "  simp only [Finsupp.degree_def, Finsupp.zero_apply, Finset.sum_const_zero]\n",
      "body": "```suggestion\n  simp only [Finsupp.degree_def, Finsupp.zero_apply, Finset.sum_const_zero]\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Homogeneous.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "list",
          "order",
          "finset"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Finsupp",
          "apply",
          "MvPolynomial",
          "theorem",
          "Finset",
          "zero_apply",
          "isHomogeneous_C",
          "sum_const_zero",
          "IsHomogeneous",
          "simp",
          "degree",
          "only",
          "isHomogeneous_monomial"
        ]
      }
    },
    {
      "id": 2605,
      "before_code": "end",
      "suggestion": "\r\n  letI gen : M.GeneratingSections :=\r\n    { I := \u03c3\r\n      s := M.freeHomEquiv g\r\n      epi := by simpa using epi_of_isColimit_cofork H'}\r\n  haveI eq_aux : gen.\u03c0 = g := Equiv.symm_apply_apply M.freeHomEquiv g\r\n  haveI comp_zero : f \u226b gen.\u03c0 = 0 := eq_aux \u25b8 H\r\n  { generators := gen\r\n    relations :=\r\n      { I := \u03b9\r\n        s := (kernel gen.\u03c0).freeHomEquiv <| kernel.lift gen.\u03c0 f comp_zero\r\n        epi := by\r\n          let h : cokernel f \u2245 M := (H'.coconePointUniqueUpToIso (colimit.isColimit _)).symm\r\n          let h' : Abelian.image f \u2245 kernel gen.\u03c0 :=\r\n            kernel.mapIso (cokernel.\u03c0 f) gen.\u03c0 (Iso.refl _) h (by simp [h, eq_aux])\r\n          have comp_aux : Abelian.factorThruImage f \u226b h'.hom =\r\n            (kernel.lift gen.\u03c0 f comp_zero) := equalizer.hom_ext <| by simp [h']\r\n          rw [\u2190 comp_aux, Equiv.symm_apply_apply]\r\n          infer_instance }}\r\n",
      "body": "```suggestion\r\n  letI gen : M.GeneratingSections :=\r\n    { I := \u03c3\r\n      s := M.freeHomEquiv g\r\n      epi := by simpa using epi_of_isColimit_cofork H'}\r\n  haveI eq_aux : gen.\u03c0 = g := Equiv.symm_apply_apply M.freeHomEquiv g\r\n  haveI comp_zero : f \u226b gen.\u03c0 = 0 := eq_aux \u25b8 H\r\n  { generators := gen\r\n    relations :=\r\n      { I := \u03b9\r\n        s := (kernel gen.\u03c0).freeHomEquiv <| kernel.lift gen.\u03c0 f comp_zero\r\n        epi := by\r\n          let h : cokernel f \u2245 M := (H'.coconePointUniqueUpToIso (colimit.is",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2606,
      "before_code": "end",
      "suggestion": "\r\ndef Presentation.isColimit {M : SheafOfModules.{u} R} (P : Presentation M) :\r\n    IsColimit (CokernelCofork.of\u03c0\r\n      (f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))\r\n      P.generators.\u03c0 (by simp)) :=\r\n  isCokernelEpiComp (c := CokernelCofork.of\u03c0 _ (kernel.condition P.generators.\u03c0))\r\n      (Abelian.epiIsCokernelOfKernel _ <| limit.isLimit _) _ rfl\r\n",
      "body": "I find it a bit akward to state things using this Sigma-type given that here all the data are explicit and already known:\r\n\r\n```suggestion\r\ndef Presentation.isColimit {M : SheafOfModules.{u} R} (P : Presentation M) :\r\n    IsColimit (CokernelCofork.of\u03c0\r\n      (f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))\r\n      P.generators.\u03c0 (by simp)) :=\r\n  isCokernelEpiComp (c := CokernelCofork.of\u03c0 _ (kernel.condition P.generators.\u03c0))\r\n      (Abelian.epiIsCokernelOfKernel _ <| limit.isLimit _) _ rf",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2607,
      "before_code": "end",
      "suggestion": "\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map f \u226b\r\n    (PreservesCoproduct.iso F _).hom \u226b (Sigma.mapIso fun b \u21a6 hf').hom\r\n  letI g_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map g\r\n  haveI H' : f_new \u226b g_new = 0 := by\r\n    simp_rw [f_new, g_new, Category.assoc, Iso.hom_inv_id_assoc,\r\n      Preadditive.IsIso.comp_left_eq_zero, IsHomLift.eq_of_isHomLift F (F.map f \u226b F.map g) (f \u226b g),\r\n      H, Functor.map_zero]\r\n  letI h' : IsColimit (CokernelCofork.of\u03c0 g_new H') := by\r\n    refine IsColimit.ofIsoColimit ((IsColimit.precomposeHom",
      "body": "This suggestion uses the modification suggested above for `Presentation.isColimit`\r\n\r\n```suggestion\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_ne",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2610,
      "before_code": "end",
      "suggestion": "/-- Given two morphisms of sheaves of `R`-modules `f : free \u03b9 \u27f6 free \u03c3` and `g : free \u03c3 \u27f6 M`\nsatisfying `H : f \u226b g = 0` and `IsColimit (CokernelCofork.of\u03c0 g H)`, we obtain a `Presentation M`. -/\n",
      "body": "```suggestion\n/-- Given two morphisms of sheaves of `R`-modules `f : free \u03b9 \u27f6 free \u03c3` and `g : free \u03c3 \u27f6 M`\nsatisfying `H : f \u226b g = 0` and `IsColimit (CokernelCofork.of\u03c0 g H)`, we obtain a `Presentation M`. -/\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2613,
      "before_code": "end",
      "suggestion": "  letI f := (map_free F hf' P.relations.I).inv \u226b F.map ((freeHomEquiv _).symm P.relations.s) \u226b\n    F.map (kernel.\u03b9 _) \u226b (map_free F hf' P.generators.I).hom\n  letI g := (map_free F hf' P.generators.I).inv \u226b F.map (P.generators.\u03c0)\n  presentationOfIsCokernelFree f g (by simp [f, g, \u2190 Functor.map_comp]) <|\n    cokernel.cokernelIso f g ((((cokernel.mapIso (F.map\n      ((freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))) f\n        (map_free F hf' P.relations.I) (map_free F hf' P.generators.I) (by simp [f])).symm) \u226a\u226b\n          (Limits.PreservesCokernel.iso F ((freeHomEquiv _).symm P.relations.s \u226b\n            (kernel.\u03b9 _))).symm) \u226a\u226b F.mapIso (Limits.IsColimit.coconePointUniqueUpToIso\n              (colimit.isColimit _) P.isColimit)) (by simp [\u2190 Functor.map_comp, g])\n",
      "body": "```suggestion\n  letI f := (map_free F hf' P.relations.I).inv \u226b F.map ((freeHomEquiv _).symm P.relations.s) \u226b\n    F.map (kernel.\u03b9 _) \u226b (map_free F hf' P.generators.I).hom\n  letI g := (map_free F hf' P.generators.I).inv \u226b F.map (P.generators.\u03c0)\n  presentationOfIsCokernelFree f g (by simp [f, g, \u2190 Functor.map_comp]) <|\n    cokernel.cokernelIso f g ((((cokernel.mapIso (F.map\n      ((freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))) f\n        (map_free F hf' P.relations.I) (map_free F hf' P.generat",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2618,
      "before_code": "end",
      "suggestion": "\r\n@[simps]\r\ndef presentationOfIsCokernelFree {M : SheafOfModules.{u} R}\r\n",
      "body": "```suggestion\r\n@[simps]\r\ndef presentationOfIsCokernelFree {M : SheafOfModules.{u} R}\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 2635,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "    have : (2 * X * T R (n + 1)).degree = \u2191(n + 2) := by\n      change (C 2 * X * T R (n + 1)).degree = \u2191(n + 2)\n      rw [mul_assoc, degree_C_mul (NeZero.ne 2), mul_comm, degree_mul_X, ih1]\n      rfl\n    rw [T_add_two, degree_sub_eq_left_of_degree_lt]\n    \u00b7 rw [this]; rfl\n    \u00b7 rw [ih2, this]; tauto\n  | neg n ih => simp [ih]\n",
      "body": "```suggestion\n    have : (2 * X * T R (n + 1)).degree = \u2191(n + 2) := by\n      change (C 2 * X * T R (n + 1)).degree = \u2191(n + 2)\n      rw [mul_assoc, degree_C_mul (NeZero.ne 2), mul_comm, degree_mul_X, ih1]\n      rfl\n    rw [T_add_two, degree_sub_eq_left_of_degree_lt]\n    \u00b7 rw [this]; rfl\n    \u00b7 rw [ih2, this]; tauto\n  | neg n ih => simp [ih]\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 2636,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "      rw [mul_assoc, degree_C_mul (NeZero.ne 2), mul_comm, degree_mul_X, degree_T, degree_T]\n      tauto\n  | neg n ih => simp [ih]\n",
      "body": "```suggestion\n      rw [mul_assoc, degree_C_mul (NeZero.ne 2), mul_comm, degree_mul_X, degree_T, degree_T]\n      tauto\n  | neg n ih => simp [ih]\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 2637,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "  | neg n ih => simp [ih]\n",
      "body": "```suggestion\n  | neg n ih => simp [ih]\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 2638,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "    \u00b7 simp only [T_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, ih1, Int.negOnePow_add,\n        Int.negOnePow_one, Units.val_neg, Int.cast_neg, ih2, Int.negOnePow_even 2 even_two]\n      ring_nf\n",
      "body": "Avoid non-terminal `simp`:\n\n```suggestion\n    \u00b7 simp only [T_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, ih1, Int.negOnePow_add,\n        Int.negOnePow_one, Units.val_neg, Int.cast_neg, ih2, Int.negOnePow_even 2 even_two]\n      ring_nf\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "ring_nf",
          "simp"
        ],
        "body_tactics": [
          "ring_nf",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "ring_nf"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 2640,
      "before_code": "sum_insert (notMem_singleton.mpr hxy), sum_singleton, basis_pair_left hxy,\n    basis_pair_right hxy, id, id]",
      "suggestion": "  have : (\u220f j \u2208 s.erase i, (X - C (v j))).coeff (#s - 1) = 1 := by\n    simpa [hi] using (monic_prod_X_sub_C v (s.erase i)).coeff_natDegree\n  simp_rw [leadingCoeff, natDegree_basis hvs hi, Lagrange.basis]\n  simp [basisDivisor, Finset.prod_mul_distrib, \u2190 map_prod, this]\n",
      "body": "```suggestion\n  have : (\u220f j \u2208 s.erase i, (X - C (v j))).coeff (#s - 1) = 1 := by\n    simpa [hi] using (monic_prod_X_sub_C v (s.erase i)).coeff_natDegree\n  simp_rw [leadingCoeff, natDegree_basis hvs hi, Lagrange.basis]\n  simp [basisDivisor, Finset.prod_mul_distrib, \u2190 map_prod, this]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "basis_pair_left",
          "sum_singleton",
          "notMem_singleton",
          "basis_pair_right",
          "hxy",
          "sum_insert"
        ]
      }
    },
    {
      "id": 2641,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  \u00b7 rwa [ht]\n  \u00b7 intro x hx\n    obtain \u27e8i, hi, rfl\u27e9 := Finset.mem_image.mp hx\n    rw [eval_interpolate_at_node _ hvs hi]\n",
      "body": "```suggestion\n  \u00b7 rwa [ht]\n  \u00b7 intro x hx\n    obtain \u27e8i, hi, rfl\u27e9 := Finset.mem_image.mp hx\n    rw [eval_interpolate_at_node _ hvs hi]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "obtain",
          "rw",
          "intro"
        ],
        "body_tactics": [
          "obtain",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 2643,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n",
      "body": "```suggestion\n    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind",
          "simp_all",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp_all",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "simp_all",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 2644,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n",
      "body": "```suggestion\n  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind",
          "have",
          "simp_all"
        ],
        "body_tactics": [
          "grind",
          "have",
          "simp_all"
        ],
        "new_tactics": [
          "grind",
          "simp_all",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 2651,
      "before_code": "private def coconeQuotientDiagDesc\n    (s : Cocone (quotientDiag V h u \u22d9 functorToAction F)) :\n      (coconeQuotientDiag h u hUinV).pt \u27f6 s.pt where\n  hom := Quotient.lift (fun \u03c3 \u21a6 (u.inv \u226b s.\u03b9.app (SingleObj.star _)).hom \u27e6\u03c3\u27e7) <| fun \u03c3 \u03c4 hst \u21a6 by\n    let J' := quotientDiag V h u \u22d9 functorToAction F\n    let m : End (SingleObj.star (V.toSubgroup \u29f8 Subgroup.subgroupOf U V)) :=\n      \u27e6\u27e8\u03c3\u207b\u00b9 * \u03c4, (QuotientGroup.leftRel_apply).mp hst\u27e9\u27e7\n    have h1 : J'.map m \u226b s.\u03b9.app (SingleObj.star _) = s.\u03b9.app (SingleObj.star _) := s.\u03b9.naturality m\n    conv_rhs => rw [\u2190 h1]\n    have h2 : (J'.map m).hom (u.inv.hom \u27e6\u03c4\u27e7) = u.inv.hom \u27e6\u03c3\u27e7 := by\n      simp only [comp_obj, quotientDiag_obj, Functor.comp_map, quotientDiag_map, J',\n        functorToAction_map_quotientToEndObjectHom V h u m]\n      change (u.inv \u226b u.hom \u226b _ \u226b u.inv).hom \u27e6\u03c4\u27e7 = u.inv.hom \u27e6\u03c3\u27e7\n      simp [m]\n    simp only [\u2190 h2, const_obj_obj, Action.comp_hom, FintypeCat.comp_apply]",
      "suggestion": "      simp [\u2190 h2, J'])\n",
      "body": "```suggestion\n      simp [\u2190 h2, J'])\n```",
      "path": "Mathlib/CategoryTheory/Galois/EssSurj.lean",
      "tags": {
        "before_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "have"
        ],
        "topics": [
          "list",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "hom",
          "inv",
          "change",
          "lift",
          "Cocone",
          "QuotientGroup",
          "coconeQuotientDiag",
          "Action",
          "comp_map",
          "Quotient",
          "quotientDiag_map",
          "private",
          "quotientDiag_obj",
          "have",
          "map",
          "conv_rhs",
          "star",
          "SingleObj",
          "quotientDiag",
          "def",
          "Functor",
          "coconeQuotientDiagDesc",
          "hUinV",
          "comp_apply",
          "app",
          "hst",
          "naturality",
          "functorToAction_map_quotientToEndObjectHom",
          "simp",
          "comp_hom",
          "only",
          "const_obj_obj",
          "End",
          "FintypeCat",
          "functorToAction",
          "comp_obj",
          "toSubgroup",
          "subgroupOf",
          "leftRel_apply"
        ]
      }
    },
    {
      "id": 2658,
      "before_code": "apply propext\n      constructor\n      \u00b7 rintro \u27e8i, w\u27e9\n        exact \u27e8i \u226b h.hom.left, by rw [Category.assoc, MonoOver.w, w]\u27e9",
      "suggestion": "        exact \u27e8i \u226b h.hom.hom.left, by rw [Category.assoc, Over.w h.hom.hom, w]\u27e9\n",
      "body": "```suggestion\n        exact \u27e8i \u226b h.hom.hom.left, by rw [Category.assoc, Over.w h.hom.hom, w]\u27e9\n```",
      "path": "Mathlib/CategoryTheory/Subobject/FactorThru.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "constructor"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "constructor"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "hom",
          "assoc",
          "MonoOver",
          "exact",
          "Category",
          "left",
          "rintro",
          "propext",
          "constructor"
        ]
      }
    },
    {
      "id": 2659,
      "before_code": "apply propext\n      constructor\n      \u00b7 rintro \u27e8i, w\u27e9\n        exact \u27e8i \u226b h.hom.left, by rw [Category.assoc, MonoOver.w, w]\u27e9\n      \u00b7 rintro \u27e8i, w\u27e9\n        exact \u27e8i \u226b h.inv.left, by rw [Category.assoc, MonoOver.w, w]\u27e9)",
      "suggestion": "        exact \u27e8i \u226b h.inv.hom.left, by rw [Category.assoc, Over.w h.inv.hom, w]\u27e9)\n",
      "body": "```suggestion\n        exact \u27e8i \u226b h.inv.hom.left, by rw [Category.assoc, Over.w h.inv.hom, w]\u27e9)\n```",
      "path": "Mathlib/CategoryTheory/Subobject/FactorThru.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "constructor"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "constructor"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "hom",
          "assoc",
          "MonoOver",
          "exact",
          "Category",
          "left",
          "inv",
          "rintro",
          "propext",
          "constructor"
        ]
      }
    },
    {
      "id": 2660,
      "before_code": "\ud835\udda3.gluedIso forgetToPresheafedSpace\n\ntheorem \u03b9_isoPresheafedSpace_inv (i : D.J) :\n    D.toPresheafedSpaceGlueData.toGlueData.\u03b9 i \u226b D.isoPresheafedSpace.inv = \ud835\udda3.\u03b9 i :=\n  \ud835\udda3.\u03b9_gluedIso_inv _ _\n\ninstance \u03b9IsOpenImmersion (i : D.J) : IsOpenImmersion (\ud835\udda3.\u03b9 i) := by",
      "suggestion": "  dsimp [IsOpenImmersion]  \n",
      "body": "```suggestion\n  dsimp [IsOpenImmersion]  \n```",
      "path": "Mathlib/Geometry/RingedSpace/PresheafedSpace/Gluing.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "gluedIso",
          "inv",
          "toGlueData",
          "forgetToPresheafedSpace",
          "IsOpenImmersion",
          "toPresheafedSpaceGlueData",
          "isoPresheafedSpace",
          "instance"
        ]
      }
    },
    {
      "id": 2661,
      "before_code": "abbrev isoSheafedSpace : \ud835\udda3.glued.toSheafedSpace \u2245 D.toSheafedSpaceGlueData.toGlueData.glued :=\n  \ud835\udda3.gluedIso forgetToSheafedSpace\n\ntheorem \u03b9_isoSheafedSpace_inv (i : D.J) :\n    D.toSheafedSpaceGlueData.toGlueData.\u03b9 i \u226b D.isoSheafedSpace.inv = (\ud835\udda3.\u03b9 i).1 :=\n  \ud835\udda3.\u03b9_gluedIso_inv forgetToSheafedSpace i\n\ninstance \u03b9_isOpenImmersion (i : D.J) : IsOpenImmersion (\ud835\udda3.\u03b9 i) := by\n  delta IsOpenImmersion; rw [\u2190 D.\u03b9_isoSheafedSpace_inv]",
      "suggestion": "  dsimp [IsOpenImmersion]\n",
      "body": "```suggestion\n  dsimp [IsOpenImmersion]\n```",
      "path": "Mathlib/Geometry/RingedSpace/PresheafedSpace/Gluing.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "toSheafedSpace",
          "theorem",
          "abbrev",
          "gluedIso",
          "isoSheafedSpace",
          "inv",
          "forgetToSheafedSpace",
          "delta",
          "toGlueData",
          "IsOpenImmersion",
          "glued",
          "instance",
          "toSheafedSpaceGlueData"
        ]
      }
    },
    {
      "id": 2662,
      "before_code": "def limitConeIsLimit {J : Type v} [SmallCategory J] (F : J \u2964 CompHaus.{max v u}) :\n    Limits.IsLimit.{v} (limitCone.{v,u} F) :=\n  letI FF : J \u2964 TopCat := F \u22d9 compHausToTop\n  { lift := fun S => (TopCat.limitConeIsLimit FF).lift (compHausToTop.mapCone S)\n    fac := fun S => (TopCat.limitConeIsLimit FF).fac (compHausToTop.mapCone S)\n    uniq := fun S => (TopCat.limitConeIsLimit FF).uniq (compHausToTop.mapCone S) }",
      "suggestion": "        simp [\u2190 hm]\n        rfl )) }\n",
      "body": "```suggestion\n        simp [\u2190 hm]\n        rfl )) }\n```",
      "path": "Mathlib/Topology/Category/CompHaus/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fac",
          "letI",
          "Limits",
          "def",
          "uniq",
          "Type",
          "SmallCategory",
          "IsLimit",
          "lift",
          "limitCone",
          "CompHaus",
          "mapCone",
          "max",
          "compHausToTop",
          "TopCat",
          "limitConeIsLimit"
        ]
      }
    },
    {
      "id": 2663,
      "before_code": "(F : J \u2964 LightProfinite.{max u v}) :\n    Limits.IsLimit (limitCone F) where\n  lift S :=\n    (CompHaus.limitConeIsLimit.{v, u} (F \u22d9 lightProfiniteToCompHaus)).lift\n      (lightProfiniteToCompHaus.mapCone S)\n  uniq S _ h := (CompHaus.limitConeIsLimit.{v, u} _).uniq (lightProfiniteToCompHaus.mapCone S) _ h",
      "suggestion": "    simp [\u2190 h]\n",
      "body": "```suggestion\n    simp [\u2190 h]\n```",
      "path": "Mathlib/Topology/Category/LightProfinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Limits",
          "uniq",
          "IsLimit",
          "lift",
          "limitCone",
          "LightProfinite",
          "mapCone",
          "max",
          "CompHaus",
          "limitConeIsLimit",
          "lightProfiniteToCompHaus"
        ]
      }
    },
    {
      "id": 2664,
      "before_code": "def limitConeIsLimit {J : Type v} [SmallCategory J] (F : J \u2964 Profinite.{max u v}) :\n    Limits.IsLimit (limitCone F) where\n  lift S :=\n    (CompHaus.limitConeIsLimit.{v, u} (F \u22d9 profiniteToCompHaus)).lift\n      (profiniteToCompHaus.mapCone S)\n  uniq S _ h := (CompHaus.limitConeIsLimit.{v, u} _).uniq (profiniteToCompHaus.mapCone S) _ h",
      "suggestion": "          simp [\u2190 h]\n          rfl))\n",
      "body": "```suggestion\n          simp [\u2190 h]\n          rfl))\n```",
      "path": "Mathlib/Topology/Category/Profinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "profiniteToCompHaus",
          "Limits",
          "def",
          "uniq",
          "Type",
          "SmallCategory",
          "IsLimit",
          "lift",
          "Profinite",
          "limitCone",
          "mapCone",
          "max",
          "CompHaus",
          "limitConeIsLimit"
        ]
      }
    },
    {
      "id": 2665,
      "before_code": "-- TODO: generalize to `InducedCategory.forget\u2082_full`?\ninstance forgetToTop_full : (forget\u2082 AlexDisc TopCat).Full where\n  map_surjective f := \u27e8f, rfl\u27e9\n\ninstance forgetToTop_faithful : (forget\u2082 AlexDisc TopCat).Faithful where",
      "suggestion": "    exact ConcreteCategory.congr_hom h x\n",
      "body": "```suggestion\n    exact ConcreteCategory.congr_hom h x\n```",
      "path": "Mathlib/Topology/Order/Category/AlexDisc.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "forgetToTop_full",
          "map_surjective",
          "Faithful",
          "AlexDisc",
          "generalize",
          "forgetToTop_faithful",
          "rfl",
          "TopCat",
          "instance",
          "Full",
          "InducedCategory",
          "TODO"
        ]
      }
    },
    {
      "id": 2668,
      "before_code": "\u00b7 rw [\u2190 P.finrank_corootSpan_eq', h, finrank_top, P.toPerfPair.finrank_eq,\n      Subspace.dual_finrank_eq]",
      "suggestion": "@[simp]\nlemma polarizationEquiv_apply (m : M) :\n",
      "body": "Should this be simp, or did you leave the attr out for a reason? (If so, maybe add a short comment.)\n```suggestion\n@[simp]\nlemma polarizationEquiv_apply (m : M) :\n```",
      "path": "Mathlib/LinearAlgebra/RootSystem/Finite/Nondegenerate.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Subspace",
          "toPerfPair",
          "finrank_eq",
          "dual_finrank_eq",
          "finrank_corootSpan_eq",
          "finrank_top"
        ]
      }
    },
    {
      "id": 2669,
      "before_code": "## Future work\n\nIt would be nice to have a usable framework of enriched categories in which this just became",
      "suggestion": "It would be nice to have a usable framework of enriched categories in which this would just be\n",
      "body": "```suggestion\nIt would be nice to have a usable framework of enriched categories in which this would just be\n```",
      "path": "Mathlib/CategoryTheory/Linear/Basic.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "would",
          "work",
          "usable",
          "framework",
          "nice",
          "Future",
          "which",
          "just",
          "have",
          "this",
          "enriched",
          "became",
          "categories"
        ]
      }
    },
    {
      "id": 2670,
      "before_code": "intro x hx\n  simp [hx]",
      "suggestion": "  have h\u2081' := h\u2081.to_subtype\n  have h\u2082 : IsOpen s := isOpen_analyticAt \ud835\udd5c f\n  have h\u2083 : ContinuousOn f s := fun z hz \u21a6 hz.continuousAt.continuousWithinAt\n  exact .of_union_range_cover (.subtype_coe h\u2082.measurableSet) (.subtype_coe h\u2081.measurableSet)\n    (by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n",
      "body": "I think this is easier. If `s` is a measurable set, and `f` is measurable on both `s` and `s\u1d9c` (the former because it's continuous there, the latter because `s\u1d9c` is countable), then `f` is measurable.\n```suggestion\n  have h\u2081' := h\u2081.to_subtype\n  have h\u2082 : IsOpen s := isOpen_analyticAt \ud835\udd5c f\n  have h\u2083 : ContinuousOn f s := fun z hz \u21a6 hz.continuousAt.continuousWithinAt\n  exact .of_union_range_cover (.subtype_coe h\u2082.measurableSet) (.subtype_coe h\u2081.measurableSet)\n    (by simp [- mem_compl_iff]) h\u2083.rest",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "have"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "intro"
        ]
      }
    },
    {
      "id": 2671,
      "before_code": "intro x hx\n  simp [hx]",
      "suggestion": "theorem measurable [MeasurableSpace \ud835\udd5c] [SecondCountableTopology \ud835\udd5c] [BorelSpace \ud835\udd5c]\n",
      "body": "At least until we have the `Meromorphic` predicate (which I suggest adding before you develop too much theory using the spelling `MeromorphicOn f Set.univ` and then you have to change it later), you should write it like this.\n```suggestion\ntheorem measurable [MeasurableSpace \ud835\udd5c] [SecondCountableTopology \ud835\udd5c] [BorelSpace \ud835\udd5c]\n```",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "intro"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "intro"
        ]
      }
    },
    {
      "id": 2682,
      "before_code": "(Metric.PiNatEmbed.toPiNatHomeo X Y f continuous_f separating_f).isEmbedding.metrizableSpace\n\nend CompactSpace",
      "suggestion": "/-- Given a separable metric space `X`, `denseSeq X : \u2115 \u2192 X` gives a countable\ndense sequence. This measures the distance between `denseSeq X n` and `x`, truncated to the unit interval `I` so that the distances remain bounded.\n\nThe function `(fun x n \u21a6 distDenseSeq n x) : X \u2192 \u2115 \u2192 I` is a mapping from `X` to the Hilbert cube. -/\nnoncomputable abbrev distDenseSeq (n : \u2115) (x : X) : I :=\n",
      "body": "This is not a good name for this. We don't have anything called `hCube` in Mathlib. And this *isn't* an embedding (at least, not with this argument order), but you use all of them to build one.\nI suggest calling it `distDenseSeq`.\n\nInstead, the docstring should specify exactly what this is:\n```suggestion\n/-- Given a separable metric space `X`, `denseSeq X : \u2115 \u2192 X` gives a countable\ndense sequence. This measures the distance between `denseSeq X n` and `x`, truncated to the unit interval `I` so th",
      "path": "Mathlib/Topology/MetricSpace/PiNat.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "separating_f",
          "isEmbedding",
          "end",
          "metrizableSpace",
          "toPiNatHomeo",
          "Metric",
          "continuous_f",
          "CompactSpace",
          "PiNatEmbed"
        ]
      }
    },
    {
      "id": 2687,
      "before_code": "variable [NonAssocRing R] [Pow R \u2115] [BinomialRing R]",
      "suggestion": "  congr\n  abel\n",
      "body": "I realize it's longer, but `abel` is meant to be a finishing tactic.\n```suggestion\n  congr\n  abel\n```",
      "path": "Mathlib/RingTheory/Binomial.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr"
        ],
        "body_tactics": [
          "congr"
        ],
        "new_tactics": [
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "Pow",
          "NonAssocRing",
          "variable",
          "BinomialRing"
        ]
      }
    },
    {
      "id": 2704,
      "before_code": "rw [norm_pow, norm_norm, one_mul, add_pow_two]\n    exact le_add_of_nonneg_left (by positivity)",
      "suggestion": "    rintro - \u27e8y, rfl\u27e9\n    simp only [Set.mem_setOf_eq, t]\n    exact lt_add_of_lt_add_left (c := 0) (by norm_num) (by positivity)\n  have hdiff : ContDiffOn \u211d \u221e (fun x \u21a6 x ^ r) t :=\n    contDiffOn_id.rpow_const_of_ne fun x hx \u21a6 (lt_trans (by norm_num) hx).ne'\n",
      "body": "```suggestion\n    rintro - \u27e8y, rfl\u27e9\n    simp only [Set.mem_setOf_eq, t]\n    exact lt_add_of_lt_add_left (c := 0) (by norm_num) (by positivity)\n  have hdiff : ContDiffOn \u211d \u221e (fun x \u21a6 x ^ r) t :=\n    contDiffOn_id.rpow_const_of_ne fun x hx \u21a6 (lt_trans (by norm_num) hx).ne'\n```",
      "path": "Mathlib/Analysis/Distribution/TemperateGrowth.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "suggestion_tactics": [
          "norm_num",
          "positivity",
          "exact",
          "have",
          "simp"
        ],
        "body_tactics": [
          "norm_num",
          "positivity",
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "norm_num",
          "simp",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "norm_pow",
          "positivity",
          "le_add_of_nonneg_left",
          "add_pow_two",
          "exact",
          "norm_norm",
          "one_mul"
        ]
      }
    },
    {
      "id": 2726,
      "before_code": "instance category : LargeCategory.{max v u} Cat.{v, u} :=\n  StrictBicategory.category Cat.{v, u}\n\n@[ext]\ntheorem ext {C D : Cat} {F G : C \u27f6 D} {\u03b1 \u03b2 : F \u27f6 G} (w : \u03b1.app = \u03b2.app) : \u03b1 = \u03b2 :=\n  NatTrans.ext w",
      "suggestion": "\r\nlemma Hom.id_toFunctor {C : Cat.{v, u}} : (\ud835\udfd9 C : C \u27f6 C).toFunctor = \ud835\udfed C := rfl\r\n",
      "body": "```suggestion\r\nlemma Hom.id_toFunctor {C : Cat.{v, u}} : (\ud835\udfd9 C : C \u27f6 C).toFunctor = \ud835\udfed C := rfl\r\n```",
      "path": "Mathlib/CategoryTheory/Category/Cat.lean",
      "tags": {
        "before_tactics": [
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "StrictBicategory",
          "NatTrans",
          "ext",
          "theorem",
          "category",
          "LargeCategory",
          "Cat",
          "app",
          "max",
          "instance"
        ]
      }
    },
    {
      "id": 2728,
      "before_code": "let value \u2190 apprec 0 value\n  return value\n\n/--\nGiven morphisms `f g : C \u27f6 D` in the bicategory `Cat`, and an equation `\u03b7 = \u03b8` between 2-morphisms\n(possibly after a `\u2200` binder), produce the equation `\u2200 (X : C), f.app X = g.app X`, and simplify\nit using basic lemmas about `NatTrans.app`. -/\ndef toAppExpr (e : Expr) : MetaM Expr := do\n  mapForallTelescope (fun e => do simpType catAppSimp (\u2190 mkAppM ``NatTrans.congr_app #[e])) e\n\n/--\nAdding `@[to_app]` to a lemma named `F` of shape `\u2200 .., \u03b7 = \u03b8`, where `\u03b7 \u03b8 : f \u27f6 g` are 2-morphisms\nin some bicategory, create a new lemma named `F_app`. This lemma is obtained by first specializing\nthe bicategory in which the equality is taking place to `Cat`, then applying `NatTrans.congr_app`\nto obtain a proof of `\u2200 ... (X : Cat), \u03b7.app X = \u03b8.app X`, and finally simplifying the conclusion\nusing some basic lemmas in the bicategory `Cat`:",
      "suggestion": "\r\nthe bicategory in which the equality is taking place to `Cat`, then applying `toNatTrans_congr` and\r\n",
      "body": "```suggestion\r\nthe bicategory in which the equality is taking place to `Cat`, then applying `toNatTrans_congr` and\r\n```\r\ndid you mean this?",
      "path": "Mathlib/Tactic/CategoryTheory/ToApp.lean",
      "tags": {
        "before_tactics": [
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "binder",
          "morphisms",
          "MetaM",
          "Expr",
          "produce",
          "lemma",
          "after",
          "which",
          "taking",
          "bicategory",
          "to_app",
          "obtain",
          "new",
          "simplify",
          "place",
          "using",
          "named",
          "simpType",
          "This",
          "NatTrans",
          "create",
          "are",
          "equality",
          "Adding",
          "conclusion",
          "applying",
          "def",
          "then",
          "possibly",
          "Cat",
          "basic",
          "toAppExpr",
          "app",
          "return",
          "F_app",
          "between",
          "catAppSimp",
          "obtained",
          "first",
          "simplifying",
          "mapForallTelescope",
          "congr_app",
          "lemmas",
          "about",
          "equation",
          "mkAppM",
          "apprec",
          "Given",
          "shape",
          "specializing"
        ]
      }
    },
    {
      "id": 2729,
      "before_code": "Adding `@[to_app]` to a lemma named `F` of shape `\u2200 .., \u03b7 = \u03b8`, where `\u03b7 \u03b8 : f \u27f6 g` are 2-morphisms\nin some bicategory, create a new lemma named `F_app`. This lemma is obtained by first specializing\nthe bicategory in which the equality is taking place to `Cat`, then applying `NatTrans.congr_app`\nto obtain a proof of `\u2200 ... (X : Cat), \u03b7.app X = \u03b8.app X`, and finally simplifying the conclusion\nusing some basic lemmas in the bicategory `Cat`:\n`Cat.whiskerLeft_app`, `Cat.whiskerRight_app`, `Cat.id_app`, `Cat.comp_app` and `Cat.eqToHom_app`",
      "suggestion": "\r\nusing some basic lemmas in the bicategory `Cat` (see `catAppSimp` for the list of these).\r\n",
      "body": "```suggestion\r\nusing some basic lemmas in the bicategory `Cat` (see `catAppSimp` for the list of these).\r\n```",
      "path": "Mathlib/Tactic/CategoryTheory/ToApp.lean",
      "tags": {
        "before_tactics": [
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "morphisms",
          "lemma",
          "id_app",
          "which",
          "taking",
          "bicategory",
          "to_app",
          "obtain",
          "new",
          "comp_app",
          "place",
          "whiskerLeft_app",
          "named",
          "This",
          "NatTrans",
          "create",
          "eqToHom_app",
          "are",
          "equality",
          "Adding",
          "some",
          "conclusion",
          "whiskerRight_app",
          "applying",
          "then",
          "Cat",
          "basic",
          "app",
          "F_app",
          "obtained",
          "first",
          "simplifying",
          "congr_app",
          "lemmas",
          "shape",
          "specializing",
          "finally",
          "proof",
          "using"
        ]
      }
    },
    {
      "id": 2731,
      "before_code": "id_comp {a b} f := by\n    ext\n    \u00b7 simp\n    \u00b7 simp [F.mapComp_id_right_inv_app, Strict.rightUnitor_eqToIso, \u2190 NatTrans.naturality_assoc]",
      "suggestion": "    \u00b7 simp [F.mapComp_id_right_inv_app, \u2190 NatTrans.naturality_assoc, Strict.rightUnitor_eqToIso,\n        \u2190 Cat.Hom\u2082.comp_app, Iso.inv_hom_id]\n",
      "body": "```suggestion\n    \u00b7 simp [F.mapComp_id_right_inv_app, \u2190 NatTrans.naturality_assoc, Strict.rightUnitor_eqToIso,\n        \u2190 Cat.Hom\u2082.comp_app, Iso.inv_hom_id]\n```",
      "path": "Mathlib/CategoryTheory/Bicategory/Grothendieck.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "NatTrans",
          "ext",
          "rightUnitor_eqToIso",
          "mapComp_id_right_inv_app",
          "id_comp",
          "naturality_assoc",
          "simp",
          "Strict"
        ]
      }
    },
    {
      "id": 2733,
      "before_code": "def map (\u03b1 : F \u27f6 G) : \u222b\u1d9c F \u2964 \u222b\u1d9c G where\n  obj a := {\n    base := a.base\n    fiber := (\u03b1.app \u27e8op a.base\u27e9).obj a.fiber }\n  map {a b} f := {\n    base := f.1\n    fiber := (\u03b1.app \u27e8op a.base\u27e9).map f.2 \u226b (\u03b1.naturality f.1.op.toLoc).hom.app b.fiber }\n  map_id a := by\n    ext1\n    \u00b7 dsimp\n    \u00b7 simp [StrongTrans.naturality_id_hom_app, \u2190 Functor.map_comp_assoc]",
      "suggestion": "    \u00b7 simp [Cat.Hom.comp_toFunctor, naturality_id_hom_app, Cat.Hom.id_toFunctor, \n        \u2190 Category.assoc, \u2190 Functor.map_comp, \u2190 Cat.Hom\u2082.comp_app]\n",
      "body": "```suggestion\n    \u00b7 simp [Cat.Hom.comp_toFunctor, naturality_id_hom_app, Cat.Hom.id_toFunctor, \n        \u2190 Category.assoc, \u2190 Functor.map_comp, \u2190 Cat.Hom\u2082.comp_app]\n```",
      "path": "Mathlib/CategoryTheory/Bicategory/Grothendieck.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hom",
          "def",
          "Functor",
          "StrongTrans",
          "base",
          "app",
          "map",
          "naturality",
          "naturality_id_hom_app",
          "simp",
          "fiber",
          "toLoc",
          "dsimp",
          "ext1",
          "map_comp_assoc",
          "obj",
          "map_id"
        ]
      }
    },
    {
      "id": 2734,
      "before_code": "def map (\u03b1 : F \u27f6 G) : \u222b\u1d9c F \u2964 \u222b\u1d9c G where\n  obj a := {\n    base := a.base\n    fiber := (\u03b1.app \u27e8op a.base\u27e9).obj a.fiber }\n  map {a b} f := {\n    base := f.1\n    fiber := (\u03b1.app \u27e8op a.base\u27e9).map f.2 \u226b (\u03b1.naturality f.1.op.toLoc).hom.app b.fiber }\n  map_id a := by\n    ext1\n    \u00b7 dsimp\n    \u00b7 simp [StrongTrans.naturality_id_hom_app, \u2190 Functor.map_comp_assoc]\n  map_comp {a b c} f g := by\n    ext\n    \u00b7 dsimp\n    \u00b7 dsimp\n      simp only [StrongTrans.naturality_comp_hom_app, map_comp, assoc, comp_id]\n      slice_lhs 2 4 => simp only [\u2190 Functor.map_comp, Iso.inv_hom_id_app, Cat.comp_obj, comp_id]\n      simp [\u2190 Functor.comp_map]",
      "suggestion": "      slice_lhs 2 4 => simp [\u2190 Cat.Hom.toNatIso_inv, Cat.Hom.comp_toFunctor,\n        \u2190 Cat.Hom.toNatIso_hom, \u2190 map_comp, Iso.inv_hom_id_app, comp_obj, map_id, comp_id]\n      simp only [assoc, \u2190 reassoc_of% Cat.Hom.comp_map, \n        (\u03b1.naturality f.base.op.toLoc).hom.toNatTrans.naturality_assoc]\n",
      "body": "```suggestion\n      slice_lhs 2 4 => simp [\u2190 Cat.Hom.toNatIso_inv, Cat.Hom.comp_toFunctor,\n        \u2190 Cat.Hom.toNatIso_hom, \u2190 map_comp, Iso.inv_hom_id_app, comp_obj, map_id, comp_id]\n      simp only [assoc, \u2190 reassoc_of% Cat.Hom.comp_map, \n        (\u03b1.naturality f.base.op.toLoc).hom.toNatTrans.naturality_assoc]\n```",
      "path": "Mathlib/CategoryTheory/Bicategory/Grothendieck.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "hom",
          "comp_id",
          "StrongTrans",
          "base",
          "inv_hom_id_app",
          "assoc",
          "comp_map",
          "ext",
          "map_comp",
          "map",
          "toLoc",
          "Iso",
          "ext1",
          "naturality_comp_hom_app",
          "def",
          "Functor",
          "Cat",
          "app",
          "naturality",
          "naturality_id_hom_app",
          "simp",
          "dsimp",
          "only",
          "obj",
          "map_id",
          "fiber",
          "slice_lhs",
          "comp_obj",
          "map_comp_assoc"
        ]
      }
    },
    {
      "id": 2735,
      "before_code": "instance closed : Closed (Cat.of C) where\n  rightAdj := exp C\n  adj := Adjunction.mkOfHomEquiv\n    { homEquiv _ _ := curryingFlipEquiv.symm\n      homEquiv_naturality_left_symm := comp_flip_uncurry_eq\n      homEquiv_naturality_right := curry_obj_comp_flip }",
      "suggestion": "      homEquiv_naturality_left_symm _ _ := rfl\n      homEquiv_naturality_right _ _ := rfl }\n",
      "body": "```suggestion\n      homEquiv_naturality_left_symm _ _ := rfl\n      homEquiv_naturality_right _ _ := rfl }\n```",
      "path": "Mathlib/CategoryTheory/Category/Cat/CartesianClosed.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rightAdj",
          "exp",
          "symm",
          "Adjunction",
          "Cat",
          "adj",
          "homEquiv_naturality_left_symm",
          "Closed",
          "mkOfHomEquiv",
          "homEquiv",
          "closed",
          "curryingFlipEquiv",
          "homEquiv_naturality_right",
          "comp_flip_uncurry_eq",
          "instance",
          "curry_obj_comp_flip"
        ]
      }
    },
    {
      "id": 2736,
      "before_code": "# Stieltjes measures on the real line\n\nConsider a function `f : \u211d \u2192 \u211d` which is monotone and right-continuous. Then one can define a\ncorresponding measure, giving mass `f b - f a` to the interval `(a, b]`.\n\n## Main definitions\n\n* `StieltjesFunction` is a structure containing a function from `\u211d \u2192 \u211d`, together with the\n  assertions that it is monotone and right-continuous. To `f : StieltjesFunction`, one associates\n  a Borel measure `f.measure`.\n* `f.measure_Ioc` asserts that `f.measure (Ioc a b) = ofReal (f b - f a)`\n* `f.measure_Ioo` asserts that `f.measure (Ioo a b) = ofReal (leftLim f b - f a)`.\n* `f.measure_Icc` and `f.measure_Ico` are analogous.\n-/\n\n@[expose] public section\n\nnoncomputable section\n\nopen Set Filter Function ENNReal NNReal Topology MeasureTheory\n\nopen ENNReal (ofReal)",
      "suggestion": "  \u00b7 simp\n\nlemma notMem_botSet_of_lt {x y : R} (h : x < y) : y \u2209 botSet := by\n",
      "body": "```suggestion\n  \u00b7 simp\n\nlemma notMem_botSet_of_lt {x y : R} (h : x < y) : y \u2209 botSet := by\n```",
      "path": "Mathlib/MeasureTheory/Measure/Stieltjes.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "list",
          "set_theory",
          "order",
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "analogous",
          "expose",
          "Topology",
          "real",
          "leftLim",
          "which",
          "associates",
          "ofReal",
          "giving",
          "measure_Icc",
          "assertions",
          "Main",
          "Function",
          "Ioo",
          "open",
          "section",
          "measures",
          "right",
          "noncomputable",
          "asserts",
          "monotone",
          "corresponding",
          "structure",
          "Filter",
          "are",
          "measure_Ioc",
          "one",
          "can",
          "public",
          "together",
          "definitions",
          "measure_Ioo",
          "that",
          "measure_Ico",
          "mass",
          "line",
          "Consider",
          "ENNReal",
          "function",
          "Borel",
          "StieltjesFunction",
          "Set",
          "Stieltjes",
          "continuous",
          "measure",
          "MeasureTheory",
          "Then",
          "Ioc",
          "from",
          "interval"
        ]
      }
    },
    {
      "id": 2739,
      "before_code": "instance countableCategoryDiscreteOfCountable (J : Type*) [Countable J] :\n    CountableCategory (Discrete J) where",
      "suggestion": "\r\ninstance {J : Type u} [Countable J] [Category* J] [Quiver.IsThin J] : CountableCategory J :=\r\n",
      "body": "```suggestion\r\ninstance {J : Type u} [Countable J] [Category* J] [Quiver.IsThin J] : CountableCategory J :=\r\n```\r\n\r\nYou need to merge latest master before applying this suggestion.",
      "path": "Mathlib/CategoryTheory/Countable.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Discrete",
          "countableCategoryDiscreteOfCountable",
          "Countable",
          "Type",
          "instance",
          "CountableCategory"
        ]
      }
    },
    {
      "id": 2743,
      "before_code": "theorem isCompact_generateFrom' [T : TopologicalSpace X]\n    {S : Set (Set X)} (hTS : T = generateFrom S) {s : Set X}\n    (h : \u2200 (\u03b9 : Type u) (U : \u03b9 \u2192 S), s \u2286 \u22c3 i, U i \u2192 \u2203 J : Set \u03b9, J.Finite \u2227 s \u2286 \u22c3 i \u2208 J, U i) :\n    IsCompact s := by\n  apply isCompact_generateFrom hTS\n  intro P hP hs\n  rw [Set.sUnion_eq_iUnion] at hs\n  obtain \u27e8J, hJ, cover\u27e9 := h P (fun a \u21a6 \u27e8a.1, hP a.2\u27e9) hs\n  refine \u27e8(fun x \u21a6 x.1) '' J, \u27e8by simp, Set.Finite.image _ hJ, ?_\u27e9\u27e9\n  simpa only [Set.sUnion_eq_iUnion, Set.iUnion_coe_set, Set.mem_image, Subtype.exists,\n    exists_and_right, exists_eq_right, Set.iUnion_exists] using cover",
      "suggestion": "\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n",
      "body": "```suggestion\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "simpa",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "Subtype",
          "exists_eq_right",
          "Type",
          "obtain",
          "exists",
          "apply",
          "refine",
          "intro",
          "sUnion_eq_iUnion",
          "IsCompact",
          "hTS",
          "TopologicalSpace",
          "exists_and_right",
          "simp",
          "generateFrom",
          "only",
          "isCompact_generateFrom",
          "Finite",
          "cover",
          "mem_image",
          "theorem",
          "Set",
          "iUnion_coe_set",
          "simpa",
          "image",
          "iUnion_exists",
          "using"
        ]
      }
    },
    {
      "id": 2744,
      "before_code": "\u2203 x, ClusterPt x f := by\n  simpa using isCompact_univ (show f \u2264 \ud835\udcdf univ by simp)\n\nnonrec theorem Ultrafilter.le_nhds_lim [CompactSpace X] (F : Ultrafilter X) : \u2191F \u2264 \ud835\udcdd F.lim := by\n  rcases isCompact_univ.ultrafilter_le_nhds F (by simp) with \u27e8x, -, h\u27e9\n  exact le_nhds_lim \u27e8x, h\u27e9\n\ntheorem CompactSpace.elim_nhds_subcover [CompactSpace X] (U : X \u2192 Set X) (hU : \u2200 x, U x \u2208 \ud835\udcdd x) :\n    \u2203 t : Finset X, \u22c3 x \u2208 t, U x = \u22a4 := by\n  obtain \u27e8t, -, s\u27e9 := IsCompact.elim_nhds_subcover isCompact_univ U fun x _ => hU x\n  exact \u27e8t, top_unique s\u27e9",
      "suggestion": "\r\n  have \u27e8t, _, s\u27e9 := isCompact_univ.elim_nhds_subcover U fun x _ \u21a6 hU x\r\n",
      "body": "```suggestion\r\n  have \u27e8t, _, s\u27e9 := isCompact_univ.elim_nhds_subcover U fun x _ \u21a6 hU x\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "topics": [
          "order",
          "finset",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "show",
          "le_nhds_lim",
          "top_unique",
          "rcases",
          "obtain",
          "nonrec",
          "isCompact_univ",
          "Finset",
          "CompactSpace",
          "ClusterPt",
          "elim_nhds_subcover",
          "IsCompact",
          "univ",
          "ultrafilter_le_nhds",
          "simp",
          "lim",
          "theorem",
          "exact",
          "Set",
          "Ultrafilter",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 2766,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
      "suggestion": "theorem house_rpow_le (\u03b1 : K) (i : \u2115) : house (\u03b1^i) \u2264 house \u03b1 ^ (i : \u211d) := by\n  exact_mod_cast house_pow_le \u03b1 i\n",
      "body": "This proof works:\n\n```suggestion\ntheorem house_rpow_le (\u03b1 : K) (i : \u2115) : house (\u03b1^i) \u2264 house \u03b1 ^ (i : \u211d) := by\n  exact_mod_cast house_pow_le \u03b1 i\n```\n\nSo I suggest to drop this lemma.\n```suggestion\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "theorem",
          "map_mul",
          "simp",
          "house_mul_le",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2767,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
      "suggestion": "theorem house_pow_le (\u03b1 : K) (i : \u2115) : house (\u03b1^i) \u2264 house \u03b1 ^ i := by\n  simpa only [house, map_pow] using norm_pow_le ((canonicalEmbedding K) \u03b1) i\n",
      "body": "```suggestion\ntheorem house_pow_le (\u03b1 : K) (i : \u2115) : house (\u03b1^i) \u2264 house \u03b1 ^ i := by\n  simpa only [house, map_pow] using norm_pow_le ((canonicalEmbedding K) \u03b1) i\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "house",
          "apply",
          "theorem",
          "map_mul",
          "simp",
          "house_mul_le",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2768,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
      "suggestion": "theorem house_nat_mul (\u03b1 : K) (c : \u2115) :\n    house (c * \u03b1) = c * house \u03b1 := by\n  rw [house_eq_sup', house_eq_sup', Finset.sup'_eq_sup, Finset.sup'_eq_sup]\n  norm_cast\n  simp [NNReal.mul_finset_sup]\n",
      "body": "```suggestion\ntheorem house_nat_mul (\u03b1 : K) (c : \u2115) :\n    house (c * \u03b1) = c * house \u03b1 := by\n  rw [house_eq_sup', house_eq_sup', Finset.sup'_eq_sup, Finset.sup'_eq_sup]\n  norm_cast\n  simp [NNReal.mul_finset_sup]\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "rw",
          "norm_cast"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "theorem",
          "map_mul",
          "simp",
          "house_mul_le",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2769,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
      "suggestion": "theorem house_num_mul_int (\u03b1 : K) (c' : \u2124) (hc : 0 \u2264 c') :\n    house ((c' : K) * \u03b1) = |(c' : \u211d)| * house (\u03b1) := by\n  lift c' to \u2115 using hc\n  simpa using house_nat_mul \u03b1 c'\n",
      "body": "You can use the `lift` tactic in a situation like this.\n```suggestion\ntheorem house_num_mul_int (\u03b1 : K) (c' : \u2124) (hc : 0 \u2264 c') :\n    house ((c' : K) * \u03b1) = |(c' : \u211d)| * house (\u03b1) := by\n  lift c' to \u2115 using hc\n  simpa using house_nat_mul \u03b1 c'\n```\nSo I think you can drop this lemma.\n\n```suggestion\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "house",
          "apply",
          "theorem",
          "map_mul",
          "simp",
          "house_mul_le",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2770,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "/-- Let `\u03b1` be a non-zero algebraic integer. Then `\u03b1` has a conjugate `\u03c3 \u03b1` with `\u2016\u03c3 \u03b1\u2016 \u2265 1`. -/\nlemma exists_conjugate_one_le_norm {\u03b1 : \ud835\udcde K} (h\u03b10 : \u03b1 \u2260 0) :\n    \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016 := by\n  obtain \u27e8w, hw\u27e9 : \u2203 w : InfinitePlace K, 1 \u2264 w \u03b1 := by\n    by_contra! h_neg\n    let w\u2080 := Classical.arbitrary (InfinitePlace K)\n    have h_ge_one : 1 \u2264 w\u2080 \u03b1 := InfinitePlace.one_le_of_lt_one h\u03b10 (fun z _ \u21a6 h_neg z)\n    exact (h_neg w\u2080).not_ge h_ge_one\n  use w.embedding\n  rwa [InfinitePlace.norm_embedding_eq]\n",
      "body": "```suggestion\n/-- Let `\u03b1` be a non-zero algebraic integer. Then `\u03b1` has a conjugate `\u03c3 \u03b1` with `\u2016\u03c3 \u03b1\u2016 \u2265 1`. -/\nlemma exists_conjugate_one_le_norm {\u03b1 : \ud835\udcde K} (h\u03b10 : \u03b1 \u2260 0) :\n    \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016 := by\n  obtain \u27e8w, hw\u27e9 : \u2203 w : InfinitePlace K, 1 \u2264 w \u03b1 := by\n    by_contra! h_neg\n    let w\u2080 := Classical.arbitrary (InfinitePlace K)\n    have h_ge_one : 1 \u2264 w\u2080 \u03b1 := InfinitePlace.one_le_of_lt_one h\u03b10 (fun z _ \u21a6 h_neg z)\n    exact (h_neg w\u2080).not_ge h_ge_one\n  use w.embedding\n  rwa [InfinitePlace.n",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2771,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n",
      "body": "```suggestion\nlemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "rw",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "rw",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2772,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma house_prod_le (s : Finset K) : house (\u220f x \u2208 s, x) \u2264 \u220f x \u2208 s, house x := by\n  simpa [house, map_prod] using Finset.norm_prod_le _ _\n",
      "body": "Please move this right after `house_mul_le`.\n```suggestion\nlemma house_prod_le (s : Finset K) : house (\u220f x \u2208 s, x) \u2264 \u220f x \u2208 s, house x := by\n  simpa [house, map_prod] using Finset.norm_prod_le _ _\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2773,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma norm_embedding_le_house (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) : \u2016\u03c3 \u03b1\u2016 \u2264 house \u03b1 := by\n  rw [house_eq_sup']\n  exact Finset.le_sup' (f := (\u2016\u00b7 \u03b1\u2016\u208a)) (Finset.mem_univ \u03c3)\n",
      "body": "```suggestion\nlemma norm_embedding_le_house (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) : \u2016\u03c3 \u03b1\u2016 \u2264 house \u03b1 := by\n  rw [house_eq_sup']\n  exact Finset.le_sup' (f := (\u2016\u00b7 \u03b1\u2016\u208a)) (Finset.mem_univ \u03c3)\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "rw"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2775,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma norm_norm_le_norm_mul_house_pow (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) :\n    \u2016Algebra.norm \u211a \u03b1\u2016 \u2264 \u2016\u03c3 \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by\n  classical\n  set \u03c3' := \u03c3.toRatAlgHom\n  calc _ = \u2016\u220f \u03c4 : K \u2192\u2090[\u211a] \u2102, \u03c4 \u03b1\u2016 := ?_\n       _ = \u2016(\u03c3' \u03b1) * \u220f \u03c4 \u2208 univ.erase \u03c3', \u03c4 \u03b1\u2016 := by rw [mul_prod_erase univ (\u00b7 \u03b1) (mem_univ \u03c3')]\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', \u2016\u03c4 \u03b1\u2016 := ?_\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', house \u03b1 := by gcongr; apply norm_embedding_le_house\n       _ = \u2016\u03c3' \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by simp\n  \u00b7 rw [\u2190 Algebra.norm_eq_prod_embeddings, \u2190 Rat.norm_cast_real,\n      Real.norm_eq_abs, eq_ratCast, Complex.norm_ratCast]\n  \u00b7 rw [Complex.norm_mul]\n    gcongr\n    exact norm_prod_le (univ.erase \u03c3') (\u00b7 \u03b1)\n",
      "body": "```suggestion\nlemma norm_norm_le_norm_mul_house_pow (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) :\n    \u2016Algebra.norm \u211a \u03b1\u2016 \u2264 \u2016\u03c3 \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by\n  classical\n  set \u03c3' := \u03c3.toRatAlgHom\n  calc _ = \u2016\u220f \u03c4 : K \u2192\u2090[\u211a] \u2102, \u03c4 \u03b1\u2016 := ?_\n       _ = \u2016(\u03c3' \u03b1) * \u220f \u03c4 \u2208 univ.erase \u03c3', \u03c4 \u03b1\u2016 := by rw [mul_prod_erase univ (\u00b7 \u03b1) (mem_univ \u03c3')]\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', \u2016\u03c4 \u03b1\u2016 := ?_\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', house \u03b1 := by gcongr; apply norm_embedding_le_house\n       _ = \u2016\u03c3' \u03b1\u2016 * house \u03b1 ",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "gcongr",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 2776,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "    suffices B x y \u2264 0 by simpa [hc, \u2190 hB.le_zero_iff, B.toQuadraticMap_apply]\n    suffices 0 \u2264 \u2211 x \u2208 s with c x < 0, \u2211 i \u2208 s with 0 \u2264 c i, c x * (c i * (B (v i)) (v x)) by\n      simpa [hx, hy, map_neg, Finset.mul_sum]\n",
      "body": "```suggestion\n    suffices B x y \u2264 0 by simpa [hc, \u2190 hB.le_zero_iff, B.toQuadraticMap_apply]\n    suffices 0 \u2264 \u2211 x \u2208 s with c x < 0, \u2211 i \u2208 s with 0 \u2264 c i, c x * (c i * (B (v i)) (v x)) by\n      simpa [hx, hy, map_neg, Finset.mul_sum]\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 2777,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "  rw [\u2190 s.sum_filter_add_sum_filter_not (p := fun i \u21a6 0 \u2264 c i), add_eq_zero_iff_eq_neg] at hc\n  set x := \u2211 i \u2208 s with 0 \u2264 c i, c i \u2022 v i with hx\n  set y := \u2211 i \u2208 s with c i < 0, (-c i) \u2022 v i with hy\n  replace hc : x = y := by simpa [hy] using hc\n",
      "body": "Extreme nitpicking\n```suggestion\n  rw [\u2190 s.sum_filter_add_sum_filter_not (p := fun i \u21a6 0 \u2264 c i), add_eq_zero_iff_eq_neg] at hc\n  set x := \u2211 i \u2208 s with 0 \u2264 c i, c i \u2022 v i with hx\n  set y := \u2211 i \u2208 s with c i < 0, (-c i) \u2022 v i with hy\n  replace hc : x = y := by simpa [hy] using hc\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 2778,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "  apply_fun f at hx hy\n  replace hx : \u2211 i \u2208 s with 0 \u2264 c i, c i * f (v i) = 0 := by simpa [hx\u2080] using hx.symm\n  replace hy : \u2211 i \u2208 s with c i < 0, c i * f (v i) = 0 := by simpa [\u2190 hc, hx\u2080] using hy.symm\n  replace hx (i : \u03b9) (hi : i \u2208 s) : c i \u2264 0 := by\n    rw [Finset.sum_eq_zero_iff_of_nonneg (by grind [mul_nonneg])] at hx\n    by_contra! hi'\n    grind [mul_pos hi' (hp i)]\n  replace hy (i : \u03b9) (hi : i \u2208 s) : 0 \u2264 c i := by\n    rw [Finset.sum_eq_zero_iff_of_nonpos (by grind [mul_nonpos_of_nonpos_of_nonneg])] at hy\n    by_contra! hi'\n    grind [mul_neg_of_neg_of_pos hi' (hp i)]\n",
      "body": "```suggestion\n  apply_fun f at hx hy\n  replace hx : \u2211 i \u2208 s with 0 \u2264 c i, c i * f (v i) = 0 := by simpa [hx\u2080] using hx.symm\n  replace hy : \u2211 i \u2208 s with c i < 0, c i * f (v i) = 0 := by simpa [\u2190 hc, hx\u2080] using hy.symm\n  replace hx (i : \u03b9) (hi : i \u2208 s) : c i \u2264 0 := by\n    rw [Finset.sum_eq_zero_iff_of_nonneg (by grind [mul_nonneg])] at hx\n    by_contra! hi'\n    grind [mul_pos hi' (hp i)]\n  replace hy (i : \u03b9) (hi : i \u2208 s) : 0 \u2264 c i := by\n    rw [Finset.sum_eq_zero_iff_of_nonpos (by grind [mul_nonpo",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 2780,
      "before_code": "variable {G}",
      "suggestion": "\r\n    have : f.NeBot := hf.1\r\n    obtain \u27e8K, K_compact, K_mem\u27e9 := WeaklyLocallyCompactSpace.exists_compact_mem_nhds (1 : G)\r\n    obtain \u27e8x, hx\u27e9 : \u2203 x, \u2200\u1da0 y in f, y / x \u2208 K := by\r\n      rw [cauchy_iff_le, uniformity_eq_comap_nhds_one', \u2190 tendsto_iff_comap] at hf\r\n      exact hf.eventually_mem K_mem |>.curry.exists\r\n    simp_rw [div_eq_mul_inv, \u2190 op_smul_eq_mul, op_inv, \u2190 mem_smul_set_iff_inv_smul_mem] at hx\r\n    have Kx_complete : IsComplete (K <\u2022 x) := K_compact.smul _ |>.isComplete\r\n    obtain \u27e8l, -, hl\u27e9 := Kx_complete f hf (by simpa using hx)\r\n    exact \u27e8l, hl\u27e9\r\n ",
      "body": "Thanks a lot for starting on this! This proof can be cleaned a bit using our filter library, which prevents having to manipulate sets explicitly. I would suggest the following (which needs an `open MulOpposite`) for example:\r\n```suggestion\r\n    have : f.NeBot := hf.1\r\n    obtain \u27e8K, K_compact, K_mem\u27e9 := WeaklyLocallyCompactSpace.exists_compact_mem_nhds (1 : G)\r\n    obtain \u27e8x, hx\u27e9 : \u2203 x, \u2200\u1da0 y in f, y / x \u2208 K := by\r\n      rw [cauchy_iff_le, uniformity_eq_comap_nhds_one', \u2190 tendsto_iff_comap] at hf",
      "path": "Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "rw",
          "exact",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "line_break"
        ],
        "keywords": [
          "variable"
        ]
      }
    },
    {
      "id": 2784,
      "before_code": "end MeasureTheory.Measure",
      "suggestion": "/-- Define a tempered distribution from a L^p function. -/\ndef toTemperedDistribution {p : \u211d\u22650\u221e}\n    [hp : Fact (1 \u2264 p)] (f : Lp F p \u03bc) : \ud835\udce2'(E, F) :=\n  haveI := ENNReal.HolderConjugate.inv_one_sub_inv' hp.out\n  haveI : Fact (1 \u2264 (1 - p\u207b\u00b9)\u207b\u00b9) := by simp [fact_iff]\n  toPointwiseConvergenceCLM _ _ _ _ <|\n    (lsmul \u2102 \u2102).flip.lpPairing \u03bc p (1 - p\u207b\u00b9)\u207b\u00b9 f \u2218L toLpCLM \u2102 \u2102 (1 - p\u207b\u00b9)\u207b\u00b9 \u03bc\n",
      "body": "I suggest instead:\n```suggestion\n/-- Define a tempered distribution from a L^p function. -/\ndef toTemperedDistribution {p : \u211d\u22650\u221e}\n    [hp : Fact (1 \u2264 p)] (f : Lp F p \u03bc) : \ud835\udce2'(E, F) :=\n  haveI := ENNReal.HolderConjugate.inv_one_sub_inv' hp.out\n  haveI : Fact (1 \u2264 (1 - p\u207b\u00b9)\u207b\u00b9) := by simp [fact_iff]\n  toPointwiseConvergenceCLM _ _ _ _ <|\n    (lsmul \u2102 \u2102).flip.lpPairing \u03bc p (1 - p\u207b\u00b9)\u207b\u00b9 f \u2218L toLpCLM \u2102 \u2102 (1 - p\u207b\u00b9)\u207b\u00b9 \u03bc\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "MeasureTheory",
          "Measure"
        ]
      }
    },
    {
      "id": 2785,
      "before_code": "end MeasureTheory.Measure",
      "suggestion": "  \u00b7 exact (Lp.memLp f).locallyIntegrable hp.elim\n  \u00b7 intro g g_smooth g_cpt\n    have hg\u2081 : HasCompactSupport (Complex.ofRealCLM \u2218 g) := g_cpt.comp_left rfl\n",
      "body": "dot notation\n\n```suggestion\n  \u00b7 exact (Lp.memLp f).locallyIntegrable hp.elim\n  \u00b7 intro g g_smooth g_cpt\n    have hg\u2081 : HasCompactSupport (Complex.ofRealCLM \u2218 g) := g_cpt.comp_left rfl\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "have",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "have",
          "intro"
        ],
        "new_tactics": [
          "exact",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "MeasureTheory",
          "Measure"
        ]
      }
    },
    {
      "id": 2786,
      "before_code": "@[simp]\ntheorem card_add (s t : Multiset \u03b1) : card (s + t) = card s + card t :=\n  Quotient.inductionOn\u2082 s t length_append",
      "suggestion": "\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n",
      "body": "```suggestion\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n```",
      "path": "Mathlib/Data/Multiset/AddSub.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Quotient",
          "length_append",
          "simp",
          "card_add",
          "Multiset",
          "card"
        ]
      }
    },
    {
      "id": 2794,
      "before_code": "@[simp]\ntheorem card_add (s t : Multiset \u03b1) : card (s + t) = card s + card t :=\n  Quotient.inductionOn\u2082 s t length_append",
      "suggestion": "\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n",
      "body": "```suggestion\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n```",
      "path": "Mathlib/Data/Multiset/AddSub.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Quotient",
          "length_append",
          "simp",
          "card_add",
          "Multiset",
          "card"
        ]
      }
    },
    {
      "id": 2802,
      "before_code": "@[simp]\ntheorem card_add (s t : Multiset \u03b1) : card (s + t) = card s + card t :=\n  Quotient.inductionOn\u2082 s t length_append",
      "suggestion": "\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n",
      "body": "```suggestion\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n```",
      "path": "Mathlib/Data/Multiset/AddSub.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Quotient",
          "length_append",
          "simp",
          "card_add",
          "Multiset",
          "card"
        ]
      }
    },
    {
      "id": 2810,
      "before_code": "@[simp]\ntheorem card_add (s t : Multiset \u03b1) : card (s + t) = card s + card t :=\n  Quotient.inductionOn\u2082 s t length_append",
      "suggestion": "\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n",
      "body": "```suggestion\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n```",
      "path": "Mathlib/Data/Multiset/AddSub.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Quotient",
          "length_append",
          "simp",
          "card_add",
          "Multiset",
          "card"
        ]
      }
    },
    {
      "id": 2818,
      "before_code": "@[simp]\ntheorem card_add (s t : Multiset \u03b1) : card (s + t) = card s + card t :=\n  Quotient.inductionOn\u2082 s t length_append",
      "suggestion": "\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n",
      "body": "```suggestion\r\n  Quotient.inductionOn\u2082 s t fun _ _ => length_append\r\n```",
      "path": "Mathlib/Data/Multiset/AddSub.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Quotient",
          "length_append",
          "simp",
          "card_add",
          "Multiset",
          "card"
        ]
      }
    },
    {
      "id": 2830,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n    p \u2208 idealOfVars \u03c3 R ^ n \u2194 \u2200 x \u2208 p.support, n \u2264 x.sum (fun _ => id) := by\r\n",
      "body": "I feel like this makes more sense as a statement.\r\n```suggestion\r\n    p \u2208 idealOfVars \u03c3 R ^ n \u2194 \u2200 x \u2208 p.support, n \u2264 x.sum (fun _ => id) := by\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 2834,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  simp [\u2190 degree_preimage_nsmul, hn]\r\n",
      "body": "You are missing the following lemmas\r\n```lean\r\nopen scoped Pointwise in\r\nlemma exists_le_degree_eq {\u03c3 : Type*} (f : \u03c3 \u2192\u2080 \u2115) (n : \u2115) (hn : n \u2264 f.degree) :\r\n    \u2203 g \u2264 f, g.degree = n := by\r\n  induction n with\r\n  | zero => simp [degree_eq_zero_iff]\r\n  | succ n IH =>\r\n    obtain \u27e8g, hgf, rfl\u27e9 := IH (by lia)\r\n    obtain \u27e8f, rfl\u27e9 := le_iff_exists_add.mp hgf\r\n    obtain \u27e8i, hi\u27e9 : f.support.Nonempty := by aesop\r\n    exact \u27e8g + .single i 1, add_le_add_right (by simp; grind) _, by simp\u27e9\r\n\r\nopen scoped Poi",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "exact",
          "grind",
          "obtain",
          "induction",
          "simp_all",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 2835,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\n  \u00b7 simp [hn]\r\n",
      "body": "```suggestion\r\n  \u00b7 simp [hn]\r\n```\r\nIf you add this as a simp lemma\r\n```lean\r\n@[simp]\r\nlemma Set.Ici_zero {\u03b1 : Type*} [AddZeroClass \u03b1] [Preorder \u03b1] [CanonicallyOrderedAdd \u03b1] :\r\n    Set.Ici (0 : \u03b1) = Set.univ := by aesop\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 2836,
      "before_code": "closure s \u2286 f \u207b\u00b9' closure (f '' s) :=\n  (mapsTo_image _ _).closure h",
      "suggestion": "    Continuous f \u2194 \u2200 s, f '' closure s \u2286 closure (f '' s) where\n  mp h s := image_closure_subset_closure_image h\n  mpr h := continuous_iff_isClosed.mpr fun s hs \u21a6 isClosed_of_closure_subset <| by\n    grw [image_subset_iff.mp <| h (f \u207b\u00b9' s), image_preimage_subset, hs.closure_subset]\n",
      "body": "I find this more readable.\n```suggestion\n    Continuous f \u2194 \u2200 s, f '' closure s \u2286 closure (f '' s) where\n  mp h s := image_closure_subset_closure_image h\n  mpr h := continuous_iff_isClosed.mpr fun s hs \u21a6 isClosed_of_closure_subset <| by\n    grw [image_subset_iff.mp <| h (f \u207b\u00b9' s), image_preimage_subset, hs.closure_subset]\n```",
      "path": "Mathlib/Topology/Continuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "closure",
          "mapsTo_image"
        ]
      }
    },
    {
      "id": 2837,
      "before_code": "f \u207b\u00b9' interior t \u2286 interior (f \u207b\u00b9' t) :=\n  interior_maximal (preimage_mono interior_subset) (isOpen_interior.preimage hf)",
      "suggestion": "    Continuous f \u2194 \u2200 s, f \u207b\u00b9' (interior s) \u2286 interior (f \u207b\u00b9' s) where\n  mp h s := preimage_interior_subset_interior_preimage h\n  mpr h := \u27e8fun s hs \u21a6 subset_interior_iff_isOpen.mp <| by grw [\u2190 h, hs.interior_eq]\u27e9\n",
      "body": "```suggestion\n    Continuous f \u2194 \u2200 s, f \u207b\u00b9' (interior s) \u2286 interior (f \u207b\u00b9' s) where\n  mp h s := preimage_interior_subset_interior_preimage h\n  mpr h := \u27e8fun s hs \u21a6 subset_interior_iff_isOpen.mp <| by grw [\u2190 h, hs.interior_eq]\u27e9\n```",
      "path": "Mathlib/Topology/Continuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "preimage_mono",
          "interior_maximal",
          "isOpen_interior",
          "interior_subset",
          "preimage",
          "interior"
        ]
      }
    },
    {
      "id": 2838,
      "before_code": "hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\nend Dense",
      "suggestion": "  \u27e8fun h \u21a6 by simpa using congr($h\u15ee), fun h \u21a6 congr($h\u15ee)\u27e9\n",
      "body": "```suggestion\n  \u27e8fun h \u21a6 by simpa using congr($h\u15ee), fun h \u21a6 congr($h\u15ee)\u27e9\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "congr"
        ],
        "new_tactics": [
          "simpa",
          "congr"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "inner_zero_right",
          "end",
          "Dense",
          "eq_of_inner_right"
        ]
      }
    },
    {
      "id": 2839,
      "before_code": "hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\nend Dense",
      "suggestion": "theorem orthogonal_injective [CompleteSpace E] :\n    Function.Injective (fun K : ClosedSubmodule \ud835\udd5c E \u21a6 K\u15ee) :=\n  (orthogonal_eq_orthogonal_iff \u00b7 \u00b7 |>.mp)\n\n/-- The sup of two orthogonal subspaces equals the subspace orthogonal\nto the inf. -/\ntheorem sup_orthogonal [CompleteSpace E] (K\u2081 K\u2082 : ClosedSubmodule \ud835\udd5c E) :\n    K\u2081\u15ee \u2294 K\u2082\u15ee = (K\u2081 \u2293 K\u2082)\u15ee := by\n  simpa using congr($(inf_orthogonal K\u2081\u15ee K\u2082\u15ee)\u15ee).symm\n",
      "body": "Here's a another `simpa` proof, and let's have this `orthogonal_injective` lemma too.\n```suggestion\ntheorem orthogonal_injective [CompleteSpace E] :\n    Function.Injective (fun K : ClosedSubmodule \ud835\udd5c E \u21a6 K\u15ee) :=\n  (orthogonal_eq_orthogonal_iff \u00b7 \u00b7 |>.mp)\n\n/-- The sup of two orthogonal subspaces equals the subspace orthogonal\nto the inf. -/\ntheorem sup_orthogonal [CompleteSpace E] (K\u2081 K\u2082 : ClosedSubmodule \ud835\udd5c E) :\n    K\u2081\u15ee \u2294 K\u2082\u15ee = (K\u2081 \u2293 K\u2082)\u15ee := by\n  simpa using congr($(inf_orthogonal K\u2081\u15ee K\u2082\u15ee)\u15ee).symm\n`",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "congr"
        ],
        "body_tactics": [
          "simpa",
          "congr",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "congr"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "inner_zero_right",
          "end",
          "Dense",
          "eq_of_inner_right"
        ]
      }
    },
    {
      "id": 2840,
      "before_code": "theorem continuous_closure : Continuous (Closeds.closure (\u03b1 := \u03b1)) :=\n  uniformContinuous_closure.continuous",
      "suggestion": "instance [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) where\n  isCompact_univ := by simpa [gi.l_surjective.range_eq]\n    using isCompact_univ.image continuous_closure\n",
      "body": "```suggestion\ninstance [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) where\n  isCompact_univ := by simpa [gi.l_surjective.range_eq]\n    using isCompact_univ.image continuous_closure\n```",
      "path": "Mathlib/Topology/UniformSpace/Closeds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "theorem",
          "closure",
          "continuous_closure",
          "continuous",
          "Closeds",
          "Continuous",
          "uniformContinuous_closure"
        ]
      }
    },
    {
      "id": 2843,
      "before_code": "instance isRegularEpi_of_extremalEpi (f : X \u27f6 Y) [ExtremalEpi f] : IsRegularEpi f :=\n  \u27e8\u27e8regularEpiOfExtremalEpi f\u27e9\u27e9",
      "suggestion": "noncomputable def frobeniusMorphism :\n  underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n  (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip.lift\n    ((ofLE _ _ (inf_le_right A' ((Subobject.pullback f).obj B'))) \u226b (pullback\u03c0 _ _))\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))) \u226b (imageFactorisation f A').F.e)\n    (by simp [\u2190 imageFactorisation_F_m, (isPullback _ _).w])\n\nlemma frobeniusMorphism_isPullback :\n  IsPullback (frobeniusMorphism f A' B')\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))))\n    ((ofLE _ _ (inf_le_left ((\u00abexists\u00bb f).obj A') B')))\n    (imageFactorisation _ _).F.e := by\n  apply IsPullback.of_right (t := (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip)\n    (p := by simp [frobeniusMorphism])\n  simpa [frobeniusMorphism, IsPullback.lift_fst, \u2190 imageFactorisation_F_m,\n    (isPullback f B').paste_horiz_iff ] using\n    (inf_isPullback A' ((Subobject.pullback f).obj B')).flip\n\ninstance : IsRegula",
      "body": "```suggestion\nnoncomputable def frobeniusMorphism :\n  underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n  (inf_isPullback ((\u00abexists\u00bb f).obj A') B').flip.lift\n    ((ofLE _ _ (inf_le_right A' ((Subobject.pullback f).obj B'))) \u226b (pullback\u03c0 _ _))\n    ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))) \u226b (imageFactorisation f A').F.e)\n    (by simp [\u2190 imageFactorisation_F_m, (isPullback _ _).w])\n\nlemma frobeniusMorphism_isPullback :\n  IsPullbac",
      "path": "Mathlib/CategoryTheory/RegularCategory/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "rw",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "IsRegularEpi",
          "regularEpiOfExtremalEpi",
          "isRegularEpi_of_extremalEpi",
          "instance",
          "ExtremalEpi"
        ]
      }
    },
    {
      "id": 2845,
      "before_code": "p.darts[i].snd = p.support.tail[i]'(by grind) := by\n  grind [map_snd_darts]",
      "suggestion": "lemma support_getElem_zero (p : G.Walk u v) : p.support[0] = u := by cases p <;> simp\n",
      "body": "```suggestion\nlemma support_getElem_zero (p : G.Walk u v) : p.support[0] = u := by cases p <;> simp\n```\nThis seems to work for me",
      "path": "Mathlib/Combinatorics/SimpleGraph/Walks/Basic.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [
          "cases",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "simp"
        ],
        "removed_tactics": [
          "grind"
        ],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support",
          "map_snd_darts",
          "grind",
          "tail",
          "snd",
          "darts"
        ]
      }
    },
    {
      "id": 2852,
      "before_code": "theorem \u03c9Sup_zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : \u03c9Sup (c\u2080.zip c\u2081) = (\u03c9Sup c\u2080, \u03c9Sup c\u2081) := rfl",
      "suggestion": "\r\n    {g : \u03b1 \u2192 \u03b3} (hg : \u03c9ScottContinuous g) :\r\n    \u03c9ScottContinuous fun x \u21a6 (f x, g x) :=\r\n",
      "body": "```suggestion\r\n    {g : \u03b1 \u2192 \u03b3} (hg : \u03c9ScottContinuous g) :\r\n    \u03c9ScottContinuous fun x \u21a6 (f x, g x) :=\r\n```\r\nSame everywhere else",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "rfl",
          "Chain",
          "zip",
          "theorem"
        ]
      }
    },
    {
      "id": 2853,
      "before_code": "\u03c9ScottContinuous.of_monotone_map_\u03c9Sup\n    \u27e8fun _ _ h \u21a6 hf.monotone h a, fun c \u21a6 congr_fun (hf.map_\u03c9Sup c) a\u27e9",
      "suggestion": "\r\nlemma \u03c9ScottContinuous.apply (x : \u03b1) : \u03c9ScottContinuous (fun f : \u2200 x, \u03b2 x \u21a6 f x) :=\r\n",
      "body": "```suggestion\r\nlemma \u03c9ScottContinuous.apply (x : \u03b1) : \u03c9ScottContinuous (fun f : \u2200 x, \u03b2 x \u21a6 f x) :=\r\n```",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "monotone",
          "congr_fun"
        ]
      }
    },
    {
      "id": 2854,
      "before_code": "simpa [map_coe, OrderHom.coe_mk, Set.range_comp]\n    using hf (by simp) (Set.range_nonempty _) (isChain_range c).directedOn (isLUB_range_\u03c9Sup c)",
      "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```\r\nThis way, the `fun_id` lemma is also tagged with fun_prop.",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "OrderHom",
          "range_comp",
          "map_coe",
          "coe_mk",
          "Set",
          "directedOn",
          "simpa",
          "simp",
          "range_nonempty",
          "isChain_range",
          "using"
        ]
      }
    },
    {
      "id": 2855,
      "before_code": "inter_eq_self_of_subset_right (Ici_subset_Ici.2 hab)]\n  exact isLeast_Ici\n\n@[simp] lemma ScottContinuousOn.id : ScottContinuousOn D (id : \u03b1 \u2192 \u03b1) := by simp [ScottContinuousOn]\n\nvariable {g : \u03b1 \u2192 \u03b2}\n\nlemma ScottContinuousOn.prodMk (hD : \u2200 a b : \u03b1, a \u2264 b \u2192 {a, b} \u2208 D)",
      "suggestion": "\r\n@[to_fun (attr := fun_prop, simp)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop, simp)]\r\n```",
      "path": "Mathlib/Order/ScottContinuity.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "continuity",
          "set_theory"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "Ici_subset_Ici",
          "inter_eq_self_of_subset_right",
          "lemma",
          "variable",
          "exact",
          "ScottContinuousOn",
          "hab",
          "isLeast_Ici",
          "simp",
          "prodMk"
        ]
      }
    },
    {
      "id": 2856,
      "before_code": "theorem \u03c9Sup_zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : \u03c9Sup (c\u2080.zip c\u2081) = (\u03c9Sup c\u2080, \u03c9Sup c\u2081) := rfl",
      "suggestion": "    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n",
      "body": "Something like\n```suggestion\n    exact \u27e8pair a b hab, range_pair a b hab\u27e9\n```\nshould work, and then you can remove the `by exact` and (probably) format everything on one line.",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "rfl",
          "Chain",
          "zip",
          "theorem"
        ]
      }
    },
    {
      "id": 2857,
      "before_code": "OmegaCompletePartialOrder.lift ContinuousHom.toMono ContinuousHom.\u03c9Sup\n    (fun _ _ h => h) (fun _ => rfl)\n\nnamespace Prod\n\n/-- The application of continuous functions as a continuous function. -/\n@[simps]\ndef apply : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1 \u2192\ud835\udc84 \u03b2 where\n  toFun f := f.1 f.2\n  monotone' x y h := by\n    dsimp\n    trans y.fst x.snd <;> [apply h.1; apply y.1.monotone h.2]\n  map_\u03c9Sup' c := by\n    apply le_antisymm\n    \u00b7 apply \u03c9Sup_le\n      intro i\n      dsimp\n      rw [(c _).fst.continuous]\n      apply \u03c9Sup_le\n      intro j\n      apply le_\u03c9Sup_of_le (max i j)\n      apply apply_mono\n      \u00b7 exact monotone_fst (OrderHom.mono _ (le_max_left _ _))\n      \u00b7 exact monotone_snd (OrderHom.mono _ (le_max_right _ _))\n    \u00b7 apply \u03c9Sup_le\n      intro i\n      apply le_\u03c9Sup_of_le i\n      dsimp\n      apply OrderHom.mono _\n      apply le_\u03c9Sup_of_le i\n      rfl",
      "suggestion": "def apply : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1 \u2192\ud835\udc84 \u03b2 := ofFun (fun f \u21a6 f.1 f.2)\n",
      "body": "```suggestion\ndef apply : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1 \u2192\ud835\udc84 \u03b2 := ofFun (fun f \u21a6 f.1 f.2)\n```",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw",
          "intro"
        ],
        "topics": [
          "continuity",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "OrderHom",
          "monotone_fst",
          "le_antisymm",
          "le_max_left",
          "lift",
          "snd",
          "apply_mono",
          "apply",
          "mono",
          "monotone",
          "fst",
          "OmegaCompletePartialOrder",
          "max",
          "intro",
          "Prod",
          "def",
          "toFun",
          "simps",
          "rfl",
          "application",
          "dsimp",
          "namespace",
          "function",
          "ContinuousHom",
          "exact",
          "continuous",
          "trans",
          "toMono",
          "le_max_right",
          "functions",
          "monotone_snd"
        ]
      }
    },
    {
      "id": 2860,
      "before_code": "obtain \u27e8s, rfl\u27e9 := hN\n    induction s using Finset.induction with\n    | empty =>\n      rw [Finset.coe_empty, Submodule.span_empty, \u2190 Submodule.span_zero_singleton]\n      exact h\u2081 _\n    | insert _ _ _ ih =>\n      rw [Finset.coe_insert, Submodule.span_insert]\n      exact h\u2082 _ _ (h\u2081 _) ih\n\ntheorem fg_restrictScalars {R S M : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommMonoid M] [Module S M] [Module R M] [IsScalarTower R S M] (N : Submodule S M)\n    (hfin : N.FG) (h : Function.Surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).FG := by\n  obtain \u27e8X, rfl\u27e9 := hfin\n  use X\n  exact (Submodule.restrictScalars_span R S h (X : Set M)).symm\n\nlemma FG.of_restrictScalars (R) {A M} [Semiring R] [Semiring A] [AddCommMonoid M]\n    [SMul R A] [Module R M] [Module A M] [IsScalarTower R A M] (S : Submodule A M)\n    (hS : (S.restrictScalars R).FG) : S.FG := by\n  obtain \u27e8s, e\u27e9 := hS\n  refine \u27e8s, Submodule.restrictScalars_injective R _ _ (le_antisymm ?_ ?_)\u27e9\n  \u00b7 change Submodule.span A s \u2264 S\n    have := Submodule.span_le.mp e.le\n    rwa [Submodule.span_le]\n  \u00b7 rw [\u2190 e]\n    exact Submodule.span_le_restrictScalars _ _ _\n\ntheorem FG.stabilizes_of_iSup_eq {M' : Submodule R M} (hM' : M'.FG) (N : \u2115 \u2192o Submodule R M)\n    (H : iSup N = M') : \u2203 n, M' = N n := by\n  obtain \u27e8S, hS\u27e9 := hM'\n  have : \u2200 s : S, \u2203 n, (s : M) \u2208 N n := fun s =>\n    (Submodule.mem_iSup_of_chain N s).mp\n      (by\n        rw [H, \u2190 hS]\n        exact Submodule.subset_span s.2)",
      "suggestion": "\r\n  have (s : S) : \u2203 n, (s : M) \u2208 N n :=\r\n    (mem_iSup_of_chain N s).mp (by simpa [H, \u2190 hS] using subset_span s.prop)\r\n",
      "body": "```suggestion\r\n  have (s : S) : \u2203 n, (s : M) \u2208 N n :=\r\n    (mem_iSup_of_chain N s).mp (by simpa [H, \u2190 hS] using subset_span s.prop)\r\n```",
      "path": "Mathlib/RingTheory/Finiteness/Basic.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "induction"
        ],
        "suggestion_tactics": [
          "simpa",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "have"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "refine",
          "exact",
          "obtain",
          "induction",
          "rw"
        ],
        "topics": [
          "function",
          "nat",
          "algebra",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Module",
          "lemma",
          "rwa",
          "fg_restrictScalars",
          "le_antisymm",
          "Type",
          "change",
          "obtain",
          "of_restrictScalars",
          "Function",
          "span_zero_singleton",
          "coe_empty",
          "empty",
          "insert",
          "restrictScalars",
          "symm",
          "refine",
          "span_insert",
          "Finset",
          "have",
          "Submodule",
          "span_empty",
          "mem_iSup_of_chain",
          "span_le_restrictScalars",
          "CommSemiring",
          "restrictScalars_injective",
          "hfin",
          "span",
          "stabilizes_of_iSup_eq",
          "Semiring",
          "induction",
          "rfl",
          "use",
          "subset_span",
          "AddCommMonoid",
          "theorem",
          "IsScalarTower",
          "exact",
          "Set",
          "iSup",
          "coe_insert",
          "restrictScalars_span",
          "SMul",
          "algebraMap",
          "Algebra",
          "Surjective",
          "span_le",
          "using"
        ]
      }
    },
    {
      "id": 2863,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n        rw [\u2190 (DiffContOnCl.circleIntegral_one_div_sub_center_pow_smul hR n hf)]\r\n",
      "body": "Please keep indentation consistent inside `calc` blocks, it aids readability. \r\n\r\nIf you're using `congr` followed by `exact`, it's worth trying whether `rw` (or `simp_rw`, `simp only` etc) can do it in one line:\r\n```suggestion\r\n        rw [\u2190 (DiffContOnCl.circleIntegral_one_div_sub_center_pow_smul hR n hf)]\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 2864,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n      rw [RCLike.norm_nsmul (K := \u2102), nsmul_eq_mul, mul_le_mul_iff_right\u2080 (by positivity)]\r\n      exact circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const hR.le hp\r\n",
      "body": "```suggestion\r\n      rw [RCLike.norm_nsmul (K := \u2102), nsmul_eq_mul, mul_le_mul_iff_right\u2080 (by positivity)]\r\n      exact circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const hR.le hp\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "new_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 2865,
      "before_code": "norm_deriv_le_aux hR (e.differentiable.comp_diffContOnCl hd) fun z hz =>\n        (UniformSpace.Completion.norm_coe _).trans_le (hC z hz)",
      "suggestion": "\r\n      \u222e z in C(c, R), (z - c)\u207b\u00b9 ^ (n + 1) \u2022 f z\u2016 := by rw [hq]\r\n",
      "body": "Alternative (not saying it's better, matter of taste):\r\n```suggestion\r\n      \u222e z in C(c, R), (z - c)\u207b\u00b9 ^ (n + 1) \u2022 f z\u2016 := by rw [hq]\r\n```",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "differentiability",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "Completion",
          "trans_le",
          "UniformSpace",
          "norm_coe",
          "norm_deriv_le_aux",
          "comp_diffContOnCl",
          "differentiable"
        ]
      }
    },
    {
      "id": 2870,
      "before_code": "simp only [mem_adjoin_iff_div, Algebra.adjoin_singleton_eq_range_aeval,\n    AlgHom.mem_range, exists_exists_eq_and]",
      "suggestion": "\r\ntheorem forall_mem_adjoin_smul_eq_self_iff {M : Type*} [Group M] [MulSemiringAction M E]\r\n    [SMulCommClass M F E] (m : M) :\r\n    (\u2200 x \u2208 adjoin F S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) := by\r\n  refine \u27e8fun h x hx \u21a6 h _ <| mem_adjoin_of_mem F hx, fun h x hx \u21a6 ?_\u27e9\r\n  induction hx using adjoin_induction F <;> simp_all [smul_inv\u2080']\r\n",
      "body": "Here is an almost working suggestion:\r\n```suggestion\r\ntheorem forall_mem_adjoin_smul_eq_self_iff {M : Type*} [Group M] [MulSemiringAction M E]\r\n    [SMulCommClass M F E] (m : M) :\r\n    (\u2200 x \u2208 adjoin F S, m \u2022 x = x) \u2194 (\u2200 x \u2208 S, m \u2022 x = x) := by\r\n  refine \u27e8fun h x hx \u21a6 h _ <| mem_adjoin_of_mem F hx, fun h x hx \u21a6 ?_\u27e9\r\n  induction hx using adjoin_induction F <;> simp_all [smul_inv\u2080']\r\n```\r\nThe problem is that this requires `M` to be a group because [smul_inv\u2080'](https://leanprover-community.github.io",
      "path": "Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "induction",
          "simp_all"
        ],
        "body_tactics": [
          "refine",
          "induction",
          "simp_all"
        ],
        "new_tactics": [
          "simp_all",
          "induction",
          "refine"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "mem_adjoin_iff_div",
          "mem_range",
          "exists_exists_eq_and",
          "simp",
          "AlgHom",
          "adjoin_singleton_eq_range_aeval",
          "Algebra",
          "only"
        ]
      }
    },
    {
      "id": 2878,
      "before_code": "go (.app (.app c f) x) as\n    | .app f a, as => go f (as.push { expr := a })",
      "suggestion": "\r\n      let u \u2190 getLevel t\r\n      let v \u2190 withLocalDecl x bi t fun x => getLevel (b.instantiate1 x)\r\n",
      "body": "```suggestion\r\n      let u \u2190 getLevel t\r\n      let v \u2190 withLocalDecl x bi t fun x => getLevel (b.instantiate1 x)\r\n```",
      "path": "Mathlib/Tactic/FunProp/Mor.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "push",
          "expr",
          "app"
        ]
      }
    },
    {
      "id": 2879,
      "before_code": "/-- `mkAppN f #[a\u2080, ..., a\u2099]` ==> `f a\u2080 a\u2081 .. a\u2099` where `f` can be bundled morphism. -/\ndef mkAppN (f : Expr) (xs : Array Arg) : Expr :=\n  xs.foldl (init := f) (fun f x =>",
      "suggestion": "\r\n  let f :=\r\n    if f.isConstOf `_Forall then\r\n      Expr.mkLambdaForall f.constLevels![0]! f.constLevels![1]!\r\n    else f\r\n  xs.foldl (init := f) (fun f x =>\r\n",
      "body": "```suggestion\r\n  let f :=\r\n    if f.isConstOf `_Forall then\r\n      Expr.mkLambdaForall f.constLevels![0]! f.constLevels![1]!\r\n    else f\r\n  xs.foldl (init := f) (fun f x =>\r\n```\r\nI think shadowing names like this is clearer as it shows you're not using the old name anymore",
      "path": "Mathlib/Tactic/FunProp/Mor.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Arg",
          "can",
          "def",
          "Expr",
          "morphism",
          "init",
          "mkAppN",
          "bundled",
          "Array",
          "foldl"
        ]
      }
    },
    {
      "id": 2880,
      "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
      "suggestion": "  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n",
      "body": "```suggestion\n  \u00b7 exact (MeasurableSet.sUnion D_mem.2 (by grind)).nullMeasurableSet\n```",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "nullMeasurable",
          "g_mble",
          "Set",
          "Countable",
          "Measurable"
        ]
      }
    },
    {
      "id": 2881,
      "before_code": "(g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } } :=\n  countable_meas_level_set_pos\u2080 g_mble.nullMeasurable",
      "suggestion": "  apply ae_sum_iff.2 (fun n \u21a6 (hD n s hs).trans ?_)\n",
      "body": "```suggestion\n  apply ae_sum_iff.2 (fun n \u21a6 (hD n s hs).trans ?_)\n```",
      "path": "Mathlib/MeasureTheory/Measure/Typeclasses/SFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply"
        ],
        "body_tactics": [
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "nullMeasurable",
          "g_mble",
          "Set",
          "Countable",
          "Measurable"
        ]
      }
    },
    {
      "id": 2887,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  rw [\u2190 isCoatom_stabilizer_iff_preprimitive _ s, stabilizer_coe]\r\n  apply alternatingGroup.isCoatom_stabilizer\r\n  \u00b7 rw [Combination.coe_nonempty_iff]\r\n    exact le_trans (by norm_num) h_three_le\r\n  \u00b7 simp [Set.nonempty_compl, Set.eq_univ_iff_ncard, ncard_eq, hn.ne]\r\n  \u00b7 simpa [ncard_eq]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 isCoatom_stabilizer_iff_preprimitive _ s, stabilizer_coe]\r\n  apply alternatingGroup.isCoatom_stabilizer\r\n  \u00b7 rw [Combination.coe_nonempty_iff]\r\n    exact le_trans (by norm_num) h_three_le\r\n  \u00b7 simp [Set.nonempty_compl, Set.eq_univ_iff_ncard, ncard_eq, hn.ne]\r\n  \u00b7 simpa [ncard_eq]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "norm_num",
          "apply",
          "exact",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "norm_num",
          "apply",
          "exact",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "norm_num",
          "apply",
          "simpa",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 2889,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j :=\n  \u27e8fun hsum i j \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mp (by simpa using hsum) i j,\n    fun heq \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mpr (by simpa using heq)\u27e9\n",
      "body": "```suggestion\n    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j :=\n  \u27e8fun hsum i j \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mp (by simpa using hsum) i j,\n    fun heq \u21a6 by simpa using (sum_eq_zero_iff_eq_coeff h\u03b6 (\u03b1 \u00b7)).mpr (by simpa using heq)\u27e9\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 2890,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pred_eq_of_pos hprime.pos\n    -- Derive a vanishing relation with coefficients `\u03b1\u1d62 - \u03b1_{p-1}` and exponents `< n`.\n    have : \u2211 i \u2208 Finset.range (n + 1), \u03b1Nat i * \u03b6 ^ i = 0 := by\n      simpa [show n + 1 = p by omega, \u2190 Fin.sum_univ_eq_sum_range, h\u03b1Nat_val]\n    have : \u2211 i \u2208 Finset.range n, \u03b1Nat i * \u03b6 ^ i - \u03b1Nat n * \u2211 i \u2208 Finset.range n, \u03b6 ^ i = 0 := by\n      rw [Finset.sum_range_succ] at this\n      -- Use the standard relation for primitive roots: `\u03b6^{p-1} = -\u2211_{i<p-1} \u03b6^i`.\n      grind [h\u03b6.pow_sub_one_eq hprime.one_lt]\n    have h",
      "body": "Attempted golfing\n\n```suggestion\n  have hprime : Nat.Prime p := Fact.out\n  constructor\n  -- Forward direction: vanishing implies equal coefficients\n  \u00b7 intro\n    -- Use a total function on \u2115 to avoid dependent Fin casts.\n    let \u03b1Nat i := if hi : i < p then \u03b1 \u27e8i, hi\u27e9 else 0\n    -- Rewrite the sum over `Fin p` as a sum over `Finset.range p`.\n    have h\u03b1Nat_val i : \u03b1Nat i.val = \u03b1 i := dif_pos _\n    -- Split off the last term at index `n = p - 1`.\n    set n := p.pred\n    have hn_succ := Nat.succ_pr",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "body_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "new_tactics": [
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro",
          "ring",
          "omega"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_omega",
          "cleanup_simp",
          "use_simpa",
          "use_grind",
          "use_ring"
        ],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 2892,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "  refine ext fun x => \u27e8?_, fun \u27e8t, \u27e8i, hi\u27e9, ht\u27e9 \u21a6 ?_\u27e9\n",
      "body": "I suggest you start with this to avoid `;`:\n```suggestion\n  refine ext fun x => \u27e8?_, fun \u27e8t, \u27e8i, hi\u27e9, ht\u27e9 \u21a6 ?_\u27e9\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "ext"
        ],
        "body_tactics": [
          "refine",
          "ext"
        ],
        "new_tactics": [
          "refine",
          "ext"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 2893,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "    \u00b7 exact .biUnion (to_countable _) fun _ _ \u21a6 hm _\n",
      "body": "`measurability` tends to be a bit slow so I suggest you replace it with this.\n```suggestion\n    \u00b7 exact .biUnion (to_countable _) fun _ _ \u21a6 hm _\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "measurability"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 2894,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "  \u00b7 refine \u27e8fun n => SimpleFunc.indexedPartitionPiecewise hs hm (fun i => (hf i).approx n),\n      fun x => ?_\u27e9\n    simp [SimpleFunc.indexedPartitionPiecewise, IndexedPartition.piecewise_apply,\n      StronglyMeasurable.tendsto_approx]\n  simp only [not_finite_iff_infinite] at Fi\n",
      "body": "When you have small subgoals followed a main one, it's ok to not put a dot before the last one, so as to avoid too much indentation.\n```suggestion\n  \u00b7 refine \u27e8fun n => SimpleFunc.indexedPartitionPiecewise hs hm (fun i => (hf i).approx n),\n      fun x => ?_\u27e9\n    simp [SimpleFunc.indexedPartitionPiecewise, IndexedPartition.piecewise_apply,\n      StronglyMeasurable.tendsto_approx]\n  simp only [not_finite_iff_infinite] at Fi\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 2895,
      "before_code": "(hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg",
      "suggestion": "        have : y = (\u27e8y, by lia\u27e9 : Fin (b + 1)).1 := rfl\n",
      "body": "`linarith` should also be replaced by `lia`, can you do so in the rest of the proof as well?\n```suggestion\n        have : y = (\u27e8y, by lia\u27e9 : Fin (b + 1)).1 := rfl\n```",
      "path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have",
          "linarith"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "StronglyMeasurable",
          "ite",
          "piecewise"
        ]
      }
    },
    {
      "id": 2896,
      "before_code": "@SeparatesPoints _ m' := @SeparatesPoints.mk _ m' fun _ _ hxy \u21a6\n    @SeparatesPoints.separates _ m hsep _ _ fun _ hs \u21a6 hxy _ (h _ hs)",
      "suggestion": "    \u00b7 absurd hx\n      simp [\u2190 mem_preimage, h']\n    \u00b7 absurd hy\n      simp [\u2190 mem_preimage, h']\n  obtain h' | h' := isEmpty_or_nonempty \u03b1\n  \u00b7 use (Classical.ofNonempty : \u03b2), funext (by simp)\n  \u00b7 use f (Classical.ofNonempty : \u03b1), funext (fun x \u21a6 h _ _)\n",
      "body": "I think it's better not to use semicolons here. Also you can avoid `swap` by doing the following (or doing ` by_cases! h' : IsEmpty \u03b1` instead, or just not using `swap` because both proofs are one-liners):\n```suggestion\n    \u00b7 absurd hx\n      simp [\u2190 mem_preimage, h']\n    \u00b7 absurd hy\n      simp [\u2190 mem_preimage, h']\n  obtain h' | h' := isEmpty_or_nonempty \u03b1\n  \u00b7 use (Classical.ofNonempty : \u03b2), funext (by simp)\n  \u00b7 use f (Classical.ofNonempty : \u03b1), funext (fun x \u21a6 h _ _)\n```",
      "path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "SeparatesPoints",
          "hxy",
          "separates",
          "hsep"
        ]
      }
    },
    {
      "id": 2904,
      "before_code": "In general, a type `A` is `SetLike` with elements of type `B` if it\nhas an injective map to `Set B`.  This module provides standard\nboilerplate for every `SetLike`: a `coe_sort`, a `coe` to set, a\n`PartialOrder`, and various extensionality and simp lemmas.",
      "suggestion": "\r\nand various extensionality and simp lemmas. The order induced by set inclusion is\r\ncalled `PartialOrder.ofSetlike`: this is not an instance for better defeqs.\r\nThe class `IsConcreteLE` abstractly states the order is equal to that induced by set inclusion;\r\nan instance is automatically available when defining a `PartialOrder` as\r\n`.ofSetLike (MySubobject X) X`.\r\n",
      "body": "How about:\r\n```suggestion\r\nand various extensionality and simp lemmas. The order induced by set inclusion is\r\ncalled `PartialOrder.ofSetlike`: this is not an instance for better defeqs.\r\nThe class `IsConcreteLE` abstractly states the order is equal to that induced by set inclusion;\r\nan instance is automatically available when defining a `PartialOrder` as\r\n`.ofSetLike (MySubobject X) X`.\r\n```",
      "path": "Mathlib/Data/SetLike/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "boilerplate",
          "type",
          "has",
          "elements",
          "This",
          "standard",
          "set",
          "map",
          "injective",
          "various",
          "for",
          "SetLike",
          "extensionality",
          "coe_sort",
          "module",
          "simp",
          "general",
          "lemmas",
          "every",
          "Set",
          "PartialOrder",
          "coe",
          "provides"
        ]
      }
    },
    {
      "id": 2905,
      "before_code": "@[simp] lemma setOf_mem_eq (a : A) : {b | b \u2208 a} = a := rfl\n\ninstance (priority := 100) instPartialOrder : PartialOrder A :=\n  { PartialOrder.lift (SetLike.coe : A \u2192 Set B) coe_injective with\n    le := fun H K => \u2200 \u2983x\u2984, x \u2208 H \u2192 x \u2208 K }\n\ntheorem le_def {S T : A} : S \u2264 T \u2194 \u2200 \u2983x : B\u2984, x \u2208 S \u2192 x \u2208 T :=\n  Iff.rfl",
      "suggestion": "\r\n/-- The partial order induced from a `SetLike` instance by inclusion.\r\n\r\nA partial order defined as `.ofSetLike` will automatically make available an instance\r\nof `IsConcreteLE`.\r\n-/\r\n",
      "body": "```suggestion\r\n/-- The partial order induced from a `SetLike` instance by inclusion.\r\n\r\nA partial order defined as `.ofSetLike` will automatically make available an instance\r\nof `IsConcreteLE`.\r\n-/\r\n```",
      "path": "Mathlib/Data/SetLike/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "theorem",
          "SetLike",
          "le_def",
          "setOf_mem_eq",
          "coe",
          "Set",
          "PartialOrder",
          "Iff",
          "instPartialOrder",
          "lift",
          "priority",
          "simp",
          "rfl",
          "instance",
          "coe_injective"
        ]
      }
    },
    {
      "id": 2908,
      "before_code": "rw [P.over_def p]\n  exact isMaximal_comap_of_isIntegral_of_isMaximal P\n\ntheorem eq_bot_of_liesOver_bot [Nontrivial A] [IsDomain B] [h : P.LiesOver (\u22a5 : Ideal A)] :\n    P = \u22a5 :=\n  eq_bot_of_comap_eq_bot <| ((liesOver_iff _ _).mp h).symm",
      "suggestion": "variable (A) {P} in\ntheorem under_ne_bot [Nontrivial A] [IsDomain B] (hP : P \u2260 \u22a5) : under A P \u2260 \u22a5 :=\n  fun h \u21a6 hP <| eq_bot_of_comap_eq_bot h\n",
      "body": "```suggestion\nvariable (A) {P} in\ntheorem under_ne_bot [Nontrivial A] [IsDomain B] (hP : P \u2260 \u22a5) : under A P \u2260 \u22a5 :=\n  fun h \u21a6 hP <| eq_bot_of_comap_eq_bot h\n```",
      "path": "Mathlib/RingTheory/Ideal/GoingUp.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "Ideal",
          "theorem",
          "liesOver_iff",
          "Nontrivial",
          "exact",
          "over_def",
          "eq_bot_of_comap_eq_bot",
          "IsDomain",
          "eq_bot_of_liesOver_bot",
          "isMaximal_comap_of_isIntegral_of_isMaximal",
          "LiesOver"
        ]
      }
    },
    {
      "id": 2914,
      "before_code": "simp [b', Module.Basis.toMatrix_apply, mul_comm (RingOfIntegers.basis K i),\n      b, integralBasis_apply, \u2190 map_mul, Algebra.trace_localization \u2124 \u2124\u2070]\n\nlemma NumberField.discr_mem_differentIdeal : \u2191(discr K) \u2208 differentIdeal \u2124 \ud835\udcaa := by\n  have := (differentIdeal \u2124 \ud835\udcaa).absNorm_mem\n  cases (discr K).natAbs_eq with\n  | inl h =>\n    rwa [absNorm_differentIdeal (K := K), \u2190 Int.cast_natCast, \u2190 h] at this\n  | inr h =>\n    rwa [absNorm_differentIdeal (K := K), \u2190 Int.cast_natCast, Int.eq_neg_comm.mp h,\n      Int.cast_neg, neg_mem_iff] at this",
      "suggestion": "    [IsDedekindDomain \ud835\udcaa'] [Algebra K L] [Algebra \ud835\udcaa \ud835\udcaa'] [Algebra \ud835\udcaa L]\n",
      "body": "```suggestion\n    [IsDedekindDomain \ud835\udcaa'] [Algebra K L] [Algebra \ud835\udcaa \ud835\udcaa'] [Algebra \ud835\udcaa L]\n```\nThis is implied by other assumptions if I am not confused.",
      "path": "Mathlib/NumberTheory/NumberField/Discriminant/Different.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "simp",
          "have"
        ],
        "topics": [
          "norm",
          "int",
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "lemma",
          "rwa",
          "discr_mem_differentIdeal",
          "cast_natCast",
          "eq_neg_comm",
          "inl",
          "neg_mem_iff",
          "absNorm_mem",
          "cases",
          "RingOfIntegers",
          "have",
          "discr",
          "map_mul",
          "NumberField",
          "natAbs_eq",
          "differentIdeal",
          "integralBasis_apply",
          "Int",
          "mul_comm",
          "simp",
          "basis",
          "cast_neg",
          "trace_localization",
          "Basis",
          "this",
          "toMatrix_apply",
          "absNorm_differentIdeal",
          "Algebra",
          "inr"
        ]
      }
    },
    {
      "id": 2917,
      "before_code": "/-- A recursor for `WithLower`. Use as `induction x`. -/\n@[elab_as_elim, cases_eliminator, induction_eliminator]\nprotected def rec {\u03b2 : WithLower \u03b1 \u2192 Sort*} (h : \u2200 a, \u03b2 (toLower a)) : \u2200 a, \u03b2 a := fun a =>\n  h (ofLower a)",
      "suggestion": "protected def rec {motive : WithLower \u03b1 \u2192 Sort*} (toLower : \u2200 a, motive (toLower a)) :\n    \u2200 a, motive a := fun a =>\n",
      "body": "```suggestion\nprotected def rec {motive : WithLower \u03b1 \u2192 Sort*} (toLower : \u2200 a, motive (toLower a)) :\n    \u2200 a, motive a := fun a =>\n```",
      "path": "Mathlib/Topology/Order/LowerUpperTopology.lean",
      "tags": {
        "before_tactics": [
          "induction"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "induction"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Sort",
          "def",
          "elab_as_elim",
          "ofLower",
          "cases_eliminator",
          "protected",
          "WithLower",
          "recursor",
          "induction_eliminator",
          "induction",
          "rec",
          "Use",
          "toLower",
          "for"
        ]
      }
    },
    {
      "id": 2918,
      "before_code": "/-- A recursor for `WithUpper`. Use as `induction x`. -/\n@[elab_as_elim, cases_eliminator, induction_eliminator]\nprotected def rec {\u03b2 : WithUpper \u03b1 \u2192 Sort*} (h : \u2200 a, \u03b2 (toUpper a)) : \u2200 a, \u03b2 a := fun a =>\n  h (ofUpper a)",
      "suggestion": "protected def rec {motive : WithUpper \u03b1 \u2192 Sort*} (toUpper : \u2200 a, motive (toUpper a)) :\n    \u2200 a, motive a := fun a =>\n",
      "body": "```suggestion\nprotected def rec {motive : WithUpper \u03b1 \u2192 Sort*} (toUpper : \u2200 a, motive (toUpper a)) :\n    \u2200 a, motive a := fun a =>\n```",
      "path": "Mathlib/Topology/Order/LowerUpperTopology.lean",
      "tags": {
        "before_tactics": [
          "induction"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "induction"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Sort",
          "def",
          "elab_as_elim",
          "toUpper",
          "cases_eliminator",
          "WithUpper",
          "protected",
          "ofUpper",
          "recursor",
          "induction_eliminator",
          "induction",
          "rec",
          "Use",
          "for"
        ]
      }
    },
    {
      "id": 2926,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "\r\n  have ha : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\r\n",
      "body": "I'd be inclined to inline this\r\n```suggestion\r\n  have ha : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 2927,
      "before_code": "m (\u22c3\u2080 I) = \u2211 u \u2208 I, m u :=\n  m.sUnion' I h_ss h_dis h_mem",
      "suggestion": "  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n",
      "body": "```suggestion\n  classical\n  have A : \u22c3 i \u2208 a, f i = \u22c3\u2080 (a.image f) := by simp\n  rw [A, addContent_sUnion]; rotate_left\n  \u00b7 grind\n  \u00b7 simpa using h_dis.image\n  \u00b7 rwa [\u2190 A]\n  rw [sum_image_of_pairwise_eq_zero]\n  refine h_dis.imp ?_\n  grind [Set.bot_eq_empty (\u03b1 := \u03b1), addContent_empty]\n```\na little golf",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "refine",
          "simp",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "h_dis",
          "h_ss",
          "sUnion",
          "h_mem"
        ]
      }
    },
    {
      "id": 2928,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    \u00b7 exact hJ'disj.mono fun _ \u21a6 by simp\n",
      "body": "```suggestion\n    \u00b7 exact hJ'disj.mono fun _ \u21a6 by simp\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 2929,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    \u00b7 exact hJdisj.mono fun _ \u21a6 by simp\n",
      "body": "```suggestion\n    \u00b7 exact hJdisj.mono fun _ \u21a6 by simp\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 2931,
      "before_code": "module\n\npublic import Mathlib.Analysis.SpecialFunctions.Log.Basic",
      "suggestion": "\r\n",
      "body": "This import is redundant, let's not annoy Sebastian by making him do even more `shake` work :)\r\n```suggestion\r\n```",
      "path": "Mathlib/NumberTheory/Height/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "Basic",
          "import",
          "Mathlib",
          "public",
          "module",
          "Log",
          "Analysis",
          "SpecialFunctions"
        ]
      }
    },
    {
      "id": 2933,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n\n/-- An antitone, bounded below sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddBelow_antitone {f : \u2115 \u2192 \u211d} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9\n\n/-- An antitone sequence `f : \u2115 \u2192 \u211d\u22650` has a finite limit. -/\ntheorem tendsto_of_antitone {f : \u2115 \u2192 \u211d\u22650} (h_ant : Antitone f) :\n    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := by\n  have h_bdd_0 : (0 : \u211d) \u2208 lowerBounds (Set.range fun n : \u2115 => (f n : \u211d)) := by\n    rintro r \u27e8n, hn\u27e9\n    simp_rw [\u2190 hn]\n    exact NNReal.coe_nonneg _\n  obtain \u27e8L, hL\u27e9 := Real.tendsto_of_bddBelow_antitone \u27e80, h_bdd_0\u27e9 h_ant\n  have hL0 : 0 \u2264 L :=\n    haveI h_glb : IsGLB (Set.range fun n => (f n : \u211d)) L := isGLB_of_tendsto_atTop h_ant hL\n    (le_isGLB_iff h_glb).mpr h_bdd_0\n  exact \u27e8\u27e8L, hL0\u27e9, NNReal.tendsto_coe.mp hL\u27e9",
      "suggestion": "    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := \u27e8iInf f, tendsto_atTop_ciInf h_ant (by simp)\u27e9\n",
      "body": "```suggestion\n    \u2203 r : \u211d\u22650, Tendsto f atTop (\ud835\udcdd r) := \u27e8iInf f, tendsto_atTop_ciInf h_ant (by simp)\u27e9\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "lowerBounds",
          "mpr",
          "antitone",
          "rintro",
          "obtain",
          "hL0",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "have",
          "isGLB_of_tendsto_atTop",
          "exists_isLUB",
          "Antitone",
          "simp_rw",
          "h_mon",
          "range",
          "Real",
          "exists_isGLB",
          "Tendsto",
          "sequence",
          "IsGLB",
          "tendsto_of_bddAbove_monotone",
          "le_isGLB_iff",
          "tendsto_atTop_isLUB",
          "BddBelow",
          "tendsto_coe",
          "above",
          "bounded",
          "NNReal",
          "h_bdd",
          "below",
          "tendsto_atTop_isGLB",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set",
          "coe_nonneg",
          "h_bdd_0",
          "tendsto_of_bddBelow_antitone",
          "h_glb",
          "tendsto_of_antitone",
          "h_ant",
          "haveI"
        ]
      }
    },
    {
      "id": 2934,
      "before_code": "@[simp] lemma sup'_eq_zero (hs) : s.sup' hs f = 0 \u2194 \u2200 i \u2208 s, f i = 0 := by simp [sup'_eq_sup]\n\nend Finset",
      "suggestion": "\r\ntheorem range_add_eq_image_Ici : range (fun x \u21a6 f (x + k)) = f '' Ici k :=\r\n",
      "body": "```suggestion\r\ntheorem range_add_eq_image_Ici : range (fun x \u21a6 f (x + k)) = f '' Ici k :=\r\n```",
      "path": "Mathlib/Algebra/Order/Monoid/Canonical/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "end",
          "_eq_sup",
          "_eq_zero",
          "Finset",
          "simp",
          "sup"
        ]
      }
    },
    {
      "id": 2937,
      "before_code": "section Monotone",
      "suggestion": "  obtain rfl : iSup f = B := h_lub.csSup_eq (range_nonempty f)\n",
      "body": "This is a fun trick:\n```suggestion\n  obtain rfl : iSup f = B := h_lub.csSup_eq (range_nonempty f)\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain"
        ],
        "body_tactics": [
          "obtain"
        ],
        "new_tactics": [
          "obtain"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Monotone",
          "section"
        ]
      }
    },
    {
      "id": 2938,
      "before_code": "end Zero\n\nsection One\n\nvariable [DecidableEq n] [MulZeroOneClass \u03b1]\nvariable (M : Matrix n n \u03b1)\n\ntheorem hadamard_one : M \u2299 (1 : Matrix n n \u03b1) = diagonal fun i => M i i := by\n  ext i j\n  by_cases h : i = j <;> simp [h]\n\ntheorem one_hadamard : (1 : Matrix n n \u03b1) \u2299 M = diagonal fun i => M i i := by\n  ext i j\n  by_cases h : i = j <;> simp [h]\n\nend One",
      "suggestion": "    A \u2299 of 1 = A := by ext; simp\n\n@[simp] theorem of_one_hadamard [MulOneClass \u03b1] (A : Matrix m n \u03b1) :\n    of 1 \u2299 A = A := by ext; simp\n",
      "body": "```suggestion\n    A \u2299 of 1 = A := by ext; simp\n\n@[simp] theorem of_one_hadamard [MulOneClass \u03b1] (A : Matrix m n \u03b1) :\n    of 1 \u2299 A = A := by ext; simp\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/Hadamard.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "ext",
          "variable",
          "by_cases",
          "theorem",
          "Matrix",
          "diagonal",
          "hadamard_one",
          "One",
          "DecidableEq",
          "simp",
          "MulZeroOneClass",
          "Zero",
          "one_hadamard",
          "section"
        ]
      }
    },
    {
      "id": 2942,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "/-- Composition of intertwining maps. -/\ndef llcomp : IntertwiningMap \u03c3 \u03c4 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c3 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c4 where\n  toFun f :=\n    { toFun g :=\n      { toLinearMap := f.toLinearMap.comp g.toLinearMap\n        isIntertwining' := by simp [f.isIntertwining, g.isIntertwining] }\n      map_add' _ _ := by ext; simp [map_add]\n      map_smul' _ _ := by ext; simp }\n  map_add' _ _ := by ext; simp\n  map_smul' _ _ := by ext; simp\n\nvariable {\u03c1 \u03c3 \u03c4} in\n/-- Composition of intertwining maps.\n\nA convenience variant of `IntertwiningMap.llcomp` for use in dot notation. -/\ndef comp (f : IntertwiningMap \u03c3 \u03c4) (g : IntertwiningMap \u03c1 \u03c3) : IntertwiningMap \u03c1 \u03c4 :=\n  llcomp _ _ _ f g\n",
      "body": "How about we also capture the fact that this operation is bilinear as follows:\n```suggestion\n/-- Composition of intertwining maps. -/\ndef llcomp : IntertwiningMap \u03c3 \u03c4 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c3 \u2192\u2097[A] IntertwiningMap \u03c1 \u03c4 where\n  toFun f :=\n    { toFun g :=\n      { toLinearMap := f.toLinearMap.comp g.toLinearMap\n        isIntertwining' := by simp [f.isIntertwining, g.isIntertwining] }\n      map_add' _ _ := by ext; simp [map_add]\n      map_smul' _ _ := by ext; simp }\n  map_add' _ _ := by ext; simp\n ",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 2943,
      "before_code": "right_inv f := rfl\n\n/-- The identity map, considered as an intertwining map from a representation to itself. -/\nnoncomputable def id : IntertwiningMap \u03c1 \u03c1 where\n  toLinearMap := LinearMap.id\n  isIntertwining' := by simp\n\n@[simp] lemma id_apply (v : V) : IntertwiningMap.id \u03c1 v = v := rfl",
      "suggestion": "  Algebra.ofModule (fun a f g => rfl) (fun a f g => by ext; simp)\n",
      "body": "If we add `mul_apply` above, this can be just:\n```suggestion\n  Algebra.ofModule (fun a f g => rfl) (fun a f g => by ext; simp)\n```",
      "path": "Mathlib/RepresentationTheory/Intertwining.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "intertwining",
          "lemma",
          "noncomputable",
          "LinearMap",
          "def",
          "id_apply",
          "isIntertwining",
          "right_inv",
          "representation",
          "map",
          "considered",
          "IntertwiningMap",
          "simp",
          "from",
          "toLinearMap",
          "identity",
          "rfl",
          "itself"
        ]
      }
    },
    {
      "id": 2950,
      "before_code": "rw [\u2190 sub_pos] at hR\n    rcases eq_or_ne x 0 with rfl | hx\n    \u00b7 have A : ContinuousAt (fun p : \u211d \u00d7 E \u21a6 (p.1 - \u2016p.2\u2016) / (p.1 - 1)) (R, 0) :=\n        (continuousAt_fst.sub continuousAt_snd.norm).div\n          (continuousAt_fst.sub continuousAt_const) hR.ne'",
      "suggestion": "\r\n        by fun_prop (disch := grind)\r\n",
      "body": "Can't this be\r\n```suggestion\r\n        by fun_prop (disch := grind)\r\n```\r\nor similar with a weaker discharger?",
      "path": "Mathlib/Analysis/Calculus/BumpFunction/InnerProduct.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "grind",
          "fun_prop"
        ],
        "body_tactics": [
          "grind",
          "fun_prop"
        ],
        "new_tactics": [
          "grind",
          "fun_prop"
        ],
        "removed_tactics": [
          "cases",
          "rw",
          "have"
        ],
        "topics": [
          "continuity",
          "real",
          "list",
          "norm"
        ],
        "transforms": [
          "use_fun_prop",
          "use_grind"
        ],
        "keywords": [
          "sub",
          "ContinuousAt",
          "have",
          "sub_pos",
          "div",
          "continuousAt_fst",
          "rcases",
          "norm",
          "rfl",
          "eq_or_ne",
          "continuousAt_snd",
          "continuousAt_const"
        ]
      }
    },
    {
      "id": 2951,
      "before_code": "g_an.continuousAt.continuousWithinAt.tendsto.norm\n    have : Tendsto (fun z \u21a6 z - x) (\ud835\udcdd[\u2260] x) (\ud835\udcdd[\u2260] 0) := by\n      refine tendsto_nhdsWithin_iff.2 \u27e8?_, ?_\u27e9\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) ({x}\u1d9c) x :=\n          ContinuousAt.continuousWithinAt (by fun_prop)",
      "suggestion": "\r\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) {x}\u1d9c x := by fun_prop\r\n",
      "body": "```suggestion\r\n      \u00b7 have : ContinuousWithinAt (fun z \u21a6 z - x) {x}\u1d9c x := by fun_prop\r\n```\r\nWhy the brackets?",
      "path": "Mathlib/Analysis/Meromorphic/Order.lean",
      "tags": {
        "before_tactics": [
          "fun_prop",
          "refine",
          "have"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "have"
        ],
        "body_tactics": [
          "fun_prop",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "continuity",
          "norm"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "ContinuousWithinAt",
          "tendsto",
          "refine",
          "tendsto_nhdsWithin_iff",
          "continuousAt",
          "ContinuousAt",
          "have",
          "Tendsto",
          "norm",
          "continuousWithinAt",
          "g_an",
          "fun_prop"
        ]
      }
    },
    {
      "id": 2952,
      "before_code": "congr 1\n      exact (norm_of_nonneg (posf _ _ x hx)).symm\n    \u00b7 refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi\n      refine (Continuous.continuousOn ?_).mul (continuousOn_of_forall_continuousAt fun x hx => ?_)\n      \u00b7 exact continuous_exp.comp (continuous_const.mul continuous_id')\n      \u00b7 exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')",
      "suggestion": "\r\n      refine .mul (by fun_prop)\r\n",
      "body": "```suggestion\r\n      refine .mul (by fun_prop)\r\n```\r\nmaybe?",
      "path": "Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "congr",
          "refine"
        ],
        "suggestion_tactics": [
          "fun_prop",
          "refine"
        ],
        "body_tactics": [
          "fun_prop",
          "refine"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "exact",
          "congr"
        ],
        "topics": [
          "continuity",
          "list",
          "norm",
          "set_theory",
          "measurability"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "mem_Ioi",
          "posf",
          "ContinuousOn",
          "inl",
          "mul",
          "aestronglyMeasurable",
          "symm",
          "continuous_exp",
          "norm_of_nonneg",
          "refine",
          "continuousAt_rpow_const",
          "Continuous",
          "continuous_id",
          "continuousOn_of_forall_continuousAt",
          "continuous_const",
          "comp",
          "measurableSet_Ioi",
          "congr",
          "exact",
          "continuousOn"
        ]
      }
    },
    {
      "id": 2953,
      "before_code": "have : x = (fun \u03b5 : \u211d => mulExpNegMulSq \u03b5 x) 0 := by\n    simp only [mulExpNegMulSq, zero_mul, neg_zero, exp_zero, mul_one]\n  nth_rw 2 [this]\n  apply Continuous.tendsto (Continuous.mul continuous_const (by fun_prop))",
      "suggestion": "\r\n  apply Continuous.tendsto (by fun_prop)\r\n",
      "body": "Unnecessary diff? or maybe\r\n```suggestion\r\n  apply Continuous.tendsto (by fun_prop)\r\n```\r\nworks?",
      "path": "Mathlib/Analysis/SpecialFunctions/MulExpNegMulSq.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "have",
          "simp",
          "fun_prop"
        ],
        "suggestion_tactics": [
          "apply",
          "fun_prop"
        ],
        "body_tactics": [
          "apply",
          "fun_prop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "have"
        ],
        "topics": [
          "continuity",
          "real",
          "list"
        ],
        "transforms": [
          "remove_redundant",
          "use_fun_prop"
        ],
        "keywords": [
          "apply",
          "nth_rw",
          "tendsto",
          "have",
          "this",
          "exp_zero",
          "mulExpNegMulSq",
          "continuous_const",
          "mul_one",
          "neg_zero",
          "simp",
          "Continuous",
          "fun_prop",
          "zero_mul",
          "mul",
          "only"
        ]
      }
    },
    {
      "id": 2964,
      "before_code": "This procedure is mostly intended as a post-procedure: it will work better if `f` and `g`\nhave already been traversed beforehand. -/\ndef cancelIsoSimproc : Simp.Simproc := fun e => withReducible do -- is withReducible necessary here?\n  let e_whnf \u2190 whnf e\n  let_expr CategoryStruct.comp C instCat x y t f g := e_whnf | return .continue",
      "suggestion": "\r\ndef cancelIsoSimproc : Simp.Simproc := fun e => do\r\n",
      "body": "```suggestion\r\ndef cancelIsoSimproc : Simp.Simproc := fun e => do\r\n```",
      "path": "Mathlib/Tactic/CategoryTheory/CancelIso.lean",
      "tags": {
        "before_tactics": [
          "have",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "have"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "let_expr",
          "traversed",
          "necessary",
          "already",
          "mostly",
          "better",
          "work",
          "This",
          "been",
          "Simproc",
          "here",
          "have",
          "instCat",
          "withReducible",
          "continue",
          "Simp",
          "procedure",
          "def",
          "return",
          "comp",
          "will",
          "cancelIsoSimproc",
          "whnf",
          "intended",
          "post",
          "e_whnf",
          "CategoryStruct",
          "beforehand"
        ]
      }
    },
    {
      "id": 2971,
      "before_code": "abbrev Coloring (\u03b1 : Type v) := G \u2192g completeGraph \u03b1\n\nvariable {G}\nvariable {\u03b1 \u03b2 : Type*} (C : G.Coloring \u03b1)\n\ntheorem Coloring.valid {v w : V} (h : G.Adj v w) : C v \u2260 C w :=\n  C.map_rel h",
      "suggestion": "\r\nlemma Coloring.comp_injective_of_pairwise_adj (C : G.Coloring \u03b1) (f : \u03b9 \u2192 V)\r\n    (hf : Pairwise (G.Adj on f)) : (C \u2218 f).Injective :=\r\n  Function.injective_iff_pairwise_ne.2 <| hf.mono fun _ _ \u21a6 C.valid\r\n",
      "body": "```suggestion\r\nlemma Coloring.comp_injective_of_pairwise_adj (C : G.Coloring \u03b1) (f : \u03b9 \u2192 V)\r\n    (hf : Pairwise (G.Adj on f)) : (C \u2218 f).Injective :=\r\n  Function.injective_iff_pairwise_ne.2 <| hf.mono fun _ _ \u21a6 C.valid\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Adj",
          "map_rel",
          "variable",
          "abbrev",
          "theorem",
          "Coloring",
          "Type",
          "valid",
          "completeGraph"
        ]
      }
    },
    {
      "id": 2972,
      "before_code": "/-- If `G` is `n`-colorable, then mapping the vertices of `G` produces an `n`-colorable simple\ngraph. -/\ntheorem Colorable.map {\u03b2 : Type*} (f : V \u21aa \u03b2) [NeZero n] {G : SimpleGraph V} (hc : G.Colorable n) :\n    (G.map f).Colorable n := by\n  obtain \u27e8C\u27e9 := hc\n  use extend f C (const \u03b2 default)\n  intro a b \u27e8_, _, hadj, ha, hb\u27e9\n  rw [\u2190 ha, f.injective.extend_apply, \u2190 hb, f.injective.extend_apply]\n  exact C.valid hadj\n\n/-- The \"tautological\" coloring of a graph, using the vertices of the graph as colors. -/\ndef selfColoring : G.Coloring V := Coloring.mk id fun {_ _} => G.ne_of_adj\n\n/-- The chromatic number of a graph is the minimal number of colors needed to color it.\nThis is `\u22a4` (infinity) iff `G` isn't colorable with finitely many colors.\n\nIf `G` is colorable, then `ENat.toNat G.chromaticNumber` is the `\u2115`-valued chromatic number. -/\nnoncomputable def chromaticNumber : \u2115\u221e := \u2a05 n \u2208 setOf G.Colorable, (n : \u2115\u221e)\n\nlemma chromaticNumber_eq_biInf {G : SimpleGraph V} :\n    G.chromaticNumber = \u2a05 n \u2208 setOf G.Colorable, (n : \u2115\u221e) := rfl\n\nlemma chromaticNumber_eq_iInf {G : SimpleGraph V} :\n    G.chromaticNumber = \u2a05 n : {m | G.Colorable m}, (n : \u2115\u221e) := by",
      "suggestion": "\r\nlemma card_le_chromaticNumber_of_pairwise_adj (f : \u03b9 \u2192 V) (hf : Pairwise (G.Adj on f)) :\r\n    Nat.card \u03b9 \u2264 G.chromaticNumber :=\r\n  le_chromaticNumber_iff_colorable.2 fun _m hm \u21a6 hm.card_le_of_pairwise_adj f hf\r\n",
      "body": "This is `Nat.card \u03b9 \u2264 G.chromaticNumber` combined with an `le_trans`, but the caller can use transitivity if needed\r\n```suggestion\r\nlemma card_le_chromaticNumber_of_pairwise_adj (f : \u03b9 \u2192 V) (hf : Pairwise (G.Adj on f)) :\r\n    Nat.card \u03b9 \u2264 G.chromaticNumber :=\r\n  le_chromaticNumber_iff_colorable.2 fun _m hm \u21a6 hm.card_le_of_pairwise_adj f hf\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "list",
          "order",
          "function",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "selfColoring",
          "simple",
          "lemma",
          "infinity",
          "Type",
          "chromaticNumber",
          "const",
          "many",
          "chromatic",
          "tautological",
          "obtain",
          "Colorable",
          "colorable",
          "coloring",
          "This",
          "noncomputable",
          "extend",
          "Coloring",
          "setOf",
          "iff",
          "produces",
          "map",
          "vertices",
          "hadj",
          "intro",
          "minimal",
          "chromaticNumber_eq_iInf",
          "injective",
          "SimpleGraph",
          "toNat",
          "colors",
          "ne_of_adj",
          "def",
          "extend_apply",
          "then",
          "number",
          "default",
          "rfl",
          "valid",
          "isn",
          "use",
          "graph",
          "theorem",
          "exact",
          "needed",
          "NeZero",
          "chromaticNumber_eq_biInf",
          "mapping",
          "valued",
          "finitely"
        ]
      }
    },
    {
      "id": 2975,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=",
      "suggestion": "\r\n  \u27e8fun h_surj \u21a6 Surjective.isEmpty h_surj, fun _ \u21a6 Surjective.of_isEmpty f \u27e9\r\n",
      "body": "nit: bad indent,\r\n```suggestion\r\n  \u27e8fun h_surj \u21a6 Surjective.isEmpty h_surj, fun _ \u21a6 Surjective.of_isEmpty f \u27e9\r\n```\r\n\r\nThis might golf to\r\n```suggestion\r\n  \u27e8.isEmpty, fun _ \u21a6 Surjective.of_isEmpty f \u27e9\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "theorem",
          "and_true",
          "IsEmpty",
          "leftTotal_iff_isEmpty_left",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 2976,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=",
      "suggestion": "\r\n  \u27e8Surjective.isEmpty, fun _ \u21a6 .of_isEmpty f\u27e9\r\n",
      "body": "```suggestion\r\n  \u27e8Surjective.isEmpty, fun _ \u21a6 .of_isEmpty f\u27e9\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "theorem",
          "and_true",
          "IsEmpty",
          "leftTotal_iff_isEmpty_left",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 2977,
      "before_code": "set f' := fun i => (f i : M\u2081 i \u2192\u2097[R] M\u2081' i)\n  rw [\u2190 zero_compLinearMap f', compLinearMap_inj f' fun i => (f i).surjective]",
      "suggestion": "\r\ndef compMultilinearMap (g : MultilinearMap R M\u2081 M\u2082) (f : (i : \u03b9) \u2192 MultilinearMap R (N i) (M\u2081 i)) :\r\n    MultilinearMap R (fun j : \u03a3 i, \u03b2 i \u21a6 N j.fst j.snd) M\u2082 where\r\n  toFun m := g fun i \u21a6 f i (Sigma.curry m i)\r\n  map_update_add' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n  map_update_smul' {hDecEqSigma} := by\r\n    classical\r\n    simp [Subsingleton.elim hDecEqSigma Sigma.instDecidableEqSigma,\r\n      Sigma.curry_update, Function.apply_update (fun i \u21a6 f i)]\r\n",
      "body": "A few changes and we can do it in a single `intro; classical; simp`:\r\n\r\n* `DecidableEq` is not needed to define `toFun`, so we should add this assumption (with `classical`) only for the proofs.\r\n* We only need to introduce `hDecEqSigma`, the rest is handled by `simp`. Might as well put the hypothesis before the colon (but I would also accept `intro` here).\r\n* `simp only` can do all the rewriting if we hint it what to exactly rewrite. In particular, breaking `[Sigma.apply_curry_update .., Sigma.c",
      "path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "function"
        ],
        "transforms": [
          "cleanup_simp",
          "line_break",
          "remove_redundant"
        ],
        "keywords": [
          "compLinearMap_inj",
          "zero_compLinearMap",
          "surjective",
          "set"
        ]
      }
    },
    {
      "id": 2992,
      "before_code": "\u03bcH[d] (K.orthogonalProjection '' s) \u2264 \u03bcH[d] s := by\n  simpa using K.lipschitzWith_orthogonalProjection.hausdorffMeasure_image_le hs s",
      "suggestion": "\r\n    apply iInf_le_of_le fun _ => {x}\r\n    simpa using hs\r\n",
      "body": "```suggestion\r\n    apply iInf_le_of_le fun _ => {x}\r\n    simpa using hs\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply"
        ],
        "body_tactics": [
          "simpa",
          "apply"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "orthogonalProjection",
          "simpa",
          "hausdorffMeasure_image_le",
          "lipschitzWith_orthogonalProjection",
          "using"
        ]
      }
    },
    {
      "id": 2993,
      "before_code": "\u03bcH[d] (K.orthogonalProjection '' s) \u2264 \u03bcH[d] s := by\n  simpa using K.lipschitzWith_orthogonalProjection.hausdorffMeasure_image_le hs s",
      "suggestion": "\r\n    refine discreteTopology_iff_isOpen_singleton.mpr fun x => ?_\r\n",
      "body": "```suggestion\r\n    refine discreteTopology_iff_isOpen_singleton.mpr fun x => ?_\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "orthogonalProjection",
          "simpa",
          "hausdorffMeasure_image_le",
          "lipschitzWith_orthogonalProjection",
          "using"
        ]
      }
    },
    {
      "id": 2996,
      "before_code": "public meta section\n\nnamespace Mathlib.Tactic\nopen Lean Meta Elab Tactic Term\n\n/--\n`apply (config := cfg) e` is like `apply e` but allows you to provide a configuration\n`cfg : ApplyConfig` to pass to the underlying `apply` operation.",
      "suggestion": "\r\n  * `-synthAssignedInstances` will not synthesize instance implicit arguments if they have been\r\n",
      "body": "The `ApplyConfig` docstring for `synthAssignedInstances` is a bit confusing: it explains what `synthAssignedInstances := true` does, but this is in fact already the case by default. So `-synthAssignedInstances` does the opposite: it does not resynthesize and therefore there is nothing to check.\r\n\r\nBut we can get rid of the \"even\" in this sentence, because that would be confusing.\r\n\r\n```suggestion\r\n  * `-synthAssignedInstances` will not synthesize instance implicit arguments if they have been\r\n``",
      "path": "Mathlib/Tactic/ApplyWith.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "operation",
          "but",
          "open",
          "section",
          "apply",
          "Mathlib",
          "Lean",
          "pass",
          "configuration",
          "ApplyConfig",
          "like",
          "Elab",
          "public",
          "underlying",
          "allows",
          "Term",
          "provide",
          "you",
          "namespace",
          "config",
          "cfg",
          "Meta",
          "meta",
          "Tactic"
        ]
      }
    },
    {
      "id": 3000,
      "before_code": "continuous_invFun := Units.continuous_iff.mpr\n    \u27e8continuous_pi fun _ \u21a6 Units.continuous_val.comp <| continuous_apply _,\n      continuous_pi fun _ \u21a6 Units.continuous_coe_inv.comp <| continuous_apply _\u27e9",
      "suggestion": "\r\n  { __ := Units.mapEquiv f\r\n    continuous_toFun := f.continuous.units_map _\r\n    continuous_invFun := f.symm.continuous.units_map _ }\r\n",
      "body": "```suggestion\r\n  { __ := Units.mapEquiv f\r\n    continuous_toFun := f.continuous.units_map _\r\n    continuous_invFun := f.symm.continuous.units_map _ }\r\n```\r\n\r\nalso, maybe add some API? like: `f.units_map x = Units.mapEquiv f x` and `f.units_map.toMulEquiv = Units.mapEquiv f`?",
      "path": "Mathlib/Topology/Algebra/Group/Units.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "Units",
          "mpr",
          "continuous_pi",
          "continuous_iff",
          "comp",
          "continuous_coe_inv",
          "continuous_apply",
          "continuous_val",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 3002,
      "before_code": "Indep m\u2081 m\u2083 \u03ba \u03bc :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)",
      "suggestion": "  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n",
      "body": "I suggest this proof instead:\n```suggestion\n  fun s t ht \u21a6 h_indep s fun i hi \u21a6 h_le i (t i) <| ht i hi\n```\nIt's exactly the same but I reworked the variables (and removed unnecessary parentheses). We often use `s`, `t` for sets. Here `s` and `t` are not of the same kind (`s` is a finset of the index type while `t` is a family of sets) so it's better to use `s` and `t` rather than `t1` and `t2` which suggests they are of the same kind. As `i` is an element of the index type `\u03b9`, `i` is the usual",
      "path": "Mathlib/Probability/Independence/Kernel/Indep.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "ht1",
          "ht2",
          "h_indep",
          "h32",
          "Indep"
        ]
      }
    },
    {
      "id": 3003,
      "before_code": "def Weird (n : \u2115) : Prop := Abundant n \u2227 \u00ac Pseudoperfect n\n\ntheorem not_pseudoperfect_iff_forall :\n    \u00ac Pseudoperfect n \u2194 n = 0 \u2228 \u2200 s \u2286 properDivisors n, \u2211 i \u2208 s, i \u2260 n := by\n  rw [Pseudoperfect, not_and_or]\n  simp only [not_lt, nonpos_iff_eq_zero, not_exists, not_and, ne_eq]\n\ntheorem deficient_one : Deficient 1 := zero_lt_one\ntheorem deficient_two : Deficient 2 := one_lt_two\ntheorem deficient_three : Deficient 3 := by norm_num [Deficient]\n\ntheorem abundant_twelve : Abundant 12 := by\n  rw [Abundant, show properDivisors 12 = {1,2,3,4,6} by rfl]\n  simp\n\ntheorem weird_seventy : Weird 70 := by\n  rw [Weird, Abundant, not_pseudoperfect_iff_forall]\n  have h : properDivisors 70 = {1, 2, 5, 7, 10, 14, 35} := by rfl",
      "suggestion": "\r\n  rw [Weird, Abundant, not_pseudoperfect_iff_forall,\r\n    show properDivisors 70 = {1, 2, 5, 7, 10, 14, 35} by rfl]\r\n",
      "body": "```suggestion\r\n  rw [Weird, Abundant, not_pseudoperfect_iff_forall,\r\n    show properDivisors 70 = {1, 2, 5, 7, 10, 14, 35} by rfl]\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "norm_num",
          "simp",
          "have"
        ],
        "topics": [
          "order",
          "nat",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "nonpos_iff_eq_zero",
          "abundant_twelve",
          "show",
          "deficient_three",
          "have",
          "Prop",
          "ne_eq",
          "not_and",
          "deficient_one",
          "norm_num",
          "not_pseudoperfect_iff_forall",
          "Deficient",
          "Pseudoperfect",
          "weird_seventy",
          "not_and_or",
          "def",
          "properDivisors",
          "Abundant",
          "Weird",
          "simp",
          "one_lt_two",
          "rfl",
          "not_lt",
          "only",
          "theorem",
          "zero_lt_one",
          "not_exists",
          "deficient_two"
        ]
      }
    },
    {
      "id": 3004,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n",
      "body": "```suggestion\r\n  obtain \u27e8k, hk\u27e9 := hd\r\n  have hk0 : k \u2260 0 := by grind\r\n  rw [abundancyIndex, abundancyIndex, hk, cast_mul, div_mul_eq_div_div_swap]\r\n  refine div_le_div_of_nonneg_right ?_ m.cast_nonneg\r\n  rw [le_div_iff\u2080 (by grind [cast_pos]), \u2190 cast_mul, cast_le, sum_mul]\r\n  exact (sum_image (f := fun i \u21a6 i) (mul_left_injective\u2080 hk0).injOn).symm.trans_le\r\n    (sum_le_sum_of_subset (by grind [mul_dvd_mul_iff_right hk0]))\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "have",
          "refine"
        ],
        "removed_tactics": [
          "omega",
          "intro"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3005,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "theorem abundant_945 : Abundant 945 := by decide +kernel\n",
      "body": "```suggestion\ntheorem abundant_945 : Abundant 945 := by decide +kernel\n```\nIf you add `deriving Decidable` after the def of `Abundant`.\n\nBut why 945? And why can't this proof be inline?",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [
          "decide"
        ],
        "body_tactics": [
          "decide"
        ],
        "new_tactics": [
          "decide"
        ],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3007,
      "before_code": "rw [Set.range_eq_univ]\n  exact Surjective.comp_left hf",
      "suggestion": "\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family_span_fixedDegree_aux\r\n    {I : Type*} [LinearOrder I] (v : I \u2192 M) (\u03b1 : Fin n \u2192 I) :\r\n    ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) \u2208 span R (range (ExteriorAlgebra.\u03b9Multi_family R n v)) := by\r\n  by_cases \u03b1_inj : Injective \u03b1; swap\r\n  \u00b7 suffices ExteriorAlgebra.\u03b9Multi R n (v \u2218 \u03b1) = 0 by simp [this]\r\n    exact AlternatingMap.map_eq_zero_of_not_injective _ _ <| fun h \u21a6 \u03b1_inj (Injective.of_comp h)\r\n",
      "body": "Looking at this one last time, even though it is a private \"auxiliary\" lemma, I think we should fold in the case analysis on whether `\u03b1` is injective so that we don't have a redundant hypothesis:\r\n```suggestion\r\n/-- Given an ordered family of vectors `i \u21a6 v i` ranging over `i \u2208 I`, and indexes\r\n`\u03b1\u2081, \u03b1\u2082, \u2026, \u03b1\u2099 \u2208 I` (not necessarily in order) the wedge product `v (\u03b1 1) \u2227 \u22ef \u2227 v (\u03b1 n)` belongs to\r\nthe span of `n`-fold _ordered_ wedge products of elements of the `v i`. -/\r\nprivate lemma \u03b9Multi_family",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "comp_left",
          "exact",
          "Set",
          "range_eq_univ",
          "Surjective"
        ]
      }
    },
    {
      "id": 3008,
      "before_code": "theorem isOpen_implies_isOpen_iff : (\u2200 s, IsOpen[t\u2081] s \u2192 IsOpen[t\u2082] s) \u2194 t\u2082 \u2264 t\u2081 :=\n  Iff.rfl",
      "suggestion": "This can also go by the name \"trivial topology\" or \"codiscrete topology\". -/\n",
      "body": "```suggestion\nThis can also go by the name \"trivial topology\" or \"codiscrete topology\". -/\n```",
      "path": "Mathlib/Topology/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Iff",
          "isOpen_implies_isOpen_iff",
          "IsOpen",
          "rfl"
        ]
      }
    },
    {
      "id": 3009,
      "before_code": "/-- We say that a type has `MeasurableSup` if `(c \u2294 \u00b7)` and `(\u00b7 \u2294 c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (\u00b7 \u2294 \u00b7)` see `MeasurableSup\u2082`. -/\nclass MeasurableSup (M : Type*) [MeasurableSpace M] [Max M] : Prop where\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7)\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c)",
      "suggestion": "\r\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7) := by intro c; measurability\r\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c) := by intro c; measurability\r\n",
      "body": "Do we have a good understanding of when to use `fun_prop` vs `measurability`? I thought the latter was now based on the former and therefore as fast but also slightly stronger. Therefore I was expecting\r\n```suggestion\r\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7) := by intro c; measurability\r\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c) := by intro c; measurability\r\n```",
      "path": "Mathlib/MeasureTheory/Order/Lattice.lean",
      "tags": {
        "before_tactics": [
          "measurability"
        ],
        "suggestion_tactics": [
          "measurability",
          "intro"
        ],
        "body_tactics": [
          "fun_prop",
          "measurability",
          "have",
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "measurability",
          "order"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "Type",
          "typeclass",
          "class",
          "type",
          "has",
          "Max",
          "For",
          "MeasurableSup",
          "Prop",
          "are",
          "see",
          "say",
          "assuming",
          "measurable_sup_const",
          "that",
          "measurability",
          "MeasurableSpace",
          "measurable_const_sup",
          "uncurry",
          "functions",
          "measurable",
          "Measurable"
        ]
      }
    },
    {
      "id": 3012,
      "before_code": "let c \u2190 Term.exprToSyntax (mkConst `Complex)\n      Term.elabTerm (\u2190 `(\ud835\udcd8($c))) none\n    else throwError \"`{e}` is not the complex upper half plane\"",
      "suggestion": "      let searchNormedAlgebra \u2190 findSomeLocalInstanceOf? ``NormedAlgebra fun inst type \u21a6 do\n",
      "body": "Nit:\n\n```suggestion\n      let searchNormedAlgebra \u2190 findSomeLocalInstanceOf? ``NormedAlgebra fun inst type \u21a6 do\n```",
      "path": "Mathlib/Geometry/Manifold/Notation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "half",
          "else",
          "Complex",
          "elabTerm",
          "mkConst",
          "none",
          "Term",
          "exprToSyntax",
          "throwError",
          "complex",
          "plane",
          "upper"
        ]
      }
    },
    {
      "id": 3015,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    by simpa using im_pnat_div_pos 1 z\u27e9)\r\n",
      "body": "```suggestion\r\n    by simpa using im_pnat_div_pos 1 z\u27e9)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3016,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n      (by simpa using norm_exp_two_pi_I_lt_one \u27e8-N / z, im_pnat_div_pos N z\u27e9)]\r\n",
      "body": "```suggestion\r\n      (by simpa using norm_exp_two_pi_I_lt_one \u27e8-N / z, im_pnat_div_pos N z\u27e9)]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3017,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n",
      "body": "```suggestion\r\nlemma summable_right_one_div_linear_sub_one_div_linear_succ (m : \u2124) :\r\n    Summable fun b : \u2124 \u21a6 1 / (m * (z : \u2102) + b) - 1 / (m * z + b + 1) := by\r\n  have := summable_linear_right_add_one_mul_linear_right z m m\r\n  rw [\u2190 Finset.summable_compl_iff (s := {0, -1})] at *\r\n  apply this.congr (fun b \u21a6 ?_)\r\n  simpa [add_assoc, mul_comm] using\r\n    (one_div_linear_sub_one_div_linear_eq z b (b + 1) m (by grind)).symm\r\n```\r\n(re-labelling variables for consistency with previous lemma)",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "grind",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "grind",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "grind",
          "congr",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3018,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  simp_rw [inv_neg, mul_neg, mul_sum]\r\n  rw [Summable.tsum_finsetSum (fun i hi \u21a6 by apply linear_left_summable (ne_zero z) i le_rfl)]\r\n",
      "body": "```suggestion\r\n  simp_rw [inv_neg, mul_neg, mul_sum]\r\n  rw [Summable.tsum_finsetSum (fun i hi \u21a6 by apply linear_left_summable (ne_zero z) i le_rfl)]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "rw"
        ],
        "body_tactics": [
          "apply",
          "rw"
        ],
        "new_tactics": [
          "apply"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3019,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact fun i hi \u21a6 by simpa using linear_left_summable (ne_zero z) i le_rfl\r\n",
      "body": "```suggestion\r\n  exact fun i hi \u21a6 by simpa using linear_left_summable (ne_zero z) i le_rfl\r\n```\r\nI don't think we need `omega` to tell us that `2 \u2264 2`; and doing it this way avoids having to specify `k`.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "simpa",
          "exact",
          "omega"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_omega"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3020,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (m * z + n + 1)) =\r\n    1 / (m * z - b) - 1 / (m * z + b) := by\r\n  convert telescope_aux' b (fun n \u21a6 1 / ((m : \u2102) * z + n)) using 2 <;>\r\n  simp [add_assoc, sub_eq_add_neg]\r\n",
      "body": "I'd suggest splitting this up:\r\n```suggestion\r\nprivate lemma telescope_aux' (b : \u2115)  {\u03b1 : Type*} [AddCommGroup \u03b1] (f : \u2124 \u2192 \u03b1) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (f n - f (n + 1)) = f (-b) - f b := by\r\n  induction b with\r\n  | zero => aesop\r\n  | succ b ihb =>\r\n    simp only [Nat.cast_add_one, Ico_succ_succ]\r\n    rw [sum_union (by aesop), sum_insert (by grind), sum_singleton, ihb]\r\n    grind\r\n\r\nprivate lemma telescope_aux (z : \u2102) (m : \u2124) (b : \u2115) :\r\n    \u2211 n \u2208 Ico (-b : \u2124) b, (1 / ((m : \u2102) * z + n) - 1 / (",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "aesop",
          "grind",
          "induction",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "grind",
          "induction",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "aesop",
          "induction",
          "simp"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "cleanup_simp",
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3021,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n",
      "body": "```suggestion\r\n  \u00b7 have := Summable_cotTerm (by simpa using z.int_div_mem_integerComplement (n := -d) (by aesop))\r\n```\r\nAlso the capitalization is inconsistent: `Summable_cotTerm` is a proof of summability, not a statement of summability, so it should be lowercase \u2013 please change it wherever it's defined and here to match.",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "aesop",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "aesop",
          "have"
        ],
        "new_tactics": [
          "aesop",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3022,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  exact this.congr <| by grind\r\n",
      "body": "```suggestion\r\n  exact this.congr <| by grind\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "congr",
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3023,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  \u00b7 exact tendsto_comp_val_Ioi_atTop.mpr <| \r\n      by simpa using (tendsto_inv_atTop_nhds_zero_nat (\ud835\udd5c := \u2102)).const_mul (-2)\r\n",
      "body": "```suggestion\r\n  \u00b7 exact tendsto_comp_val_Ioi_atTop.mpr <| \r\n      by simpa using (tendsto_inv_atTop_nhds_zero_nat (\ud835\udd5c := \u2102)).const_mul (-2)\r\n```\r\nSome of the proofs here are a bit awkward (here and elsewhere in this file) because you are using `tendsto_comp_val_Ioi_atTop` with `\u2115+` arguments, relying on the defeq that `\u2115+ = \u2191(Set.Ioi 0)` (which `rw` and `simp` cannot see through). I wonder if it would be better to have a version of `tendsto_comp_val_Ioi_atTop` stated for the `\u2115+` case (maybe `PN",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3031,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n",
      "body": "```suggestion\r\n    have : 1 < g.support\u1d9c.card := by grind [Finset.card_compl, Nat.card_eq_fintype_card]\r\n    obtain \u27e8b, c, hb, hc, hbc\u27e9 := Finset.one_lt_card_iff.mp this\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 3032,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n",
      "body": "```suggestion\r\n      exact cycleType_swap_mul_swap_of_nodup (by grind [Finset.mem_compl])\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 3033,
      "before_code": "theorem posDef_gram_of_linearIndependent\n    {v : n \u2192 E} (h_li : LinearIndependent \ud835\udd5c v) : PosDef (gram \ud835\udd5c v) := by\n  rw [Fintype.linearIndependent_iff] at h_li\n  obtain \u27e8h0, h1\u27e9 := posSemidef_gram \ud835\udd5c v\n  refine \u27e8h0, fun x hx \u21a6 (h1 x).lt_of_ne' ?_\u27e9",
      "suggestion": "\r\n  refine .of_dotProduct_mulVec_pos (isHermitian_gram _ _) fun x hx \u21a6\r\n    (posSemidef_gram ..).dotProduct_mulVec_nonneg.lt_of_ne' ?_\r\n",
      "body": "```suggestion\r\n  refine .of_dotProduct_mulVec_pos (isHermitian_gram _ _) fun x hx \u21a6\r\n    (posSemidef_gram ..).dotProduct_mulVec_nonneg.lt_of_ne' ?_\r\n```\r\nMaybe add `PosDef.of_posSemidef` in the future",
      "path": "Mathlib/Analysis/InnerProductSpace/GramMatrix.lean",
      "tags": {
        "before_tactics": [
          "obtain",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "obtain",
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "refine",
          "PosDef",
          "theorem",
          "posDef_gram_of_linearIndependent",
          "gram",
          "linearIndependent_iff",
          "lt_of_ne",
          "obtain",
          "Fintype",
          "LinearIndependent",
          "h_li",
          "posSemidef_gram"
        ]
      }
    },
    {
      "id": 3034,
      "before_code": "/-- The Laplacian matrix is positive semidefinite -/\ntheorem posSemidef_lapMatrix [Field R] [LinearOrder R] [IsStrictOrderedRing R] [StarRing R]\n    [TrivialStar R] : PosSemidef (G.lapMatrix R) := by\n  constructor",
      "suggestion": "\r\n  refine .of_dotProduct_mulVec_nonneg ?_ fun x => ?_\r\n",
      "body": "```suggestion\r\n  refine .of_dotProduct_mulVec_nonneg ?_ fun x => ?_\r\n```\r\neven",
      "path": "Mathlib/Combinatorics/SimpleGraph/LapMatrix.lean",
      "tags": {
        "before_tactics": [
          "constructor"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "constructor"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "lapMatrix",
          "TrivialStar",
          "IsStrictOrderedRing",
          "Field",
          "posSemidef_lapMatrix",
          "constructor",
          "positive",
          "LinearOrder",
          "matrix",
          "semidefinite",
          "PosSemidef",
          "Laplacian",
          "StarRing"
        ]
      }
    },
    {
      "id": 3035,
      "before_code": "M\u1d34.PosSemidef \u2194 M.PosSemidef :=\n  \u27e8(by simpa using \u00b7.conjTranspose), .conjTranspose\u27e9\n\nprotected lemma zero : PosSemidef (0 : Matrix n n R) :=\n  \u27e8isHermitian_zero, by simp\u27e9",
      "suggestion": "\r\n  refine \u27e8.smul (.of_nonneg ha) hx.1, fun y => ?_\u27e9\r\n",
      "body": "```suggestion\r\n  refine \u27e8.smul (.of_nonneg ha) hx.1, fun y => ?_\u27e9\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/PosDef.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "simp"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "simpa",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "lemma",
          "protected",
          "isHermitian_zero",
          "simpa",
          "conjTranspose",
          "simp",
          "zero",
          "Matrix",
          "PosSemidef",
          "using"
        ]
      }
    },
    {
      "id": 3037,
      "before_code": "end disjointOfUnion",
      "suggestion": "\r\n    IsSetSemiring (Set.range fun x : \u03b1 \u00d7 \u03b1 \u21a6 Set.Ioc x.1 x.2) where\r\n",
      "body": "This is perhaps a nicer spelling for what you're doing.\r\n```suggestion\r\n    IsSetSemiring (Set.range fun x : \u03b1 \u00d7 \u03b1 \u21a6 Set.Ioc x.1 x.2) where\r\n```",
      "path": "Mathlib/MeasureTheory/SetSemiring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "disjointOfUnion"
        ]
      }
    },
    {
      "id": 3039,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero\n\nsection MultiplicativeNotation\n\n/-- Notation for `WithZero (Multiplicative \u2115)` -/\nscoped[Multiplicative] notation \"\u2115\u2098\u2080\" => WithZero (Multiplicative \u2115)\n\n/-- Notation for `WithZero (Multiplicative \u2124)` -/\nscoped[Multiplicative] notation \"\u2124\u2098\u2080\" => WithZero (Multiplicative \u2124)",
      "suggestion": "\r\n    Set.InjOn (fun x : WithZero \u03b1 \u21a6 x ^ n) (Set.Ioi 0) := by\r\n",
      "body": "```suggestion\r\n    Set.InjOn (fun x : WithZero \u03b1 \u21a6 x ^ n) (Set.Ioi 0) := by\r\n```",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "int",
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "Notation",
          "scoped",
          "WithZero",
          "MultiplicativeNotation",
          "instLinearOrderedCommMonoidWithZero",
          "Multiplicative",
          "notation",
          "commGroupWithZero",
          "section",
          "for"
        ]
      }
    },
    {
      "id": 3040,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero",
      "suggestion": "theorem one_lt_div' [LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1) {b : \u03b1} (hb : 0 < b) :\n    1 < a / b \u2194 b < a := by\n  rw [\u2190 mul_lt_mul_right (zero_lt_iff.mpr hb), one_mul, div_eq_mul_inv, inv_mul_cancel_right\u2080 hb]\n",
      "body": "Can you generalise that to `GroupWithZero` + `LinearOrder` + compatibility typeclasses by assuming \n```suggestion\ntheorem one_lt_div' [LinearOrderedCommGroupWithZero \u03b1] (a : \u03b1) {b : \u03b1} (hb : 0 < b) :\n    1 < a / b \u2194 b < a := by\n  rw [\u2190 mul_lt_mul_right (zero_lt_iff.mpr hb), one_mul, div_eq_mul_inv, inv_mul_cancel_right\u2080 hb]\n```\nThis way it will also apply to eg linearly ordered fields. Same for the three lemmas below",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "apply",
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "WithZero",
          "end",
          "commGroupWithZero",
          "instLinearOrderedCommMonoidWithZero"
        ]
      }
    },
    {
      "id": 3042,
      "before_code": "the diagonal as `(x, y)` tends to the diagonal while remaining in `s \u00d7\u02e2 s`.\nIn other words, if `x` is sufficiently close to `y`, then `f x` is close to\n`f y` no matter where `x` and `y` are located in `s`. -/\ndef UniformContinuousOn [UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  Tendsto (fun x : \u03b1 \u00d7 \u03b1 => (f x.1, f x.2)) (\ud835\udce4 \u03b1 \u2293 \ud835\udcdf (s \u00d7\u02e2 s)) (\ud835\udce4 \u03b2)\n\ntheorem uniformContinuous_def [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 \u2200 r \u2208 \ud835\udce4 \u03b2, { x : \u03b1 \u00d7 \u03b1 | (f x.1, f x.2) \u2208 r } \u2208 \ud835\udce4 \u03b1 :=\n  Iff.rfl\n\ntheorem uniformContinuous_iff_eventually [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 \u2200 r \u2208 \ud835\udce4 \u03b2, \u2200\u1da0 x : \u03b1 \u00d7 \u03b1 in \ud835\udce4 \u03b1, (f x.1, f x.2) \u2208 r :=\n  Iff.rfl\n\ntheorem uniformContinuousOn_univ [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuousOn f univ \u2194 UniformContinuous f := by\n  rw [UniformContinuousOn, UniformContinuous, univ_prod_univ, principal_univ, inf_top_eq]\n\ntheorem uniformContinuous_of_const [UniformSpace \u03b2] {c : \u03b1 \u2192 \u03b2} (h : \u2200 a b, c a = c b) :\n    UniformContinuous c :=\n  have : (fun x : \u03b1 \u00d7 \u03b1 => (c x.fst, c x.snd)) \u207b\u00b9' SetRel.id = univ :=\n    eq_univ_iff_forall.2 fun \u27e8a, b\u27e9 => h a b\n  le_trans (map_le_iff_le_comap.2 <| by simp [comap_principal, this]) refl_le_uniformity\n\ntheorem uniformContinuous_id : UniformContinuous (@id \u03b1) := tendsto_id\n\ntheorem uniformContinuous_const [UniformSpace \u03b2] {b : \u03b2} : UniformContinuous fun _ : \u03b1 => b :=\n  uniformContinuous_of_const fun _ _ => rfl\n\nnonrec theorem UniformContinuous.comp [UniformSpace \u03b2] [UniformSpace \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : UniformContinuous g) (hf : UniformContinuous f) : UniformContinuous (g \u2218 f) :=\n  hg.comp hf\n\n/-- If a function `T` is uniformly continuous in a uniform space `\u03b2`,\nthen its `n`-th iterate `T^[n]` is also uniformly continuous. -/\ntheorem UniformContinuous.iterate [UniformSpace \u03b2] (T : \u03b2 \u2192 \u03b2) (n : \u2115) (h : UniformContinuous T) :\n    UniformContinuous T^[n] := by\n  induction n with\n  | zero => exact uniformContinuous_id\n  | succ n hn => exact Function.iterate_succ _ _ \u25b8 Unifor",
      "suggestion": "  comap_uniformity : comap (fun x : \u03b1 \u00d7 \u03b1 \u21a6 (f x.1, f x.2)) (\ud835\udce4 \u03b2) = \ud835\udce4 \u03b1\n",
      "body": "```suggestion\n  comap_uniformity : comap (fun x : \u03b1 \u00d7 \u03b1 \u21a6 (f x.1, f x.2)) (\ud835\udce4 \u03b2) = \ud835\udce4 \u03b1\n```",
      "path": "Mathlib/Topology/UniformSpace/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "rw",
          "simp",
          "induction"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "simp",
          "induction",
          "exact",
          "have"
        ],
        "topics": [
          "function",
          "nat",
          "continuity",
          "list",
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "mem_prod",
          "uniformContinuous_const",
          "tends",
          "its",
          "uniformContinuous_of_const",
          "succ",
          "Iff",
          "uniformContinuous_def",
          "Function",
          "located",
          "nonrec",
          "uniformContinuous_iff_eventually",
          "iterate",
          "snd",
          "inter_comm",
          "matter",
          "while",
          "close",
          "map_le_iff_le_comap",
          "fst",
          "sufficiently",
          "have",
          "Prop",
          "Filter",
          "UniformContinuousOn",
          "are",
          "uniformContinuousOn_univ",
          "simp_rw",
          "inf_principal",
          "words",
          "also",
          "uniform",
          "uniformContinuous_iff",
          "univ_prod_univ",
          "remaining",
          "Prod",
          "def",
          "then",
          "SetRel",
          "other",
          "univ",
          "forall",
          "Tendsto",
          "comp",
          "and_imp",
          "induction",
          "simp",
          "uniformContinuous_id",
          "tendsto_iff",
          "rfl"
        ]
      }
    },
    {
      "id": 3044,
      "before_code": "theorem inf_orthogonal_eq_bot : K \u2293 K\u15ee = \u22a5 := by\n  rw [eq_bot_iff]\n  intro x\n  simp only [toSubmodule_inf, orthogonal_toSubmodule_eq, Submodule.mem_inf, toSubmodule_bot,\n    Submodule.mem_bot, and_imp]\n  exact fun hx ho => inner_self_eq_zero.1 (ho x hx)",
      "suggestion": "\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n",
      "body": "```suggestion\r\n  simpa using fun hx ho => inner_self_eq_zero.1 (ho x hx)\r\n```\r\nDoes this work?",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "theorem",
          "toSubmodule_inf",
          "exact",
          "eq_bot_iff",
          "mem_inf",
          "toSubmodule_bot",
          "mem_bot",
          "Submodule",
          "and_imp",
          "simp",
          "intro",
          "orthogonal_toSubmodule_eq",
          "inner_self_eq_zero",
          "inf_orthogonal_eq_bot"
        ]
      }
    },
    {
      "id": 3045,
      "before_code": ".of_isCoveringMap_subtype (by simp) _ isCoveringMap_exp\n\nend Complex",
      "suggestion": "\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n",
      "body": "```suggestion\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\ntheorem isCoveringMap_npow (n : \u2115) (hn : (n : \ud835\udd5c) \u2260 0) :\r\n    IsCoveringMap fun x : {x : \ud835\udd5c // x \u2260 0} \u21a6 (\u27e8x ^ n, pow_ne_zero n x.2\u27e9 : {x : \ud835\udd5c // x \u2260 0}) := by\r\n  convert (isCoveringMapOn_npow n hn).isCoveringMap_restrictPreimage.comp_homeomorph (.setCongr _)\r\n    using 1\r\n  ext; simp [show n \u2260 0 by aesop]; rfl\r\n\r\n/-- `(\u00b7 ^ n) : \ud835\udd5c \\ {0} \u2192 \ud835\udd5c \\ {0}` is a covering map (if `n \u2260 0` in `\ud835\udd5c`). -/\r\n```",
      "path": "Mathlib/Analysis/Complex/CoveringMap.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "aesop",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "aesop",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "aesop",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "of_isCoveringMap_subtype",
          "end",
          "Complex",
          "simp",
          "isCoveringMap_exp"
        ]
      }
    },
    {
      "id": 3048,
      "before_code": "lemma stdSimplexHomeomorphUnitInterval_one :\n    stdSimplexHomeomorphUnitInterval \u27e8_, single_mem_stdSimplex _ 1\u27e9 = 1 := rfl",
      "suggestion": "\r\n  Metric.diam_le_of_forall_dist_le zero_le_one fun x hx y hy \u21a6\r\n    (dist_pi_le_iff zero_le_one).mpr fun i \u21a6 by\r\n",
      "body": "looks weird indented, in my opinion,\r\n```suggestion\r\n  Metric.diam_le_of_forall_dist_le zero_le_one fun x hx y hy \u21a6\r\n    (dist_pi_le_iff zero_le_one).mpr fun i \u21a6 by\r\n```\r\nI guess the rest can be indented more tho if you want?",
      "path": "Mathlib/Analysis/Convex/StdSimplex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "rfl",
          "single_mem_stdSimplex",
          "stdSimplexHomeomorphUnitInterval",
          "stdSimplexHomeomorphUnitInterval_one"
        ]
      }
    },
    {
      "id": 3050,
      "before_code": "rw [isLittleO_iff_forall_isBigOWith, isLittleO_iff_forall_isBigOWith]\n  simp [isBigOWith_mul_iff_isBigOWith_div hf]",
      "suggestion": "\r\n      _ \u2264 C\u2081 * \u2016g m\u2016 := by\r\n        gcongr\r\n        exact Finset.le_sup' (fun x => \u2016f x\u2016 / \u2016g x\u2016) (Finset.mem_def.mpr hm)\r\n",
      "body": "```suggestion\r\n      _ \u2264 C\u2081 * \u2016g m\u2016 := by\r\n        gcongr\r\n        exact Finset.le_sup' (fun x => \u2016f x\u2016 / \u2016g x\u2016) (Finset.mem_def.mpr hm)\r\n```",
      "path": "Mathlib/Analysis/Asymptotics/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "gcongr"
        ],
        "body_tactics": [
          "exact",
          "gcongr"
        ],
        "new_tactics": [
          "exact",
          "gcongr"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isBigOWith_mul_iff_isBigOWith_div",
          "simp",
          "isLittleO_iff_forall_isBigOWith"
        ]
      }
    },
    {
      "id": 3051,
      "before_code": "\u21d1f.toHomeomorphOfFiniteDimensional.symm = f.symm :=\n  rfl",
      "suggestion": "\r\n  refine \u27e8\u27e8\u2016fL\u2016\u208a, LipschitzWith.of_dist_le_mul fun x y \u21a6 ?_\u27e9\r\n",
      "body": "```suggestion\r\n  refine \u27e8\u27e8\u2016fL\u2016\u208a, LipschitzWith.of_dist_le_mul fun x y \u21a6 ?_\u27e9\r\n```\r\nThis ought to work",
      "path": "Mathlib/Analysis/Normed/Module/FiniteDimension.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "symm",
          "toHomeomorphOfFiniteDimensional"
        ]
      }
    },
    {
      "id": 3052,
      "before_code": "map n (g \u2218\u2097 f) = map n g \u2218\u2097 map n f := by\n  aesop",
      "suggestion": "\r\n/-- If a linear map has a retraction, then the map it induces on exterior powers is injective. -/\r\nlemma map_injective {f : M \u2192\u2097[R] N} (g : N \u2192\u2097[R] M) (hg : g \u2218\u2097 f = .id) :\r\n    Injective (map n f) :=\r\n  RightInverse.injective (g := map n g)\r\n    (fun _ \u21a6 by rw [\u2190 LinearMap.comp_apply, \u2190 map_comp, hg, map_id, LinearMap.id_coe, id_eq])\r\n\r\n/-- If the base ring is a field, then any injective linear map induces an injective map on\r\nexterior powers. -/\r\nlemma map_injective_field {K : Type*} [Field K] [Module K M] [Module K N]\r\n    {f : M \u2192\u2097[K] N} (hf : Injective f) :\r\n    Injective (map n f) :=\r\n  map_injective _ (f.exists_leftInverse_of_injective (LinearMap.ker_eq_bot.mpr hf)).choose_spec\r\n",
      "body": "It is almost always more convenient to destruct an existential hypothesis and I think we should do so here. Given that and some other very minor style tweaks I suggest:\r\n```suggestion\r\n/-- If a linear map has a retraction, then the map it induces on exterior powers is injective. -/\r\nlemma map_injective {f : M \u2192\u2097[R] N} (g : N \u2192\u2097[R] M) (hg : g \u2218\u2097 f = .id) :\r\n    Injective (map n f) :=\r\n  RightInverse.injective (g := map n g)\r\n    (fun _ \u21a6 by rw [\u2190 LinearMap.comp_apply, \u2190 map_comp, hg, map_id, Line",
      "path": "Mathlib/LinearAlgebra/ExteriorPower/Basic.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [
          "ring",
          "rw"
        ],
        "body_tactics": [
          "ring",
          "rw"
        ],
        "new_tactics": [
          "ring",
          "rw"
        ],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [],
        "transforms": [
          "use_ring"
        ],
        "keywords": [
          "map",
          "aesop"
        ]
      }
    },
    {
      "id": 3053,
      "before_code": "have B : \u2200\u1da0 x in atTop, x + 1 \u2264 exp x := eventually_atTop.2 \u27e80, fun x _ => add_one_le_exp x\u27e9\n  exact tendsto_atTop_mono' atTop B A",
      "suggestion": "  have h_le : y \u2264 exp (y - 1) := by simpa using add_one_le_exp (y - 1)\n  have h_mul_le : y * rexp (-y) \u2264 rexp (y - 1) * rexp (-y) := by gcongr\n  simpa [\u2190 exp_add, sub_add_eq_add_sub] using h_mul_le\n",
      "body": "```suggestion\n  have h_le : y \u2264 exp (y - 1) := by simpa using add_one_le_exp (y - 1)\n  have h_mul_le : y * rexp (-y) \u2264 rexp (y - 1) * rexp (-y) := by gcongr\n  simpa [\u2190 exp_add, sub_add_eq_add_sub] using h_mul_le\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Exp.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "simpa",
          "gcongr",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "gcongr",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "gcongr"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exp",
          "eventually_atTop",
          "exact",
          "have",
          "tendsto_atTop_mono",
          "add_one_le_exp",
          "atTop"
        ]
      }
    },
    {
      "id": 3055,
      "before_code": "lemma uIoo_of_gt (h : b < a) : uIoo a b = Ioo b a := uIoo_of_ge h.le\n\nlemma uIoo_self : uIoo a a = \u2205 := by simp [uIoo]",
      "suggestion": "\r\nlemma uIoo_self : uIoo a a = \u2205 := by simp [uIoo]\r\n",
      "body": "```suggestion\r\nlemma uIoo_self : uIoo a a = \u2205 := by simp [uIoo]\r\n```",
      "path": "Mathlib/Order/Interval/Set/UnorderedInterval.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "uIoo_of_gt",
          "uIoo",
          "lemma",
          "uIoo_self",
          "simp",
          "uIoo_of_ge",
          "Ioo"
        ]
      }
    },
    {
      "id": 3056,
      "before_code": "(hx : \u2200 r : R, r \u2022 x \u2208 Submodule.span R s \u2192 r = 0) : LinearIndepOn R id (insert x s) :=\n  hs.insert' <| by simpa",
      "suggestion": "/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?_\n  have aux (j : \u03b9) (hjs : j \u2208 s) (hji : j \u2260 i) : g j * (f i) (v j) = 0 := by simp [h1 hji.symm]\n  simpa [s.sum_eq_single i aux (by aesop), h2 i] using congr_arg (f i) hrel\n",
      "body": "Just a few minor style tweaks:\n```suggestion\n/-- If `v : \u03b9 \u2192 M` is a family of vectors and there exists a family of linear forms\n`f : \u03b9 \u2192 Dual R M` such that `f i (v j)` is `1` for `i = j` and `0` for `i \u2260 j`, then\n`v` is linearly independent. -/\ntheorem LinearIndependent.of_pairwise_dual_eq_zero_one (v : \u03b9 \u2192 M) (f : \u03b9 \u2192 Dual R M)\n    (h1 : Pairwise fun i j \u21a6 f i (v j) = 0)\n    (h2 : \u2200 i, (f i) (v i) = 1) :\n    LinearIndependent R v := by\n  refine linearIndependent_iff'.mpr fun s g hrel i hi \u21a6 ?",
      "path": "Mathlib/LinearAlgebra/LinearIndependent/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "have",
          "aesop",
          "simp",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "insert",
          "LinearIndepOn",
          "span",
          "simpa",
          "Submodule"
        ]
      }
    },
    {
      "id": 3065,
      "before_code": "end IsSetSemiring",
      "suggestion": "      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n",
      "body": "```suggestion\n      \u00b7 have : onIocAux f (Set.Ioc u u) = \u2211 u \u2208 I, 0 := by simp [onIocAux_empty f]\n        rw [h'uv, this]\n        apply Finset.sum_congr rfl fun i hi \u21a6 ?_\n        have : i = \u2205 := by grind [sUnion_eq_empty]\n        grind [onIocAux_empty]\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "rw",
          "simp",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 3066,
      "before_code": "end IsSetSemiring",
      "suggestion": "      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n",
      "body": "```suggestion\n      -- we have `u \u2264 u'` and `v' = v` since `(u', v']` is part of the union, and therefore\n      -- contained in `(u, v]`.\n      have \u27e8_, uu'\u27e9 : v' \u2264 v \u2227 u \u2264 u' := (Ioc_subset_Ioc_iff (by grind)).1 (by grind)\n      obtain rfl : v = v' := by grind\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "grind",
          "obtain",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 3067,
      "before_code": "end IsSetSemiring",
      "suggestion": "      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n",
      "body": "```suggestion\n      have IH : onIocAux f (\u22c3\u2080 \u2191I') = \u2211 u \u2208 I', onIocAux f u :=\n        ih _ (Subset.trans I'I hI) (h'I.subset I'I) (by grind) (by grind)\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "IsSetSemiring",
          "end"
        ]
      }
    },
    {
      "id": 3068,
      "before_code": "ext\n  simp +contextual [imp_false]",
      "suggestion": "\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n",
      "body": "I know you're not a fan but `diagSet` seems to fit the hypothesis pretty well:\r\n```suggestion\r\n@[simp] lemma deleteEdges_of_subset_diagSet (G : SimpleGraph V) (hs : s \u2286 Sym2.diagSet) :\r\n    G.deleteEdges s = G := by ext u v; simpa using (\u00b7.ne <| Sym2.mem_diagSet_iff_eq.mp <| hs \u00b7)\r\n```\r\nThe current proof (just without the underscore) will also work after your #32679 is merged",
      "path": "Mathlib/Combinatorics/SimpleGraph/DeleteEdges.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simpa",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "contextual",
          "imp_false",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 3077,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3078,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3079,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3080,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3081,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 \u2264 a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3082,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a \u2264 f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3083,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (f \u00b7 < a) (by grind [Monotone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3084,
      "before_code": "variable {n : \u2115} {\u03b1 : Type*}\n\n/-- If `f\u2080 \u2264 f\u2081 \u2264 f\u2082 \u2264 \u22ef` is a sorted `m`-tuple of elements of `\u03b1`, then for any `j : Fin m` and\n`a : \u03b1` we have `j < #{i | f\u1d62 \u2264 a}` iff `f\u2c7c \u2264 a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a := by\n  suffices h1 : \u2200 k : Fin m, (k < Fintype.card {i // f i \u2264 a}) \u2192 f k \u2264 a by\n    refine \u27e8h1 j, fun h \u21a6 ?_\u27e9\n    by_contra! hc\n    let p : Fin m \u2192 Prop := fun x \u21a6 f x \u2264 a\n    let q : Fin m \u2192 Prop := fun x \u21a6 x < Fintype.card {i // f i \u2264 a}\n    let q' : {i // f i \u2264 a} \u2192 Prop := fun x \u21a6 q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x \u2264 a} // \u00ac q' j} :=\n      Fintype.card_pos_iff.2 \u27e8\u27e8\u27e8j, h\u27e9, not_lt.2 hc\u27e9\u27e9\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i \u2264 a } \u2264 m := by lia\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_eq_left] at he\n  intro _ h\n  contrapose! h\n  rw [\u2190 Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  rw [Finset.mem_filter_univ, Finset.mem_Iio]\n  exact fun hij hia \u21a6 h ((h_sorted (le_of_not_gt hij)).trans hia)\n\ntheorem lt_card_ge_iff_apply_ge_of_antitone [Preorder \u03b1] [DecidableLE \u03b1]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j",
      "suggestion": "  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n",
      "body": "```suggestion\n  Fin.lt_card_filter_univ_iff_apply_of_imp (a < f \u00b7) (by grind [Antitone])\n```",
      "path": "Mathlib/Data/Fin/Tuple/Sort.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "rw",
          "intro"
        ],
        "topics": [
          "function",
          "nat",
          "equiv",
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rwa",
          "hij",
          "Type",
          "sorted",
          "lt_card_le_iff_apply_le_of_monotone",
          "Function",
          "dual_right",
          "elements",
          "mtr",
          "apply",
          "le_of_not_gt",
          "contrapose",
          "refine",
          "Finset",
          "have",
          "Prop",
          "h_sorted",
          "iff",
          "Equiv",
          "intro",
          "Antitone",
          "by_contra",
          "tuple",
          "card_fin_lt_of_le",
          "lia",
          "toDual",
          "lt_card_ge_iff_apply_ge_of_antitone",
          "for",
          "add_eq_left",
          "h_le",
          "hia",
          "variable",
          "then",
          "card_mono",
          "sumCompl",
          "Preorder",
          "card_subtype",
          "not_lt",
          "card_sum",
          "mem_Iio",
          "card_Iio",
          "card",
          "mem_filter_univ",
          "theorem",
          "exact",
          "card_pos_iff",
          "OrderDual",
          "Monotone",
          "suffices",
          "card_congr"
        ]
      }
    },
    {
      "id": 3085,
      "before_code": "ext s hs\n  simp [hs]",
      "suggestion": "\r\n    (sum m).join = sum fun (i : \u03b9) \u21a6 (m i).join := by\r\n",
      "body": "According to the [style guide](https://leanprover-community.github.io/contribute/style.html) theorem statements should be indented by four spaces.\r\n```suggestion\r\n    (sum m).join = sum fun (i : \u03b9) \u21a6 (m i).join := by\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 3086,
      "before_code": "let \u27e8f, hfm, hf\u27e9 := hg\n  \u27e8(bind \u00b7 f), measurable_bind' hfm, (ae_ae_of_ae_join hf).mono fun _ \u21a6 bind_congr_right\u27e9",
      "suggestion": "\r\n    (sum fun (i : \u03b9) \u21a6 m i).bind f = sum fun (i : \u03b9) \u21a6 (m i).bind f := by\r\n",
      "body": "As above.\r\n```suggestion\r\n    (sum fun (i : \u03b9) \u21a6 m i).bind f = sum fun (i : \u03b9) \u21a6 (m i).bind f := by\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "bind",
          "mono",
          "hfm",
          "measurable_bind",
          "ae_ae_of_ae_join",
          "bind_congr_right"
        ]
      }
    },
    {
      "id": 3089,
      "before_code": "(p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (\u2a05 i, p i) = \u2a05 i, comap f (p i) :=\n  (gc_map_comap f).u_iInf",
      "suggestion": "\r\n    (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (s.inf p) = s.inf fun i \u21a6 comap f (p i) := by\r\n  simp [Finset.inf_eq_iInf]\r\n",
      "body": "```suggestion\r\n    (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) : comap f (s.inf p) = s.inf fun i \u21a6 comap f (p i) := by\r\n  simp [Finset.inf_eq_iInf]\r\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Map.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "gc_map_comap",
          "Submodule",
          "comap",
          "u_iInf"
        ]
      }
    },
    {
      "id": 3090,
      "before_code": "theorem comap_iInf (K : \u03b9 \u2192 Ideal S) : (iInf K).comap f = \u2a05 i, (K i).comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_iInf",
      "suggestion": "\r\n    (s.inf K).comap f = s.inf fun i \u21a6 (K i).comap f := by\r\n  simp [Finset.inf_eq_iInf, comap_iInf]\r\n",
      "body": "```suggestion\r\n    (s.inf K).comap f = s.inf fun i \u21a6 (K i).comap f := by\r\n  simp [Finset.inf_eq_iInf, comap_iInf]\r\n```",
      "path": "Mathlib/RingTheory/Ideal/Maps.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Ideal",
          "GaloisConnection",
          "theorem",
          "comap_iInf",
          "gc_map_comap",
          "iInf",
          "map",
          "u_iInf",
          "comap"
        ]
      }
    },
    {
      "id": 3095,
      "before_code": "simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b\u2081, h, \u2190 mul_assoc, mul_comm _ (f a)]",
      "suggestion": "    exact (hki.2 (hs hi hj hij k (by grind))).elim\n",
      "body": "```suggestion\n    exact (hki.2 (hs hi hj hij k (by grind))).elim\n```",
      "path": "Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "grind"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [
          "exact",
          "grind"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mul_assoc",
          "not_true_eq_false",
          "false_and",
          "mem_erase",
          "ne_eq",
          "not_false_eq_true",
          "simp",
          "mul_comm",
          "only",
          "prod_insert"
        ]
      }
    },
    {
      "id": 3098,
      "before_code": "theorem preCantorSet_antitone : Antitone preCantorSet := by\n  apply antitone_nat_of_succ_le\n  intro m",
      "suggestion": "\r\n  refine antitone_nat_of_succ_le fun m \u21a6 ?_\r\n",
      "body": "Since we're already golfing:\r\n```suggestion\r\n  refine antitone_nat_of_succ_le fun m \u21a6 ?_\r\n```",
      "path": "Mathlib/Topology/Instances/CantorSet.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "intro"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "apply",
          "intro"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "antitone_nat_of_succ_le",
          "theorem",
          "preCantorSet",
          "preCantorSet_antitone",
          "Antitone",
          "intro"
        ]
      }
    },
    {
      "id": 3101,
      "before_code": "theorem symm_comp : e.symm.toLinearMap \u2218\u209b\u2097 e.toLinearMap = LinearMap.id :=\n  LinearMap.ext e.symm_apply_apply",
      "suggestion": "\r\n    e\u2081\u2082.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n\r\n@[simp]\r\nlemma symm_comp_assoc (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) [RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082] :\r\n    e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n",
      "body": "```suggestion\r\n    e\u2081\u2082.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n\r\n@[simp]\r\nlemma symm_comp_assoc (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) [RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082] :\r\n    e\u2081\u2082.symm.toLinearMap \u2218\u209b\u2097 e\u2081\u2082.toLinearMap \u2218\u209b\u2097 f = f := by ext; simp\r\n```",
      "path": "Mathlib/Algebra/Module/Equiv/Defs.lean",
      "tags": {
        "before_tactics": [
          "ext"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "LinearMap",
          "theorem",
          "symm_apply_apply",
          "symm_comp",
          "toLinearMap"
        ]
      }
    },
    {
      "id": 3111,
      "before_code": "theorem irreducible_of_factor {a : \u03b1} : \u2200 x : \u03b1, x \u2208 factors a \u2192 Irreducible x := fun x h =>\n  (prime_of_factor x h).irreducible",
      "suggestion": "  have hf : factors a \u2260 0 := by\n    intro hf\n    simpa [hf, Associated.comm, ha.not_isUnit] using factors_prod ha.ne_zero\n",
      "body": "I think this is clearer as:\n```suggestion\n  have hf : factors a \u2260 0 := by\n    intro hf\n    simpa [hf, Associated.comm, ha.not_isUnit] using factors_prod ha.ne_zero\n```\nand then deindent the rest of the proof",
      "path": "Mathlib/RingTheory/UniqueFactorizationDomain/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "irreducible",
          "theorem",
          "Irreducible",
          "factors",
          "irreducible_of_factor",
          "prime_of_factor"
        ]
      }
    },
    {
      "id": 3115,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
      "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ico_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 3116,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n",
      "body": "```suggestion\r\n  simpa [Set.Ici_bot] using biUnion_Ici_Ioc_map_succ (fun i _ \u21a6 hf i) h2f'\r\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 3117,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
      "body": "```suggestion\n  simpa using biUnion_Ici_Ico_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 3118,
      "before_code": "suffices \u2200 i, a \u2264 i \u2192 f i < b from \u27e8b, by aesop (add simp [upperBounds, le_of_lt])\u27e9\n  exact Succ.rec (P := fun i _ \u21a6 f i < b) hb (by aesop)",
      "suggestion": "  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n",
      "body": "```suggestion\n  simpa using biUnion_Ici_Ioc_map_succ (f := f) (a := \u22a5) (by simpa) (by simpa)\n```",
      "path": "Mathlib/Order/SuccPred/IntervalSucc.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "aesop",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "add",
          "aesop",
          "upperBounds",
          "Succ",
          "exact",
          "suffices",
          "simp",
          "rec",
          "from"
        ]
      }
    },
    {
      "id": 3120,
      "before_code": "instance [Nontrivial M] : Nontrivial P.invtRootSubmodule where\n  exists_pair_ne := \u27e8\u22a5, \u22a4, by rw [ne_eq, Subtype.ext_iff]; exact bot_ne_top\u27e9",
      "suggestion": "    q = \u22a4 \u2194 range P.root \u2286 q :=\n  \u27e8fun h \u21a6 by simp [h], fun h \u21a6 by simpa using Submodule.span_mono h (R := K)\u27e9\n",
      "body": "How about:\n```suggestion\n    q = \u22a4 \u2194 range P.root \u2286 q :=\n  \u27e8fun h \u21a6 by simp [h], fun h \u21a6 by simpa using Submodule.span_mono h (R := K)\u27e9\n```\n(I confess I'm slightly amazed I could golf this so much: it suggests our `simp` sets are in pretty good shape)",
      "path": "Mathlib/LinearAlgebra/RootSystem/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Subtype",
          "ext_iff",
          "Nontrivial",
          "exact",
          "invtRootSubmodule",
          "ne_eq",
          "exists_pair_ne",
          "instance",
          "bot_ne_top"
        ]
      }
    },
    {
      "id": 3129,
      "before_code": "TensorProduct.map_map_comp_assoc_eq]\n\ninstance instIsCocomm [IsCocomm R A] : IsCocomm R (\u03b9 \u2192\u2080 A) where\n  comm_comp_comul := by\n    ext i : 1\n    -- TODO: Add `reassoc` for `LinearMap`. Then we wouldn't need to reassociate back and forth.\n    simp only [comp_assoc, comul_comp_lsingle]\n    simp only [\u2190 comp_assoc, \u2190 TensorProduct.map_comp_comm_eq]\n    simp [LinearMap.comp_assoc]\n\nend Finsupp",
      "suggestion": "\r\n    counit \u2218\u2097 Finsupp.lcoeFun = counit := by\r\n",
      "body": "```suggestion\r\n    counit \u2218\u2097 Finsupp.lcoeFun = counit := by\r\n```",
      "path": "Mathlib/RingTheory/Coalgebra/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "forth",
          "end",
          "comm_comp_comul",
          "back",
          "comp_assoc",
          "map_comp_comm_eq",
          "TODO",
          "wouldn",
          "ext",
          "LinearMap",
          "IsCocomm",
          "for",
          "Finsupp",
          "need",
          "TensorProduct",
          "reassociate",
          "simp",
          "comul_comp_lsingle",
          "Add",
          "only",
          "instIsCocomm",
          "reassoc",
          "map_map_comp_assoc_eq",
          "Then",
          "instance"
        ]
      }
    },
    {
      "id": 3130,
      "before_code": "ext\n    simp",
      "suggestion": "\r\n@[simp] theorem lcoeFun_apply (x : \u03b1) (m : M) (f : \u03b1 \u2192\u2080 M) : lcoeFun (R := R) f = \u21d1f :=\r\n  rfl\r\n",
      "body": "I think actually the `simps` above is to blame, and we should remove it and instead write\r\n```suggestion\r\n@[simp] theorem lcoeFun_apply (x : \u03b1) (m : M) (f : \u03b1 \u2192\u2080 M) : lcoeFun (R := R) f = \u21d1f :=\r\n  rfl\r\n```",
      "path": "Mathlib/LinearAlgebra/Finsupp/Pi.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 3131,
      "before_code": "end LinearMap.transvection\n\nend baseChange",
      "suggestion": "private theorem det_ofField [FiniteDimensional K V] (f : Module.Dual K V) (v : V) :\n",
      "body": "Given that this is dominated by the eventual result:\n```suggestion\nprivate theorem det_ofField [FiniteDimensional K V] (f : Module.Dual K V) (v : V) :\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "LinearMap",
          "end",
          "baseChange"
        ]
      }
    },
    {
      "id": 3134,
      "before_code": "have h\u2082 := cos_pi_div_three;\n    have h\u2082 := cos_zero] <;>\n  simp [injOn_cos h_bnd \u27e8by positivity, by linarith [pi_nonneg]\u27e9 (h\u2082 \u25b8 h)]",
      "suggestion": "  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n",
      "body": "```suggestion\n  apply smul_left_injective \u211a pi_ne_zero |>.mem_set_image.mp\n  replace h_bnd : (r : \u211d) * \u03c0 \u2208 Set.Icc (0 * \u03c0) (1 * \u03c0) := by\n    obtain \u27e8hr, hr'\u27e9 := h_bnd; constructor <;> gcongr <;> norm_cast\n  generalize h : (r : \u211d) * \u03c0 = \u03b8 at *\n  have := niven_angle_eq \u27e8r, h.symm\u27e9 hcos (by simpa using h_bnd)\n  simp_all [Rat.smul_def]\n  grind\n```",
      "path": "Mathlib/NumberTheory/Niven.lean",
      "tags": {
        "before_tactics": [
          "positivity",
          "have",
          "simp",
          "linarith"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "grind",
          "have",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "grind",
          "have",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "grind",
          "simpa",
          "obtain",
          "constructor",
          "simp_all",
          "norm_cast"
        ],
        "removed_tactics": [
          "positivity",
          "simp",
          "linarith"
        ],
        "topics": [],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "injOn_cos",
          "cos_pi_div_three",
          "positivity",
          "pi_nonneg",
          "have",
          "h_bnd",
          "simp",
          "linarith",
          "cos_zero"
        ]
      }
    },
    {
      "id": 3136,
      "before_code": "obtain \u27e8b', hb', d_ab\u27e9 := exists_lt_mul_right_of_nonneg ha'.1 hd d_ab\n  exact d_ab.le.trans (h a' ha'.1 ha'.2 b' hb'.1 hb'.2)\n\ntheorem mul_self_inj_of_nonneg (a0 : 0 \u2264 a) (b0 : 0 \u2264 b) : a * a = b * b \u2194 a = b :=\n  mul_self_eq_mul_self_iff.trans <|\n    or_iff_left_of_imp fun h => by grind",
      "suggestion": "\r\n  have := fun h \u21a6 le_antisymm (neg_nonneg.mp h) b0\r\n  grind [sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg]\r\n",
      "body": "this is the same proof, but just using grind:\r\n```suggestion\r\n  have := fun h \u21a6 le_antisymm (neg_nonneg.mp h) b0\r\n  grind [sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg]\r\n```\r\nnot sure what file this could go to though\r\n\r\nalso, we have this [sq_eq_sq\u2080](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#sq_eq_sq%E2%82%80) which is essentially the same (but uses `LinearOrder`)",
      "path": "Mathlib/Algebra/Order/Field/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "grind",
          "obtain"
        ],
        "suggestion_tactics": [
          "grind",
          "have"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mul_self_eq_mul_self_iff",
          "theorem",
          "exact",
          "mul_self_inj_of_nonneg",
          "grind",
          "d_ab",
          "obtain",
          "trans",
          "exists_lt_mul_right_of_nonneg",
          "or_iff_left_of_imp"
        ]
      }
    },
    {
      "id": 3138,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "    derivative^[k] (\u220f vj \u2208 (s.erase i).image v, (X - C vj)) := by rw [Finset.prod_image hvs']\n",
      "body": "```suggestion\n    derivative^[k] (\u220f vj \u2208 (s.erase i).image v, (X - C vj)) := by rw [Finset.prod_image hvs']\n```\n(matter of taste, maybe)",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3139,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_injOn hvs').mono (by grind)\n        case i_surj => grind [card_image_of_injOn, hvs'.mono]\n        case h =>\n          rw [eq_comm]\n          exact prod_image <| by grind [hvs'.mono]\n",
      "body": "```suggestion\n          \u220f va \u2208 t, (X - C va) := by\n        grind [iterate_derivative_prod_X_sub_C]\n    _ = k.factorial * \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (X - C (v a)) := by\n        rw [powersetCard_eq_filter, powerset_image, eq_comm]\n        congrm k.factorial * ?_\n        refine sum_nbij (\u00b7.image v) (fun a ha \u21a6 ?hi) ?i_inj (fun t ht \u21a6 ?i_surj) fun a ha \u21a6 ?h\n        case hi => grind [card_image_of_injOn, hvs'.mono]  \n        case i_inj => exact (image_injOn_powerset_of_in",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "rw",
          "intro",
          "omega"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_omega",
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3140,
      "before_code": "minTensorProduct C\u2081 C\u2082 \u2264 maxTensorProduct C\u2081 C\u2082 := by\n  exact Submodule.span_le.mpr (tmul_subset_maxTensorProduct C\u2081 C\u2082)",
      "suggestion": "  refine \u27e8?_, fun hz \u21a6\n    \u27e8(TensorProduct.comm R H G) z, ?_, (TensorProduct.comm R H G).symm_apply_apply z\u27e9\u27e9\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9 \u03c8 h\u03c8 \u03c6 h\u03c6\n    simpa [dualDistrib_apply_comm] using hw \u03c6 h\u03c6 \u03c8 h\u03c8\n  \u00b7 intro \u03c6 h\u03c6 \u03c8 h\u03c8\n    simpa [dualDistrib_apply_comm] using hz \u03c8 h\u03c8 \u03c6 h\u03c6\n",
      "body": "```suggestion\n  refine \u27e8?_, fun hz \u21a6\n    \u27e8(TensorProduct.comm R H G) z, ?_, (TensorProduct.comm R H G).symm_apply_apply z\u27e9\u27e9\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9 \u03c8 h\u03c8 \u03c6 h\u03c6\n    simpa [dualDistrib_apply_comm] using hw \u03c6 h\u03c6 \u03c8 h\u03c8\n  \u00b7 intro \u03c6 h\u03c6 \u03c8 h\u03c8\n    simpa [dualDistrib_apply_comm] using hz \u03c8 h\u03c8 \u03c6 h\u03c6\n```\ngolf; unsqueeze terminal simps",
      "path": "Mathlib/Geometry/Convex/Cone/TensorProduct.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "refine",
          "intro"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "tmul_subset_maxTensorProduct",
          "mpr",
          "exact",
          "maxTensorProduct",
          "Submodule",
          "minTensorProduct",
          "span_le"
        ]
      }
    },
    {
      "id": 3143,
      "before_code": "simp_rw [measurable_iff_comap_le, MeasurableSpace.pi, MeasurableSpace.comap_iSup,\n    MeasurableSpace.comap_comp, Function.comp_def, iSup_le_iff]",
      "suggestion": "theorem MeasurableSpace.comap_le_comap_pi {g : (a : \u03b4) \u2192 \u03b2 \u2192 X a} (a : \u03b4) :\n    .comap (g a) inferInstance \u2264 pi.comap (fun b c \u21a6 g c b) := by\n  simpa only [pi, comap_iSup] using le_iSup_of_le a <| by measurability\n",
      "body": "```suggestion\ntheorem MeasurableSpace.comap_le_comap_pi {g : (a : \u03b4) \u2192 \u03b2 \u2192 X a} (a : \u03b4) :\n    .comap (g a) inferInstance \u2264 pi.comap (fun b c \u21a6 g c b) := by\n  simpa only [pi, comap_iSup] using le_iSup_of_le a <| by measurability\n```",
      "path": "Mathlib/MeasureTheory/MeasurableSpace/Constructions.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "measurability"
        ],
        "body_tactics": [
          "simpa",
          "measurability"
        ],
        "new_tactics": [
          "simpa",
          "measurability"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "order",
          "function"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "comp_def",
          "iSup_le_iff",
          "comap_iSup",
          "comap_comp",
          "simp_rw",
          "MeasurableSpace",
          "Function",
          "measurable_iff_comap_le"
        ]
      }
    },
    {
      "id": 3144,
      "before_code": "intros\n    ext\n    simp [fromModuleCatToModuleCatLinearEquivtoModuleCatObj]",
      "suggestion": "\r\n  toFun m i := \u27e8single j i (1 : R) \u2022 m, single j i (1 : R) \u2022 m, by\r\n",
      "body": "Does this work as the shorter\r\n```suggestion\r\n  toFun m i := \u27e8single j i (1 : R) \u2022 m, single j i (1 : R) \u2022 m, by\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "fromModuleCatToModuleCatLinearEquivtoModuleCatObj",
          "intros",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 3160,
      "before_code": "end QuasiFinite",
      "suggestion": "  have : IsLocalizedModule (.powers r) (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8fun x \u21a6 IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n      \u27e8x, hrp' x.2\u27e9, fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simp [Submonoid.mem_powers_iff]\u27e9\n",
      "body": "```suggestion\n  have : IsLocalizedModule (.powers r) (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8fun x \u21a6 IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p))\n      \u27e8x, hrp' x.2\u27e9, fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simp [Submonoid.mem_powers_iff]\u27e9\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 3162,
      "before_code": "end QuasiFinite",
      "suggestion": "  have : IsLocalizedModule p.primeCompl (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p)),\n      fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simpa using \u27e81, p.primeCompl.one_mem\u27e9\u27e9\n",
      "body": "```suggestion\n  have : IsLocalizedModule p.primeCompl (.id (R := S) (M := Localization.AtPrime p)) :=\n    \u27e8IsLocalizedModule.map_units (Algebra.linearMap S (Localization.AtPrime p)),\n      fun y \u21a6 \u27e8\u27e8y, 1\u27e9, by simp\u27e9, by simpa using \u27e81, p.primeCompl.one_mem\u27e9\u27e9\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 3164,
      "before_code": "end QuasiFinite\n\nend Algebra",
      "suggestion": "/-- If `P` is a prime of `R[X]/I` that is quasi finite over `R`,\nthen `I` is not contained in `(P \u2229 R)[X]`.\nFor usability, we replace `I` by the kernel of a surjective map `R[X] \u2192\u2090[R] S`  -/\n",
      "body": "```suggestion\n/-- If `P` is a prime of `R[X]/I` that is quasi finite over `R`,\nthen `I` is not contained in `(P \u2229 R)[X]`.\nFor usability, we replace `I` by the kernel of a surjective map `R[X] \u2192\u2090[R] S`  -/\n```\nOr something like that.",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Algebra",
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 3168,
      "before_code": "(g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g :=\n  rfl",
      "suggestion": "\r\n  toFun := \u220f i \u2208 s, f i\r\n",
      "body": "```suggestion\r\n  toFun := \u220f i \u2208 s, f i\r\n```\r\n(needed to get the autogenerated simp lemma to look right)",
      "path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "SlashInvariantForm",
          "mul"
        ]
      }
    },
    {
      "id": 3169,
      "before_code": "toFun := let := Fintype.ofFinite \ud835\udcac; \u220f q : \ud835\udcac, quotientFunc f q\n  slash_action_eq' h hh := by\n    let := Fintype.ofFinite \ud835\udcac\n    simpa [\u2190 Finset.card_univ, ModularForm.prod_slash Finset.univ_nonempty,\n      quotientFunc_smul f hh, Subgroup.HasDetPlusMinusOne.abs_det hh,\n      -Matrix.GeneralLinearGroup.val_det_apply] using Equiv.prod_comp (MulAction.toPerm (_ : \u210b)) _",
      "suggestion": "\r\n      quotientFunc_smul f hh, Subgroup.HasDetPlusMinusOne.abs_det hh,\r\n      -Matrix.GeneralLinearGroup.val_det_apply] using Equiv.prod_comp (MulAction.toPerm (_ : \u210b)) _\r\n",
      "body": "Nonstandard indenting?\r\n```suggestion\r\n      quotientFunc_smul f hh, Subgroup.HasDetPlusMinusOne.abs_det hh,\r\n      -Matrix.GeneralLinearGroup.val_det_apply] using Equiv.prod_comp (MulAction.toPerm (_ : \u210b)) _\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/NormTrace.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "finset",
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "prod_comp",
          "quotientFunc",
          "ModularForm",
          "univ_nonempty",
          "Finset",
          "Equiv",
          "quotientFunc_smul",
          "MulAction",
          "slash_action_eq",
          "ofFinite",
          "toFun",
          "GeneralLinearGroup",
          "HasDetPlusMinusOne",
          "val_det_apply",
          "abs_det",
          "simpa",
          "prod_slash",
          "Fintype",
          "Matrix",
          "card_univ",
          "toPerm",
          "using"
        ]
      }
    },
    {
      "id": 3179,
      "before_code": "end Real",
      "suggestion": "\r\n  rw [eq_div_iff (Nat.cast_ne_zero.mpr (by positivity)), mul_comm, iterate_derivative_T_eval_one]\r\n",
      "body": "```suggestion\r\n  rw [eq_div_iff (Nat.cast_ne_zero.mpr (by positivity)), mul_comm, iterate_derivative_T_eval_one]\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "rw"
        ],
        "body_tactics": [
          "positivity",
          "rw"
        ],
        "new_tactics": [
          "positivity",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Real",
          "end"
        ]
      }
    },
    {
      "id": 3180,
      "before_code": "end Real",
      "suggestion": "\r\n  rw [eq_div_iff (Nat.cast_ne_zero.mpr (by positivity)), mul_comm, iterate_derivative_U_eval_one]\r\n",
      "body": "```suggestion\r\n  rw [eq_div_iff (Nat.cast_ne_zero.mpr (by positivity)), mul_comm, iterate_derivative_U_eval_one]\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "rw"
        ],
        "body_tactics": [
          "positivity",
          "rw"
        ],
        "new_tactics": [
          "positivity",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Real",
          "end"
        ]
      }
    },
    {
      "id": 3190,
      "before_code": "@[simp] theorem logCounting_const_zero {e : WithTop E} :\n    logCounting (0 : \ud835\udd5c \u2192 E) e = 0 := logCounting_const",
      "suggestion": "\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n",
      "body": "```suggestion\r\n  all_goals simpa [h] using locallyFinsuppWithin.logCounting_mono (by positivity))\r\n```",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CountingFunction.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "positivity"
        ],
        "body_tactics": [
          "simpa",
          "positivity"
        ],
        "new_tactics": [
          "simpa",
          "positivity"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "logCounting",
          "WithTop",
          "theorem",
          "logCounting_const_zero",
          "logCounting_const",
          "simp"
        ]
      }
    },
    {
      "id": 3192,
      "before_code": "theorem Ici_top [PartialOrder \u03b1] [OrderTop \u03b1] : Ici (\u22a4 : \u03b1) = {\u22a4} :=\n  isMax_top.Ici_eq",
      "suggestion": "\r\n  Set.ext fun _ => lt_top_iff_ne_top\r\n",
      "body": "```suggestion\r\n  Set.ext fun _ => lt_top_iff_ne_top\r\n```\r\n`grind` feels like overkill here.",
      "path": "Mathlib/Order/Interval/Set/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "grind",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "theorem",
          "Ici_top",
          "OrderTop",
          "PartialOrder",
          "isMax_top",
          "Ici",
          "Ici_eq"
        ]
      }
    },
    {
      "id": 3193,
      "before_code": "isLocalizedModule_iff_isLocalization.mp inferInstance\n  inferInstance",
      "suggestion": "\r\n  rw [show s \u2297\u209c[R] 1 = algebraMap S (S \u2297[R] A) s by rfl,\r\n    show (algebraMap A (S \u2297[R] A)) a = 1 \u2297\u209c[R] a by rfl,\r\n    algebraMap_smul, \u2190 Derivation.map_smul, smul_tmul', smul_eq_mul, mul_one]\r\n",
      "body": "```suggestion\r\n  rw [show s \u2297\u209c[R] 1 = algebraMap S (S \u2297[R] A) s by rfl,\r\n    show (algebraMap A (S \u2297[R] A)) a = 1 \u2297\u209c[R] a by rfl,\r\n    algebraMap_smul, \u2190 Derivation.map_smul, smul_tmul', smul_eq_mul, mul_one]\r\n```\r\nI think this is slightly better: this way it\u2019s clear what defeq are being used.",
      "path": "Mathlib/RingTheory/Kaehler/TensorProduct.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "isLocalizedModule_iff_isLocalization",
          "inferInstance"
        ]
      }
    },
    {
      "id": 3194,
      "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
      "suggestion": "\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n",
      "body": "Untested, but something like this should work?\r\n```suggestion\r\n  refine Field.ofIsUnitOrEqZero fun \u27e8a, ha\u27e9 \u21a6 ?_\r\n  rw [Classical.or_iff_not_imp_right, isUnit_iff_exists_inv']\r\n  use \u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9\r\n  aesop\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "body_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "new_tactics": [
          "aesop",
          "rw",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "_ha",
          "mem_top",
          "le_top",
          "theorem"
        ]
      }
    },
    {
      "id": 3195,
      "before_code": "theorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _",
      "suggestion": "\r\n  refine fun h \u21a6 \u27e8\u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9, ?_\u27e9\r\n",
      "body": "You could merge these two lines as well (though you might argue the original is cleaner)\r\n```suggestion\r\n  refine fun h \u21a6 \u27e8\u27e8a\u207b\u00b9, ValuationSubring.mem_top _\u27e9, ?_\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "_ha",
          "mem_top",
          "le_top",
          "theorem"
        ]
      }
    },
    {
      "id": 3198,
      "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
      "suggestion": "\r\n  simp only [Submodule.ext_iff, mem_map, mem_orthogonal, forall_exists_index, and_imp,\r\n    forall_apply_eq_imp_iff\u2082, LinearIsometryEquiv.inner_map_eq_flip]\r\n  exact fun x \u21a6 \u27e8fun \u27e8y, hy\u27e9 z hz \u21a6 by simp [\u2190 hy.2, hy.1 _ hz], fun h \u21a6 \u27e8_, h, by simp\u27e9\u27e9\r\n",
      "body": "```suggestion\r\n  simp only [Submodule.ext_iff, mem_map, mem_orthogonal, forall_exists_index, and_imp,\r\n    forall_apply_eq_imp_iff\u2082, LinearIsometryEquiv.inner_map_eq_flip]\r\n  exact fun x \u21a6 \u27e8fun \u27e8y, hy\u27e9 z hz \u21a6 by simp [\u2190 hy.2, hy.1 _ hz], fun h \u21a6 \u27e8_, h, by simp\u27e9\u27e9\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "CompleteSpace",
          "instOrthogonalCompleteSpace",
          "isClosed_orthogonal",
          "instance",
          "completeSpace_coe"
        ]
      }
    },
    {
      "id": 3199,
      "before_code": "instance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace K\u15ee :=\n  K.isClosed_orthogonal.completeSpace_coe",
      "suggestion": "\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n",
      "body": "(I don't know if this is recommended, but you _can_ technically do this in one line:\r\n```suggestion\r\n  aesop (add safe (by simp only [Submodule.ext_iff, mem_orthogonal, f.inner_map_eq_flip]))\r\n```\r\n)\r\nProbably over-golfed though... so less of a suggestion, and more of an observation I guess",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "cleanup_simp",
          "use_aesop"
        ],
        "keywords": [
          "CompleteSpace",
          "instOrthogonalCompleteSpace",
          "isClosed_orthogonal",
          "instance",
          "completeSpace_coe"
        ]
      }
    },
    {
      "id": 3201,
      "before_code": "convert ((open_iff i subset_rfl).mp open_V).inter open_W using 1\n    refine Set.ext fun e \u21a6 and_right_comm.trans (and_congr_right fun \u27e8hV, hU\u27e9 \u21a6 ?_)\n    rw [Set.mem_preimage, dif_pos hV, inj i (inv_U i _) hU (f_inv i _)]",
      "suggestion": "\r\n  /- for each preimage e of x, choose a homeomorphism \u03c6\u2091\r\n    from a neighborhood of e to its image -/\r\n  choose \u03c6 h\u03c6 using fun e : f \u207b\u00b9' {x} \u21a6 h e e.2\r\n  -- separately, choose pairwise disjoint neighborhoods V\u2091 by Hausdorff-ness\r\n  have \u27e8V, hV, disj\u27e9 := fin.t2_separation\r\n  -- let V\u2091' be the intersection V\u2091 \u2229 dom(\u03c6\u2091)\r\n  let V' (e : f \u207b\u00b9' {x}) := V e \u2229 (\u03c6 e).source\r\n  have hV' e : IsOpen (V' e) := (hV e).2.inter (\u03c6 e).open_source\r\n  have : \u22c3 e, V' e \u2208 nhdsSet (f \u207b\u00b9' {x}) :=\r\n    (isOpen_iUnion hV').mem_nhdsSet.2 fun e he \u21a6 mem_iUnion_of_mem \u27e8e, he\u27e9 \u27e8(hV e).1, (h\u03c6 _).1\u27e9\r\n  -- since f is a closed map, the union of the V\u2091' contains the preimage of a neighborhood U \u220b x\r\n  have \u27e8W, hWx, hWV\u27e9 := isClosedMap_iff_comap_nhds_le.mp hf this\r\n  cases isEmpty_or_nonempty (f \u207b\u00b9' {x})\r\n  \u00b7 exact .of_preimage_eq_empty _ hWx (by simpa using hWV)\r\n  have \u27e8U, hUW, hU, hxU\u27e9 := mem_nhds_iff.mp hWx\r\n  -- show that the intersection of U with the images of V\u2091' is evenly covered\r\n  let U' := U \u2229 \u22c2 e : f \u207b\u00b9' ",
      "body": "```suggestion\r\n  /- for each preimage e of x, choose a homeomorphism \u03c6\u2091\r\n    from a neighborhood of e to its image -/\r\n  choose \u03c6 h\u03c6 using fun e : f \u207b\u00b9' {x} \u21a6 h e e.2\r\n  -- separately, choose pairwise disjoint neighborhoods V\u2091 by Hausdorff-ness\r\n  have \u27e8V, hV, disj\u27e9 := fin.t2_separation\r\n  -- let V\u2091' be the intersection V\u2091 \u2229 dom(\u03c6\u2091)\r\n  let V' (e : f \u207b\u00b9' {x}) := V e \u2229 (\u03c6 e).source\r\n  have hV' e : IsOpen (V' e) := (hV e).2.inter (\u03c6 e).open_source\r\n  have : \u22c3 e, V' e \u2208 nhdsSet (f \u207b\u00b9' {x}) :=\r\n    (",
      "path": "Mathlib/Topology/Covering/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "suggestion_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "cases",
          "exact",
          "have"
        ],
        "removed_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "and_right_comm",
          "refine",
          "ext",
          "convert",
          "f_inv",
          "open_iff",
          "dif_pos",
          "inter",
          "and_congr_right",
          "subset_rfl",
          "open_W",
          "inv_U",
          "Set",
          "trans",
          "mem_preimage",
          "using",
          "open_V",
          "inj"
        ]
      }
    },
    {
      "id": 3203,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    exact (one_ne_zero heq).elim\r\n",
      "body": "Here's a slight golf.\r\n```suggestion\r\n  have : Fact (1 < n) := \u27e8by grind\u27e9\r\n  ext x\r\n  simp only [Subgroup.mem_center_iff, Subgroup.mem_bot]\r\n  refine \u27e8fun hx \u21a6 ?_, fun hx \u21a6 by simp [hx]\u27e9\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr 0))\r\n    rw [zero_add, zero_sub, eq_neg_iff_add_eq_zero, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n    rw [heq, r_zero]\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    rw [sub_eq_iff_eq_add, add_assoc, left_eq_add, ZMod.add_self_eq_zero_iff_eq_zero hodd] at he",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "cases",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 3204,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n",
      "body": "```suggestion\r\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun x hx => ?_\r\n  rw [Subgroup.mem_center_iff] at hx\r\n  rcases x with i | i\r\n  \u00b7 have heq := sr.inj (hx (sr i))\r\n    simp_all\r\n  \u00b7 have heq := sr.inj (hx (r 1))\r\n    have : Fact (1 < n) := \u27e8by grind\u27e9\r\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\r\n```\r\nThis is slightly shorter.",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "grind",
          "cases",
          "have",
          "simp_all",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 3205,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n",
      "body": "```suggestion\n  simp only [Subgroup.eq_bot_iff_forall, Subgroup.mem_center_iff]\n  rintro (i | i) h\n  \u00b7 have heq := sr.inj (h (sr i))\n    simp_all\n  \u00b7 have heq := sr.inj (h (r 1))\n    have : Fact (1 < n) := \u27e8by grind\u27e9\n    simp [sub_eq_iff_eq_add, add_assoc, ZMod.add_self_eq_zero_iff_eq_zero hodd] at heq\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "grind",
          "simp_all",
          "have",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp_all",
          "have",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "have",
          "simp",
          "simp_all"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 3210,
      "before_code": "theorem formula_mem_typeOf {\u03c6 : L.Formula \u03b1} :\n    Formula.equivSentence \u03c6 \u2208 T.typeOf v \u2194 \u03c6.Realize v := by simp",
      "suggestion": "lemma typesWith_mem {\u03c6} (h\u03c6 : \u03c6 \u2208 (L.lhomWithConstants \u03b1).onTheory T) :\n    typesWith (T := T) \u03c6 = Set.univ :=\n  univ_subset_iff.mp fun p _ \u21a6 p.subset h\u03c6\n",
      "body": "```suggestion\nlemma typesWith_mem {\u03c6} (h\u03c6 : \u03c6 \u2208 (L.lhomWithConstants \u03b1).onTheory T) :\n    typesWith (T := T) \u03c6 = Set.univ :=\n  univ_subset_iff.mp fun p _ \u21a6 p.subset h\u03c6\n```\nbut there's no `mem` in sight, so probably something more like `typesWith_eq_univ_of_mem_onTheory_lhomWithConstants`?",
      "path": "Mathlib/ModelTheory/Types.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Formula",
          "typeOf",
          "Realize",
          "equivSentence",
          "simp",
          "formula_mem_typeOf"
        ]
      }
    },
    {
      "id": 3219,
      "before_code": "ContinuousLinearMap.fst \ud835\udd5c E E + ContinuousLinearMap.snd \ud835\udd5c E E |>.isBigOTVS_comp\n    |>.trans <| h\u2081.prodMk h\u2082",
      "suggestion": "\r\n\r\ntheorem isLittleOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isLittleOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =o[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =o[\ud835\udd5c; l] g :=\r\n  isLittleOTVS_comm\r\n\r\n@[to_fun]\r\nprotected theorem IsBigOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n\r\ntheorem isBigOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isBigOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =O[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =O[\ud835\udd5c; l] g :=\r\n  isBigOTVS_comm\r\n\r\n",
      "body": "Why no also add the following?\r\n```suggestion\r\n\r\ntheorem isLittleOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (f\u2081 - f\u2082) =o[\ud835\udd5c; l] g \u2194 (f\u2082 - f\u2081) =o[\ud835\udd5c; l] g :=\r\n  \u27e8.symm, .symm\u27e9\r\n\r\ntheorem isLittleOTVS_fun_comm {f\u2081 f\u2082 : \u03b1 \u2192 E} :\r\n    (fun a \u21a6 f\u2081 a - f\u2082 a) =o[\ud835\udd5c; l] g \u2194 (fun a \u21a6 f\u2082 a - f\u2081 a) =o[\ud835\udd5c; l] g :=\r\n  isLittleOTVS_comm\r\n\r\n@[to_fun]\r\nprotected theorem IsBigOTVS.symm {f\u2081 f\u2082 : \u03b1 \u2192 E} (h : (f\u2081 - f\u2082) =O[\ud835\udd5c; l] g) :\r\n    (f\u2082 - f\u2081) =O[\ud835\udd5c; l] g := by\r\n  simpa using h.neg_left\r\n\r\ntheorem isBigOTVS_comm {f\u2081 f\u2082 : \u03b1 \u2192 ",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigOTVS_comp",
          "ContinuousLinearMap",
          "fst",
          "trans",
          "prodMk",
          "snd"
        ]
      }
    },
    {
      "id": 3222,
      "before_code": "example (ha : a \u2260 0) (hb : b \u2260 0) : 0 < a * b := by positivity\nexample (ha : a \u2260 0) : 0 \u2264 a * b := by positivity",
      "suggestion": "\r\nexample {x y : \u211d\u22650\u221e} : x + y + 1 \u2260 0 := by positivity\r\nexample {x y : \u211d\u22650\u221e} (hx : x \u2260 0) : x + y + 1 \u2260 0 := by positivity\r\n",
      "body": "```suggestion\r\nexample {x y : \u211d\u22650\u221e} : x + y + 1 \u2260 0 := by positivity\r\nexample {x y : \u211d\u22650\u221e} (hx : x \u2260 0) : x + y + 1 \u2260 0 := by positivity\r\n```",
      "path": "MathlibTest/positivity.lean",
      "tags": {
        "before_tactics": [
          "positivity"
        ],
        "suggestion_tactics": [
          "positivity"
        ],
        "body_tactics": [
          "positivity"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "example",
          "positivity"
        ]
      }
    },
    {
      "id": 3223,
      "before_code": "- `Polynomial.card_mahlerMeasure_le_prod`: an upper bound on the number of integer polynomials\n  of degree at most `n` and Mahler measure at most `B`.\n- `Polynomial.cyclotomic_mahlerMeasure_eq_one`: the Mahler measure of a cyclotomic polynomial is 1.",
      "suggestion": "  Mahler measure equal to 1 and is not a multiple of X, then it is divisible by a cyclotomic polynomial.\n",
      "body": "The documentation states that the polynomial \"is a multiple of X\", but the theorem parameter `hX : \u00ac X \u2223 p` actually requires that the polynomial is NOT a multiple of X. The documentation should say \"is not a multiple of X\" to match the actual theorem signature.\n```suggestion\n  Mahler measure equal to 1 and is not a multiple of X, then it is divisible by a cyclotomic polynomial.\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "most",
          "polynomial",
          "polynomials",
          "cyclotomic_mahlerMeasure_eq_one",
          "bound",
          "number",
          "integer",
          "card_mahlerMeasure_le_prod",
          "cyclotomic",
          "measure",
          "upper",
          "Polynomial",
          "Mahler",
          "degree"
        ]
      }
    },
    {
      "id": 3224,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "primitive roots of unity (for some positive integer order `n`). -/\n",
      "body": "The documentation comment is identical to the one for `pow_eq_one_of_mahlerMeasure_eq_one`, but this theorem provides a stronger result by showing that the roots are primitive roots of unity for some order n, not just roots of unity. The documentation should clarify this distinction, for example: \"If an integer polynomial has Mahler measure equal to 1, then all its complex nonzero roots are primitive roots of unity.\"\n```suggestion\nprimitive roots of unity (for some positive integer order `n`). -",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3225,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "        mem_le_prod_of_one_le _ (fun a \u21a6 le_max_left 1 \u2016a\u2016) _ z hz\n",
      "body": "```suggestion\n        mem_le_prod_of_one_le _ (fun a \u21a6 le_max_left 1 \u2016a\u2016) _ z hz\n```\n(this is where you'll have some simplification from making the arguments implicit)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3226,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "/- We want to use `NumberField.Embeddings.pow_eq_one_of_norm_le_one` but it can only be applied to\nelements of number fields. We thus first construct the number field `K` obtained by adjoining `z`\nto `\u211a`.\n-/\n",
      "body": "```suggestion\n/- We want to use `NumberField.Embeddings.pow_eq_one_of_norm_le_one` but it can only be applied to\nelements of number fields. We thus first construct the number field `K` obtained by adjoining `z`\nto `\u211a`.\n-/\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3227,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  suffices \u2203 (n : \u2115) (_ : 0 < n), y ^ n = 1 by\n    obtain \u27e8n, hn\u2080, hn\u2081\u27e9 := this\n    exact \u27e8n, hn\u2080, congrArg (algebraMap K \u2102) hn\u2081\u27e9\n  refine NumberField.Embeddings.pow_eq_one_of_norm_le_one (x := y) K \u2102 (Subtype.coe_ne_coe.mp hz\u2080)\n    (coe_isIntegral_iff.mp <| isIntegral_of_mahlerMeasure_eq_one h hz)\n    fun \u03c6 \u21a6 norm_root_le_one_of_mahlerMeasure_eq_one h ?_\n  -- the conjugates of `y` are inside the closed unit disk\n",
      "body": "```suggestion\n  suffices \u2203 (n : \u2115) (_ : 0 < n), y ^ n = 1 by\n    obtain \u27e8n, hn\u2080, hn\u2081\u27e9 := this\n    exact \u27e8n, hn\u2080, congrArg (algebraMap K \u2102) hn\u2081\u27e9\n  refine NumberField.Embeddings.pow_eq_one_of_norm_le_one (x := y) K \u2102 (Subtype.coe_ne_coe.mp hz\u2080)\n    (coe_isIntegral_iff.mp <| isIntegral_of_mahlerMeasure_eq_one h hz)\n    fun \u03c6 \u21a6 norm_root_le_one_of_mahlerMeasure_eq_one h ?_\n  -- the conjugates of `y` are inside the closed unit disk\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "refine"
        ],
        "new_tactics": [
          "obtain",
          "refine"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3228,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  rw [mem_aroots] at hz \u22a2\n  refine \u27e8hz.1, ?_\u27e9\n  have H (\u03c8 : K \u2192+* \u2102) : \u03c8 ((aeval y) p) = (aeval (\u03c8 y)) p := by\n    conv_rhs => rw [\u2190 map_id (p := p)]\n    exact p.map_aeval_eq_aeval_map (by ext; simp) y\n  rw [\u2190 H, map_eq_zero_iff _ \u03c6.injective,\n    \u2190 map_eq_zero_iff _ (FaithfulSMul.algebraMap_injective \u21a5K \u2102), H]\n  exact hz.2\n",
      "body": "```suggestion\n  rw [mem_aroots] at hz \u22a2\n  refine \u27e8hz.1, ?_\u27e9\n  have H (\u03c8 : K \u2192+* \u2102) : \u03c8 ((aeval y) p) = (aeval (\u03c8 y)) p := by\n    conv_rhs => rw [\u2190 map_id (p := p)]\n    exact p.map_aeval_eq_aeval_map (by ext; simp) y\n  rw [\u2190 H, map_eq_zero_iff _ \u03c6.injective,\n    \u2190 map_eq_zero_iff _ (FaithfulSMul.algebraMap_injective \u21a5K \u2102), H]\n  exact hz.2\n```\n* The `convert`s resulting in an `Iff` are a bit ugly.\n* The way I have arranged it is closer to the usual Mathlib style (arguing \"backwards\").\n* Also, one ",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "ext",
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3229,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "/-- If an integer non-constant polynomial has Mahler measure equal to 1 and is not a multiple\nof `X`, then it is divisible by a cyclotomic polynomial. -/\n",
      "body": "```suggestion\n/-- If an integer non-constant polynomial has Mahler measure equal to 1 and is not a multiple\nof `X`, then it is divisible by a cyclotomic polynomial. -/\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 3230,
      "before_code": "have := Algebra.FormallyEtale.of_isLocalization (R\u2098 := T) M\n  (isLocalizedModule_iff_isBaseChange M T _).mpr (isBaseChange_of_formallyEtale R S T)",
      "suggestion": "\r\n    Submodule.span T (Set.range fun s \u21a6 map R R S T (D R S s)) = \u22a4 := by\r\n",
      "body": "```suggestion\r\n    Submodule.span T (Set.range fun s \u21a6 map R R S T (D R S s)) = \u22a4 := by\r\n```\r\nOr even `map R R S T \u2218 D R S` if you feel like it.",
      "path": "Mathlib/RingTheory/Etale/Kaehler.lean",
      "tags": {
        "before_tactics": [
          "have"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "have"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "FormallyEtale",
          "have",
          "Algebra",
          "isLocalizedModule_iff_isBaseChange",
          "isBaseChange_of_formallyEtale",
          "of_isLocalization"
        ]
      }
    },
    {
      "id": 3231,
      "before_code": "rintro rfl\n      exact \u27e81, rfl\u27e9 }",
      "suggestion": "\r\n  have : Away (algebraMap R S z) T := by rwa [iff_of_associated h]\r\n",
      "body": "```suggestion\r\n  have : Away (algebraMap R S z) T := by rwa [iff_of_associated h]\r\n```",
      "path": "Mathlib/RingTheory/Localization/Away/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "exact",
          "rintro"
        ]
      }
    },
    {
      "id": 3232,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis is by infer instance.",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 3233,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n    Finsupp.linearCombination _ fun i \u21a6 D R S (a i)\r\n",
      "body": "```suggestion\r\n    Finsupp.linearCombination _ fun i \u21a6 D R S (a i)\r\n```\r\nI think this is clearer.",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 3234,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis is by infer instance (since `Localization.Away g` is already `R`-formally smooth).",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 3235,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis is by infer instance.",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 3236,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  exact \u27e8algebraMap S _ (a i), by simp +zetaDelta [IsLocalizedModule.map_linearCombination]\u27e9\r\n",
      "body": "```suggestion\r\n  exact \u27e8algebraMap S _ (a i), by simp +zetaDelta [IsLocalizedModule.map_linearCombination]\u27e9\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 3241,
      "before_code": "finsum (fun d \u21a6 coeff d f \u2022 (constantCoeff (d.prod fun s e => (a s) ^ e))) := by\n  simp only [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_subst ha f 0]",
      "suggestion": "\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n",
      "body": "```suggestion\r\n      simpa [map_finsuppProd, ha] using\r\n        Finset.prod_eq_zero (i := i) (by simpa) (by simp [zero_pow hi])\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Substitution.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "coeff",
          "prod",
          "coeff_zero_eq_constantCoeff_apply",
          "coeff_subst",
          "simp",
          "finsum",
          "constantCoeff",
          "only"
        ]
      }
    },
    {
      "id": 3243,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n",
      "body": "```suggestion\n    x - y \u2208 K\u15ee :=\n  Submodule.sub_mem_orthogonal_of_inner_right h\n```\nMost of the time, `by exact` is useless.",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 3245,
      "before_code": "def homMk {X Y : P.FullSubcategory} (f : X.obj \u27f6 Y.obj) : X \u27f6 Y where\n  hom := f",
      "suggestion": "lemma homMk_surjective {X Y : P.FullSubcategory} :\n    Function.Surjective (homMk : (X.obj \u27f6 Y.obj) \u2192 _) :=\n  fun f \u21a6 \u27e8f.hom, rfl\u27e9\n",
      "body": "```suggestion\nlemma homMk_surjective {X Y : P.FullSubcategory} :\n    Function.Surjective (homMk : (X.obj \u27f6 Y.obj) \u2192 _) :=\n  fun f \u21a6 \u27e8f.hom, rfl\u27e9\n```\nThis is def-eq, but probably slightly more useful?",
      "path": "Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hom",
          "def",
          "FullSubcategory",
          "homMk",
          "obj"
        ]
      }
    },
    {
      "id": 3246,
      "before_code": "variable {\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} [Preorder \u03b9] {f : Filtration \u03b9 m}",
      "suggestion": "protected theorem measurable {i : \u03b9} (hf : Adapted f u) : Measurable[m] (u i) :=\n  (hf i).mono (f.le i) (by rfl)\n\ntheorem measurable_le {i j : \u03b9} (hf : Adapted f u) (hij : i \u2264 j) : Measurable[f j] (u i) :=\n  (hf i).mono (f.mono hij) (by rfl)\n",
      "body": "```suggestion\nprotected theorem measurable {i : \u03b9} (hf : Adapted f u) : Measurable[m] (u i) :=\n  (hf i).mono (f.le i) (by rfl)\n\ntheorem measurable_le {i j : \u03b9} (hf : Adapted f u) (hij : i \u2264 j) : Measurable[f j] (u i) :=\n  (hf i).mono (f.mono hij) (by rfl)\n```",
      "path": "Mathlib/Probability/Process/Adapted.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "variable",
          "Filtration",
          "Type",
          "Preorder",
          "MeasurableSpace"
        ]
      }
    },
    {
      "id": 3249,
      "before_code": "F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]",
      "suggestion": "\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n",
      "body": "```suggestion\r\n      isoAdd' (show a + bc = abc by grind) ea (isoAdd' hbc eb ec) := by\r\n```\r\nvery minor, but this way you don\u2019t have to guess what the `rwa` is proving from the source.",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isoAdd",
          "inv",
          "shiftFunctorAdd",
          "app",
          "_eq_shiftFunctorAdd",
          "map",
          "simp",
          "_inv_app",
          "only"
        ]
      }
    },
    {
      "id": 3259,
      "before_code": "let tail := middle.drop ctx |>.takeWhile (!\u00b7.isWhitespace)\n  s!\"{headCtx}{middle.take ctx}{tail}\"\n\n@[inherit_doc Mathlib.Linter.linter.style.commandStart]\ndef commandStartLinter : Linter where run := withSetOptionIn fun stx \u21a6 do\n  unless Linter.getLinterValue linter.style.commandStart (\u2190 getLinterOptions) do",
      "suggestion": "\r\n  if Linter.getLinterValue linter.style.commandStart (\u2190 getLinterOptions) do\r\n    logWarningAt stx \"`linter.style.commandStart` is deprecated, use `linter.style.whitespace` instead.\"\r\n  unless Linter.getLinterValue linter.style.whitespace (\u2190 getLinterOptions) do\r\n",
      "body": "Should we include a deprecation warning? Because currently `set_option linter.commandStart true` does nothing. Something like:\r\n\r\n```suggestion\r\n  if Linter.getLinterValue linter.style.commandStart (\u2190 getLinterOptions) do\r\n    logWarningAt stx \"`linter.style.commandStart` is deprecated, use `linter.style.whitespace` instead.\"\r\n  unless Linter.getLinterValue linter.style.whitespace (\u2190 getLinterOptions) do\r\n```",
      "path": "Mathlib/Tactic/Linter/Whitespace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "run",
          "getLinterOptions",
          "withSetOptionIn",
          "style",
          "take",
          "Mathlib",
          "linter",
          "stx",
          "ctx",
          "Linter",
          "takeWhile",
          "commandStart",
          "def",
          "isWhitespace",
          "inherit_doc",
          "drop",
          "commandStartLinter",
          "unless",
          "middle",
          "getLinterValue",
          "tail",
          "headCtx"
        ]
      }
    },
    {
      "id": 3260,
      "before_code": "namespace Mathlib.Linter",
      "suggestion": "\r\n@[deprecated linter.style.whitespace (since := \"2026-01-07\")]\r\npublic register_option linter.style.commandStart : Bool := {\r\n",
      "body": "```suggestion\r\n@[deprecated linter.style.whitespace (since := \"2026-01-07\")]\r\npublic register_option linter.style.commandStart : Bool := {\r\n```\r\nhow about this?  It should go after the `whitespace` option is defined, though.",
      "path": "Mathlib/Tactic/Linter/Whitespace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "Linter",
          "Mathlib",
          "namespace"
        ]
      }
    },
    {
      "id": 3261,
      "before_code": "these instances non-computably.\n-/\n\nset_option linter.style.whitespace false",
      "suggestion": "\r\nset_option linter.style.whitespace false -- manual alignment is not recognised\r\n",
      "body": "```suggestion\r\nset_option linter.style.whitespace false -- manual alignment is not recognised\r\n```\r\nshould this be not `in`?  If so, it should not pass CI anyway.",
      "path": "Mathlib/Algebra/Ring/Int/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "whitespace",
          "linter",
          "these",
          "instances",
          "computably",
          "non",
          "false",
          "style",
          "set_option"
        ]
      }
    },
    {
      "id": 3263,
      "before_code": "these instances non-computably.\n-/\n\nset_option linter.style.whitespace false",
      "suggestion": "\r\nset_option linter.style.whitespace false -- manual alignment is not recognised\r\n",
      "body": "```suggestion\r\nset_option linter.style.whitespace false -- manual alignment is not recognised\r\n```",
      "path": "Mathlib/Algebra/Group/Int/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "whitespace",
          "linter",
          "these",
          "instances",
          "computably",
          "non",
          "false",
          "style",
          "set_option"
        ]
      }
    },
    {
      "id": 3264,
      "before_code": "These also prevent non-computable instances being used to construct these instances non-computably.\n-/\n\nset_option linter.style.whitespace false",
      "suggestion": "\r\nset_option linter.style.whitespace false -- manual alignment is not recognised\r\n",
      "body": "```suggestion\r\nset_option linter.style.whitespace false -- manual alignment is not recognised\r\n```",
      "path": "Mathlib/Algebra/Group/Nat/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "These",
          "used",
          "being",
          "prevent",
          "these",
          "linter",
          "computable",
          "instances",
          "whitespace",
          "computably",
          "also",
          "non",
          "false",
          "construct",
          "style",
          "set_option"
        ]
      }
    },
    {
      "id": 3265,
      "before_code": "/-- Pushforward and pullback of ideal sheaves forms a Galois connection. -/\nlemma map_gc : GaloisConnection (comap \u00b7 f) (map \u00b7 f) := fun _ _ \u21a6 le_map_iff_comap_le.symm\n\nset_option linter.style.whitespace false",
      "suggestion": "\r\nset_option linter.style.whitespace false -- manual alignment is not recognised\r\n",
      "body": "```suggestion\r\nset_option linter.style.whitespace false -- manual alignment is not recognised\r\n```",
      "path": "Mathlib/AlgebraicGeometry/IdealSheaf/Functorial.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "Galois",
          "whitespace",
          "connection",
          "style",
          "symm",
          "map_gc",
          "linter",
          "map",
          "ideal",
          "pullback",
          "false",
          "Pushforward",
          "sheaves",
          "GaloisConnection",
          "le_map_iff_comap_le",
          "comap",
          "set_option",
          "forms"
        ]
      }
    },
    {
      "id": 3266,
      "before_code": "/-! ### Exceptional Cartan matrices -/",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nThis should have been flagged by the `emptyLine` linter.",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Cartan",
          "Exceptional",
          "matrices"
        ]
      }
    },
    {
      "id": 3268,
      "before_code": "rw [contMDiffAt_iff_contDiffAt]\n    exact contDiffAt_ringInverse _ _",
      "suggestion": "example {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] [CompleteSpace V] (n : WithTop \u2115\u221e) :\n    LieGroup \ud835\udcd8(\ud835\udd5c, V \u2192L[\ud835\udd5c] V) n (V \u2192L[\ud835\udd5c] V)\u02e3 := inferInstance\n",
      "body": "Again I'm a bit surprised by the literal. Could this be:\n```suggestion\nexample {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] [CompleteSpace V] (n : WithTop \u2115\u221e) :\n    LieGroup \ud835\udcd8(\ud835\udd5c, V \u2192L[\ud835\udd5c] V) n (V \u2192L[\ud835\udd5c] V)\u02e3 := inferInstance\n```",
      "path": "Mathlib/Geometry/Manifold/Instances/UnitsOfNormedAlgebra.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "contMDiffAt_iff_contDiffAt",
          "contDiffAt_ringInverse"
        ]
      }
    },
    {
      "id": 3272,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm\n\ntheorem leadingCoeff_eq_sum\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : s.card = P.degree + 1) :\n    P.leadingCoeff = \u2211 i \u2208 s, (P.eval (v i)) / \u220f j \u2208 s.erase i, ((v i) - (v j)) := by\n  have P_degree : P.degree = \u2191(s.card - 1) := by\n    cases h : P.degree\n    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n  have P_natDegree : P.natDegree = s.card - 1 := natDegree_eq_of_degree_eq_some P_degree\n  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n  rw [leadingCoeff, P_natDegree]\n  rw (occs := [1]) [\u2190 interpolate_poly_eq_self hvs hP']\n  rw [interpolate_apply, finset_sum_coeff]\n  congr! with i hi\n  rw [coeff_C_mul, \u2190 natDegree_basis hvs hi, \u2190 leadingCoeff, leadingCoeff_basis hvs hi]\n  field_simp",
      "suggestion": "\r\n  lift P.degree to \u2115 using (by contrapose! hP; simp [hP]) with deg hdeg\r\n",
      "body": "```suggestion\r\n  lift P.degree to \u2115 using (by contrapose! hP; simp [hP]) with deg hdeg\r\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "field_simp",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp",
          "congr"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "field_simp",
          "exact",
          "grind",
          "cases",
          "have",
          "rw",
          "simp_all",
          "congr"
        ],
        "topics": [
          "nat",
          "set_theory",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "leadingCoeff_basis",
          "interpolate_apply",
          "eval",
          "leadingCoeff_eq_sum",
          "simp_all",
          "Polynomial",
          "open",
          "natDegree_eq_of_degree_eq_some",
          "symm",
          "occs",
          "coe_inj",
          "scoped",
          "cases",
          "Nat",
          "grind",
          "have",
          "eq_interpolate",
          "case",
          "interpolate",
          "cast_withBot",
          "by_contra",
          "insert_subset_iff",
          "InjOn",
          "finset_sum_coeff",
          "erase",
          "sdiff_singleton_eq_erase",
          "WithBot",
          "bot",
          "hvs",
          "simp",
          "leadingCoeff",
          "P_natDegree",
          "congr",
          "natDegree_basis",
          "degree",
          "card",
          "s_card",
          "Classical",
          "natDegree",
          "field_simp",
          "interpolate_poly_eq_self",
          "theorem",
          "exact",
          "cast_lt",
          "Set",
          "suffices",
          "coeff_C_mul",
          "coe",
          "P_degree"
        ]
      }
    },
    {
      "id": 3274,
      "before_code": "also unify with `Nat.ModEq`.\n-/\n\n@[expose] public section\n\nassert_not_exists Module\n\nnamespace AddCommGroup\n\nvariable {\u03b1 : Type*}\n\nsection AddCommGroup\n\nvariable [AddCommGroup \u03b1] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1} {n : \u2115} {z : \u2124}\n\n/-- `a \u2261 b [PMOD p]` means that `b` is congruent to `a` modulo `p`.\n\nEquivalently (as shown in `Algebra.Order.ToIntervalMod`), `b` does not lie in the open interval\n`(a, a + p)` modulo `p`, or `toIcoMod hp a` disagrees with `toIocMod hp a` at `b`, or\n`toIcoDiv hp a` disagrees with `toIocDiv hp a` at `b`. -/\ndef ModEq (p a b : \u03b1) : Prop :=\n  \u2203 z : \u2124, b - a = z \u2022 p",
      "suggestion": "\r\ninductive ModEq (p a b : M) : Prop where\r\n  | of_nsmul (m n : \u2115) : m \u2022 p + a = n \u2022 p + b\r\n",
      "body": "If our goal is to make the implementation opaque (by not `expose`ing it), should we instead change to\r\n```suggestion\r\ninductive ModEq (p a b : M) : Prop where\r\n  | of_nsmul (m n : \u2115) : m \u2022 p + a = n \u2022 p + b\r\n```\r\n\r\nI don't think this change needs to be part of this PR, but I'd be curious to explore which pattern is preferred.",
      "path": "Mathlib/Algebra/ModEq.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat",
          "algebra",
          "equiv",
          "set_theory",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "congruent",
          "Module",
          "expose",
          "shown",
          "Type",
          "ModEq",
          "open",
          "section",
          "modulo",
          "toIcoDiv",
          "Nat",
          "does",
          "toIocDiv",
          "Prop",
          "AddCommGroup",
          "toIocMod",
          "also",
          "lie",
          "assert_not_exists",
          "public",
          "variable",
          "Order",
          "def",
          "toIcoMod",
          "that",
          "unify",
          "PMOD",
          "ToIntervalMod",
          "namespace",
          "Equivalently",
          "disagrees",
          "means",
          "interval",
          "Algebra"
        ]
      }
    },
    {
      "id": 3275,
      "before_code": "namespace RCLike",
      "suggestion": "\r\n@[simp] theorem map_apply_real (x : \u211d) : map \u211d K x = x := by simp [im, re]\r\n",
      "body": "```suggestion\r\n@[simp] theorem map_apply_real (x : \u211d) : map \u211d K x = x := by simp [im, re]\r\n```",
      "path": "Mathlib/Analysis/RCLike/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "RCLike",
          "namespace"
        ]
      }
    },
    {
      "id": 3278,
      "before_code": "calc \u27e6p\u2081\u27e7\n      _ = trans (trans \u27e6p\u2081\u27e7 (symm \u27e6p\u2082\u27e7)) \u27e6p\u2082\u27e7 := by simp\n      _ = \u27e6p\u2082\u27e7 := by grind",
      "suggestion": "\r\n      prop' := by simp }\u27e9\r\n",
      "body": "```suggestion\r\n      prop' := by simp }\u27e9\r\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "grind"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "calc",
          "grind",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 3281,
      "before_code": "fun _ h\u2081 _ h\u2082 \u21a6 h\u2082 _ fun _ h\u2083 \u21a6 h\u2081 _ fun _ h\u2084 \u21a6 h_comm _ h\u2084 _ h\u2083\n\n@[to_additive addCentralizer_empty]\ntheorem centralizer_empty : (\u2205 : Set M).centralizer = \u22a4 := by\n  simp only [centralizer, mem_empty_iff_false, IsEmpty.forall_iff, implies_true, setOf_true,\n    top_eq_univ]",
      "suggestion": "\r\n@[simp] theorem centralizer_empty : (\u2205 : Set M).centralizer = \u22a4 := by simp [centralizer]\r\n",
      "body": "yeah sure\r\n```suggestion\r\n@[simp] theorem centralizer_empty : (\u2205 : Set M).centralizer = \u22a4 := by simp [centralizer]\r\n```",
      "path": "Mathlib/Algebra/Group/Center.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "top_eq_univ",
          "theorem",
          "centralizer_empty",
          "setOf_true",
          "IsEmpty",
          "implies_true",
          "Set",
          "centralizer",
          "addCentralizer_empty",
          "forall_iff",
          "simp",
          "mem_empty_iff_false",
          "h_comm",
          "only"
        ]
      }
    },
    {
      "id": 3284,
      "before_code": "lemma Odd.ne_two_of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : m \u2260 2 := by\n  rintro rfl\n  exact absurd (hn.of_dvd_nat hm) (by decide)",
      "suggestion": "lemma Int.le_abs_of_dvd {a b : \u2124} (h\u2081 : b \u2260 0) (h\u2082 : a \u2223 b) : a \u2264 |b| :=\n  le_of_dvd (by simpa) (by simpa)\n",
      "body": "```suggestion\nlemma Int.le_abs_of_dvd {a b : \u2124} (h\u2081 : b \u2260 0) (h\u2082 : a \u2223 b) : a \u2264 |b| :=\n  le_of_dvd (by simpa) (by simpa)\n```",
      "path": "Mathlib/Algebra/Order/Ring/Abs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "decide"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "decide"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "lemma",
          "Odd",
          "exact",
          "rintro",
          "decide",
          "absurd",
          "rfl",
          "of_dvd_nat",
          "ne_two_of_dvd_nat"
        ]
      }
    },
    {
      "id": 3285,
      "before_code": "## Behaviour under Arithmetic Operations\n-/",
      "suggestion": "\r\n  calc proximity (f\u2081 + f\u2082) \u22a4 r + logCounting (f\u2081 + f\u2082) \u22a4 r\r\n    _ \u2264 (proximity f\u2081 \u22a4 r + proximity f\u2082 \u22a4 r + log 2)\r\n",
      "body": "The lines *following* a `calc` should be indented by two spaces:\r\n```suggestion\r\n  calc proximity (f\u2081 + f\u2082) \u22a4 r + logCounting (f\u2081 + f\u2082) \u22a4 r\r\n    _ \u2264 (proximity f\u2081 \u22a4 r + proximity f\u2082 \u22a4 r + log 2)\r\n```\r\n(of course, this applies to the subsequent lines of the `calc` block as well.",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CharacteristicFunction.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Behaviour",
          "Operations",
          "Arithmetic",
          "under"
        ]
      }
    },
    {
      "id": 3287,
      "before_code": "\u00b7 exact \u27e8i, hi, j, hj, h_lt, x, hx\u2081, hx\u2082\u27e9\n  \u00b7 exact \u27e8j, hj, i, hi, h_lt, x, hx\u2082, hx\u2081\u27e9",
      "suggestion": "\r\n    s.PairwiseDisjoint (fun i \u21a6 ({f i} : Finset \u03b1)) \u2194 s.InjOn f := by\r\n",
      "body": "Do we want the\r\n```suggestion\r\n    s.PairwiseDisjoint (fun i \u21a6 ({f i} : Finset \u03b1)) \u2194 s.InjOn f := by\r\n```\r\nversion too?",
      "path": "Mathlib/Data/Set/Pairwise/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "h_lt"
        ]
      }
    },
    {
      "id": 3289,
      "before_code": "instance [Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] : IsSemireal R where\n  one_add_ne_zero hs amo := zero_ne_one' R (le_antisymm zero_le_one\n                              (le_of_le_of_eq (le_add_of_nonneg_right hs.nonneg) amo))",
      "suggestion": "\r\n      rw [add_comm] at hn\r\n      push_cast at hn\r\n      simpa using IsSemireal.one_add_ne_zero (by simp) hn\r\n",
      "body": "```suggestion\r\n      rw [add_comm] at hn\r\n      push_cast at hn\r\n      simpa using IsSemireal.one_add_ne_zero (by simp) hn\r\n```",
      "path": "Mathlib/Algebra/Ring/Semireal/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "body_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "simp",
          "push_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "ExistsAddOfLE",
          "le_antisymm",
          "zero_ne_one",
          "Semiring",
          "amo",
          "le_of_le_of_eq",
          "one_add_ne_zero",
          "LinearOrder",
          "IsSemireal",
          "instance",
          "le_add_of_nonneg_right",
          "IsStrictOrderedRing",
          "zero_le_one",
          "nonneg"
        ]
      }
    },
    {
      "id": 3291,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\n/-- The support of a graph is empty if there at most one vertex. -/\r\n@[simp]\r\ntheorem support_of_subsingleton [Subsingleton V] (G : SimpleGraph V) : G.support = \u2205 :=\r\n  Set.eq_empty_of_forall_notMem fun v \u27e8w, h\u27e9 => G.irrefl <| Subsingleton.elim v w \u25b8 h\r\n",
      "body": "```suggestion\r\n/-- The support of a graph is empty if there at most one vertex. -/\r\n@[simp]\r\ntheorem support_of_subsingleton [Subsingleton V] (G : SimpleGraph V) : G.support = \u2205 :=\r\n  Set.eq_empty_of_forall_notMem fun v \u27e8w, h\u27e9 => G.irrefl <| Subsingleton.elim v w \u25b8 h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3292,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\n  Set.eq_empty_of_forall_notMem fun _ \u27e8_, h\u27e9 => h\r\n",
      "body": "Or even shorter:\r\n```suggestion\r\n  Set.eq_empty_of_forall_notMem fun _ \u27e8_, h\u27e9 => h\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3293,
      "before_code": "theorem support_mono {G G' : SimpleGraph V} (h : G \u2264 G') : G.support \u2286 G'.support :=\n  SetRel.dom_mono fun _uv huv \u21a6 h huv",
      "suggestion": "\r\n  \u27e8fun h \u21a6 eq_bot_iff_forall_not_adj.mpr fun v w nadj \u21a6\r\n",
      "body": "```suggestion\r\n  \u27e8fun h \u21a6 eq_bot_iff_forall_not_adj.mpr fun v w nadj \u21a6\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "SetRel",
          "support",
          "_uv",
          "theorem",
          "dom_mono",
          "huv",
          "support_mono",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3297,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "/--\nDetermines if the pretty-printed version of the given name would parse as an `ident` with an underlying name (via `getId`) equal to the original name. The pretty-printer usually escapes unparseable components of a name with `\u00ab\u00bb`, but makes exceptions for various names with special meaning, meaning that the result does not round trip. We therefore re-check those conditions here.\n\nThis function is intended to be \"safe\" in that it if it returns `true`, the name will definitely round trip. Any deviation from this behavior is a bug which should be fixed.\n-/\n-- See also [Zulip](https://leanprover.zulipchat.com/#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Check.20if.20a.20.60Lean.2EName.60.20is.20roundtrippable/with/565735560)\ndef Lean.Name.willRoundTrip (n : Name) : Bool :=\n  !n.isAnonymous -- anonymous names do not roundtrip\n    && !n.hasMacroScopes -- names with macroscopes do not roundtrip\n    && !maybePseudoSyntax -- names which might be \"pseudo-syntax\" do not roundtrip\n ",
      "body": "Oh, hey, this seems so familiar... :)\n\nIf we keep this, we should document the living daylights out of this function. Without doing so, it would be totally mysterious to a future maintainer of this file who is trying to figure out e.g. what core change made roundtripping break.\n\nHere's a first pass at documentation. (Sorry, adding newlines is necessary.)\n\n```suggestion\n/--\nDetermines if the pretty-printed version of the given name would parse as an `ident` with an underlying name (via `getId`) e",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 3301,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "        withLocalDecl n bi t fun fvar =>\n          Path.body n <$> go (b.instantiate1 fvar) i.succ\n",
      "body": "Likewise:\n```suggestion\n        withLocalDecl n bi t fun fvar =>\n          Path.body n <$> go (b.instantiate1 fvar) i.succ\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 3302,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "        withLocalDecl n bi t fun fvar =>\n          Path.body n <$> go (b.instantiate1 fvar) i.succ\n",
      "body": "Likewise:\n```suggestion\n        withLocalDecl n bi t fun fvar =>\n          Path.body n <$> go (b.instantiate1 fvar) i.succ\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 3303,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "    let enterStx \u2190 `(conv| enter [$xs,*])\n    let funStx \u2190 `(conv| fun)\n    let skipStx \u2190 `(conv| skip)\n    if !xs.elemsAndSeps.isEmpty then arr := arr.push enterStx\n    for _ in [0:depth] do arr := arr.push funStx\n    arr := arr.push skipStx\n    let seq \u2190 `(convSeq1Indented|$arr:conv*)\n",
      "body": "I think we might be able to simplify this section as such; do you foresee any problems doing it this way?\n```suggestion\n    let enterStx \u2190 `(conv| enter [$xs,*])\n    let funStx \u2190 `(conv| fun)\n    let skipStx \u2190 `(conv| skip)\n    if !xs.elemsAndSeps.isEmpty then arr := arr.push enterStx\n    for _ in [0:depth] do arr := arr.push funStx\n    arr := arr.push skipStx\n    let seq \u2190 `(convSeq1Indented|$arr:conv*)\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 3304,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "        withLocalDeclD n t fun fvar => do\n          let e := b.instantiate1 fvar\n",
      "body": "Is there any reason not to simply use `withLocalDecl`(`D`), here and below?\n```suggestion\n        withLocalDeclD n t fun fvar => do\n          let e := b.instantiate1 fvar\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 3310,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  have := hs (i := 1) (j := 2) (by decide)\r\n",
      "body": "```suggestion\r\n  have := hs (i := 1) (j := 2) (by decide)\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "decide",
          "have"
        ],
        "body_tactics": [
          "decide",
          "have"
        ],
        "new_tactics": [
          "decide",
          "have"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 3311,
      "before_code": "theorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2",
      "suggestion": "\r\n  have := hs (i := 0) (j := 1) (by decide)\r\n",
      "body": "```suggestion\r\n  have := hs (i := 0) (j := 1) (by decide)\r\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "fin_cases",
          "simp"
        ],
        "suggestion_tactics": [
          "decide",
          "have"
        ],
        "body_tactics": [
          "decide",
          "have"
        ],
        "new_tactics": [
          "decide",
          "have"
        ],
        "removed_tactics": [
          "fin_cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fin_cases",
          "IsSimplyLaced",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 3317,
      "before_code": "set at this point. -/\n@[fun_prop]",
      "suggestion": "\r\n@[to_fun (attr := fun_prop)]\r\n",
      "body": "```suggestion\r\n@[to_fun (attr := fun_prop)]\r\n```",
      "path": "Mathlib/Analysis/Calculus/ContDiff/Operations.lean",
      "tags": {
        "before_tactics": [
          "fun_prop"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "fun_prop",
          "point",
          "this",
          "set"
        ]
      }
    },
    {
      "id": 3319,
      "before_code": "deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x), deriv_fun_const_smul',\n      neg_smul]",
      "suggestion": "\r\n    obtain \u27e8U, hU, H\u27e9 := ((hf.eventually (by simp)).and (hg.eventually (by simp))).exists_mem\r\n",
      "body": ":golf:\r\n```suggestion\r\n    obtain \u27e8U, hU, H\u27e9 := ((hf.eventually (by simp)).and (hg.eventually (by simp))).exists_mem\r\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "deriv_comp_neg",
          "neg_smul",
          "deriv_fun_const_smul",
          "iteratedDeriv"
        ]
      }
    },
    {
      "id": 3320,
      "before_code": "rw [weierstrassPExceptSeries, FormalMultilinearSeries.ofScalars_apply_eq,\n      FormalMultilinearSeries.coeff_ofScalars, smul_eq_mul]\n\nlemma analyticOnNhd_weierstrassPExcept (l\u2080 : \u2102) : AnalyticOnNhd \u2102 \u2118[L - l\u2080] (L.lattice \\ {l\u2080})\u1d9c :=\n  (L.differentiableOn_weierstrassPExcept l\u2080).analyticOnNhd L.isOpen_compl_lattice_diff",
      "suggestion": "\r\n    \u00b7 simp [Nat.factorial_succ (n + 1)]\r\n      field [(n + 1).factorial_pos.ne']\r\n",
      "body": "```suggestion\r\n    \u00b7 simp [Nat.factorial_succ (n + 1)]\r\n      field [(n + 1).factorial_pos.ne']\r\n```\r\nIt's a pity that `field_simp` isn't able to spot automatically that factorials are non-zero, given how often one needs to divide by `n!`. Perhaps one could do the following:\r\n- add an instance `NeZero n.factorial` for all `n : Nat` (a bundled version of `Nat.factorial_ne_zero`)\r\n- add `NeZero.ne` to the list of lemmas used by `field_simp` in line 85-6 of `Mathlib.Tactic.FieldSimp.Discharger`.\r\nB",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "field_simp",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "complex",
          "differentiability",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "analyticOnNhd_weierstrassPExcept",
          "FormalMultilinearSeries",
          "weierstrassPExceptSeries",
          "AnalyticOnNhd",
          "coeff_ofScalars",
          "isOpen_compl_lattice_diff",
          "ofScalars_apply_eq",
          "differentiableOn_weierstrassPExcept",
          "smul_eq_mul",
          "analyticOnNhd",
          "lattice"
        ]
      }
    },
    {
      "id": 3322,
      "before_code": "iteratedSliceBackward f \u22d9 forget f \u22d9 forget X = forget f.left :=\n  rfl",
      "suggestion": "  NatIso.ofComponents (fun h => Over.isoMk (Over.isoMk (Iso.refl _)))\n",
      "body": "```suggestion\n  NatIso.ofComponents (fun h => Over.isoMk (Over.isoMk (Iso.refl _)))\n```\n\nThis naturality is filled in automatically",
      "path": "Mathlib/CategoryTheory/Comma/Over/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "forget",
          "left",
          "rfl",
          "iteratedSliceBackward"
        ]
      }
    },
    {
      "id": 3324,
      "before_code": "rw [homMk_comp_homMk ((Edge.CompStruct.idComp ex).tensor (Edge.CompStruct.compId ey)),\n    homMk_comp_homMk ((Edge.CompStruct.compId ex).tensor (Edge.CompStruct.idComp ey))]",
      "suggestion": "\r\n    (mkNatIso (fun x \u21a6 mkNatIso (fun y \u21a6 Iso.refl _))\r\n",
      "body": "```suggestion\r\n    (mkNatIso (fun x \u21a6 mkNatIso (fun y \u21a6 Iso.refl _))\r\n```",
      "path": "Mathlib/AlgebraicTopology/SimplicialSet/HoFunctorMonoidal.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Edge",
          "tensor",
          "CompStruct",
          "idComp",
          "compId",
          "homMk_comp_homMk"
        ]
      }
    },
    {
      "id": 3325,
      "before_code": "rw [homMk_comp_homMk ((Edge.CompStruct.idComp ex).tensor (Edge.CompStruct.compId ey)),\n    homMk_comp_homMk ((Edge.CompStruct.compId ex).tensor (Edge.CompStruct.idComp ey))]",
      "suggestion": "\r\n    (prod.associativity ..).inverse \u22d9 (inverse X Y).prod (\ud835\udfed _) \u22d9 inverse (X \u2297 Y) Z \u22d9\r\n      mapHomotopyCategory (\u03b1_ _ _ _).hom \u2245\r\n    Functor.prod (\ud835\udfed _) (inverse Y Z) \u22d9 inverse X (Y \u2297 Z) :=\r\n",
      "body": "```suggestion\r\n    (prod.associativity ..).inverse \u22d9 (inverse X Y).prod (\ud835\udfed _) \u22d9 inverse (X \u2297 Y) Z \u22d9\r\n      mapHomotopyCategory (\u03b1_ _ _ _).hom \u2245\r\n    Functor.prod (\ud835\udfed _) (inverse Y Z) \u22d9 inverse X (Y \u2297 Z) :=\r\n```\r\nFeel free to disagree with this particular indentation style, but the point is mainly that in the current code, `Functor.prod` and `inverse` are only indented by 1 space instead of 2.",
      "path": "Mathlib/AlgebraicTopology/SimplicialSet/HoFunctorMonoidal.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Edge",
          "tensor",
          "CompStruct",
          "idComp",
          "compId",
          "homMk_comp_homMk"
        ]
      }
    },
    {
      "id": 3326,
      "before_code": "initialize registerTraceClass `Meta.gcongr",
      "suggestion": "\r\n/-- `gcongr_discharger` is used by `gcongr` to discharge side goals.\r\n",
      "body": "```suggestion\r\n/-- `gcongr_discharger` is used by `gcongr` to discharge side goals.\r\n```",
      "path": "Mathlib/Tactic/GCongr/Core.lean",
      "tags": {
        "before_tactics": [
          "gcongr"
        ],
        "suggestion_tactics": [
          "gcongr"
        ],
        "body_tactics": [
          "gcongr"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "initialize",
          "gcongr",
          "registerTraceClass",
          "Meta"
        ]
      }
    },
    {
      "id": 3327,
      "before_code": "instance ULift.instT5Space [T5Space X] : T5Space (ULift X) :=\n  IsEmbedding.uliftDown.t5Space",
      "suggestion": "    T5Space X \u2194 \u2200 s : Set X, IsOpen s \u2192 T4Space s where\n  mp := fun _ _ _ => inferInstance\n  mpr h := \n  \t{ toCompletelyNormalSpace :=\n        completelyNormalSpace_iff_forall_isOpen_normalSpace.2 fun s hs => (h s hs).toNormalSpace\n      toT1Space :=\n        have := h univ isOpen_univ\n        t1Space_of_injective_of_continuous\n          (fun _ _ => congrArg Subtype.val) (continuous_id.subtype_mk mem_univ) }\n",
      "body": "I prefer to use `where` or `:= by` when the proof of an `\u2194` where one of the proofs is more than a line or two.\n```suggestion\n    T5Space X \u2194 \u2200 s : Set X, IsOpen s \u2192 T4Space s where\n  mp := fun _ _ _ => inferInstance\n  mpr h := \n  \t{ toCompletelyNormalSpace :=\n        completelyNormalSpace_iff_forall_isOpen_normalSpace.2 fun s hs => (h s hs).toNormalSpace\n      toT1Space :=\n        have := h univ isOpen_univ\n        t1Space_of_injective_of_continuous\n          (fun _ _ => congrArg Subtype.val) (",
      "path": "Mathlib/Topology/Separation/Regular.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsEmbedding",
          "T5Space",
          "ULift",
          "uliftDown",
          "t5Space",
          "instT5Space",
          "instance"
        ]
      }
    },
    {
      "id": 3328,
      "before_code": "theorem toSpanSingleton_eq_algebra_linearMap : toSpanSingleton R A 1 = Algebra.linearMap R A := by\n  ext; simp",
      "suggestion": "  map_smul' a x := x.induction_on (by simp) (by simp +contextual [mul', smul_tmul', mul_assoc])\n",
      "body": "```suggestion\n  map_smul' a x := x.induction_on (by simp) (by simp +contextual [mul', smul_tmul', mul_assoc])\n```",
      "path": "Mathlib/Algebra/Algebra/Bilinear.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "toSpanSingleton",
          "ext",
          "theorem",
          "linearMap",
          "simp",
          "toSpanSingleton_eq_algebra_linearMap",
          "Algebra"
        ]
      }
    },
    {
      "id": 3329,
      "before_code": "filter_upwards [self_mem_nhdsWithin] with x hx\n  exact ha x hx",
      "suggestion": "\r\nspectra of `a x` for all `x \u2208 t`, then `fun x \u21a6 cfc f (a x)` is continuous on `t`.\r\n",
      "body": "```suggestion\r\nspectra of `a x` for all `x \u2208 t`, then `fun x \u21a6 cfc f (a x)` is continuous on `t`.\r\n```",
      "path": "Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Continuity.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "self_mem_nhdsWithin",
          "filter_upwards"
        ]
      }
    },
    {
      "id": 3330,
      "before_code": "filter_upwards [self_mem_nhdsWithin] with x hx\n  exact ha x hx",
      "suggestion": "\r\nspectra of `a x` for all `x \u2208 t`, then `fun x \u21a6 cfc f (a x)` is continuous on `t`.\r\n",
      "body": "```suggestion\r\nspectra of `a x` for all `x \u2208 t`, then `fun x \u21a6 cfc f (a x)` is continuous on `t`.\r\n```",
      "path": "Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Continuity.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "self_mem_nhdsWithin",
          "filter_upwards"
        ]
      }
    },
    {
      "id": 3331,
      "before_code": "filter_upwards [self_mem_nhdsWithin] with x hx\n  exact ha x hx",
      "suggestion": "\r\nquasispectra of `a x` for all `x \u2208 t`, then `fun x \u21a6 cfc\u2099 f (a x)` is continuous on `t`.\r\n",
      "body": "```suggestion\r\nquasispectra of `a x` for all `x \u2208 t`, then `fun x \u21a6 cfc\u2099 f (a x)` is continuous on `t`.\r\n```",
      "path": "Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Continuity.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "self_mem_nhdsWithin",
          "filter_upwards"
        ]
      }
    },
    {
      "id": 3332,
      "before_code": "filter_upwards [self_mem_nhdsWithin] with x hx\n  exact ha x hx",
      "suggestion": "\r\nquasispectra of `a x` for all `x \u2208 t`, then `fun x \u21a6 cfc\u2099 f (a x)` is continuous on `t`.\r\n",
      "body": "```suggestion\r\nquasispectra of `a x` for all `x \u2208 t`, then `fun x \u21a6 cfc\u2099 f (a x)` is continuous on `t`.\r\n```",
      "path": "Mathlib/Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Continuity.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "self_mem_nhdsWithin",
          "filter_upwards"
        ]
      }
    },
    {
      "id": 3333,
      "before_code": "let missing := modulesWithoutMathlibImports.erase `Mathlib.Tactic.Linter.Header\n    -- This file is imported by `Mathlib/Tactic/Linter/Header.lean`.\n    |>.erase `Mathlib.Tactic.Linter.DirectoryDependency",
      "suggestion": "\r\n    -- These files are transitively imported by `Mathlib/Tactic/Linter/Header.lean`.\r\n    |>.erase `Mathlib.Tactic.Linter.DirectoryDependency\r\n    |>.erase `Mathlib.Lean.Linter\r\n",
      "body": "```suggestion\r\n    -- These files are transitively imported by `Mathlib/Tactic/Linter/Header.lean`.\r\n    |>.erase `Mathlib.Tactic.Linter.DirectoryDependency\r\n    |>.erase `Mathlib.Lean.Linter\r\n```",
      "path": "scripts/lint-style.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "file",
          "erase",
          "This",
          "modulesWithoutMathlibImports",
          "Mathlib",
          "Header",
          "missing",
          "lean",
          "DirectoryDependency",
          "Linter",
          "imported",
          "Tactic"
        ]
      }
    },
    {
      "id": 3336,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\n  have : p.IsPrime := by rw [P.over_def p]; infer_instance\r\n",
      "body": "```suggestion\r\n  have : p.IsPrime := by rw [P.over_def p]; infer_instance\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw",
          "have"
        ],
        "body_tactics": [
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 3337,
      "before_code": "end single",
      "suggestion": "\r\ntheorem trace_surjective [AddCommMonoid R] [Nonempty n] :\r\n    Function.Surjective (trace : Matrix n n R \u2192 R) := fun r \u21a6 by\r\n  classical\r\n  let i := Classical.arbitrary n\r\n  exact \u27e8single i i r, trace_single_eq_same i r\u27e9\r\n",
      "body": "No need to section things off. And better to just use the variables above. And also instead of repeating `Classical.arbitrary` just define it once:\r\n\r\n```suggestion\r\ntheorem trace_surjective [AddCommMonoid R] [Nonempty n] :\r\n    Function.Surjective (trace : Matrix n n R \u2192 R) := fun r \u21a6 by\r\n  classical\r\n  let i := Classical.arbitrary n\r\n  exact \u27e8single i i r, trace_single_eq_same i r\u27e9\r\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/Trace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [
          "exact"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "single",
          "end"
        ]
      }
    },
    {
      "id": 3339,
      "before_code": "(rootSpaceProduct R L H \u03b1 (-\u03b1) 0 (add_neg_cancel \u03b1) (\u27e8y, hy\u27e9 \u2297\u209c[R] \u27e8z, hz\u27e9)).property using 0\n  simp [hyz]",
      "suggestion": "lemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n",
      "body": "```suggestion\nlemma cartan_sup_iSup_rootSpace_eq_top :\n    H.toLieSubmodule \u2294 \u2a06 \u03b1 : H.root, rootSpace H \u03b1 = \u22a4 := by\n  rw [eq_top_iff, \u2190 LieModule.iSup_genWeightSpace_eq_top', iSup_le_iff]\n  intro \u03b1\n  by_cases h\u03b1 : \u03b1.IsZero\n  \u00b7 simp [h\u03b1]\n  \u00b7 exact le_sup_of_le_right <| le_iSup_of_le \u27e8\u03b1, by simpa\u27e9 (le_refl _)\n```",
      "path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "exact",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "exact",
          "simpa",
          "rw",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "rootSpaceProduct",
          "property",
          "simp",
          "add_neg_cancel",
          "using",
          "hyz"
        ]
      }
    },
    {
      "id": 3340,
      "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
      "suggestion": "    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n",
      "body": "There are two _independent_ changes here:\n\n1. Fix the `by exact` issue by adding `.toLinearMap` to help elaboration\n2. Add `.toSubmodule` rather than a coercion to avoid an indirect coercion (`LieIdeal` to `LieSubalgebra` to `Submodule`)\n```suggestion\n    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    (invtSubmoduleToLieIdeal q hq).toSubmodule =\n```",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "add_lie",
          "mem_coe",
          "SetLike",
          "exact",
          "Submodule",
          "add_mem",
          "simp",
          "carrier_eq_coe",
          "only"
        ]
      }
    },
    {
      "id": 3341,
      "before_code": "simp only [add_lie, Submodule.carrier_eq_coe, SetLike.mem_coe] at ih\u2081 ih\u2082 \u22a2\n      exact add_mem ih\u2081 ih\u2082",
      "suggestion": "\r\n-- This should probably be somewhere in the file `Algebra.Lie.Weights.RootSystem`\r\nopen LieSubmodule in\r\n@[simp]\r\nlemma biSup_corootSpace_eq_top :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 := by\r\n  simp only [\u2190 toSubmodule_inj, top_toSubmodule, iSup_toSubmodule,\r\n    \u2190 RootPairing.IsRootSystem.span_coroot_eq_top (P := rootSystem H),\r\n    coe_corootSpace_eq_span_singleton, Submodule.iSup_span]\r\n  congr\r\n  ext \u03b1\r\n  simp [eq_comm]\r\n\r\n-- This should probably be below `bisup_corootSpace_eq_top`\r\n@[simp]\r\nlemma biSup_corootSubmodule_eq_cartan :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSubmodule \u03b1 = H.toLieSubmodule := by\r\n  suffices \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 from\r\n    le_antisymm (by simp) (by simp [\u2190 LieSubmodule.map_iSup, this])\r\n  simp\r\n\r\nopen LieSubmodule in\r\n@[simp] lemma invtSubmoduleToLieIdeal_top :\r\n    invtSubmoduleToLieIdeal (\u22a4 : Submodule K (Module.Dual K H)) (by simp) = \u22a4 := by\r\n  simp_rw [\u2190 toSubmodule_inj, coe_",
      "body": "I think the right way to break this result down is as follows:\r\n```suggestion\r\n-- This should probably be somewhere in the file `Algebra.Lie.Weights.RootSystem`\r\nopen LieSubmodule in\r\n@[simp]\r\nlemma biSup_corootSpace_eq_top :\r\n    \u2a06 \u03b1 : Weight K H L, \u2a06 (_ : \u03b1.IsNonZero), corootSpace \u03b1 = \u22a4 := by\r\n  simp only [\u2190 toSubmodule_inj, top_toSubmodule, iSup_toSubmodule,\r\n    \u2190 RootPairing.IsRootSystem.span_coroot_eq_top (P := rootSystem H),\r\n    coe_corootSpace_eq_span_singleton, Submodule.iSup_span]\r\n  ",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "congr",
          "refine",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "congr",
          "refine",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "congr",
          "refine",
          "ext"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "line_break"
        ],
        "keywords": [
          "add_lie",
          "mem_coe",
          "SetLike",
          "exact",
          "Submodule",
          "add_mem",
          "simp",
          "carrier_eq_coe",
          "only"
        ]
      }
    },
    {
      "id": 3349,
      "before_code": "rw [and_congr_right IsClosed.isNowhereDense_iff,\n    isOpen_compl_iff, interior_eq_empty_iff_dense_compl]",
      "suggestion": "  rw [IsNowhereDense] at h \u22a2\n",
      "body": "```suggestion\n  rw [IsNowhereDense] at h \u22a2\n```\nYou can input `\u22a2` by typing `\\goal` or `\\vdash` in VS Code.",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "interior_eq_empty_iff_dense_compl",
          "and_congr_right",
          "isOpen_compl_iff",
          "IsClosed",
          "isNowhereDense_iff"
        ]
      }
    },
    {
      "id": 3350,
      "before_code": "contrapose! hs\n  simpa [hs] using IsMeagre.empty",
      "suggestion": "  suffices IsMeagre (\u22c3 i : I, A i) by simpa\n",
      "body": "```suggestion\n  suffices IsMeagre (\u22c3 i : I, A i) by simpa\n```",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "contrapose",
          "empty",
          "IsMeagre",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 3351,
      "before_code": "applyReplacementFun t e #[]\n\n/-- Unfold auxlemmas in the type and value. -/",
      "suggestion": "\r\n/-- Unfold auxlemmas (generated by `simp`) in the type and value. -/\r\n",
      "body": "```suggestion\r\n/-- Unfold auxlemmas (generated by `simp`) in the type and value. -/\r\n```",
      "path": "Mathlib/Tactic/Translate/Core.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "auxlemmas",
          "Unfold",
          "value",
          "type",
          "applyReplacementFun"
        ]
      }
    },
    {
      "id": 3354,
      "before_code": "(\u220f a \u2208 s, \u220f\u1da0 b : \u03b2, f a b) = \u220f\u1da0 b : \u03b2, \u220f a \u2208 s, f a b :=\n  (finprod_prod_comm s (fun b a => f a b) h).symm",
      "suggestion": "    \u220f\u1da0 x, \u220f y \u2208 s with f y = x, g y = \u220f k \u2208 s, g k := by\n",
      "body": "What you have is fine but we could also consider:\n```suggestion\n    \u220f\u1da0 x, \u220f y \u2208 s with f y = x, g y = \u220f k \u2208 s, g k := by\n```\nor even:\n```lean\n    \u220f\u1da0 x, \u220f y \u2208 s.filter (fun j \u21a6 f j = x), g y = \u220f k \u2208 s, g k := by\n```",
      "path": "Mathlib/Algebra/BigOperators/Finprod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "finprod_prod_comm"
        ]
      }
    },
    {
      "id": 3355,
      "before_code": "simp only [ContinuousLinearMap.ext_iff, ContinuousLinearMap.comp_apply] at hg'inv hg'invf \u22a2\n  simp [ContinuousLinearEquiv.eq_symm_apply, *]",
      "suggestion": "theorem eventuallyEq_implicitFunction {\u03c8 : F \u2192 G \u2192 E}\n    (h : \u2200\u1da0 x in \ud835\udcdd \u03c6.pt, \u03c8 (\u03c6.leftFun x) (\u03c6.rightFun x) = x) :\n    Function.uncurry \u03c8 =\u1da0[\ud835\udcdd (\u03c6.prodFun \u03c6.pt)] Function.uncurry \u03c6.implicitFunction :=\n  HasStrictFDerivAt.localInverse_unique _ h\n",
      "body": "I think this is a justifiable convenient wrapper around [HasStrictFDerivAt.localInverse_unique](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Calculus/InverseFunctionTheorem/FDeriv.html#HasStrictFDerivAt.localInverse_unique). How about we state it as:\n```suggestion\ntheorem eventuallyEq_implicitFunction {\u03c8 : F \u2192 G \u2192 E}\n    (h : \u2200\u1da0 x in \ud835\udcdd \u03c6.pt, \u03c8 (\u03c6.leftFun x) (\u03c6.rightFun x) = x) :\n    Function.uncurry \u03c8 =\u1da0[\ud835\udcdd (\u03c6.prodFun \u03c6.pt)] Function.uncurry \u03c6.implicitFunction :=\n  HasStr",
      "path": "Mathlib/Analysis/Calculus/Implicit.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "ContinuousLinearEquiv",
          "eq_symm_apply",
          "ext_iff",
          "ContinuousLinearMap",
          "inv",
          "comp_apply",
          "invf",
          "simp",
          "only"
        ]
      }
    },
    {
      "id": 3356,
      "before_code": "\u00b7 rw [h1]\n  \u00b7 rfl",
      "suggestion": "theorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitFunction xy.1 = xy.2 := by\n  refine h.implicitFunctionData.hasStrictFDerivAt.eventually_left_inverse.mono fun xy h\u2081 h\u2082 \u21a6 ?_\n  change (h.implicitFunctionData.implicitFunction xy.1 (f a)).2 = xy.2\n  change h.implicitFunctionData.implicitFunction xy.1 (f xy) = xy at h\u2081\n  aesop\n",
      "body": "I strongly encourage you to embrace the existing API for `ImplicitFunctionData`. You're currently fighting it quite a bit in this proof. I prefer the following golf not so much because it is shorter but because it makes it clear that this is really just a wrapper around `ImplicitFunctionData.hasStrictFDerivAt` and `HasStrictFDerivAt.eventually_left_inverse`:\n```suggestion\ntheorem eventually_implicitFunction_apply_eq (h : IsContDiffImplicitAt n f f' a) :\n    \u2200\u1da0 xy in \ud835\udcdd a, f xy = f a \u2192 h.implicitF",
      "path": "Mathlib/Analysis/Calculus/ImplicitContDiff.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "rfl"
        ]
      }
    },
    {
      "id": 3357,
      "before_code": "theorem pow_eq_one_of_norm_le_one {x : K} (hx\u2080 : x \u2260 0) (hxi : IsIntegral \u2124 x)\n    (hx : \u2200 \u03c6 : K \u2192+* A, \u2016\u03c6 x\u2016 \u2264 1) : \u2203 (n : \u2115) (_ : 0 < n), x ^ n = 1 := by\n  obtain \u27e8a, -, b, -, habne, h\u27e9 :=\n    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ \u00b7 : \u2115 \u2192 K) Set.infinite_univ\n      (by exact fun a _ => \u27e8hxi.pow a, fun \u03c6 => by simp [pow_le_one\u2080 (norm_nonneg (\u03c6 x)) <| hx \u03c6]\u27e9)",
      "suggestion": "\r\n      (fun a _ \u21a6 mem_setOf.mpr <|\r\n        \u27e8hxi.pow a, fun \u03c6 \u21a6 by simp [pow_le_one\u2080 (norm_nonneg (\u03c6 x)) <| hx \u03c6]\u27e9)\r\n",
      "body": "optional\r\n```suggestion\r\n      (fun a _ \u21a6 mem_setOf.mpr <|\r\n        \u27e8hxi.pow a, fun \u03c6 \u21a6 by simp [pow_le_one\u2080 (norm_nonneg (\u03c6 x)) <| hx \u03c6]\u27e9)\r\n```",
      "path": "Mathlib/NumberTheory/NumberField/InfinitePlace/Embeddings.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "norm",
          "set_theory",
          "nat",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "IsIntegral",
          "theorem",
          "exists_ne_map_eq_of_mapsTo",
          "hxi",
          "infinite_univ",
          "exact",
          "Set",
          "Infinite",
          "pow_eq_one_of_norm_le_one",
          "norm_nonneg",
          "obtain",
          "simp",
          "pow",
          "habne"
        ]
      }
    },
    {
      "id": 3358,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n    let containedTacs := tacNodes.filter fun tacRange _ =>\r\n",
      "body": "```suggestion\r\n    let containedTacs := tacNodes.filter fun tacRange _ =>\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 3359,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n    let containedTacs := tacNodes.filter fun tacRange _ =>\r\n",
      "body": "```suggestion\r\n    let containedTacs := tacNodes.filter fun tacRange _ =>\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 3360,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n    if containerRanges.any fun c => c.start \u2264 seqRange.start && seqRange.stop \u2264 c.stop then\r\n",
      "body": "```suggestion\r\n    if containerRanges.any fun c => c.start \u2264 seqRange.start && seqRange.stop \u2264 c.stop then\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 3361,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n            if open Parser.Tactic in\r\n              #[`\u00ab;\u00bb, ``cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb, ``tacticSeq, ``tacticSeq1Indented,\r\n                ``Parser.Term.byTactic, ``tacticHave__, ``tacticLet__].contains stx.getKind then\r\n",
      "body": "```suggestion\r\n            if open Parser.Tactic in\r\n              #[`\u00ab;\u00bb, ``cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb, ``tacticSeq, ``tacticSeq1Indented,\r\n                ``Parser.Term.byTactic, ``tacticHave__, ``tacticLet__].contains stx.getKind then\r\n```\r\nTo me, this seems more easily extendable.  Possibly, I would even factor out the Array/HashSet of `SyntaxNodeKind`s.",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "ofTacticInfo"
        ]
      }
    },
    {
      "id": 3362,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences",
      "suggestion": "\r\n          if stx.isOfKind ``Parser.Tactic.tacticSeq ||\r\n             stx.isOfKind ``Parser.Tactic.tacticSeq1Indented then\r\n",
      "body": "```suggestion\r\n          if stx.isOfKind ``Parser.Tactic.tacticSeq ||\r\n             stx.isOfKind ``Parser.Tactic.tacticSeq1Indented then\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "children",
          "getKind",
          "byTactic",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "Similarly",
          "getting",
          "original",
          "syntax",
          "Array",
          "context",
          "getHeadInfo",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "filterMap",
          "visitM",
          "Tactic",
          "surrounding",
          "childTactics",
          "fileMap",
          "new",
          "snd",
          "child",
          "collect",
          "get",
          "into",
          "then"
        ]
      }
    },
    {
      "id": 3363,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n  let mkTacticNodes (tacs : Std.HashMap Syntax.Range (ContextInfo \u00d7 TacticInfo)) :\r\n      Array TacticNode :=\r\n    let sorted := tacs.toArray.qsort fun (r1, _, _) (r2, _, _) => r1.start < r2.start\r\n",
      "body": "```suggestion\r\n  let mkTacticNodes (tacs : Std.HashMap Syntax.Range (ContextInfo \u00d7 TacticInfo)) :\r\n      Array TacticNode :=\r\n    let sorted := tacs.toArray.qsort fun (r1, _, _) (r2, _, _) => r1.start < r2.start\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 3368,
      "before_code": "rw [and_congr_right IsClosed.isNowhereDense_iff,\n    isOpen_compl_iff, interior_eq_empty_iff_dense_compl]",
      "suggestion": "\r\n/-- To check that `s` is nowhere dense, it suffices to check that no point of `s`\r\nis in the interior of `closure s`. -/\r\nlemma isNowhereDense_iff_disjoint {s : Set X} :\r\n    IsNowhereDense s \u2194 Disjoint s (interior (closure s)) :=\r\n  \u27e8fun H \u21a6 H \u25b8 disjoint_empty _, fun H \u21a6\r\n    H.closure_left isOpen_interior |>.mono_left interior_subset |>.eq_bot_of_self\u27e9\r\n\r\n/-- To check that `s` is nowhere dense, it suffices to check that `closure s` is not a\r\nneighborhood of any point of `s`. -/\r\nlemma isNowhereDense_iff_forall_notMem_nhds {s : Set X} :\r\n    IsNowhereDense s \u2194 \u2200 x \u2208 s, closure s \u2209 \ud835\udcdd x := by\r\n  simp [isNowhereDense_iff_disjoint, disjoint_iff_inter_eq_empty, eq_empty_iff_forall_notMem,\r\n    mem_interior_iff_mem_nhds]\r\n\r\n/-- The image of a nowhere dense set through an inducing map is nowhere dense. -/\r\nlemma Topology.IsInducing.isNowhereDense_image {f : X \u2192 Y} [TopologicalSpace Y]\r\n    (hf : Topology.IsInducing f) {s : Set X} (h : IsNowhereDense s) : IsNowhereDense (f '' s) := by\r\n  rw",
      "body": "I was intrigued by this proof: it is slightly mathematically annoying, because you have to change the original `y` if it's not in `f '' s`. This led me to the following, which you should feel free to accept or not (i.e I have no preference):\r\n```suggestion\r\n/-- To check that `s` is nowhere dense, it suffices to check that no point of `s`\r\nis in the interior of `closure s`. -/\r\nlemma isNowhereDense_iff_disjoint {s : Set X} :\r\n    IsNowhereDense s \u2194 Disjoint s (interior (closure s)) :=\r\n  \u27e8fun H \u21a6",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "interior_eq_empty_iff_dense_compl",
          "and_congr_right",
          "isOpen_compl_iff",
          "IsClosed",
          "isNowhereDense_iff"
        ]
      }
    },
    {
      "id": 3369,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081_iff_termDefinable (f : M \u2192 M) : A.TermDefinable\u2081 L f \u2194\r\n    A.TermDefinable L (fun v \u21a6 f (v ())) := by\r\n  refine exists_congr fun \u03c6 \u21a6 ?_\r\n  rw [funext_iff, funext_iff, (Equiv.funUnique Unit M).forall_congr']\r\n  simp only [Equiv.funUnique_symm_apply, uniqueElim_const, Function.comp_apply]\r\n  congr!\r\n",
      "body": "This would be shorter (just an suggestion, feel free to ignore it)\r\n\r\n```suggestion\r\ntheorem TermDefinable\u2081_iff_termDefinable (f : M \u2192 M) : A.TermDefinable\u2081 L f \u2194\r\n    A.TermDefinable L (fun v \u21a6 f (v ())) := by\r\n  refine exists_congr fun \u03c6 \u21a6 ?_\r\n  rw [funext_iff, funext_iff, (Equiv.funUnique Unit M).forall_congr']\r\n  simp only [Equiv.funUnique_symm_apply, uniqueElim_const, Function.comp_apply]\r\n  congr!\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "congr",
          "refine",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3370,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.const M C) :=\r\n  (TermDefinable.const C).termDefinable\u2081\r\n",
      "body": "Generalize\r\n\r\n```suggestion\r\n/-- Constant functions are `TermDefinable`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable.const (C : L[[A]].Constants) : A.TermDefinable L (Function.const (\u03b1 \u2192 M) C) :=\r\n  \u27e8C.term, by simp only [Term.realize_constants]; rfl\u27e9\r\n\r\n/-- Constant functions are `TermDefinable\u2081`, assuming the constant value is a language constant. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.const (C : L[[A]].Constants) : A.TermDefinable\u2081 L (Function.c",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "simp"
        ],
        "new_tactics": [
          "fun_prop",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_fun_prop"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3371,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp {f g : M \u2192 M} (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable\u2081 L g) :\r\n    A.TermDefinable\u2081 L (f \u2218 g) :=\r\n  (hf.termDefinable.comp fun _ \u21a6 hg.termDefinable).termDefinable\u2081\r\n\r\n/-- A `TermDefinable` function postcomposed with `TermDefinable\u2081` is `TermDefinable`. -/\r\n@[fun_prop]\r\ntheorem TermDefinable\u2081.comp_termDefinable {f : M \u2192 M} {g : (\u03b1 \u2192 M) \u2192 M}\r\n    (hf : A.TermDefinable\u2081 L f) (hg : A.TermDefinable L g) : A.TermDefinable L (f \u2218 g) :=\r\n  hf.termDefinable.comp fun _ \u21a6 hg\r\n",
      "body": "```suggestion\r\n/-- A k-ary `TermDefinable` function composed with k `TermDefinable` functions is `TermDefinable`. -/\r\ntheorem TermDefinable.comp {f : (\u03b1 \u2192 M) \u2192 M} {g : \u03b1 \u2192 (\u03b2 \u2192 M) \u2192 M} (hf : A.TermDefinable L f)\r\n    (hg : \u2200 i, A.TermDefinable L (g i)) : A.TermDefinable L (fun b \u21a6 f (g \u00b7 b)) := by\r\n  obtain \u27e8\u03c6, rfl\u27e9 := hf\r\n  choose \u03c8 h\u03c8 using hg\r\n  simp only [funext_iff] at h\u03c8\r\n  use \u03c6.subst \u03c8\r\n  funext v\r\n  simp [h\u03c8]\r\n\r\n/-- `TermDefinable\u2081` functions are closed under composition. -/\r\n@[fun_prop",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "body_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "new_tactics": [
          "fun_prop",
          "obtain",
          "funext",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_fun_prop"
        ],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3372,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081.graph_definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n    A.Definable\u2082 L f.graph := by\r\n  obtain \u27e8t, h\u27e9 := h.termDefinable.tupleGraph_definable A L\r\n  use t.relabel (Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  ext v\r\n  convert Set.ext_iff.1 h (Sum.elim (fun _ \u21a6 v 0) (fun _ \u21a6 v 1))\r\n  rw [mem_setOf, mem_setOf, Formula.realize_relabel, Sum.comp_elim]\r\n  rfl\r\n",
      "body": "```suggestion\r\ntheorem TermDefinable\u2081.graph_definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n    A.Definable\u2082 L f.graph := by\r\n  obtain \u27e8t, h\u27e9 := h.termDefinable.tupleGraph_definable A L\r\n  use t.relabel (Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  ext v\r\n  convert Set.ext_iff.1 h (Sum.elim (fun _ \u21a6 v 0) (fun _ \u21a6 v 1))\r\n  rw [mem_setOf, mem_setOf, Formula.realize_relabel, Sum.comp_elim]\r\n  rfl\r\n```\r\n\r\n`rw [setOf]` is a defeq abuse (see docstring of `Set.setOf_app_iff`)",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3373,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n/-- TermDefinable is transitive. If f is TermDefinable in a structure S on L, and all of the\r\nfunctions' realizations on S are TermDefinable on a structure T on L', then f is\r\nTermDefinable on T in L'. -/\r\n",
      "body": "```suggestion\r\n/-- TermDefinable is transitive. If f is TermDefinable in a structure S on L, and all of the\r\nfunctions' realizations on S are TermDefinable on a structure T on L', then f is\r\nTermDefinable on T in L'. -/\r\n```\r\n\r\nThe new [style guide](https://leanprover-community.github.io/contribute/doc.html) is to not indent the docstrings. Also for other multiline docstrings.",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3374,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  A.TermDefinable L fun x => (f (x ()))\r\n",
      "body": "Alternatively, would it be better to define it via `TermDefinable`, like `Definable\u2081`?\r\n```suggestion\r\n  A.TermDefinable L fun x => (f (x ()))\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3375,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  convert Set.ext_iff.1 h (v \u2218 Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  simp\r\n",
      "body": "golf\r\n```suggestion\r\n  convert Set.ext_iff.1 h (v \u2218 Sum.elim (fun _ \u21a6 0) (fun _ \u21a6 1))\r\n  simp\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 3381,
      "before_code": "`lift` defines the universal property of `\ud835\udd4e R` as the inverse limit of `TruncatedWittVector n`.\n-/\ndef lift : S \u2192+* \ud835\udd4e R := by\n  refine {  toFun := liftFun f",
      "suggestion": "  refine {  toFun := liftFun f\n",
      "body": "```suggestion\n  refine {  toFun := liftFun f\n```",
      "path": "Mathlib/RingTheory/WittVector/Truncated.lean",
      "tags": {
        "before_tactics": [
          "refine"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "limit",
          "refine",
          "TruncatedWittVector",
          "def",
          "toFun",
          "property",
          "lift",
          "liftFun",
          "universal",
          "defines",
          "inverse"
        ]
      }
    },
    {
      "id": 3382,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "  choose g hg1 hg2 hg3 using fun n => exists_open_dense_of_open_dense_subtype hd (hof n) (hdf n)\n",
      "body": "```suggestion\n  choose g hg1 hg2 hg3 using fun n => exists_open_dense_of_open_dense_subtype hd (hof n) (hdf n)\n```\nCan you just work with this? And simp/rw with `hg3` backwards, when needed.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 3383,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n",
      "body": "```suggestion\n  have h_inter_dense : Dense (\u22c2 n, g n \u2229 V n) :=\n    BaireSpace.baire_property (fun n \u21a6 g n \u2229 V n) (fun n => (hg1 n).inter (hV.1 n))\n```\n\n`by exact` is (almost always) a no-op.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 3384,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "      (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset]))\n",
      "body": "```suggestion\n      (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset]))\n```",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 3385,
      "before_code": "(hd : \u2200 n, Dense (f n)) : Dense (\u22c2 n, f n) :=\n  BaireSpace.baire_property f ho hd",
      "suggestion": "    (fun n => (hg1 n).inter (hV.1 n))\n    (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset])) (hg1 n))\n",
      "body": "```suggestion\n    (fun n => (hg1 n).inter (hV.1 n))\n    (fun n => (hg2 n).inter_of_isOpen_left (hd.mono (by simp [hV.2, iInter_subset])) (hg1 n))\n```\nI think this slightly improves readability.",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "BaireSpace",
          "Dense",
          "baire_property"
        ]
      }
    },
    {
      "id": 3386,
      "before_code": "theorem pairing_continuous_left (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (g : \ud835\udce2(D, F)) :\n    Continuous (pairing B \u00b7 g) := (pairing B.flip g).continuous",
      "suggestion": "  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n",
      "body": "I would like to reformat this to make it easier to distinguish the different arguments. I originally thought this was one argument to `mkCLM`.\n```suggestion\n  mkCLM (fun f x \u21a6 (L x).smulRight (f x)) (by intros; ext; simp)\n    (by intro c g x; ext v; simpa using smul_comm (L x v) c (g x))\n    (by fun_prop) <| by\n```\nThen indent the remainder of the proof, and remove the final `)`.",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "simpa",
          "simp",
          "intro",
          "fun_prop"
        ],
        "body_tactics": [
          "ext",
          "simpa",
          "simp",
          "intro",
          "fun_prop"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "ext",
          "intro",
          "fun_prop"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity"
        ],
        "transforms": [
          "use_simpa",
          "use_fun_prop"
        ],
        "keywords": [
          "theorem",
          "pairing_continuous_left",
          "pairing",
          "continuous",
          "flip",
          "Continuous"
        ]
      }
    },
    {
      "id": 3387,
      "before_code": "convert hf.add hg.neg using 1\n  grind",
      "suggestion": "\r\n  classical\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert a s has ih => \r\n    obtain \u27e8hf, h\u27e9 := by simpa using hf\r\n    simpa [has] using hf.add (ih h)\r\n",
      "body": "When I saw this, I thought \"do we really not have `HasTemperateGrowth.add`?\" and then I realized we do. This is much easier than you're making it. You need to use an induction principle. In this case:\r\n```suggestion\r\n  classical\r\n  induction s using Finset.induction_on with\r\n  | empty => simp\r\n  | insert a s has ih => \r\n    obtain \u27e8hf, h\u27e9 := by simpa using hf\r\n    simpa [has] using hf.add (ih h)\r\n```",
      "path": "Mathlib/Analysis/Distribution/TemperateGrowth.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "induction",
          "simp"
        ],
        "removed_tactics": [
          "grind"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "add",
          "neg",
          "convert",
          "grind",
          "using"
        ]
      }
    },
    {
      "id": 3388,
      "before_code": "filter_upwards [Tendsto.eventually_const_lt (zero_lt_one) h\u03c6, hu\u03c6v] with x h\u03c6_pos huv'\n  simp [\u2190 Real.mul_rpow (le_of_lt h\u03c6_pos) (hv x), huv']",
      "suggestion": "\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <| Real.tendsto_log_atTop.comp g_tendsto\r\n",
      "body": "slightly cleaner\r\n```suggestion\r\n  have hf := hfg.symm.tendsto_atTop g_tendsto |>.eventually_ne_atTop 0\r\n  rw [isEquivalent_iff_tendsto_one hg] at hfg\r\n  have := hfg.log (by norm_num) |>.congr' <| by\r\n    filter_upwards [hf, hg] with n hf hg using Real.log_div hf hg\r\n  exact IsLittleO.isEquivalent <| calc\r\n    (fun n \u21a6 Real.log (f n) - Real.log (g n)) =o[l] fun _ \u21a6 (1 : \u211d) := by simpa\r\n    _ =o[l] fun n \u21a6 Real.log (g n) := isLittleO_one_left_iff \u211d |>.mpr <|\r\n      tendsto_norm_atTop_atTop.comp <",
      "path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "body_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "new_tactics": [
          "norm_num",
          "exact",
          "have",
          "simpa",
          "rw",
          "congr"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "le_of_lt",
          "eventually_const_lt",
          "zero_lt_one",
          "Real",
          "Tendsto",
          "filter_upwards",
          "mul_rpow",
          "simp",
          "huv"
        ]
      }
    },
    {
      "id": 3391,
      "before_code": "return splitCase (s.extract i\u2081 s.endPos) 0 <| (s.extract 0 i\u2081)::r\n  return splitCase s i\u2081 r\n\n/-- Helper for `capitalizeLike`. -/\npartial def capitalizeLikeAux (s : String) (i : String.Pos := 0) (p : String) : String :=\n  if p.atEnd i || s.atEnd i then\n    p\n  else\n    let j := p.next i\n    if (s.get i).isLower then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toLower)\n    else if (s.get i).isUpper then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toUpper)\n    else\n      capitalizeLikeAux s j p\n\n/-- Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. -/\ndef capitalizeLike (r : String) (s : String) :=\n  capitalizeLikeAux r 0 s\n\n/-- Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. -/\ndef capitalizeFirstLike (s : String) : List String \u2192 List String\n  | x :: r => capitalizeLike s x :: r\n  | [] => []\n\n/--\nDictionary used by `guessName` to autogenerate names.\n\nNote: `guessName` capitalizes first element of the output according to\ncapitalization of the input. Input and first element should therefore be lower-case,\n2nd element should be capitalized properly.\n-/\ndef nameDict : String \u2192 List String\n  | \"one\"           => [\"zero\"]\n  | \"mul\"           => [\"add\"]\n  | \"smul\"          => [\"vadd\"]\n  | \"inv\"           => [\"neg\"]\n  | \"div\"           => [\"sub\"]\n  | \"prod\"          => [\"sum\"]\n  | \"hmul\"          => [\"hadd\"]\n  | \"hsmul\"         => [\"hvadd\"]\n  | \"hdiv\"          => [\"hsub\"]\n  | \"hpow\"          => [\"hsmul\"]\n  | \"finprod\"       => [\"finsum\"]\n  | \"tprod\"         => [\"tsum\"]\n  | \"pow\"           => [\"nsmul\"]\n  | \"npow\"          => [\"nsmul\"]\n  | \"zpow\"          => [\"zsmul\"]\n  | \"mabs\"          => [\"abs\"]\n  | \"monoid\"        => [\"add\", \"Monoid\"]\n  | \"submonoid\"     => [\"add\", \"Submonoid\"]\n  | \"group\"         => [\"add\", \"Group\"]\n  | \"subgroup\"      => [\"add\", \"Subgroup\"]\n  | \"semigroup\"     => [\"add\", \"Semigroup\"]\n  | \"magma\"         => [",
      "suggestion": "\r\n    `fixAbbreviation [\"eventually\", \"LE\", \"_\", \"one\"]` to `\"eventuallyLE_one\"`, since otherwise the\r\n    substring `LE_zero` gets replaced by `Nonpos`. -/\r\n",
      "body": "```suggestion\r\n    `fixAbbreviation [\"eventually\", \"LE\", \"_\", \"one\"]` to `\"eventuallyLE_one\"`, since otherwise the\r\n    substring `LE_zero` gets replaced by `Nonpos`. -/\r\n```",
      "path": "Mathlib/Tactic/ToAdditive/GuessName.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "cases"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "cases"
        ],
        "topics": [
          "list",
          "measurability",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Indicator",
          "NSMul",
          "Monoid",
          "neg",
          "divisible",
          "IsCancelAdd",
          "String",
          "subtractionMonoid",
          "isUpper",
          "submonoid",
          "isCancelAdd",
          "next",
          "AddCancel",
          "mul",
          "isLeftCancelAdd",
          "Unit",
          "add",
          "work",
          "else",
          "Neg",
          "Quotient",
          "grp",
          "rootable",
          "Division",
          "toUpper",
          "prone",
          "Has",
          "Nonpos",
          "Group",
          "reduce",
          "like",
          "Cancel",
          "hmul",
          "Unique",
          "few",
          "def",
          "well",
          "addRightCancel",
          "isOfFinAddOrder",
          "mconv",
          "return",
          "addQuotientMeasure",
          "naming",
          "input",
          "output",
          "subgroup",
          "Commute",
          "that",
          "finsum",
          "capitalizeLikeAux"
        ]
      }
    },
    {
      "id": 3393,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "\r\ntheorem iterate_derivative_derivative_mul_X_pow {n m l : \u2115} (p : R[X]) (hl : m \u2264 l) :\r\n    derivative^[n] (derivative^[l] p * X ^ m) =\r\n      \u2211 k \u2208 range (min m n).succ,\r\n        ((n.choose k * m.descFactorial k) \u2022 (derivative^[n + (l - k)] p * X ^ (m - k))) := by\r\n  have {k : \u2115} (hk : k \u2208 range (min m n).succ) : n - k + l = n + (l - k) := by\r\n    replace hk : k \u2264 m \u2227 k \u2264 n := by simpa using hk\r\n    grind\r\n  simp_rw [iterate_derivative_mul_X_pow, \u2190 Function.iterate_add_apply]\r\n  exact Finset.sum_congr rfl fun k hk \u21a6 by simp [this hk]\r\n",
      "body": "I'm also dubious about this lemma since it's really just an extension of `iterate_derivative_mul_X_pow` which inlines a proof that `n + (m - k) = n - k + m` for `k` in the right range.\r\n\r\nOf course convenience lemmas can be justified if they come up enough. If you do have compelling evidence in favour then I think we should generalise since the repeated `m` is not relevant, and also avoid using low-level lemmas like `Nat.add_sub_assoc` as follows:\r\n```suggestion\r\ntheorem iterate_derivative_deriv",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "grind",
          "have",
          "simpa",
          "simp"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 3395,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "theorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n    simp_rw [iterate_derivative_mul, iterate_derivative_X_pow_eq_smul, mul_smul]\n    congr! 2 with k hk\n    norm_cast\n    ring\n  rw [hsum]\n  refine sum_congr_of_eq_on_inter (fun k hk hk' \u21a6 ?_) (by aesop) (by simp)\n  rcases le_or_gt k m with hkm | hkm\n  \u00b7 replace hk' : n < k := by simpa [hkm] using hk'\n    simp [Nat.choose_eq_zero_of_lt hk']\n  \u00b7 simp [Nat.descFactorial_eq_zero_iff_lt.mpr hkm]\n",
      "body": "Here's a slight golf. It's happens to be shorter but my main aim was to make the formal proof match how I think about this argument a bit more closely:\n```suggestion\ntheorem iterate_derivative_mul_X_pow (n m : \u2115) (p : R[X]) :\n    derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range (min m n).succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivative^[n - k] p * X ^ (m - k)) := by\n  have hsum : derivative^[n] (p * X ^ m) =\n      \u2211 k \u2208 range n.succ,\n        (n.choose k * m.descFactorial k) \u2022 (derivati",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "ring",
          "norm_cast"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "ring",
          "norm_cast"
        ],
        "new_tactics": [
          "aesop",
          "refine",
          "cases",
          "have",
          "simpa",
          "rw",
          "simp",
          "congr",
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_ring",
          "use_aesop"
        ],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 3396,
      "before_code": "map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\ndef toModuleCatObj : Submodule R M :=\r\n  LinearMap.range (\u03c4\u2081\u2082 := .id _) <|\r\n    { __ := DistribMulAction.toAddMonoidHom M (single default default 1 : Matrix \u03b9 \u03b9 R)\r\n      map_smul' r x := by\r\n        dsimp\r\n        rw [\u2190 smul_assoc r, Matrix.smul_eq_diagonal_mul, show (diagonal fun x : \u03b9 \u21a6 r) *\r\n          single _ _ 1 = single default default 1 * diagonal (fun _ \u21a6 r) by ext; simp [Matrix.single],\r\n          SemigroupAction.mul_smul, \u2190 Matrix.smul_one_eq_diagonal]\r\n        nth_rw 1 [\u2190 one_smul (Matrix \u03b9 \u03b9 R) x]\r\n        rw [smul_assoc] }\r\n",
      "body": "Perhaps nicer to build the map first:\r\n```suggestion\r\ndef toModuleCatObj : Submodule R M :=\r\n  LinearMap.range (\u03c4\u2081\u2082 := .id _) <|\r\n    { __ := DistribMulAction.toAddMonoidHom M (single default default 1 : Matrix \u03b9 \u03b9 R)\r\n      map_smul' r x := by\r\n        dsimp\r\n        rw [\u2190 smul_assoc r, Matrix.smul_eq_diagonal_mul, show (diagonal fun x : \u03b9 \u21a6 r) *\r\n          single _ _ 1 = single default default 1 * diagonal (fun _ \u21a6 r) by ext; simp [Matrix.single],\r\n          SemigroupAction.mul_smul, \u2190 Matrix.",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "LinearMap",
          "map_comp",
          "mapMatrixModule",
          "mapMatrixModule_id",
          "map",
          "ModuleCat",
          "hom_ext",
          "ofHom",
          "mapMatrixModule_comp",
          "map_id"
        ]
      }
    },
    {
      "id": 3397,
      "before_code": "map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\n  invFun x := \u27e8Pi.single i x, Function.const \u03b9 x, by\r\n",
      "body": "```suggestion\r\n  invFun x := \u27e8Pi.single i x, Function.const \u03b9 x, by\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "LinearMap",
          "map_comp",
          "mapMatrixModule",
          "mapMatrixModule_id",
          "map",
          "ModuleCat",
          "hom_ext",
          "ofHom",
          "mapMatrixModule_comp",
          "map_id"
        ]
      }
    },
    {
      "id": 3398,
      "before_code": "map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\n/-- The functor from Module Cat of `M\u2099(R)` to Module Cat of `R` induced by sending `M` to\r\n",
      "body": "```suggestion\r\n/-- The functor from Module Cat of `M\u2099(R)` to Module Cat of `R` induced by sending `M` to\r\n```\r\nI'm also not sure that \"from Module Cat\" is good English here",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "LinearMap",
          "map_comp",
          "mapMatrixModule",
          "mapMatrixModule_id",
          "map",
          "ModuleCat",
          "hom_ext",
          "ofHom",
          "mapMatrixModule_comp",
          "map_id"
        ]
      }
    },
    {
      "id": 3401,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n",
      "body": "For this sort of argument (where `fun_prop` can't quite close the goal alone), I find it works well to put auxiliary facts into the context and then run `fun_prop` with a custom discharger:\r\n ```suggestion\r\n    \u00b7 have : AnalyticAt \u2102 \u2118[L - l\u2080] l\u2080 := L.analyticOnNhd_weierstrassPExcept l\u2080 l\u2080 (by simp)\r\n      suffices AnalyticAt \u2102 (fun z \u21a6 (z - l\u2080) ^ 2 / l\u2080 ^ 2) l\u2080 by fun_prop\r\n      by_cases hl\u2080 : l\u2080 = 0\r\n      \u00b7 simpa [hl\u2080] using analyticAt_const\r\n      \u00b7 fun_prop (disch := simpa)\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "fun_prop",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "use_fun_prop"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 3402,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n",
      "body": "We can use more automation here too:\r\n```suggestion\r\nlemma meromorphicAt_weierstrassP (x : \u2102) : MeromorphicAt \u2118[L] x := by\r\n  by_cases hx : x \u2208 L.lattice\r\n  \u00b7 simp_rw [\u2190 funext <| L.weierstrassPExcept_add \u27e8x, hx\u27e9]\r\n    have := (analyticOnNhd_weierstrassPExcept L x x (by simp)).meromorphicAt\r\n    fun_prop\r\n  \u00b7 exact (L.analyticOnNhd_weierstrassP x hx).meromorphicAt\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "funext",
          "exact",
          "have",
          "simp",
          "fun_prop"
        ],
        "body_tactics": [
          "funext",
          "exact",
          "have",
          "simp",
          "fun_prop"
        ],
        "new_tactics": [
          "funext",
          "simp",
          "exact",
          "fun_prop",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 3405,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194 Nonempty (G.CompleteBipartiteSubgraph (card \u03b1) (card \u03b2)) where\r\n  mp := fun \u27e8f\u27e9 \u21a6 \u27e8CompleteBipartiteSubgraph.ofCopy f\u27e9\r\n  mpr := fun \u27e8B\u27e9 \u21a6 \u27e8B.toCopy.comp <| Iso.toCopy \u27e8(equivFin \u03b1).sumCongr (equivFin \u03b2), by simp\u27e9\u27e9\r\n",
      "body": "nit:\r\n```suggestion\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194 Nonempty (G.CompleteBipartiteSubgraph (card \u03b1) (card \u03b2)) where\r\n  mp := fun \u27e8f\u27e9 \u21a6 \u27e8CompleteBipartiteSubgraph.ofCopy f\u27e9\r\n  mpr := fun \u27e8B\u27e9 \u21a6 \u27e8B.toCopy.comp <| Iso.toCopy \u27e8(equivFin \u03b1).sumCongr (equivFin \u03b2), by simp\u27e9\u27e9\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 3413,
      "before_code": "lemma reciprocalFactors_odd {n : \u2115} (h1 : n \u2260 1) (h2 : Odd n) :\n    reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1) := by\n  have h0 : n \u2260 0 := by\n    rintro rfl\n    norm_num [\u2190 Nat.not_even_iff_odd] at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.not_even_iff_odd.2 h2)]",
      "suggestion": "\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n",
      "body": "this is 10x slower than the previous proof. What about changing it to something like this?\r\n```suggestion\r\n  rw [reciprocalFactors, dif_neg (by grind), dif_neg h1, if_neg (by simpa)]\r\n```\r\nso same as before, but the `n \u2260 0` is by `grind`.",
      "path": "Mathlib/GroupTheory/CommutingProbability.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "grind"
        ],
        "removed_tactics": [
          "norm_num",
          "have"
        ],
        "topics": [
          "nat",
          "norm"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "norm_num",
          "reciprocalFactors_odd",
          "lemma",
          "reciprocalFactors",
          "not_even_iff_odd",
          "Odd",
          "Nat",
          "dif_neg",
          "have",
          "rintro",
          "if_neg",
          "rfl"
        ]
      }
    },
    {
      "id": 3418,
      "before_code": "(fun _ _ _ _ he => AffineIndependent.injective s\u2081.independent he)\n      (fun _ _ _ _ he => AffineIndependent.injective s\u2082.independent he) h",
      "suggestion": "  exact affineSpan_mono _ (by simp) (s.faceOppositeCentroid_mem_affineSpan_face i)\n",
      "body": "```suggestion\n  exact affineSpan_mono _ (by simp) (s.faceOppositeCentroid_mem_affineSpan_face i)\n```\nDoes this work? If so, I wonder if this one-line should be an extra lemma. It seems to me that it can just be inlined when needed.",
      "path": "Mathlib/LinearAlgebra/AffineSpace/Simplex/Centroid.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "independent",
          "AffineIndependent",
          "injective"
        ]
      }
    },
    {
      "id": 3420,
      "before_code": "simp\n    \u00b7 simp [IH _ (le_of_lt_succ (div_lt_self' n b)), pow_succ', Nat.div_div_eq_div_mul]\n\nend Nat",
      "suggestion": "    Finset (List \u2115) := Finset.image (fun L \u21a6 d :: L) (fixedLengthDigits hb l)\n",
      "body": "```suggestion\n    Finset (List \u2115) := Finset.image (fun L \u21a6 d :: L) (fixedLengthDigits hb l)\n```",
      "path": "Mathlib/Data/Nat/Digits/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "div_div_eq_div_mul",
          "end",
          "div_lt_self",
          "pow_succ",
          "Nat",
          "simp",
          "le_of_lt_succ"
        ]
      }
    },
    {
      "id": 3422,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_one' := by simp\r\n        mul_le' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_mul_le_add p.1 x y) <| add_le_add _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 _\r\n            \u00b7 use q y\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 _\r\n          \u00b7 simp_all\r\n        inv' x := by simp }\r\n",
      "body": "same proofs, just significantly shorter and easier to read\r\n\r\n```suggestion\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_one' := by simp\r\n        mul_le' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_mul_le_add p.1 x y) <| add_le_add _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "refine",
          "simp_all",
          "simp",
          "exact",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "com",
          "https",
          "add_apply",
          "theorem",
          "too",
          "pull",
          "skeleton",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "rfl",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 3423,
      "before_code": "instance : Inhabited (NonarchAddGroupSeminorm E) :=\n  \u27e80\u27e9\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_zero' := by simp\r\n        add_le_max' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_add_le_max p.1 x y) <| max_le_max _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 x\r\n            \u00b7 use q y\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exact hq p' p'.2 y\r\n          \u00b7 simp_all\r\n        neg' x := congr(\u2a06 _, $(map_neg_eq_map _ x)) }\r\n",
      "body": "```suggestion\r\n      { toFun x := \u2a06 p : s, p.1 x\r\n        map_zero' := by simp\r\n        add_le_max' x y := by\r\n          by_cases! hs : s.Nonempty\r\n          \u00b7 have : Nonempty s := hs.to_subtype\r\n            apply ciSup_le fun p \u21a6 ?_\r\n            apply le_trans (map_add_le_max p.1 x y) <| max_le_max _ _ <;>\r\n              refine le_ciSup (f := fun p : s \u21a6 p.1 _) ?_ p <;>\r\n              obtain \u27e8q, hq\u27e9 := bddAbove_def.mp h\r\n            \u00b7 use q x\r\n              rintro r \u27e8p', rfl\u27e9\r\n              exa",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "simp_all",
          "simp",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "com",
          "https",
          "Inhabited",
          "too",
          "pull",
          "skeleton",
          "NonarchAddGroupSeminorm",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "instance",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 3424,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345",
      "suggestion": "noncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n            all_goals\n              apply le_ciSup (f := (DFunLike.coe \u00b7 _) \u2218 Subtype.val) ?_ p\n              simpa [Set.range_comp] using Monotone.map_bddAbove (fun _ _ h' \u21a6 by exact h' _) h\n        inv' x := by simp }\n    else 0\n",
      "body": "I think `where` syntax is nicer here, and I provided a small golf to avoid the case split.\n```suggestion\nnoncomputable instance : SupSet (GroupSeminorm E) where\n  sSup s :=\n    if h : BddAbove s then\n      { toFun x := \u2a06 p : s, p.1 x\n        map_one' := by simp\n        mul_le' x y := by\n          obtain (rfl | hs) := eq_empty_or_nonempty s\n          \u00b7 simp\n          \u00b7 have : Nonempty s := hs.to_subtype\n            refine ciSup_le fun p \u21a6 (map_mul_le_add p.1 x y).trans ?_\n            gcongr\n     ",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "obtain",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa",
          "term_mode"
        ],
        "keywords": [
          "community",
          "com",
          "https",
          "add_apply",
          "theorem",
          "too",
          "pull",
          "skeleton",
          "github",
          "issuecomment",
          "mathlib",
          "from",
          "leanprover",
          "rfl",
          "define",
          "TODO",
          "SupSet"
        ]
      }
    },
    {
      "id": 3425,
      "before_code": "theorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345\n@[to_additive]\ninstance : Max (GroupSeminorm E) :=",
      "suggestion": "\nlemma sSup_of_not_bddAbove {s : Set (GroupSeminorm E)} (hs : \u00acBddAbove s) :\n    sSup s = 0 := by\n  simp [SupSet.sSup, hs]\n\nlemma coe_sSup_apply {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = \u2a06 p : s, (p : GroupSeminorm E) x := by\n  simp [SupSet.sSup, hs]\n  rfl\n\nlemma coe_sSup_apply' {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = sSup ((\u00b7 x) '' s) := by\n  rw [coe_sSup_apply hs, \u2190 sSup_range]\n  congr\n  ext\n  simp\n\nlemma coe_iSup_apply {\u03b9 : Type*} (f : \u03b9 \u2192 GroupSeminorm E) (h : BddAbove (range f)) {x : E} :\n    \u21d1(\u2a06 i, f i) x = \u2a06 i, (f i : GroupSeminorm E) x := by\n  rw [\u2190 sSup_range, coe_sSup_apply h]\n  exact (Set.rangeFactorization_surjective.iSup_congr _ (by simp)) |>.symm\n\n@[to_additive]\ninstance : Max (GroupSeminorm E) :=\n",
      "body": "you should have these lemmas available for rewriting\n```suggestion\n\nlemma sSup_of_not_bddAbove {s : Set (GroupSeminorm E)} (hs : \u00acBddAbove s) :\n    sSup s = 0 := by\n  simp [SupSet.sSup, hs]\n\nlemma coe_sSup_apply {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = \u2a06 p : s, (p : GroupSeminorm E) x := by\n  simp [SupSet.sSup, hs]\n  rfl\n\nlemma coe_sSup_apply' {s : Set (GroupSeminorm E)} (hs : BddAbove s) {x : E} :\n    \u21d1(sSup s) x = sSup ((\u00b7 x) '' s) := by\n  rw [coe_sSup_apply hs",
      "path": "Mathlib/Analysis/Normed/Group/Seminorm.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext",
          "exact",
          "rw",
          "simp",
          "congr"
        ],
        "body_tactics": [
          "ext",
          "exact",
          "have",
          "rw",
          "simp",
          "congr"
        ],
        "new_tactics": [
          "rw",
          "simp",
          "ext",
          "exact",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "skeleton",
          "GroupSeminorm",
          "github",
          "Max",
          "TODO",
          "SupSet",
          "to_additive",
          "add_apply",
          "leanprover",
          "com",
          "issuecomment",
          "rfl",
          "https",
          "theorem",
          "too",
          "pull",
          "mathlib",
          "from",
          "instance",
          "define"
        ]
      }
    },
    {
      "id": 3426,
      "before_code": "natDegree (\u2211 i \u2208 s, f i) \u2264 n :=\n  le_trans (natDegree_sum_le s f) <| (Finset.fold_max_le n).mpr <| by simpa",
      "suggestion": "  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n",
      "body": "```suggestion\n  obtain _ | d := d\n  \u00b7 simp_all [WithBot.none_eq_bot]\n  \u00b7 replace hd k (hk : k \u2208 s) : (f k).natDegree = d := natDegree_eq_of_degree_eq_some <| hd k hk\n    suffices (\u2211 k \u2208 s, f k).natDegree = d by simp_all [leadingCoeff]\n    apply natDegree_eq_of_le_of_coeff_ne_zero\n    \u00b7 aesop (add safe natDegree_sum_le_of_forall_le)\n    \u00b7 simp_all [leadingCoeff]\n```",
      "path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "body_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "new_tactics": [
          "apply",
          "obtain",
          "aesop",
          "simp_all"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "natDegree_sum_le",
          "natDegree",
          "mpr",
          "fold_max_le",
          "Finset",
          "simpa",
          "le_trans"
        ]
      }
    },
    {
      "id": 3427,
      "before_code": "theorem option_map\u2081 {f : \u03b1 \u2192 \u03c3} (hf : Primrec f) : Primrec (Option.map f) :=\n  option_map .id (hf.comp snd).to\u2082\n\ntheorem option_iget [Inhabited \u03b1] : Primrec (@Option.iget \u03b1 _) :=\n  (option_casesOn .id (const <| @default \u03b1 _) .right).of_eq fun o => by cases o <;> rfl",
      "suggestion": "\r\ntheorem option_iget [Inhabited \u03b1] : Primrec (fun o : Option \u03b1 => o.iget) :=\r\n",
      "body": "```suggestion\r\ntheorem option_iget [Inhabited \u03b1] : Primrec (fun o : Option \u03b1 => o.iget) :=\r\n```\r\nwith `set_option` to disable the deprecation",
      "path": "Mathlib/Computability/Primrec.lean",
      "tags": {
        "before_tactics": [
          "cases"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "right",
          "of_eq",
          "theorem",
          "Inhabited",
          "cases",
          "Option",
          "const",
          "map",
          "comp",
          "option_iget",
          "default",
          "iget",
          "Primrec",
          "rfl",
          "option_casesOn",
          "snd",
          "option_map"
        ]
      }
    },
    {
      "id": 3436,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n",
      "body": "```suggestion\n  have hs_nemp : (\u0399 a b).Nonempty := nonempty_of_measure_ne_zero h\u03bc0\n```\n`by exact` should be dropped most of the time.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "exact",
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [
          "term_mode"
        ],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 3437,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "  have h : a \u2260 b := by intro hab; simp [hab] at h\u03bc0\n",
      "body": "```suggestion\n  have h : a \u2260 b := by intro hab; simp [hab] at h\u03bc0\n```\nNo need to `subst`, it's something `simp` can do.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "simp",
          "have",
          "intro"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 3438,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]\n\n/-- The mean value theorem for integrals:\nThere exists a point in an interval such that the mean of a continuous function over the interval\nequals the value of the function at the point. -/\ntheorem exists_eq_interval_average\n    {f : \u211d \u2192 \u211d} {a b : \u211d} (hab : a \u2260 b) (hf : ContinuousOn f (uIcc a b)) :\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d (x : \u211d) in a..b, f x := by\n  wlog h : a < b generalizing a b\n  \u00b7 rw [uIcc_comm] at hf\n    have := this hab.symm hf (lt_of_le_of_ne (le_of_not_gt h) (Ne.symm hab))\n    rwa [uIoo_comm, interval_average_symm] at this\n  let ave := \u2a0d (x : \u211d) in a..b, f x\n  have h_vol_fin1 : volume (uIoc a b) \u2260 0 := by simpa [h.le] using h\n  have h_vol_fin2 : volume (uIoc a b) \u2260 \u22a4 := by simp [h.le]\n  have h_intble : IntegrableOn f (uIoc a b) := by\n    have : IntegrableOn f (uIcc a b) := hf.integrableOn_uIcc\n    rwa [uIcc_of_lt h,integrableOn_Icc_iff_integrableOn_Ioc, \u2190uIoc_of_le (le_of_lt h)] at this\n  let S1 := {x | x \u2208 uIoc a b \u2227 f x \u2264 ave}\n  let S2 := {x | x \u2208 uIoc a b \u2227 ave \u2264 f x}\n  have h_meas1 : volume (S1 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_le_setAverage_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  have h_meas2 : volume (S2 \\ {b}) \u2260 0 := by\n    rw [measure_diff_null Real.volume_singleton]\n    exact (measure_setAverage_le_pos h_vol_fin1 h_vol_fin2 h_intble).ne'\n  obtain \u27e8c1, \u27e8hc1_mem, hc1_le\u27e9, hc1'\u27e9 := nonempty_of_measure_ne_zero h_meas1\n  have hc1' : c1 \u2208 Ioo a b := by\n    rw [Set.uIoc_of_le (le_of_lt h)] at hc1_mem\n    rw [notMem_singleton_iff] at hc1'\n    exact \u27e8hc1_mem.1, lt_of_le_of_ne hc1_mem.2 hc1'\u27e9\n  obtain \u27e8c2, \u27e8hc2_mem, hc2_ge\u27e9, hc2'\u27e9 := nonempty_of_measure_ne_zero h_meas2\n  have hc2' : c2 \u2208 Ioo a b := by\n    rw [Se",
      "suggestion": "    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n",
      "body": "```suggestion\n    \u2203 c \u2208 uIoo a b, f c = \u2a0d x in a..b, f x :=\n  exists_eq_interval_average_of_noAtoms hf (by simp) (by simpa using sub_ne_zero.mpr hab.symm)\n```\nsimp lemmas that you register elsewhere in the PR make the proof very direct!",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "cases",
          "have",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "continuity",
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "rwa",
          "codiscreteWithin",
          "interval_average_symm",
          "intervalIntegral",
          "le_of_lt",
          "Ioo_subset_Icc_self",
          "have",
          "mem_Ioo",
          "Filter",
          "notMem_singleton_iff",
          "integrableOn_uIcc",
          "intro",
          "hc2_mem",
          "such",
          "uIoc_of_le",
          "hab",
          "that",
          "simp",
          "h_ave",
          "volume",
          "theorem",
          "h_vol_fin2",
          "h_meas1",
          "h_meas2",
          "value",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "lt_of_lt_of_le",
          "There",
          "point",
          "imp",
          "uIcc",
          "intermediate_value_uIcc",
          "h_intble",
          "uIoo",
          "IntegrableOn",
          "hc1_mem",
          "continuous",
          "hc1_le",
          "hc1",
          "generalizing",
          "lt_of_le_of_ne",
          "interval",
          "Icc",
          "ave",
          "hc2",
          "measure_diff_null",
          "Ioo",
          "hc2_ge",
          "integrals"
        ]
      }
    },
    {
      "id": 3446,
      "before_code": "(isMulCocycle\u2081_of_mem_cocycles\u2081 _ x.2) with \u27e8\u03b2, h\u03b2\u27e9\n    use \u03b2",
      "suggestion": "  have := FiniteCyclicGroup.groupCohomology\u03c0Odd_eq_zero_iff (ofAlgebraAutOnUnits K L) g hg\n",
      "body": "There are two consecutive spaces between `groupCohomology\u03c0Odd_eq_zero_iff` and `(ofAlgebraAutOnUnits K L)`. This should be a single space for consistent formatting.\n```suggestion\n  have := FiniteCyclicGroup.groupCohomology\u03c0Odd_eq_zero_iff (ofAlgebraAutOnUnits K L) g hg\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/Hilbert90.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "use"
        ]
      }
    },
    {
      "id": 3447,
      "before_code": "2-coboundary for the representation on `M` induced by the `MulDistribMulAction`. -/",
      "suggestion": "2-coboundary for the representation on `Additive M` induced by the `MulDistribMulAction`. -/\n",
      "body": "The documentation comment says \"representation on `M`\" but should say \"representation on `Additive M`\" to be consistent with the documentation for `coboundariesOfIsMulCoboundary\u2081` on lines 899-901.\n```suggestion\n2-coboundary for the representation on `Additive M` induced by the `MulDistribMulAction`. -/\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/LowDegree.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "induced",
          "representation",
          "MulDistribMulAction",
          "coboundary",
          "for"
        ]
      }
    },
    {
      "id": 3448,
      "before_code": "(isMulCocycle\u2081_of_mem_cocycles\u2081 _ x.2) with \u27e8\u03b2, h\u03b2\u27e9\n    use \u03b2",
      "suggestion": "    have hxinv : Algebra.norm K x\u207b\u00b9 = 1 := by simp [Algebra.norm_inv, hx]\n    obtain \u27e8y, hy\u27e9 := H _ hxinv\n    use y\n    rw [IsUnit.div_eq_iff y.isUnit] at hy\n    rw [hy]\n    field_simp\n",
      "body": "```suggestion\n    have hxinv : Algebra.norm K x\u207b\u00b9 = 1 := by simp [Algebra.norm_inv, hx]\n    obtain \u27e8y, hy\u27e9 := H _ hxinv\n    use y\n    rw [IsUnit.div_eq_iff y.isUnit] at hy\n    rw [hy]\n    field_simp\n```",
      "path": "Mathlib/RepresentationTheory/Homological/GroupCohomology/Hilbert90.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "field_simp",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "field_simp",
          "have",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "obtain",
          "field_simp",
          "rw",
          "simp",
          "have"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "use"
        ]
      }
    },
    {
      "id": 3451,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9",
      "suggestion": "lemma tendsto_nhds_top_iff {\u03b1 : Type*} {f : Filter \u03b1} (x : \u03b1 \u2192 WithTop \u03b9) :\n    Tendsto x f (\ud835\udcdd \u22a4) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (a : \u03b1) in f, i < x a := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using .of_forall fun _ \u21a6 Subsingleton.elim ..\n  refine nhds_top_basis.tendsto_right_iff.trans ?_\n  rw [\u2190 Set.forall_mem_range (p := (\u2200\u1da0 a in f, \u00b7 < x a)), WithTop.range_coe]\n  simp\n",
      "body": "You can avoid the `Nonempty` hypothesis and simplify the proof like so:\n```suggestion\nlemma tendsto_nhds_top_iff {\u03b1 : Type*} {f : Filter \u03b1} (x : \u03b1 \u2192 WithTop \u03b9) :\n    Tendsto x f (\ud835\udcdd \u22a4) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (a : \u03b1) in f, i < x a := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using .of_forall fun _ \u21a6 Subsingleton.elim ..\n  refine nhds_top_basis.tendsto_right_iff.trans ?_\n  rw [\u2190 Set.forall_mem_range (p := (\u2200\u1da0 a in f, \u00b7 < x a)), WithTop.range_coe]\n  simp\n```",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 3452,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9",
      "suggestion": "",
      "body": "This can be proven by `simp_rw [WithTop.tendsto_nhds_top_iff, eventually_atTop]`, so I think it's not really necessary.\n```suggestion\n```",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 3453,
      "before_code": "exact Continuous.comp_continuousOn (by fun_prop) continuousOn_untopA\n  continuous_invFun := continuous_sum_dom.mpr \u27e8by fun_prop, by fun_prop\u27e9\n\nend WithTop",
      "suggestion": "",
      "body": "If you add this lemma (in the `WithTop` namespace):\n```lean\nlemma tendsto_coe_atTop [NoMaxOrder \u03b9] :\n    Tendsto ((\u2191) : \u03b9 \u2192 WithTop \u03b9) atTop (\ud835\udcdd \u22a4) := by\n  obtain (h | h) := isEmpty_or_nonempty \u03b9\n  \u00b7 simpa using Subsingleton.elim ..\n  rw [tendsto_nhds_top_iff]\n  intro i\n  filter_upwards [atTop_basis_Ioi.mem_of_mem (i := i) trivial]\n  simp\n```\nThen you can prove the highlighted lemma as simply as:\n```lean\ntheorem Tendsto.tendsto_withTop_atTop_nhds_top {\u03b9 : Type*}\n    [Nonempty \u03b9] [LinearOrder \u03b9] [",
      "path": "Mathlib/Topology/Order/WithTop.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "fun_prop"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "fun_prop"
        ],
        "topics": [
          "continuity",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "WithTop",
          "end",
          "exact",
          "comp_continuousOn",
          "continuous_sum_dom",
          "continuousOn_untopA",
          "Continuous",
          "fun_prop",
          "continuous_invFun"
        ]
      }
    },
    {
      "id": 3458,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, n = p \u2022 m :=\n      \u27e8Finsupp.equivFunOnFinite.symm fun i => n i / p, by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, n = p \u2022 m :=\n      \u27e8Finsupp.equivFunOnFinite.symm fun i => n i / p, by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 3459,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, d = p \u2022 m := \u27e8Finsupp.equivFunOnFinite.symm fun i => d i / p,\n      by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n",
      "body": "```suggestion\n  \u00b7 obtain \u27e8m, hm\u27e9 : \u2203 m, d = p \u2022 m := \u27e8Finsupp.equivFunOnFinite.symm fun i => d i / p,\n      by ext i; simp [(Nat.mul_div_cancel' (h i))]\u27e9\n```\nAre there more examples of this pattern?",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "body_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "new_tactics": [
          "obtain",
          "simp",
          "ext"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 3460,
      "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
      "suggestion": "theorem G\u2082_det : G\u2082.det = 1 := by decide\n\ntheorem F\u2084_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2086_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2087_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2088_det : F\u2084.det = 1 := by decide\n",
      "body": "It looks to me like there is no need to tinker with `maxRecDepth` or to exclude the higher rank cases:\n```suggestion\ntheorem G\u2082_det : G\u2082.det = 1 := by decide\n\ntheorem F\u2084_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2086_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2087_det : F\u2084.det = 1 := by decide\n\ntheorem E\u2088_det : F\u2084.det = 1 := by decide\n```\nI'd also add that proving these `by decide` is a bit of a last resort and if we had needed to bump `maxRecDepth`, then I would not be in favour.\n\nI'm slightly surprised t",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "decide",
          "simp"
        ],
        "suggestion_tactics": [
          "decide"
        ],
        "body_tactics": [
          "decide",
          "cases",
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "decide",
          "transpose",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 3461,
      "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
      "suggestion": "/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced := by\n  rw [IsSimplyLaced, IsSimplyLaced, Pairwise, Pairwise, forall_comm]\n  aesop\n\ntheorem isSimplyLaced_A (n : \u2115) : IsSimplyLaced (A n) := by\n  intro i j h\n  simp only [A, of_apply]\n  grind\n\ntheorem isSimplyLaced_D (n : \u2115) : IsSimplyLaced (D n) := by\n  intro i j h\n  simp only [D, of_apply]\n  grind\n\ntheorem isSimplyLaced_E\u2086 : IsSimplyLaced E\u2086 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2086] at h \u22a2\n\ntheorem isSimplyLaced_E\u2087 : IsSimplyLaced E\u2087 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2087] at h \u22a2\n\ntheorem isSimplyLaced_E\u2088 : IsSimplyLaced E\u2088 :=\n  fun i j h \u21a6 by fin_cases i <;> fin_cases j <;> simp [E\u2088] at h \u22a2\n",
      "body": "I've never seen being symmetric as a definition of begin simply laced before. Where does this come from?\n\nI would have expected something like:\n```suggestion\n/-- A Cartan matrix is simply laced if its off-diagonal entries are all `0` or `-1`. -/\ndef _root_.Matrix.IsSimplyLaced {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) : Prop :=\n  Pairwise fun i j \u21a6 A i j = 0 \u2228 A i j = -1\n\n@[simp] theorem _root_.Matrix.isSimplyLaced_transpose {\u03b9 : Type*} (A : Matrix \u03b9 \u03b9 \u2124) :\n    A.transpose.IsSimplyLaced \u2194 A.IsSimplyLaced :",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "decide",
          "simp"
        ],
        "suggestion_tactics": [
          "aesop",
          "grind",
          "fin_cases",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "aesop",
          "grind",
          "have",
          "fin_cases",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "aesop",
          "grind",
          "fin_cases",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "decide"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp",
          "use_aesop",
          "use_grind"
        ],
        "keywords": [
          "decide",
          "transpose",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 3463,
      "before_code": "(\u22a4 : NonUnitalSubalgebra R A).toNonUnitalSubring = \u22a4 :=\n  rfl\n\n@[simp]\ntheorem toSubmodule_eq_top {S : NonUnitalSubalgebra R A} : S.toSubmodule = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toSubmodule'.injective.eq_iff' top_toSubmodule\n\n@[simp]\ntheorem toNonUnitalSubsemiring_eq_top {S : NonUnitalSubalgebra R A} :\n    S.toNonUnitalSubsemiring = \u22a4 \u2194 S = \u22a4 :=\n  NonUnitalSubalgebra.toNonUnitalSubsemiring_injective.eq_iff' top_toNonUnitalSubsemiring",
      "suggestion": "\r\n-- This lemma isn't simp because `NonUnitalSubalgebra.toSubmodule` is a \"fake\" projection,\r\n-- which is syntactically a constructor application.\r\n",
      "body": "Then it is proved by `simp only [Submodule.mk_eq_top, NonUnitalSubsemiring.toAddSubmonoid_eq_top, toNonUnitalSubsemiring_eq_top]`. I guess I should have said\r\n```suggestion\r\n-- This lemma isn't simp because `NonUnitalSubalgebra.toSubmodule` is a \"fake\" projection,\r\n-- which is syntactically a constructor application.\r\n```\r\ninstead",
      "path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "constructor",
          "simp"
        ],
        "body_tactics": [
          "have",
          "constructor",
          "simp"
        ],
        "new_tactics": [
          "constructor"
        ],
        "removed_tactics": [],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp",
          "use_simp"
        ],
        "keywords": [
          "toNonUnitalSubsemiring",
          "toSubmodule",
          "theorem",
          "top_toSubmodule",
          "NonUnitalSubalgebra",
          "toNonUnitalSubring",
          "eq_iff",
          "toNonUnitalSubsemiring_injective",
          "toSubmodule_eq_top",
          "simp",
          "rfl",
          "injective",
          "toNonUnitalSubsemiring_eq_top",
          "top_toNonUnitalSubsemiring"
        ]
      }
    },
    {
      "id": 3465,
      "before_code": "theorem mul_natCast_floor_div_cancel {n : \u2115} (hn : n \u2260 0) (a : R) : \u230aa * n\u230b / n = \u230aa\u230b := by\n  simpa using mul_cast_floor_div_cancel_of_pos (n := n) (by positivity) a",
      "suggestion": "\r\ntheorem mul_fract_eq_one_iff_exists_int {x : R} {k : R} (hk : 1 < k) :\r\n    k * fract x = 1 \u2194 \u2203 n : \u2124, k * x = k * n + 1 := by\r\n  rw [fract, mul_sub, sub_eq_iff_eq_add']\r\n  refine \u27e8fun hx \u21a6 \u27e8\u230ax\u230b, hx\u27e9, ?_\u27e9\r\n  rintro \u27e8n, hn\u27e9\r\n  convert hn\r\n  have hk0 : 0 < (k : R) := zero_le_one.trans_lt hk\r\n  rw [floor_eq_iff, \u2190 mul_le_mul_iff_right\u2080 hk0, \u2190 mul_lt_mul_iff_right\u2080 hk0, hn]\r\n  simp [mul_add, hk]\r\n",
      "body": "Better I think as\r\n```suggestion\r\ntheorem mul_fract_eq_one_iff_exists_int {x : R} {k : R} (hk : 1 < k) :\r\n    k * fract x = 1 \u2194 \u2203 n : \u2124, k * x = k * n + 1 := by\r\n  rw [fract, mul_sub, sub_eq_iff_eq_add']\r\n  refine \u27e8fun hx \u21a6 \u27e8\u230ax\u230b, hx\u27e9, ?_\u27e9\r\n  rintro \u27e8n, hn\u27e9\r\n  convert hn\r\n  have hk0 : 0 < (k : R) := zero_le_one.trans_lt hk\r\n  rw [floor_eq_iff, \u2190 mul_le_mul_iff_right\u2080 hk0, \u2190 mul_lt_mul_iff_right\u2080 hk0, hn]\r\n  simp [mul_add, hk]\r\n```",
      "path": "Mathlib/Algebra/Order/Floor/Ring.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "positivity"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have",
          "rw",
          "refine"
        ],
        "removed_tactics": [
          "simpa",
          "positivity"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mul_cast_floor_div_cancel_of_pos",
          "positivity",
          "theorem",
          "simpa",
          "mul_natCast_floor_div_cancel",
          "using"
        ]
      }
    },
    {
      "id": 3468,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\n  intro u c hc\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\n    have eneq : e \u2260 s(x,y) := fun h => h_bridge.2 c hc (h \u25b8 he)\n    simpa [eneq] using Walk.edges_subset_edgeSet c he)\n",
      "body": "Just style nits. The only one worth highlighting is that the pattern `apply my_lemma.mp` is almost always a synonym for `rw [my_lemma]`:\n```suggestion\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\n  intro u c hc\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\n    have eneq : e \u2260 s(x,y) := fun h => h_bridge.2 c hc (h \u25b8 he)\n    simpa [eneq] using Walk.edges_subset_edgeSet c he)\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "have",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "have",
          "intro"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3469,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "/-- A subgraph is maximal acyclic iff its reachability relation agrees with the larger graph. -/\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G \u2227 F.IsAcyclic) :\n    Maximal (fun H => H \u2264 G \u2227 H.IsAcyclic) F \u2194 F.Reachable = G.Reachable := by\n  refine \u27e8reachable_eq_of_maximal_isAcyclic F, fun h \u21a6 ?_\u27e9\n",
      "body": "We don't need to have both `maximal_isAcyclic_of_reachable_eq` and `maximal_isAcyclic_iff_reachable_eq` since the latter dominates the former so let's just collapse them together like this:\n```suggestion\n/-- A subgraph is maximal acyclic iff its reachability relation agrees with the larger graph. -/\ntheorem maximal_isAcyclic_iff_reachable_eq {F : SimpleGraph V} (hF : F \u2264 G \u2227 F.IsAcyclic) :\n    Maximal (fun H => H \u2264 G \u2227 H.IsAcyclic) F \u2194 F.Reachable = G.Reachable := by\n  refine \u27e8reachable_eq_of_ma",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine",
          "have"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3470,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  have : Nonempty V := hG.nonempty\n  refine \u27e8fun h \u21a6 \u27e8\u27e8fun u v \u21a6 ?_\u27e9, h.1.2\u27e9, fun hT' \u21a6 ?_\u27e9\n  \u00b7 rw [G.reachable_eq_of_maximal_isAcyclic T h]\n    exact hG.preconnected u v\n  \u00b7 rw [maximal_isAcyclic_iff_reachable_eq \u27e8hT, hT'.IsAcyclic\u27e9]\n    replace hT' : T.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hT'.isConnected.preconnected\n    replace hG : G.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hG.preconnected\n    rw [hT', hG]\n",
      "body": "What you have is probably fine but I worry that the call to `grind` is maybe a bit brittle so let's try:\n```suggestion\n  have : Nonempty V := hG.nonempty\n  refine \u27e8fun h \u21a6 \u27e8\u27e8fun u v \u21a6 ?_\u27e9, h.1.2\u27e9, fun hT' \u21a6 ?_\u27e9\n  \u00b7 rw [G.reachable_eq_of_maximal_isAcyclic T h]\n    exact hG.preconnected u v\n  \u00b7 rw [maximal_isAcyclic_iff_reachable_eq \u27e8hT, hT'.IsAcyclic\u27e9]\n    replace hT' : T.Reachable = \u22a4 := by\n      rw [\u2190 preconnected_iff_reachable_eq_top]\n      exact hT'.isConnected.preconnected\n    replace hG : G",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "exact",
          "refine",
          "rw",
          "have"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "grind",
          "have",
          "rw"
        ],
        "new_tactics": [
          "have",
          "rw",
          "refine"
        ],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3471,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "  obtain \u27e8\u27e8hF : F \u2264 G, hF' : F.IsAcyclic\u27e9, h\u27e9 := by simpa [Maximal] using h\n  ext u v\n  refine \u27e8fun h \u21a6 h.mono hF, ?_\u27e9\n  contrapose! h\n  obtain \u27e8\u27e8p : G.Walk u v\u27e9, h : \u00ac F.Reachable u v\u27e9 := h\n  let s : Set V := F.connectedComponentMk u\n  have hus : u \u2208 s := ConnectedComponent.connectedComponentMk_mem\n  have hvs : v \u2209 s := h \u2218 (F.connectedComponentMk u).reachable_of_mem_supp hus\n  obtain \u27e8\u27e8\u27e8u', v'\u27e9, huv : G.Adj u' v'\u27e9, -, hu : u' \u2208 s, hv : v' \u2209 s\u27e9 :=\n    p.exists_boundary_dart s hus hvs\n  suffices (F \u2294 fromEdgeSet {s(u', v')}).IsAcyclic by\n    refine \u27e8F \u2294 fromEdgeSet {s(u', v')}, ?_, this, le_sup_left, ?_\u27e9\n    \u00b7 have : G.Adj v' u' := G.symm huv\n      simp only [sup_le_iff, le_iff_adj, fromEdgeSet_adj, Set.mem_singleton_iff, Sym2.eq,\n        Sym2.rel_iff'] at hF \u22a2\n      grind\n    \u00b7 rw [le_iff_adj]\n      push_neg\n      refine \u27e8u', v', ?_, fun hc \u21a6 ?_\u27e9\n      \u00b7 simpa using Or.inr huv.ne\n      \u00b7 have := (F.connectedComponentMk u).mem_supp_congr_adj hc\n        grind\n  suffices \u00ac F.Reachable u'",
      "body": "The following is a slight golf. I was not trying to make it shorter though: I was trying to make it slightly more idiomatic and readable. I think what I've got is still not great but is acceptable (as was yours already). Two minor points I highlight are:\n\n- I've added various redundant type ascriptions (e.g., to the `obtain`s). These aid readability for a human.\n- I've use the `ext` tactic rather than directly calling the underlying very low-level `funext`, `propext`\n\nI also note that [Maximal](",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "funext",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "refine",
          "ext",
          "grind",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "remove_redundant",
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3472,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "\r\n    (G \u2294 fromEdgeSet {s(x, y)}).IsAcyclic \u2194 IsAcyclic G := by\r\n  refine \u27e8fun h \u21a6 h.anti le_sup_left, fun hG \u21a6 ?_\u27e9\r\n  have x_neq_y : x \u2260 y := fun c => (c \u25b8 hxy) (Reachable.refl y)\r\n  have h_add_remove : (G \u2294 fromEdgeSet {s(x, y)}) \\ fromEdgeSet {s(x, y)} = G := by\r\n    simpa using fun h => hxy h.reachable\r\n  have h_bridge : (G \u2294 fromEdgeSet {s(x, y)}).IsBridge s(x, y) := by\r\n    simpa [isBridge_iff, x_neq_y, h_add_remove]\r\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge\r\n  intro u c hc\r\n  let c' : G.Walk u u := Walk.transfer c G (fun e he \u21a6 by\r\n    have eneq : e \u2260 s(x, y) := fun h => h_bridge.2 c hc (h \u25b8 he)\r\n",
      "body": "```suggestion\r\n    (G \u2294 fromEdgeSet {s(x, y)}).IsAcyclic \u2194 IsAcyclic G := by\r\n  refine \u27e8fun h \u21a6 h.anti le_sup_left, fun hG \u21a6 ?_\u27e9\r\n  have x_neq_y : x \u2260 y := fun c => (c \u25b8 hxy) (Reachable.refl y)\r\n  have h_add_remove : (G \u2294 fromEdgeSet {s(x, y)}) \\ fromEdgeSet {s(x, y)} = G := by\r\n    simpa using fun h => hxy h.reachable\r\n  have h_bridge : (G \u2294 fromEdgeSet {s(x, y)}).IsBridge s(x, y) := by\r\n    simpa [isBridge_iff, x_neq_y, h_add_remove]\r\n  rw [isBridge_iff_adj_and_forall_cycle_notMem] at h_bridge",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "new_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "intro"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3474,
      "before_code": "open WithZeroMulInt\n\nvariable {R K} in",
      "suggestion": "\r\ndef intAdicAbvDef (r : R) : \u211d\u22650 := fun r \u21a6 toNNReal (ne_zero_of_lt hb) (v.intValuation r)\r\n",
      "body": "```suggestion\r\ndef intAdicAbvDef (r : R) : \u211d\u22650 := fun r \u21a6 toNNReal (ne_zero_of_lt hb) (v.intValuation r)\r\n```",
      "path": "Mathlib/RingTheory/DedekindDomain/AdicValuation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "open",
          "WithZeroMulInt",
          "variable"
        ]
      }
    },
    {
      "id": 3481,
      "before_code": "rcases h\u03be with \u27e8i, hin, hi, H\u27e9\n    exact \u27e8i, \u27e8hin, hi.symm\u27e9, H\u27e9",
      "suggestion": "\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n",
      "body": "```suggestion\r\n@[simps! apply_coe]\r\ndef primitiveRootsPowEquivOfCoprime {a n : \u2115} (h : a.Coprime n) [NeZero n] :\r\n    primitiveRoots n R \u2243 primitiveRoots n R :=\r\n  haveI h2 := Nat.exists_mul_mod_eq_of_coprime 1 h NeZero.out\r\n  haveI h3 : a * h2.choose \u2261 1 [MOD n] := by grind [Nat.ModEq]\r\n  primitiveRootsPowEquiv h3\r\n```\r\nI think it\u2019s better practice to inline the \"haves\" when in term mode with a non-prop goal like this.\r\n\r\nalso, added the `@[simps! apply_coe]` adds the lemma saying that you\u2019re i",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact",
          "cases"
        ],
        "topics": [],
        "transforms": [
          "term_mode",
          "use_grind"
        ],
        "keywords": [
          "exact",
          "rcases",
          "symm",
          "hin"
        ]
      }
    },
    {
      "id": 3483,
      "before_code": "namespace Filtration",
      "suggestion": "Then you can endow `\u03b9` with the order topology by writing\n",
      "body": "```suggestion\nThen you can endow `\u03b9` with the order topology by writing\n```",
      "path": "Mathlib/Probability/Process/Filtration.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Filtration",
          "namespace"
        ]
      }
    },
    {
      "id": 3484,
      "before_code": "simp only [\u2190 contDiffOn_univ, e.comp_contDiffOn_iff]\n\n/-- If `f` admits a Taylor series `p` in a set `s`, and `g` is linear, then `f \u2218 g` admits a Taylor\nseries in `g \u207b\u00b9' s`, whose `k`-th term is given by `p k (g v\u2081, ..., g v\u2096)` . -/\ntheorem HasFTaylorSeriesUpToOn.compContinuousLinearMap\n    (hf : HasFTaylorSeriesUpToOn n f p s) (g : G \u2192L[\ud835\udd5c] E) :\n    HasFTaylorSeriesUpToOn n (f \u2218 g) (fun x k => (p (g x) k).compContinuousLinearMap fun _ => g)\n      (g \u207b\u00b9' s) := by",
      "suggestion": "\r\n      (fun x k => (p (g x) k).compContinuousLinearMap fun _ => g) (g \u207b\u00b9' s) := by\r\n",
      "body": "nit:\r\n```suggestion\r\n      (fun x k => (p (g x) k).compContinuousLinearMap fun _ => g) (g \u207b\u00b9' s) := by\r\n```",
      "path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "continuity",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "comp_contDiffOn_iff",
          "term",
          "admits",
          "whose",
          "then",
          "HasFTaylorSeriesUpToOn",
          "theorem",
          "series",
          "set",
          "compContinuousLinearMap",
          "Taylor",
          "simp",
          "given",
          "only",
          "contDiffOn_univ",
          "linear"
        ]
      }
    },
    {
      "id": 3485,
      "before_code": "attribute [symm] Perm.symm\nattribute [trans] Perm.trans\n\ninstance : IsSymm (List \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9",
      "suggestion": "\r\ninstance : Std.Symm (@Perm \u03b1) := \u27e8fun _ _ \u21a6 .symm\u27e9\r\n",
      "body": "nit but this feels like an overkill usage for <|\r\n```suggestion\r\ninstance : Std.Symm (@[user] \u03b1) := \u27e8fun _ _ \u21a6 .symm\u27e9\r\n```",
      "path": "Mathlib/Data/List/Perm/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "trans",
          "Perm",
          "IsSymm",
          "List",
          "attribute",
          "instance"
        ]
      }
    },
    {
      "id": 3486,
      "before_code": "attribute [symm] Perm.symm\nattribute [trans] Perm.trans\n\ninstance : IsSymm (List \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9",
      "suggestion": "instance : Std.Symm (\u03b1 := \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9\n",
      "body": "How about using the same style as above?\n```suggestion\ninstance : Std.Symm (\u03b1 := \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9\n```",
      "path": "Mathlib/Data/List/Perm/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "trans",
          "Perm",
          "IsSymm",
          "List",
          "attribute",
          "instance"
        ]
      }
    },
    {
      "id": 3487,
      "before_code": "attribute [symm] Perm.symm\nattribute [trans] Perm.trans\n\ninstance : IsSymm (List \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9",
      "suggestion": "\r\ninstance : Std.Symm (\u03b1 := List \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9\r\n",
      "body": "Well that would have to be a bit longer:\r\n```suggestion\r\ninstance : Std.Symm (\u03b1 := List \u03b1) Perm := \u27e8fun _ _ \u21a6 .symm\u27e9\r\n```\r\nwhich is why I specified the type in `Perm` instead of in `Std.Symm`, but sure why not",
      "path": "Mathlib/Data/List/Perm/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "trans",
          "Perm",
          "IsSymm",
          "List",
          "attribute",
          "instance"
        ]
      }
    },
    {
      "id": 3490,
      "before_code": "section BaireTheorem\n\nvariable [TopologicalSpace X] [BaireSpace X]",
      "suggestion": "theorem baire_of_finite [Finite X] : BaireSpace X where\n  baire_property f _ _ := sInter_range f \u25b8 (toFinite (range f)).dense_sInter (by grind) (by grind)\n",
      "body": "```suggestion\ntheorem baire_of_finite [Finite X] : BaireSpace X where\n  baire_property f _ _ := sInter_range f \u25b8 (toFinite (range f)).dense_sInter (by grind) (by grind)\n```",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "TopologicalSpace",
          "variable",
          "BaireSpace",
          "BaireTheorem",
          "section"
        ]
      }
    },
    {
      "id": 3509,
      "before_code": "section shift_invariance\n\nvariable {\ud835\udd5c F} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\n\n/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (s + z)) = fun t \u21a6 iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : \u2115) (f : \ud835\udd5c \u2192 F) (s : \ud835\udd5c) :\n    iteratedDeriv n (fun z \u21a6 f (z + s)) = fun t \u21a6 iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s",
      "suggestion": "  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n",
      "body": "```suggestion\n  simpa [funext_iff, neg_add_eq_sub, iteratedDeriv_comp_add_const] using\n    iteratedDeriv_comp_neg n (fun z => f (z + s))\n```",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "funext",
          "induction",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "funext",
          "induction",
          "simp"
        ],
        "topics": [
          "norm",
          "list",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "funext",
          "lemma",
          "deriv_comp_add_const",
          "succ",
          "iterated",
          "iteratedDeriv_succ",
          "commutes",
          "section",
          "right",
          "iteratedDeriv_comp_const_add",
          "NormedAddCommGroup",
          "constant",
          "variable",
          "derivative",
          "shift_invariance",
          "induction",
          "simp",
          "iteratedDeriv_comp_add_const",
          "zero",
          "only",
          "iteratedDeriv",
          "NontriviallyNormedField",
          "deriv_comp_const_add",
          "function",
          "left",
          "NormedSpace",
          "simpa",
          "iteratedDeriv_zero",
          "shifting",
          "using"
        ]
      }
    },
    {
      "id": 3512,
      "before_code": "simp only [bracket_ofTwoCocycle]\n    exact Equiv.congr_arg (by simp [\u2190 smul_add, smul_sub])",
      "suggestion": "\r\n    ofTwoCocycle c \u2243\u2097\u2045R\u2046 ofTwoCocycle c' where\r\n  toFun y :=\r\n    letI z := (ofProd c).symm y\r\n    ofProd c' (z.1, z.2 - x z.1)\r\n  invFun z :=\r\n    letI y := (ofProd c').symm z\r\n    ofProd c (y.1, y.2 + x y.1)\r\n  map_add' _ _ := by simp [\u2190 of_add]; abel\r\n  map_smul' := by simp [\u2190 of_smul, smul_sub]\r\n  map_lie' := ((ofProd c').apply_eq_iff_eq_symm_apply).2 <| by simp [bracket_ofTwoCocycle, h]; abel\r\n",
      "body": "```suggestion\r\n    ofTwoCocycle c \u2243\u2097\u2045R\u2046 ofTwoCocycle c' where\r\n  toFun y :=\r\n    letI z := (ofProd c).symm y\r\n    ofProd c' (z.1, z.2 - x z.1)\r\n  invFun z :=\r\n    letI y := (ofProd c').symm z\r\n    ofProd c (y.1, y.2 + x y.1)\r\n  map_add' _ _ := by simp [\u2190 of_add]; abel\r\n  map_smul' := by simp [\u2190 of_smul, smul_sub]\r\n  map_lie' := ((ofProd c').apply_eq_iff_eq_symm_apply).2 <| by simp [bracket_ofTwoCocycle, h]; abel\r\n```",
      "path": "Mathlib/Algebra/Lie/Extension.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "congr_arg",
          "smul_sub",
          "exact",
          "Equiv",
          "smul_add",
          "simp",
          "bracket_ofTwoCocycle",
          "only"
        ]
      }
    },
    {
      "id": 3514,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "theorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\n  Int.floor_eq_iff.mpr (by grind [pi_gt_three, pi_lt_four])\n",
      "body": "Possible alternative:\n\n```suggestion\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\n  Int.floor_eq_iff.mpr (by grind [pi_gt_three, pi_lt_four])\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 3515,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "theorem ceil_pi_eq_four : \u2308\u03c0\u2309 = 4 :=\n  Int.ceil_eq_iff.mpr (by grind [pi_gt_three, pi_lt_four])\n",
      "body": "Possible alternative:\n\n```suggestion\ntheorem ceil_pi_eq_four : \u2308\u03c0\u2309 = 4 :=\n  Int.ceil_eq_iff.mpr (by grind [pi_gt_three, pi_lt_four])\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 3516,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "theorem round_pi_eq_three : round \u03c0 = 3 :=\n  round_eq _ |>.trans <| Int.floor_eq_iff.mpr \u27e8by grind [pi_gt_three], by grind [pi_lt_d2]\u27e9\n",
      "body": "Possible alternative:\n\n```suggestion\ntheorem round_pi_eq_three : round \u03c0 = 3 :=\n  round_eq _ |>.trans <| Int.floor_eq_iff.mpr \u27e8by grind [pi_gt_three], by grind [pi_lt_d2]\u27e9\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 3517,
      "before_code": "2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]",
      "suggestion": "\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n",
      "body": "We can also\r\n```suggestion\r\ntheorem floor_pi_eq_three : \u230a\u03c0\u230b = 3 :=\r\n  Int.floor_eq_iff.mpr \u27e8pi_gt_three.le, by exact_mod_cast pi_lt_four\u27e9\r\n```",
      "path": "Mathlib/Analysis/Real/Pi/Bounds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "term_mode"
        ],
        "keywords": []
      }
    },
    {
      "id": 3529,
      "before_code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  \u00b7 exact absurd hf <| h _ _ hxy\n  \u00b7 rfl\n  \u00b7 exact absurd hf.symm <| h _ _ hxy",
      "suggestion": "\r\n  exact injective_of_eq_imp_le f fun {x y} \u21a6\r\n    not_lt (\u03b1 := \u03b1) |>.eq \u25b8 imp_not_comm.mp (eq_comm.eq \u25b8 h y x)\r\n",
      "body": "if you move the new lemma before this one, you could do\r\n```suggestion\r\n  exact injective_of_eq_imp_le f fun {x y} \u21a6\r\n    not_lt (\u03b1 := \u03b1) |>.eq \u25b8 imp_not_comm.mp (eq_comm.eq \u25b8 h y x)\r\n```\r\nor\r\n```suggestion\r\n  grind [injective_of_eq_imp_le]\r\n```",
      "path": "Mathlib/Order/Monotone/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lt_trichotomy",
          "Injective",
          "symm",
          "theorem",
          "exact",
          "rcases",
          "absurd",
          "injective_of_lt_imp_ne",
          "LinearOrder",
          "intro",
          "hxy",
          "rfl"
        ]
      }
    },
    {
      "id": 3530,
      "before_code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  \u00b7 exact absurd hf <| h _ _ hxy\n  \u00b7 rfl\n  \u00b7 exact absurd hf.symm <| h _ _ hxy",
      "suggestion": "\r\n  exact Function.Injective.of_eq_imp_le _ (le_of_not_gt <| Imp.swap.mp (h _ _) \u00b7.symm)\r\n",
      "body": "I know, I had this before:\r\n```suggestion\r\n  exact Function.Injective.of_eq_imp_le _ (le_of_not_gt <| Imp.swap.mp (h _ _) \u00b7.symm)\r\n```\r\nthen I realized I can\r\n```suggestion\r\n  exact Function.Injective.of_eq_imp_le _ <| by grind\r\n```\r\nand then\r\n```suggestion\r\n  grind [Function.Injective.of_eq_imp_le]\r\n```\r\nand finally the current version, which doesn't need the new theorem.\r\nI don't think that going back to the explicit term is better.",
      "path": "Mathlib/Order/Monotone/Defs.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "intro"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact",
          "grind"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "order",
          "function"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lt_trichotomy",
          "Injective",
          "symm",
          "theorem",
          "exact",
          "rcases",
          "absurd",
          "injective_of_lt_imp_ne",
          "LinearOrder",
          "intro",
          "hxy",
          "rfl"
        ]
      }
    },
    {
      "id": 3531,
      "before_code": "(SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n@[to_additive]\nlemma closure_pow_le : \u2200 {n}, n \u2260 0 \u2192 closure (s ^ n) \u2264 closure s\n  | 1, _ => by simp\n  | n + 2, _ =>",
      "suggestion": "\r\n  | 0 => by simp_all\r\n",
      "body": "```suggestion\r\n  | 0 => by simp_all\r\n```",
      "path": "Mathlib/Algebra/Group/Subgroup/Pointwise.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp_all"
        ],
        "body_tactics": [
          "simp_all"
        ],
        "new_tactics": [
          "simp_all"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "lemma",
          "SetLike",
          "le_def",
          "subset_closure",
          "closure_pow_le",
          "closure",
          "le_sup_right",
          "simp"
        ]
      }
    },
    {
      "id": 3532,
      "before_code": "(SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n@[to_additive]\nlemma closure_pow_le : \u2200 {n}, n \u2260 0 \u2192 closure (s ^ n) \u2264 closure s\n  | 1, _ => by simp\n  | n + 2, _ =>",
      "suggestion": "\r\n  | n + 1 => by grw [pow_succ, closure_mul_le, closure_pow_le, sup_idem]\r\n",
      "body": "```suggestion\r\n  | n + 1 => by grw [pow_succ, closure_mul_le, closure_pow_le, sup_idem]\r\n```\r\ninstead of the `calc ...`",
      "path": "Mathlib/Algebra/Group/Subgroup/Pointwise.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "to_additive",
          "lemma",
          "SetLike",
          "le_def",
          "subset_closure",
          "closure_pow_le",
          "closure",
          "le_sup_right",
          "simp"
        ]
      }
    },
    {
      "id": 3533,
      "before_code": "le_antisymm ((packingNumber_le_encard_self {x}).trans_eq (by simp)) <|\n    le_iSup_of_le {x} <| le_iSup_of_le (by simp) <| le_iSup_of_le (by simp) (by simp)",
      "suggestion": "lemma maximalSeparatedSet_subset : maximalSeparatedSet \u03b5 A \u2286 A := by\n  by grind [maximalSeparatedSet]\n",
      "body": "This and the next two lemmas can be proven with this, although for it to work on `isSeparated_maximalSeparatedSet`, you have to add\n```lean\nattribute [grind .] IsSeparated.empty\n```\nbut I think we should do that anyway.\n\n```suggestion\nlemma maximalSeparatedSet_subset : maximalSeparatedSet \u03b5 A \u2286 A := by\n  by grind [maximalSeparatedSet]\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "have"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "le_iSup_of_le",
          "trans_eq",
          "le_antisymm",
          "simp",
          "packingNumber_le_encard_self"
        ]
      }
    },
    {
      "id": 3535,
      "before_code": "\u00b7 exact hf' x\n      \u00b7 simpa [edist_comm, hxy] using hf' y",
      "suggestion": "    coveringNumber \u03b5 A \u2264 coveringNumber (\u03b5 / 2) B := calc\n  coveringNumber \u03b5 A\n",
      "body": "otherwise style guidelines would require to indent all lines below the first `calc` line.\n```suggestion\n    coveringNumber \u03b5 A \u2264 coveringNumber (\u03b5 / 2) B := calc\n  coveringNumber \u03b5 A\n```",
      "path": "Mathlib/Topology/MetricSpace/CoveringNumbers.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "edist_comm",
          "exact",
          "simpa",
          "hxy",
          "using"
        ]
      }
    },
    {
      "id": 3536,
      "before_code": "{g} (hg : g \u2208 \u0393) : |g.det.val| = 1 := by\n  rcases HasDetPlusMinusOne.det_eq hg with h | h <;> simp [h]",
      "suggestion": "\r\n  refine \u27e8fun h {g} hg \u21a6 h.abs_det hg, fun h \u21a6 \u27e8?_\u27e9\u27e9\r\n",
      "body": "```suggestion\r\n  refine \u27e8fun h {g} hg \u21a6 h.abs_det hg, fun h \u21a6 \u27e8?_\u27e9\u27e9\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/ArithmeticSubgroups.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "simp"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "cases",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "HasDetPlusMinusOne",
          "det",
          "det_eq",
          "rcases",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 3539,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by simpa [inverse, H] using hf\n  simp_all [Subsingleton.elim f 0]\n",
      "body": "```suggestion\n  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by simpa [inverse, H] using hf\n  simp_all [Subsingleton.elim f 0]\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "body_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "simp_all"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 3540,
      "before_code": "rw [\u2190 ringInverse_eq_inverse]\n  exact Ring.inverse_one _",
      "suggestion": "\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M\u2082 \u2227 Subsingleton M := by simpa [inverse, H] using hf\r\n",
      "body": "It's the other way around for some reason, or you can add `and_comm` to the `simpa` I guess:\r\n```suggestion\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M\u2082 \u2227 Subsingleton M := by simpa [inverse, H] using hf\r\n```\r\nor\r\n```suggestion\r\n  obtain \u27e8_, _\u27e9 : Subsingleton M \u2227 Subsingleton M\u2082 := by aesop\r\n```\r\nor even better (or change the `M` to `M\u2082`):\r\n```suggestion\r\n  have : Subsingleton M := by aesop\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/Equiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "obtain"
        ],
        "body_tactics": [
          "simpa",
          "obtain",
          "aesop",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "obtain"
        ],
        "removed_tactics": [
          "exact",
          "ring",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "exact",
          "Ring",
          "inverse_one",
          "ringInverse_eq_inverse"
        ]
      }
    },
    {
      "id": 3541,
      "before_code": "comap f\u2081 q \u2293 comap f\u2082 q \u2264 comap (f\u2081 + f\u2082) q := by",
      "suggestion": "\r\n    comap f\u2081 q \u2293 comap f\u2082 q \u2264 comap (f\u2081 + f\u2082) q :=\r\n  fun _ h \u21a6 mem_comap.mpr <| add_mem h.1 h.2\r\n",
      "body": "here's an even better golf\r\n```suggestion\r\n    comap f\u2081 q \u2293 comap f\u2082 q \u2264 comap (f\u2081 + f\u2082) q :=\r\n  fun _ h \u21a6 mem_comap.mpr <| add_mem h.1 h.2\r\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Map.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "comap"
        ]
      }
    },
    {
      "id": 3549,
      "before_code": "-/\ndef liftOn\u2082 {\u03b1 : Type*} (x y : LocalizedModule S M) (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') : \u03b1 :=\n  Quotient.liftOn\u2082 x y f wd\n\ntheorem liftOn\u2082_mk {\u03b1 : Type*} (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') (m m' : M)\n    (s s' : S) : liftOn\u2082 (mk m s) (mk m' s') f wd = f \u27e8m, s\u27e9 \u27e8m', s'\u27e9 := by\n  convert Quotient.liftOn\u2082_mk f wd _ _\n\ninstance : Zero (LocalizedModule S M) :=\n  \u27e8mk 0 1\u27e9\n\n/-- If `S` contains `0` then the localization at `S` is trivial. -/\ntheorem subsingleton (h : 0 \u2208 S) : Subsingleton (LocalizedModule S M) := by\n  refine \u27e8fun a b \u21a6 ?_\u27e9\n  induction a,b using LocalizedModule.induction_on\u2082\n  exact mk_eq.mpr \u27e8\u27e80, h\u27e9, by simp only [Submonoid.mk_smul, zero_smul]\u27e9\n\n@[simp]\ntheorem zero_mk (s : S) : mk (0 : M) s = 0 :=\n  mk_eq.mpr \u27e81, by rw [one_smul, smul_zero, smul_zero, one_smul]\u27e9\n\ninstance : Add (LocalizedModule S M) where\n  add p1 p2 :=\n    liftOn\u2082 p1 p2 (fun x y => mk (y.2 \u2022 x.1 + x.2 \u2022 y.1) (x.2 * y.2)) <|\n      fun \u27e8m1, s1\u27e9 \u27e8m2, s2\u27e9 \u27e8m1', s1'\u27e9 \u27e8m2', s2'\u27e9 \u27e8u1, hu1\u27e9 \u27e8u2, hu2\u27e9 =>\n          mk_eq.mpr\n            \u27e8u1 * u2, by\n              -- Put everything in the same shape, sorting the terms using `simp`\n              have hu1' := congr_arg ((u2 * s2 * s2') \u2022 \u00b7) hu1\n              have hu2' := congr_arg ((u1 * s1 * s1') \u2022 \u00b7) hu2\n              simp only [smul_add, \u2190 mul_smul, mul_comm,\n                mul_left_comm] at hu1' hu2' \u22a2\n              rw [hu1', hu2']\u27e9\n\ntheorem mk_add_mk {m1 m2 : M} {s1 s2 : S} :\n    mk m1 s1 + mk m2 s2 = mk (s2 \u2022 m1 + s1 \u2022 m2) (s1 * s2) :=\n  mk_eq.mpr <| \u27e81, rfl\u27e9\n\nprivate theorem add_assoc' (x y z : LocalizedModule S M) : x + y + z = x + (y + z) := by\n  induction x with | _ mx sx\n  induction y with | _ my sy\n  induction z with | _ mz sz\n  simp only [mk_add_mk, smul_add]\n  refine mk_eq.mpr \u27e81, ?_\u27e9\n  rw [one_smul, one_smul]\n  congr 1\n  \u00b7 rw [mul_assoc]\n  \u00b7 rw [eq_comm, mul_comm, add_assoc, mul_smul, mul_smul, \u2190 mul_smul sx sz, mul_comm,",
      "suggestion": "instance (priority := 900) {A : Type*} [Semiring A] [Algebra R A] {S : Submonoid R} :\n    Monoid (LocalizedModule S A) :=\n  fast_instance%\n  { __ := inferInstanceAs (One (LocalizedModule S A))\n    mul := LocalizedModule.mul\n    one_mul := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [one_mul, mul_one, one_smul]\u27e9\n    mul_one := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [mul_one, one_smul, one_mul]\u27e9\n    mul_assoc := by with_unfolding_all\n      rintro \u27e8a\u2081, s\u2081\u27e9 \u27e8a\u2082, s\u2082\u27e9 \u27e8a\u2083, s\u2083\u27e9\n      apply mk_eq.mpr _\n      use 1\n      simp only [one_mul, smul_smul, \u2190 mul_assoc, mul_right_comm] }\n",
      "body": "```suggestion\ninstance (priority := 900) {A : Type*} [Semiring A] [Algebra R A] {S : Submonoid R} :\n    Monoid (LocalizedModule S A) :=\n  fast_instance%\n  { __ := inferInstanceAs (One (LocalizedModule S A))\n    mul := LocalizedModule.mul\n    one_mul := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [one_mul, mul_one, one_smul]\u27e9\n    mul_one := by\n      rintro \u27e8a, s\u27e9\n      with_unfolding_all exact mk_eq.mpr \u27e81, by simp only [mul_one, one_smul, one_mul]\u27e9\n    mul_as",
      "path": "Mathlib/Algebra/Module/LocalizedModule/Basic.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "simpa",
          "rw",
          "simp",
          "induction",
          "congr",
          "ring"
        ],
        "suggestion_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "refine",
          "have",
          "simpa",
          "rw",
          "induction",
          "congr",
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "Module",
          "mpr",
          "Monoid",
          "neg",
          "zero_add",
          "hasNatSMul",
          "Type",
          "succ",
          "mul_smul_comm",
          "terms",
          "mul",
          "add",
          "eq_comm",
          "mul_right_comm",
          "Neg",
          "Quotient",
          "private",
          "liftOn",
          "zero_mk",
          "neg_add_cancel",
          "hu1",
          "have",
          "smul_smul",
          "hu2",
          "CommSemiring",
          "fix",
          "CommRing",
          "trivial",
          "def",
          "mul_comm",
          "mul_one",
          "simp",
          "rfl",
          "Add",
          "theorem",
          "add_assoc",
          "trans",
          "localization",
          "smul_smul_smul_comm",
          "SMul",
          "mul_smul",
          "sorting",
          "Zero",
          "smul",
          "show",
          "mk_eq",
          "induction_on",
          "TODO",
          "mk_add_mk",
          "apply"
        ]
      }
    },
    {
      "id": 3551,
      "before_code": "simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_iff_left_iff_imp]\n  exact fun hz \u21a6 UpperHalfPlane.coe_mem_integerComplement \u27e8z, hz\u27e9",
      "suggestion": "\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n",
      "body": "If you put this in `UpperHalfPlane` then you can dot-notate. Also `n` can be implicit since you have `hm`. \r\n```suggestion\r\nlemma UpperHalfPlane.int_div_mem_integerComplement (z : \u210d) {n : \u2124} (hn : n \u2260 0) :\r\n    n / (z : \u2102) \u2208 \u2102_\u2124 := by\r\n  rintro \u27e8_, hm\u27e9\r\n  have : (n / (z : \u2102)).im \u2260 0:= by simp [div_im, hn, z.im_pos.ne', ne_zero z]\r\n  simpa [\u2190 hm]\r\n```",
      "path": "Mathlib/Analysis/Complex/IntegerCompl.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mem_setOf_eq",
          "exact",
          "Set",
          "mem_inter_iff",
          "UpperHalfPlane",
          "coe_mem_integerComplement",
          "simp",
          "and_iff_left_iff_imp",
          "only"
        ]
      }
    },
    {
      "id": 3552,
      "before_code": "@[simp, norm_cast]\nlemma coe_I : I = Complex.I := rfl",
      "suggestion": "\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffices 0 < n * z.im / Complex.normSq z by simpa [Complex.div_im, neg_div]\r\n  positivity [NeZero.ne n, z.normSq_pos]\r\n",
      "body": "This is in the `UpperHalfPlane` namespace so you don't really need `UpperHalfPlane` in the statment. My instinct would be to formulate using `Nat` with a `[NeZero]` typeclass assumption, rather than `PNat`, but I haven't checked how that plays together with the usage of this lemma later. \r\n\r\nIf you move this to a few lines later in the file (maybe after `ne_int`) then you can do the following:\r\n```suggestion\r\nlemma im_pnat_div_pos (n : \u2115) [NeZero n] (z : \u210d) : 0 < (-(n : \u2102) / z).im := by\r\n  suffi",
      "path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa",
          "positivity"
        ],
        "body_tactics": [
          "simpa",
          "positivity"
        ],
        "new_tactics": [
          "simpa",
          "positivity"
        ],
        "removed_tactics": [
          "simp",
          "norm_cast"
        ],
        "topics": [
          "complex",
          "norm"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "coe_I",
          "lemma",
          "Complex",
          "simp",
          "rfl",
          "norm_cast"
        ]
      }
    },
    {
      "id": 3553,
      "before_code": "exact Real.rpow_le_rpow_of_nonpos (r_pos _) (r_lower_bound_on_verticalStrip z hB hz)\n    (neg_nonpos.mpr hk)\n\nlemma linear_isTheta_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\n  refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real)\n  rw [isLittleO_const_left]\n  exact Or.inr\n    (tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real)",
      "suggestion": "\r\nlemma linear_isTheta_right_add (c e : \u2124) (z : \u2102) :\r\n    (fun d : \u2124 \u21a6 c * z + d + e) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\r\n  apply IsTheta.add_isLittleO <;>\r\n  [refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real); skip] <;>\r\n  simpa [-Int.cofinite_eq] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real\r\n",
      "body": "optional golf (might be a bit convoluted):\r\n```suggestion\r\nlemma linear_isTheta_right_add (c e : \u2124) (z : \u2102) :\r\n    (fun d : \u2124 \u21a6 c * z + d + e) =\u0398[cofinite] fun n \u21a6 (n : \u211d) := by\r\n  apply IsTheta.add_isLittleO <;>\r\n  [refine Asymptotics.IsLittleO.add_isTheta ?_ (Int.cast_complex_isTheta_cast_real); skip] <;>\r\n  simpa [-Int.cofinite_eq] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real\r\n```\r\n(This makes me wonder if `Int.cofinite_eq` should not",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "apply"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "mpr",
          "lemma",
          "neg_nonpos",
          "cofinite",
          "isLittleO_const_left",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "refine",
          "rpow_le_rpow_of_nonpos",
          "isClosedEmbedding_coe_real",
          "add_isTheta",
          "linear_isTheta_right",
          "Int",
          "IsLittleO",
          "Real",
          "r_pos",
          "r_lower_bound_on_verticalStrip",
          "Asymptotics",
          "exact",
          "cast_complex_isTheta_cast_real",
          "inr"
        ]
      }
    },
    {
      "id": 3554,
      "before_code": "\u00b7 simp only [isLittleO_const_left, Int.cast_eq_zero,\n      tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real, or_true]\n\nlemma linear_inv_isBigO_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_right c z).inv.isBigO\n\nlemma linear_inv_isBigO_left (d : \u2124) {z : \u2102} (hz : z \u2260 0) :\n    (fun (c : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_left d hz).inv.isBigO",
      "suggestion": "\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n",
      "body": "`Asymptotics` is already open, and `simpa` uses `this` by default:\r\n```suggestion\r\n  apply IsBigO.trans_tendsto ?_ tendsto_inv_atTop_nhds_zero_nat (F'' := \u211d)\r\n  have := (isBigO_sup.mp (Int.cofinite_eq \u25b8 linear_inv_isBigO_right_add b 0 z)).2\r\n  simpa [\u2190 Nat.map_cast_int_atTop, isBigO_map]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "apply",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "isBigO",
          "cast_eq_zero",
          "lemma",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "linear_isTheta_right",
          "Int",
          "linear_inv_isBigO_left",
          "or_true",
          "inv",
          "linear_isTheta_left",
          "simp",
          "cofinite",
          "isClosedEmbedding_coe_real",
          "isLittleO_const_left",
          "only",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3556,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n    (fun (m : Fin 2 \u2192 \u2124) \u21a6 ((m 0 + a : \u2102) * z + m 1 + b)\u207b\u00b9) =O[cofinite]\r\n    fun (m : Fin 2 \u2192 \u2124) \u21a6 \u2016![m 0 + a, m 1 + b]\u2016\u207b\u00b9 := by\r\n",
      "body": "Formatting: let's not mix `\u21a6` and `=>` for functions in the same file. \r\n```suggestion\r\n    (fun (m : Fin 2 \u2192 \u2124) \u21a6 ((m 0 + a : \u2102) * z + m 1 + b)\u207b\u00b9) =O[cofinite]\r\n    fun (m : Fin 2 \u2192 \u2124) \u21a6 \u2016![m 0 + a, m 1 + b]\u2016\u207b\u00b9 := by\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3557,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _)]\r\n  aesop\r\n",
      "body": "I'm not a fan of `simp only [massive list of stuff] at *`, it seems a bit of a \"scattergun\" approach. Here's a shorter and cleaner version:\r\n```suggestion\r\n  rw [Asymptotics.isBigO_iff]\r\n  have h0 : z \u2208 verticalStrip |z.re| (z.im) := by simp [mem_verticalStrip_iff]\r\n  use \u2016r \u27e8\u27e8|z.re|, z.im\u27e9, z.2\u27e9\u2016\u207b\u00b9\r\n  filter_upwards with m\r\n  apply le_trans (by simpa [Real.rpow_neg_one, add_assoc] using \r\n    summand_bound_of_mem_verticalStrip zero_le_one ![m 0 + a, m 1 + b] z.2 h0)\r\n  simp [abs_of_pos (r_pos _",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "apply",
          "aesop",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "aesop",
          "have",
          "simpa",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "aesop",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp",
          "use_aesop"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3558,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n",
      "body": "```suggestion\r\nlemma isLittleO_const_vec (a b : \u2124) : (fun _ : (Fin 2 \u2192 \u2124) \u21a6 ![a, b]) =o[cofinite] (\u2016\u00b7\u2016) := by\r\n  simpa [isLittleO_const_left, Function.comp_def] using\r\n    .inr <| tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding IsClosedEmbedding.id\r\n```\r\nThe statement can be made far more general, you could do e.g.\r\n```\r\nlemma isLittleO_const_left_of_properSpace_of_discreteTopology\r\n    {\u03b1 : Type*} (a : \u03b1) [NormedAddCommGroup \u03b1] [DiscreteTopology \u03b1]\r\n    [ProperSpace \u03b1] : (fun _ : \u03b1 \u21a6 a) =",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3559,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n",
      "body": "```suggestion\r\n  have (x : Fin 2 \u2192 \u2124) : ![x 0 + a, x 1 + b] = x + ![a, b] := List.ofFn_inj.mp rfl\r\n  simpa only [isTheta_inv, isTheta_norm_left, this] \r\n    using (IsTheta.add_isLittleO (by rw [\u2190 isTheta_norm_left]) (isLittleO_const_vec a b))\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "new_tactics": [
          "rw",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3560,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n/-- If a function `\u2124\u00b2 \u2192 \u2102` is `O (\u2016n\u2016 ^ a)\u207b\u00b9` for `2 < a`, then the function is summable. -/\r\nlemma summable_of_isBigO_rpow_norm {E : Type*} [NormedAddCommGroup E] [CompleteSpace E]\r\n    {f : (Fin 2 \u2192 \u2124) \u2192 E} {a : \u211d} (hab : 2 < a)\r\n    (hf : f =O[cofinite] fun n \u21a6 (\u2016n\u2016 ^ a)\u207b\u00b9) : Summable f :=\r\n",
      "body": "The inverse isn't doing anything here, is it? And it works for more general coefficients. The exact same proof proves the following statement:\r\n```suggestion\r\n/-- If a function `\u2124\u00b2 \u2192 \u2102` is `O (\u2016n\u2016 ^ a)\u207b\u00b9` for `2 < a`, then the function is summable. -/\r\nlemma summable_of_isBigO_rpow_norm {E : Type*} [NormedAddCommGroup E] [CompleteSpace E]\r\n    {f : (Fin 2 \u2192 \u2124) \u2192 E} {a : \u211d} (hab : 2 < a)\r\n    (hf : f =O[cofinite] fun n \u21a6 (\u2016n\u2016 ^ a)\u207b\u00b9) : Summable f :=\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 3561,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 exact .comp_injective (f := (\u2016r ^ \u00b7\u2016)) (by simpa) PNat.coe_injective\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "exact"
        ],
        "body_tactics": [
          "simpa",
          "exact"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 3563,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  have := tendsto_tsum_of_dominated_convergence (\ud835\udcd5 := atTop) (g := fun _ \u21a6 0)\r\n    (f := fun d n : \u2115+ \u21a6 r ^ (n * d : \u2115)) (bound := fun n \u21a6 (\u2016r ^ (n : \u2115)\u2016))\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  have := tendsto_tsum_of_dominated_convergence (\ud835\udcd5 := atTop) (g := fun _ \u21a6 0)\r\n    (f := fun d n : \u2115+ \u21a6 r ^ (n * d : \u2115)) (bound := fun n \u21a6 (\u2016r ^ (n : \u2115)\u2016))\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 3564,
      "before_code": "rw [\u2190 h00]\n  exact tsum_congr\u2082 <| fun b c \u21a6 by simp [mul_comm c.val b.val, pow_mul]",
      "suggestion": "\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n",
      "body": "(edit - superseded - see below)\r\n```suggestion\r\n  \u00b7 simpa using \u27e81, fun b hb k \u21a6\r\n      pow_le_pow_of_le_one (norm_nonneg _) hr.le (Nat.le_mul_of_pos_right k hb)\u27e9\r\n```\r\n(It's a pity that none of the auto-tactics seem to work on the last line.)",
      "path": "Mathlib/NumberTheory/TsumDivsorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "h00",
          "exact",
          "pow_mul",
          "mul_comm",
          "simp",
          "val"
        ]
      }
    },
    {
      "id": 3566,
      "before_code": "f 0 * \u220f' n : \u2115+, f \u2191n = \u220f' n, f n := by\n  simpa [hf.tprod_eq_zero_mul] using tprod_pnat_eq_tprod_succ\n\n@[to_additive tsum_int_eq_zero_add_two_mul_tsum_pnat]\ntheorem tprod_int_eq_zero_mul_tprod_pnat_sq [UniformSpace G] [IsUniformGroup G] [CompleteSpace G]\n    [T2Space G] {f : \u2124 \u2192 G} (hf : \u2200 n : \u2124, f (-n) = f n) (hf2 : Multipliable f) :\n    \u220f' n, f n = f 0 * (\u220f' n : \u2115+, f n) ^ 2 := by\n  have hf3 : Multipliable fun n : \u2115 \u21a6 f n :=\n    (multipliable_int_iff_multipliable_nat_and_neg.mp hf2).1\n  have hf4 : Multipliable fun n : \u2115+ \u21a6 f n := by\n    rwa [multipliable_pnat_iff_multipliable_succ (f := (f \u00b7)),\n      multipliable_nat_add_iff 1 (f := (f \u00b7))]\n  have := tprod_nat_mul_neg hf2\n  rw [\u2190 tprod_zero_pnat_eq_tprod_nat (by simpa [hf] using hf3.mul hf3), mul_comm _ (f 0)] at this\n  simp only [hf, Nat.cast_zero, mul_assoc, mul_right_inj] at this\n  rw [\u2190 this, mul_right_inj, hf4.tprod_mul hf4, sq]",
      "suggestion": "\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n",
      "body": "Indentation is off here. But the proof can also be hugely shortened:\r\n```suggestion\r\n  simpa only [sq, \u2190 mul_assoc, hf] using tprod_int_eq_zero_mul_tprod_pnat hf2\r\n```\r\nYou could also use `Function.Even` as the hypothesis, at the cost of an extra import; note that if you do `(hf : Function.Even f)` then you need `hf _` in the simp call, not just `hf`.",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa",
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "topics": [
          "int",
          "finset",
          "nat",
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "cleanup_simp"
        ],
        "keywords": [
          "CompleteSpace",
          "rwa",
          "Multipliable",
          "multipliable_nat_add_iff",
          "tsum_int_eq_zero_add_two_mul_tsum_pnat",
          "mul",
          "to_additive",
          "IsUniformGroup",
          "multipliable_int_iff_multipliable_nat_and_neg",
          "hf4",
          "Nat",
          "cast_zero",
          "have",
          "tprod_zero_pnat_eq_tprod_nat",
          "hf3",
          "mul_right_inj",
          "multipliable_pnat_iff_multipliable_succ",
          "tprod_pnat_eq_tprod_succ",
          "T2Space",
          "mul_comm",
          "simp",
          "tprod_eq_zero_mul",
          "only",
          "mul_assoc",
          "theorem",
          "UniformSpace",
          "hf2",
          "tprod_nat_mul_neg",
          "tprod_mul",
          "this",
          "simpa",
          "tprod_int_eq_zero_mul_tprod_pnat_sq",
          "using"
        ]
      }
    },
    {
      "id": 3568,
      "before_code": "exact eq_comm\n\ntheorem isAdjointPair_inner (A : E \u2192\u2097[\ud835\udd5c] F) :\n    IsAdjointPair (sesqFormOfInner : E \u2192\u2097[\ud835\udd5c] E \u2192\u2097\u22c6[\ud835\udd5c] \ud835\udd5c) (sesqFormOfInner : F \u2192\u2097[\ud835\udd5c] F \u2192\u2097\u22c6[\ud835\udd5c] \ud835\udd5c) A\n      A.adjoint := by",
      "suggestion": "\r\n    IsAdjointPair (inner\u209b\u2097 \ud835\udd5c (E := E)).flip\r\n      (inner\u209b\u2097 \ud835\udd5c (E := F)).flip A A.adjoint := by\r\n",
      "body": "```suggestion\r\n    IsAdjointPair (inner\u209b\u2097 \ud835\udd5c (E := E)).flip\r\n      (inner\u209b\u2097 \ud835\udd5c (E := F)).flip A A.adjoint := by\r\n```\r\nI wonder whether this should be replaced by `IsAdjointPair inner inner A A.adjoint`, but maybe for a second PR.",
      "path": "Mathlib/Analysis/InnerProductSpace/Adjoint.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "sesqFormOfInner",
          "eq_comm",
          "theorem",
          "exact",
          "adjoint",
          "IsAdjointPair",
          "isAdjointPair_inner"
        ]
      }
    },
    {
      "id": 3569,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "    IntegrableOn (fun t \u21a6 \u03b8 t / (t * log t ^ 2)) (Set.Icc 2 x) volume := by\n",
      "body": "```suggestion\n    IntegrableOn (fun t \u21a6 \u03b8 t / (t * log t ^ 2)) (Set.Icc 2 x) volume := by\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3570,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "    Real.sqrt =o[atTop] (fun x \u21a6 x / log x ^ 2) := by\n",
      "body": "```suggestion\n    Real.sqrt =o[atTop] (fun x \u21a6 x / log x ^ 2) := by\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3572,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  \u00b7 have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -(y * log y ^ 2)\u207b\u00b9 := by\n",
      "body": "```suggestion\n  \u00b7 have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -(y * log y ^ 2)\u207b\u00b9 := by\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3573,
      "before_code": "theorem deriv_log' : deriv log = Inv.inv :=\n  funext deriv_log",
      "suggestion": "    deriv (fun x \u21a6 (log x)\u207b\u00b9) x = -x\u207b\u00b9 / (log x ^ 2) := by\n",
      "body": "```suggestion\n    deriv (fun x \u21a6 (log x)\u207b\u00b9) x = -x\u207b\u00b9 / (log x ^ 2) := by\n```\nor\n```suggestion\n    deriv (log \u00b7)\u207b\u00b9 x = -x\u207b\u00b9 / (log x ^ 2) := by\n```\nThe three conditions `h0`, `h1` and `h2` should not actually be necessary: at all three places, `(log \u00b7)\u207b\u00b9` is not differentiable, so its derivative has the junk value zero, which is also the junk value on the right.\n\nHowever, removing them would require a proof of the non-differentiability, which is likely to be some extra work.",
      "path": "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean",
      "tags": {
        "before_tactics": [
          "funext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "funext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "funext",
          "log",
          "theorem",
          "Inv",
          "deriv",
          "inv",
          "deriv_log"
        ]
      }
    },
    {
      "id": 3574,
      "before_code": "convert sum_mul_eq_sub_integral_mul\u2080 c hc m hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]",
      "suggestion": "    have H\u2081 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, c n = 0 := by grind [(Nat.floor_lt' two_ne_zero).mpr hb]\n    have H\u2082 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, f n * c n = 0 := by grind\n    simp [sum_eq_zero H\u2081, sum_eq_zero H\u2082, Set.Ioc_eq_empty_of_le hb.le]\n  --Split off the first two terms of the sum\n  have : 2 \u2264 \u230ab\u230b\u208a := Nat.le_floor hb\n  have H : \u2211 k \u2208 Icc 0 \u230ab\u230b\u208a, f \u2191k * c k = f (2 :) * c 2 + \u2211 k \u2208 Ioc 2 \u230ab\u230b\u208a, f \u2191k * c k := by\n    rw [add_sum_Ioc_eq_sum_Icc (f := fun (k : \u2115) \u21a6 f k * c k) this,\n      show Icc 0 \u230ab\u230b\u208a = {0, 1} \u222a Icc 2 \u230ab\u230b\u208a by grind]\n    exact sum_union_eq_right fun k hk hk' \u21a6 by grind\n  rw [H]\n  --Apply Abel summation to the remainder\n  nth_rewrite 3 [show 2 = \u230a(2 : \u211d)\u230b\u208a by simp]\n  rw [sum_mul_eq_sub_sub_integral_mul c zero_le_two hb hf_diff hf_int]\n  simp [show Icc 0 2 = {0, 1, 2} by rfl, hc, hc1]\n  grind\n",
      "body": "```suggestion\n    have H\u2081 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, c n = 0 := by grind [(Nat.floor_lt' two_ne_zero).mpr hb]\n    have H\u2082 : \u2200 n \u2208 Icc 0 \u230ab\u230b\u208a, f n * c n = 0 := by grind\n    simp [sum_eq_zero H\u2081, sum_eq_zero H\u2082, Set.Ioc_eq_empty_of_le hb.le]\n  --Split off the first two terms of the sum\n  have : 2 \u2264 \u230ab\u230b\u208a := Nat.le_floor hb\n  have H : \u2211 k \u2208 Icc 0 \u230ab\u230b\u208a, f \u2191k * c k = f (2 :) * c 2 + \u2211 k \u2208 Ioc 2 \u230ab\u230b\u208a, f \u2191k * c k := by\n    rw [add_sum_Ioc_eq_sum_Icc (f := fun (k : \u2115) \u21a6 f k * c k) this,\n      show Icc 0 \u230ab\u230b\u208a = ",
      "path": "Mathlib/NumberTheory/AbelSummation.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "apply",
          "exact",
          "grind",
          "have",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "all_goals",
          "convert",
          "Nat",
          "floor_natCast",
          "hf_int",
          "hf_diff"
        ]
      }
    },
    {
      "id": 3575,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have : x * log x ^ 2 \u2260 0 := mul_ne_zero this <| by simp; grind\n",
      "body": "```suggestion\n  have : x * log x ^ 2 \u2260 0 := mul_ne_zero this <| by simp; grind\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind",
          "have",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "have",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3576,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  let a : \u2115 \u2192 \u211d := Set.indicator (setOf Nat.Prime) (fun n \u21a6 log n)\n",
      "body": "```suggestion\n  let a : \u2115 \u2192 \u211d := Set.indicator (setOf Nat.Prime) (fun n \u21a6 log n)\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3577,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  \u00b7 refine sum_congr rfl fun n hn \u21a6 ?_\n    split_ifs with h\n    \u00b7 have : log n \u2260 0 := log_ne_zero_of_pos_of_ne_one (mod_cast h.pos) (mod_cast h.ne_one)\n      simp [a, h, field]\n    \u00b7 simp [a, h]\n",
      "body": "```suggestion\n  \u00b7 refine sum_congr rfl fun n hn \u21a6 ?_\n    split_ifs with h\n    \u00b7 have : log n \u2260 0 := log_ne_zero_of_pos_of_ne_one (mod_cast h.pos) (mod_cast h.ne_one)\n      simp [a, h, field]\n    \u00b7 simp [a, h]\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "body_tactics": [
          "refine",
          "have",
          "simp"
        ],
        "new_tactics": [
          "have",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3578,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "      replace hu : 2 \u2264 u := ((Set.uIcc_of_le hx) \u25b8 hu).1\n      simp [deriv_log_inv (by linarith) (by linarith) (by linarith), field]\n",
      "body": "```suggestion\n      replace hu : 2 \u2264 u := ((Set.uIcc_of_le hx) \u25b8 hu).1\n      simp [deriv_log_inv (by linarith) (by linarith) (by linarith), field]\n```\nNote that this is one of the places where `deric_log_inv` without side conditions would simplify things.",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "linarith"
        ],
        "body_tactics": [
          "simp",
          "linarith"
        ],
        "new_tactics": [
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3579,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
      "body": "```suggestion\n    have : \u2200 y \u2208 Set.Icc 2 x, deriv (fun x \u21a6 (log x)\u207b\u00b9) y = -y\u207b\u00b9 / log y ^ 2 := by\n      refine fun y hy \u21a6 deriv_log_inv ?_ ?_ ?_ <;> linarith [hy.1]\n    refine ContinuousOn.integrableOn_Icc fun z hz \u21a6 ContinuousWithinAt.congr ?_ this (this z hz)\n    have hz\u2080 : z \u2260 0 := by linarith [hz.1]\n    have : log z ^ 2 \u2260 0 := by \n      refine pow_ne_zero 2 <| log_ne_zero_of_pos_of_ne_one ?_ ?_ <;> linarith [hz.1]\n    exact ContinuousAt.continuousWithinAt <| by fun_prop (disch := assumption)\n",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine",
          "exact",
          "have",
          "fun_prop",
          "linarith",
          "congr"
        ],
        "body_tactics": [
          "refine",
          "exact",
          "have",
          "fun_prop",
          "linarith",
          "congr"
        ],
        "new_tactics": [
          "refine",
          "exact",
          "congr",
          "have",
          "linarith",
          "fun_prop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_linarith",
          "use_fun_prop"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3580,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  calc\n  _ \u2264 \u222b x in a..b, 1 / log a ^ 2 := by\n      refine intervalIntegral.integral_mono_on hab ?_ (by simp) fun x \u27e8hx, _\u27e9 \u21a6 by gcongr <;> bound\n      apply intervalIntegrable_one_div_log_sq <;> linarith\n  _ \u2264 _ := by simp [field]\n",
      "body": "```suggestion\n  calc\n  _ \u2264 \u222b x in a..b, 1 / log a ^ 2 := by\n      refine intervalIntegral.integral_mono_on hab ?_ (by simp) fun x \u27e8hx, _\u27e9 \u21a6 by gcongr <;> bound\n      apply intervalIntegrable_one_div_log_sq <;> linarith\n  _ \u2264 _ := by simp [field]\n```\n* `calc` proofs are usually easier to read than proofs using `trans`\n* `refine` allows to fold `intro` (or `use`, ...)",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "simp",
          "linarith"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "simp",
          "intro",
          "linarith"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3581,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "We will bound the integral on 2..x by splitting into two intervals and using this result on both. -/\n",
      "body": "```suggestion\nWe will bound the integral on 2..x by splitting into two intervals and using this result on both. -/\n```\netc.",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3582,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have two_le_sqrt : 2 \u2264 x.sqrt := Real.le_sqrt_of_sq_le <| by norm_num [hx]\n",
      "body": "```suggestion\n  have two_le_sqrt : 2 \u2264 x.sqrt := Real.le_sqrt_of_sq_le <| by norm_num [hx]\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "norm_num",
          "have"
        ],
        "body_tactics": [
          "norm_num",
          "have"
        ],
        "new_tactics": [
          "norm_num",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3583,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "  have sqrt_le_x : x.sqrt \u2264 x := sqrt_le_left (by linarith) |>.mpr (by bound)\n",
      "body": "```suggestion\n  have sqrt_le_x : x.sqrt \u2264 x := sqrt_le_left (by linarith) |>.mpr (by bound)\n```\n(Same proofs, only a bit more condensed.)",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "have",
          "linarith"
        ],
        "body_tactics": [
          "have",
          "linarith"
        ],
        "new_tactics": [
          "have",
          "linarith"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 3585,
      "before_code": "hW := .sup D\u2081.hW D\u2082.hW (Cardinal.IsRegular.aleph0_le Fact.out)\n  hP := .sup D\u2081.hP D\u2082.hP (Cardinal.IsRegular.aleph0_le Fact.out)",
      "suggestion": "@[simps!]\ndef D\u2080 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) :\n    Diagram J \u03ba :=\n  Diagram.iSup (fun i \u21a6 (D i).toDiagram) h\u03b9\n\n@[simps!]\ndef D\u2081 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) (m : J) :\n    Diagram J \u03ba :=\n  (D\u2080 J \u03ba D h\u03b9).sup (.single m)\n\n@[simps!]\ndef D\u2082 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba)\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) (m : J) (u : (i : \u03b9) \u2192 (D i).top \u27f6 m) :\n    Diagram J \u03ba where\n  W := (D\u2081 J \u03ba D h\u03b9 m).W \u2294 MorphismProperty.ofHoms\n    fun (x : (\u03a3 (i : \u03b9), (Subtype (D i).P))) \u21a6 (D x.1).isTerminal.lift x.2.2 \u226b u x.1\n  P := (D\u2081 J \u03ba D h\u03b9 m).P\n  src := by\n    simp only [D\u2081_W, D\u2081_P]\n    rintro _ _ _ ((hf | \u27e8\u27e8\u27e9\u27e9) | \u27e8i, j, hj\u27e9)\n    \u00b7 simp only [MorphismProperty.iSup_iff] at hf\n      obtain \u27e8i, hf\u27e9 := hf\n      exact Or.inl \u27e8i, (D i).src hf\u27e9\n    \u00b7 exact Or.inr rfl\n    \u00b7 exact Or.inl \u27e8i, hj\u27e9\n  tgt := by\n    simp only [D\u2081_W, D\u2081_P]\n    rintro _ _ _ ((hf | \u27e8\u27e8\u27e9\u27e9) | \u27e8i, j, hj\u27e9)\n   ",
      "body": "```suggestion\n@[simps!]\ndef D\u2080 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) :\n    Diagram J \u03ba :=\n  Diagram.iSup (fun i \u21a6 (D i).toDiagram) h\u03b9\n\n@[simps!]\ndef D\u2081 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba) (m : J) :\n    Diagram J \u03ba :=\n  (D\u2080 J \u03ba D h\u03b9).sup (.single m)\n\n@[simps!]\ndef D\u2082 {\u03b9 : Type w} (D : \u03b9 \u2192 DiagramWithUniqueTerminal J \u03ba) (h\u03b9 : HasCardinalLT \u03b9 \u03ba)\n    (h\u03ba : Cardinal.aleph0 \u2264 \u03ba) (m : J) (u : (i : \u03b9) \u2192 (D i).top \u27f6 m) :\n  ",
      "path": "Mathlib/CategoryTheory/Presentable/Directed.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "apply",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "out",
          "aleph0_le",
          "Fact",
          "sup",
          "IsRegular",
          "Cardinal"
        ]
      }
    },
    {
      "id": 3595,
      "before_code": "end",
      "suggestion": "\r\ninstance (X : Truncated.{u} 2) [Unique (X _\u298b0\u298c\u2082)] : Unique X.HomotopyCategory := \r\n  letI : Unique (OneTruncation\u2082 X) := inferInstanceAs (Unique (X _\u298b0\u298c\u2082))\r\n  CategoryTheory.Quotient.instUnique _\r\n\r\n/-- If `X : Truncated 2` has a unique `0`-simplex and (at most) one `1`-simplex,\r\nthen `X.HomotopyCategory` is a terminal object in `Cat`. -/\r\ndef isTerminal (X : Truncated.{u} 2) [Unique (X _\u298b0\u298c\u2082)] [Subsingleton (X _\u298b1\u298c\u2082)] :\r\n    IsTerminal (Cat.of X.HomotopyCategory) :=\r\n  letI : IsDiscrete (X.HomotopyCategory) := { eq_of_hom := by subsingleton }\r\n  Cat.isTerminalOfUniqueOfIsDiscrete\r\n",
      "body": "Same here: we already have `Cat.isTerminalOfUniqueOfIsDiscrete`:\r\n```suggestion\r\ninstance (X : Truncated.{u} 2) [Unique (X _\u298b0\u298c\u2082)] : Unique X.HomotopyCategory := \r\n  letI : Unique (OneTruncation\u2082 X) := inferInstanceAs (Unique (X _\u298b0\u298c\u2082))\r\n  CategoryTheory.Quotient.instUnique _\r\n\r\n/-- If `X : Truncated 2` has a unique `0`-simplex and (at most) one `1`-simplex,\r\nthen `X.HomotopyCategory` is a terminal object in `Cat`. -/\r\ndef isTerminal (X : Truncated.{u} 2) [Unique (X _\u298b0\u298c\u2082)] [Subsingleton (X _\u298b1\u298c",
      "path": "Mathlib/AlgebraicTopology/SimplicialSet/HomotopyCat.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3596,
      "before_code": "(fun i j Z gi gj \u21a6 hx gi gj (ofArrows.mk _) (ofArrows.mk _))\n    exact \u27e8t, fun Y f \u27e8i\u27e9 \u21a6 hA i, fun y hy \u21a6 ht y (fun i \u21a6 hy (\u03c0 i) (ofArrows.mk _))\u27e9",
      "suggestion": "\r\n      IsSheafFor P (Presieve.ofArrows _ (fun i \u21a6 (Over.map p).map (f i))) := by\r\n",
      "body": "```suggestion\r\n      IsSheafFor P (Presieve.ofArrows _ (fun i \u21a6 (Over.map p).map (f i))) := by\r\n```",
      "path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "ofArrows"
        ]
      }
    },
    {
      "id": 3598,
      "before_code": "IsStableUnderBaseChange @FinitePresentation := by\n  apply IsStableUnderBaseChange.mk\n  \u00b7 exact finitePresentation_respectsIso\n  \u00b7 introv h\n    rw [finitePresentation_algebraMap] at h\n    suffices Algebra.FinitePresentation S (S \u2297[R] T) by\n      rw [RingHom.FinitePresentation]; convert this; ext; simp_rw [Algebra.smul_def]; rfl\n    infer_instance",
      "suggestion": "\r\n    exact fun _ S _ _ _ _ _ _ _ \u21a6 Algebra.FinitePresentation.baseChange S\r\n",
      "body": "```suggestion\r\n    exact fun _ S _ _ _ _ _ _ _ \u21a6 Algebra.FinitePresentation.baseChange S\r\n```",
      "path": "Mathlib/RingTheory/RingHom/FinitePresentation.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "rw",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "introv",
          "apply",
          "finitePresentation_respectsIso",
          "convert",
          "ext",
          "infer_instance",
          "exact",
          "smul_def",
          "IsStableUnderBaseChange",
          "suffices",
          "this",
          "finitePresentation_algebraMap",
          "RingHom",
          "FinitePresentation",
          "simp_rw",
          "Algebra",
          "rfl"
        ]
      }
    },
    {
      "id": 3599,
      "before_code": "theorem finite_isStableUnderBaseChange : IsStableUnderBaseChange @Finite := by\n  refine IsStableUnderBaseChange.mk finite_respectsIso ?_\n  classical\n  introv h\n  replace h : Module.Finite R T := by\n    rw [RingHom.Finite] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl\n  suffices Module.Finite S (S \u2297[R] T) by\n    rw [RingHom.Finite]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl\n  exact inferInstance",
      "suggestion": "\r\n  exact fun R S T _ _ _ _ _ _ \u21a6 Module.Finite.base_change R S T\r\n",
      "body": "```suggestion\r\n  exact fun R S T _ _ _ _ _ _ \u21a6 Module.Finite.base_change R S T\r\n```",
      "path": "Mathlib/RingTheory/RingHom/Finite.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "ext",
          "exact",
          "rw",
          "congr"
        ],
        "suggestion_tactics": [
          "exact"
        ],
        "body_tactics": [
          "exact"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "congr",
          "rw",
          "refine",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "convert",
          "finite_respectsIso",
          "IsStableUnderBaseChange",
          "classical",
          "introv",
          "refine",
          "ext",
          "finite_isStableUnderBaseChange",
          "RingHom",
          "simp_rw",
          "rfl",
          "congr",
          "Finite",
          "theorem",
          "exact",
          "replace",
          "smul_def",
          "suffices",
          "this",
          "Algebra"
        ]
      }
    },
    {
      "id": 3601,
      "before_code": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]",
      "suggestion": "\r\n  simp [e.forall_congr_left]\r\n",
      "body": "yeah it's having trouble unifying because `e.symm.symm` looks different to `e`\r\n\r\nI found a fix though; `exact` followed by an iff statement is generally a sign that `simp` or `rw` will work\r\n\r\n````suggestion\r\n  simp [e.forall_congr_left]\r\n````",
      "path": "Mathlib/Algebra/Module/ZLattice/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "set_theory",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "Basis",
          "fundamentalDomain_reindex",
          "ext",
          "theorem",
          "fundamentalDomain",
          "forall_congr",
          "Type",
          "reindex",
          "implies_true",
          "Equiv",
          "mem_fundamentalDomain",
          "simp_rw",
          "repr_reindex_apply"
        ]
      }
    },
    {
      "id": 3603,
      "before_code": "/-- The constructor for `FiniteElement`. -/\nprotected def mk (x : K) (h : 0 \u2264 mk x) : FiniteElement K := \u27e8x, h\u27e9\n\n@[simp] theorem mk_zero (h : 0 \u2264 mk (0 : K)) : FiniteElement.mk 0 h = 0 := rfl\n@[simp] theorem mk_one (h : 0 \u2264 mk (1 : K)) : FiniteElement.mk 1 h = 1 := rfl\n@[simp] theorem mk_natCast {n : \u2115} (h : 0 \u2264 mk (n : K)) : FiniteElement.mk (n : K) h = n := rfl\n@[simp] theorem mk_intCast {n : \u2124} (h : 0 \u2264 mk (n : K)) : FiniteElement.mk (n : K) h = n := rfl\n\n@[simp]\ntheorem mk_neg {x : K} (h : 0 \u2264 mk x) :\n    -FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=",
      "suggestion": "\r\ntheorem neg_mk (x : K) (h : 0 \u2264 mk x) :\r\n    -FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=\r\n",
      "body": "Whoops, this is misnamed:\r\n```suggestion\r\ntheorem neg_mk (x : K) (h : 0 \u2264 mk x) :\r\n    -FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=\r\n```",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "constructor",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "constructor",
          "simp"
        ],
        "topics": [
          "list",
          "nat",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "rwa",
          "FiniteElement",
          "def",
          "mk_zero",
          "theorem",
          "protected",
          "mk_one",
          "mk_neg",
          "constructor",
          "simp",
          "mk_natCast",
          "rfl",
          "mk_intCast",
          "for"
        ]
      }
    },
    {
      "id": 3606,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "    lowerBounds (f '' S) = lowerBounds (range f) :=\n  hS.continuous_upperBounds (\u03b1 := \u03b1\u1d52\u1d48) hf\n",
      "body": "There's a trick you can use for this kind of thing by using the `OrderDual`.\n```suggestion\n    lowerBounds (f '' S) = lowerBounds (range f) :=\n  hS.continuous_upperBounds (\u03b1 := \u03b1\u1d52\u1d48) hf\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 3607,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n",
      "body": "It's easier if you case split on whether the range of the function from the subtype is bounded above or not.\n```suggestion\n  by_cases h : BddAbove (range (fun x : S \u21a6 f x))\n  \u00b7 refine hS.ciSup hf <| h.closure.mono ?_\n    simpa [\u2190 Function.comp_def, range_comp] using hf.range_subset_closure_image_dense hS\n  \u00b7 suffices \u00ac BddAbove (range f) by simp [ciSup_of_not_bddAbove, this, h]\n    contrapose h\n    exact h.mono fun _ \u21a6 by aesop\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "aesop",
          "refine",
          "exact",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "refine",
          "exact",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "aesop",
          "refine",
          "simp",
          "exact"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_simpa",
          "use_aesop"
        ],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 3608,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    toEuclidean '' Euclidean.closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [Euclidean.closedBall, Euclidean.dist]\r\n",
      "body": "```suggestion\r\n    toEuclidean '' Euclidean.closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [Euclidean.closedBall, Euclidean.dist]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "new_tactics": [
          "simpa",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 3610,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 ((by simp_all [x\u2081, x\u2082])) (by simp)]\r\n    simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n  \u00b7 simp [x\u2081, abs_of_nonneg, hr]\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n",
      "body": "More compact this way:\r\n```suggestion\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 ((by simp_all [x\u2081, x\u2082])) (by simp)]\r\n    simp [hr, x\u2081, x\u2082, \u2190 two_mul]\r\n  \u00b7 simp [x\u2081, abs_of_nonneg, hr]\r\n  \u00b7 simp [EuclideanSpace.norm_eq, hr, x\u2082]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine",
          "rw",
          "simp_all"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 3611,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n  let x\u2081 := toEuclidean x + EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  let x\u2082 := toEuclidean x - EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 (by simp_all [x\u2081, x\u2082]) (by simp)]\r\n",
      "body": "```suggestion\r\n  let x\u2081 := toEuclidean x + EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  let x\u2082 := toEuclidean x - EuclideanSpace.single \u27e80, Module.finrank_pos\u27e9 r\r\n  refine le_trans ?_ (dist_le_diam_of_mem (x := x\u2081) (y := x\u2082) isBounded_closedBall ?_ ?_)\r\n  \u00b7 simp_rw [dist_eq_norm, EuclideanSpace.norm_eq, PiLp.sub_apply, Real.norm_eq_abs, sq_abs]\r\n    rw [Finset.sum_eq_single \u27e80, Module.finrank_pos\u27e9 (by simp_all [x\u2081, x\u2082]) (by simp)]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simp_all",
          "refine",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "refine",
          "rw",
          "simp_all"
        ],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 3612,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    toEuclidean '' closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [closedBall, dist]\r\n",
      "body": "```suggestion\r\n    toEuclidean '' closedBall x r = Metric.closedBall (toEuclidean x) r := by\r\n  apply Set.eq_of_subset_of_subset (image_subset_iff.eq \u25b8 subset_rfl) fun y hy \u21a6 ?_\r\n  refine \u27e8toEuclidean.symm y, ?_, ContinuousLinearEquiv.apply_symm_apply _ _\u27e9\r\n  simpa [closedBall, dist]\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "refine"
        ],
        "new_tactics": [
          "simpa",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 3629,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "  rw [Nat.le_div_iff_mul_le (by positivity), Nat.mul_comm,\n    \u2190 Nat.add_mul_div_right _ _ (by positivity),\n    Nat.le_div_iff_mul_le (by positivity)]\n  have := (Commute.all (b : \u2124) (a - b)).pow_add_mul_le_add_pow_of_sq_nonneg\n    (by positivity) (sq_nonneg _) (sq_nonneg _) (by grind) (n + 1)\n  -- `grind` should solve this, but:  https://github.com/leanprover/lean4/issues/11539\n  simp [mul_sub, \u2190 add_sub_assoc] at this\n  norm_cast at this\n  grind \n",
      "body": "This worked last week\n```suggestion\n  rw [Nat.le_div_iff_mul_le (by positivity), Nat.mul_comm,\n    \u2190 Nat.add_mul_div_right _ _ (by positivity),\n    Nat.le_div_iff_mul_le (by positivity)]\n  have := (Commute.all (b : \u2124) (a - b)).pow_add_mul_le_add_pow_of_sq_nonneg\n    (by positivity) (sq_nonneg _) (sq_nonneg _) (by grind) (n + 1)\n  -- `grind` should solve this, but:  https://github.com/[user]r/lean4/issues/11539\n  simp [mul_sub, \u2190 add_sub_assoc] at this\n  norm_cast at this\n  grind \n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "grind",
          "have",
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "positivity",
          "grind",
          "have",
          "rw",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "positivity",
          "rw",
          "simp",
          "grind",
          "have",
          "norm_cast"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 3630,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "  have H : \u2203 c, a < (c + 1) ^ (n + 1) := \u27e8a, Nat.le_self_pow (by positivity) (a + 1)\u27e9\n  let +nondep (eq := hc) c := Nat.find H\n  refine \u27e8c, ?_, hc \u25b8 Nat.find_spec H\u27e9\n  cases c with\n  | zero => simp\n  | succ k => simpa using Nat.find_min H hc.le\n",
      "body": "Here's a nice little trick for you. This introduces a new name `c` which is equal (propositionally) to `Nat.find H`, but it doesn't reduce to that. This allows us to perform a nice case split on `c` which simplifies the argument.\n```suggestion\n  have H : \u2203 c, a < (c + 1) ^ (n + 1) := \u27e8a, Nat.le_self_pow (by positivity) (a + 1)\u27e9\n  let +nondep (eq := hc) c := Nat.find H\n  refine \u27e8c, ?_, hc \u25b8 Nat.find_spec H\u27e9\n  cases c with\n  | zero => simp\n  | succ k => simpa using Nat.find_min H hc.le\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "positivity",
          "refine",
          "cases",
          "have",
          "simpa",
          "simp"
        ],
        "body_tactics": [
          "positivity",
          "refine",
          "cases",
          "have",
          "simpa",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "positivity",
          "refine",
          "simp",
          "cases",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 3631,
      "before_code": "variable {C : Type u} [Category.{v} C] {X Y Z : C}\n\ninitialize_simps_projections Category (-Hom)\n\n/-- postcompose an equation between morphisms by another morphism -/",
      "suggestion": "\r\n/-- Precompose an equation between morphisms by another morphism -/]\r\n",
      "body": "Might as well fix some capitalization.\r\n```suggestion\r\n/-- Precompose an equation between morphisms by another morphism -/]\r\n```",
      "path": "Mathlib/CategoryTheory/Category/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "morphisms",
          "variable",
          "equation",
          "morphism",
          "Category",
          "Type",
          "postcompose",
          "initialize_simps_projections",
          "another",
          "between",
          "Hom"
        ]
      }
    },
    {
      "id": 3632,
      "before_code": "IsClosed { f : \u03b1 \u2192 \u03b2 | LipschitzWith K f } := by\n  simp only [\u2190 lipschitzOnWith_univ, isClosed_setOf_lipschitzOnWith]",
      "suggestion": "protected lemma LipschitzOnWith.closure_iff [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {K : \u211d\u22650}\n    (hcont : ContinuousOn f (closure s)) :\n    LipschitzOnWith K f (closure s) \u2194 LipschitzOnWith K f s := by\n  refine \u27e8fun hf \u21a6 hf.mono subset_closure, fun hf \u21a6 ?_\u27e9\n",
      "body": "How about we upgrade this to an `iff` and use `variable`s a bit more:\n```suggestion\nprotected lemma LipschitzOnWith.closure_iff [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {K : \u211d\u22650}\n    (hcont : ContinuousOn f (closure s)) :\n    LipschitzOnWith K f (closure s) \u2194 LipschitzOnWith K f s := by\n  refine \u27e8fun hf \u21a6 hf.mono subset_closure, fun hf \u21a6 ?_\u27e9\n```",
      "path": "Mathlib/Topology/Instances/ENNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "IsClosed",
          "LipschitzWith",
          "lipschitzOnWith_univ",
          "simp",
          "only",
          "isClosed_setOf_lipschitzOnWith"
        ]
      }
    },
    {
      "id": 3634,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n  have {x} (hx : x \u2208 s) : \u2203 K' : \u211d\u22650, \u2200 y \u2208 s.diff (ball x (\u03b5 x hx)),\r\n",
      "body": "Should this be stated as\r\n```suggestion\r\n  have {x} (hx : x \u2208 s) : \u2203 K' : \u211d\u22650, \u2200 y \u2208 s.diff (ball x (\u03b5 x hx)),\r\n```\r\nso you can avoid the `fun x hx` at the beginning of hte proof?",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 3636,
      "before_code": "-- Then show that `K * dist y x` tends to zero as `y \u2192 x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp",
      "suggestion": "\r\n      gcongr\r\n      exact (add_le_add_left (mul_le_mul_of_nonneg_left h (by positivity)) _).trans (by linarith)\r\n",
      "body": "```suggestion\r\n      gcongr\r\n      exact (add_le_add_left (mul_le_mul_of_nonneg_left h (by positivity)) _).trans (by linarith)\r\n```",
      "path": "Mathlib/Topology/Algebra/MetricSpace/Lipschitz.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "body_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "new_tactics": [
          "exact",
          "positivity",
          "gcongr",
          "linarith"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "continuity",
          "list"
        ],
        "transforms": [
          "use_linarith"
        ],
        "keywords": [
          "tendsto",
          "refine",
          "continuous_id",
          "show",
          "tends",
          "dist",
          "continuous_const",
          "that",
          "simp",
          "Then",
          "zero",
          "mul"
        ]
      }
    },
    {
      "id": 3637,
      "before_code": "(by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n\nend MeromorphicOn",
      "suggestion": "@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3)) :\n    Meromorphic (\u2211 n \u2208 s, G n) := fun x \u21a6 MeromorphicAt.sum (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma sub (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f - g) := fun x \u21a6 (hf x).sub (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma mul {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f * g) := fun x \u21a6 (hf x).mul (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem prod (h : \u2200 \u03c3, Meromorphic (F \u03c3)) :\n    Meromorphic (\u220f n \u2208 s, F n) := fun x \u21a6 MeromorphicAt.prod (h \u00b7 x)\n\n@[to_fun (attr := fun_prop)]\nlemma div {f g : \ud835\udd5c \u2192 \ud835\udd5c} (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f / g) := fun x \u21a6 (hf x).div (hg x)\n\n@[to_fun (attr := fun_prop)]\nlemma pow",
      "body": "There is some new metaprogramming that can help here: the `to_fun` attribute.\nTo get access, you need to add `import Mathlib.Tactic.ToFun` to the imports (doesn't need `public`).\n\n```suggestion\n@[to_fun (attr := fun_prop)]\nlemma neg (hf : Meromorphic f) : Meromorphic (-f) := fun x \u21a6 (hf x).neg\n\n@[to_fun (attr := fun_prop)]\nlemma add (hf : Meromorphic f) (hg : Meromorphic g) :\n    Meromorphic (f + g) := fun x \u21a6 (hf x).add (hg x)\n\n@[to_fun (attr := fun_prop)]\ntheorem sum (h : \u2200 \u03c3, Meromorphic (G \u03c3",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "restrict",
          "measurable_of_countable",
          "end",
          "mem_compl_iff",
          "simp",
          "MeromorphicOn",
          "measurable"
        ]
      }
    },
    {
      "id": 3643,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "  rcases (by lia : finrank R V = 0 \u2228 finrank R V = 1) with h0 | h1\n  \u00b7 have : Subsingleton V := (finrank_eq_zero_iff_of_free R V).mp h0\n    simp [Subsingleton.eq_zero v]\n",
      "body": "```suggestion\n  rcases (by lia : finrank R V = 0 \u2228 finrank R V = 1) with h0 | h1\n  \u00b7 have : Subsingleton V := (finrank_eq_zero_iff_of_free R V).mp h0\n    simp [Subsingleton.eq_zero v]\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "body_tactics": [
          "cases",
          "have",
          "simp"
        ],
        "new_tactics": [
          "cases",
          "have"
        ],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 3644,
      "before_code": "namespace LinearMap\n\nvariable {R V : Type*} [CommSemiring R] [AddCommMonoid V] [Module R V]\n\n/-- The transvection associated with a linear form `f` and a vector `v`.\n\nNB. It is only a transvection when `f v = 0`. See also `Module.preReflection`. -/\ndef transvection (f : Module.Dual R V) (v : V) : V \u2192\u2097[R] V where\n  toFun x := x + f x \u2022 v\n  map_add' x y := by simp only [map_add]; module\n  map_smul' r x := by simp only [map_smul, RingHom.id_apply, smul_eq_mul]; module\n\nnamespace transvection\n\ntheorem apply (f : Module.Dual R V) (v x : V) :\n    transvection f v x = x + f x \u2022 v :=\n  rfl\n\ntheorem comp_of_left_eq_apply {f : Module.Dual R V} {v w : V} {x : V} (hw : f w = 0) :\n    transvection f v (transvection f w x) = transvection f (v + w) x := by\n  simp only [transvection, coe_mk, AddHom.coe_mk, map_add, map_smul, hw, smul_add]\n  module\n\ntheorem comp_of_left_eq {f : Module.Dual R V} {v w : V} (hw : f w = 0) :\n    (transvection f v) \u2218\u2097 (transvection f w) = transvection f (v + w) := by\n  ext; simp [comp_of_left_eq_apply hw]\n\ntheorem comp_of_right_eq_apply {f g : Module.Dual R V} {v : V} {x : V} (hf : f v = 0) :\n    (transvection f v) (transvection g v x) = transvection (f + g) v x := by\n  simp only [transvection, coe_mk, AddHom.coe_mk, map_add, map_smul, hf, add_apply]\n  module\n\ntheorem comp_of_right_eq {f g : Module.Dual R V} {v : V} (hf : f v = 0) :\n    (transvection f v) \u2218\u2097 (transvection g v) = transvection (f + g) v := by\n  ext; simp [comp_of_right_eq_apply hf]\n\n@[simp]\ntheorem of_left_eq_zero (v : V) :\n    transvection (0 : Module.Dual R V) v = LinearMap.id := by\n  ext\n  simp [transvection]\n\n@[simp]\ntheorem of_right_eq_zero (f : Module.Dual R V) :\n    transvection f 0 = LinearMap.id := by\n  ext\n  simp [transvection]",
      "suggestion": "    rwa [Finset.sum_eq_single_of_mem i (Finset.mem_univ i) (by grind)] at this\n",
      "body": "```suggestion\n    rwa [Finset.sum_eq_single_of_mem i (Finset.mem_univ i) (by grind)] at this\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "apply",
          "simp",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Module",
          "map_smul",
          "preReflection",
          "Type",
          "when",
          "form",
          "apply",
          "add_apply",
          "LinearMap",
          "ext",
          "associated",
          "coe_mk",
          "comp_of_right_eq_apply",
          "transvection",
          "RingHom",
          "smul_eq_mul",
          "CommSemiring",
          "also",
          "linear",
          "of_left_eq_zero",
          "variable",
          "def",
          "comp_of_right_eq",
          "comp_of_left_eq",
          "See",
          "toFun",
          "module",
          "AddHom",
          "map_add",
          "simp",
          "rfl",
          "only",
          "namespace",
          "comp_of_left_eq_apply",
          "of_right_eq_zero",
          "AddCommMonoid",
          "id_apply",
          "theorem",
          "smul_add",
          "vector",
          "Dual"
        ]
      }
    },
    {
      "id": 3645,
      "before_code": "ext i\n  simp [basis_repr_comp_apply]\n\nvariable [Module.Free R V]\n\ninclude ibc in\ntheorem free : Module.Free S W :=\n  Module.Free.of_basis (ibc.basis (Module.Free.chooseBasis R V))\n\nend IsBaseChange",
      "suggestion": "    suffices (j (1 \u2297\u209c[A] x)) = x.mapRange (algebraMap A R) (by simp) by\n      simp [this, Finsupp.linearCombination_apply, Finsupp.sum_mapRange_index]\n",
      "body": "```suggestion\n    suffices (j (1 \u2297\u209c[A] x)) = x.mapRange (algebraMap A R) (by simp) by\n      simp [this, Finsupp.linearCombination_apply, Finsupp.sum_mapRange_index]\n```",
      "path": "Mathlib/RingTheory/TensorProduct/IsBaseChangeFree.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "Free",
          "end",
          "ext",
          "basis_repr_comp_apply",
          "variable",
          "IsBaseChange",
          "theorem",
          "include",
          "chooseBasis",
          "of_basis",
          "simp",
          "ibc",
          "free",
          "basis"
        ]
      }
    },
    {
      "id": 3646,
      "before_code": "theorem mk_vector (\u03b1 : Type u) (n : \u2115) : #(List.Vector \u03b1 n) = #\u03b1 ^ n :=\n  (mk_congr (Equiv.vectorEquivFin \u03b1 n)).trans <| by simp\n\ntheorem mk_list_eq_sum_pow (\u03b1 : Type u) : #(List \u03b1) = sum fun n : \u2115 => #\u03b1 ^ n :=\n  calc\n    #(List \u03b1) = #(\u03a3 n, List.Vector \u03b1 n) := mk_congr (Equiv.sigmaFiberEquiv List.length).symm\n    _ = sum fun n : \u2115 => #\u03b1 ^ n := by simp",
      "suggestion": "\r\ntheorem sum_zero_pow : sum (fun n \u21a6 (0 : Cardinal) ^ n) = 1 := by\r\n",
      "body": "````suggestion\r\ntheorem sum_zero_pow : sum (fun n \u21a6 (0 : Cardinal) ^ n) = 1 := by\r\n````",
      "path": "Mathlib/SetTheory/Cardinal/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "finset",
          "equiv",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "length",
          "mk_congr",
          "symm",
          "vectorEquivFin",
          "theorem",
          "calc",
          "mk_list_eq_sum_pow",
          "Type",
          "Equiv",
          "trans",
          "Vector",
          "simp",
          "sigmaFiberEquiv",
          "sum",
          "List",
          "mk_vector"
        ]
      }
    },
    {
      "id": 3655,
      "before_code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible",
      "suggestion": "    have hd := congr(degree $h)\n    have aux : (a \u2022 (X : R[X]) + C b).degree = 1 := by compute_degree!\n    rw [degree_mul, aux, eq_comm, Nat.WithBot.add_eq_one_iff] at hd\n    obtain \u27e8hf, -\u27e9 : f.degree = 0 \u2227 g.degree = 1 := by\n      apply hd.resolve_right\n      rintro \u27e8hf0, hfg\u27e9\n      simp_all [(zero_lt_one' (WithBot \u2115)).not_ge]\n    left\n    replace hf := f.eq_C_of_degree_eq_zero hf\n    suffices IsUnit (f.coeff 0) by\n      rw [isUnit_iff]\n      exact \u27e8f.coeff 0, this, hf.symm\u27e9\n    rw [hf, \u2190 smul_eq_C_mul] at h\n    apply hab\n    \u00b7 use g.coeff 1\n      simpa using congr(coeff $h 1)\n    \u00b7 use g.coeff 0\n      simpa using congr(coeff $h 0)\n",
      "body": "```suggestion\n    have hd := congr(degree $h)\n    have aux : (a \u2022 (X : R[X]) + C b).degree = 1 := by compute_degree!\n    rw [degree_mul, aux, eq_comm, Nat.WithBot.add_eq_one_iff] at hd\n    obtain \u27e8hf, -\u27e9 : f.degree = 0 \u2227 g.degree = 1 := by\n      apply hd.resolve_right\n      rintro \u27e8hf0, hfg\u27e9\n      simp_all [(zero_lt_one' (WithBot \u2115)).not_ge]\n    left\n    replace hf := f.eq_C_of_degree_eq_zero hf\n    suffices IsUnit (f.coeff 0) by\n      rw [isUnit_iff]\n      exact \u27e8f.coeff 0, this, hf.symm\u27e9\n    r",
      "path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "body_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "new_tactics": [
          "apply",
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp_all",
          "congr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Monic",
          "irreducible",
          "theorem",
          "Irreducible",
          "hp1",
          "prime_of_degree_eq_one",
          "irreducible_of_degree_eq_one",
          "degree"
        ]
      }
    },
    {
      "id": 3657,
      "before_code": "end ConnectedComponent\n\nset_option backward.proofsInPublic true in\n/-- Given graph homomorphisms from each connected component of `G` to `H` this is the graph\nhomomorphism from `G` to `H` -/\n@[simps]\ndef homOfConnectedComponents (G : SimpleGraph V) {H : SimpleGraph V'}\n    (C : (c : G.ConnectedComponent) \u2192 c.toSimpleGraph \u2192g H) : G \u2192g H where\n  toFun := fun x \u21a6 (C (G.connectedComponentMk _)) _",
      "suggestion": "\r\n  toFun := fun x \u21a6 (C (G.connectedComponentMk x)) \u27e8x, _\u27e9\r\n",
      "body": "I don't love the long proof; can Lean figure out just that proof if you specify x (i.e., does this work)?\r\n```suggestion\r\n  toFun := fun x \u21a6 (C (G.connectedComponentMk x)) \u27e8x, _\u27e9\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Connected.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "true",
          "each",
          "connectedComponentMk",
          "component",
          "homomorphisms",
          "proofsInPublic",
          "SimpleGraph",
          "def",
          "toFun",
          "simps",
          "backward",
          "homomorphism",
          "ConnectedComponent",
          "connected",
          "graph",
          "this",
          "Given",
          "from",
          "toSimpleGraph",
          "homOfConnectedComponents",
          "set_option"
        ]
      }
    },
    {
      "id": 3659,
      "before_code": "end Semiring",
      "suggestion": "\r\ndef toSubring : PowerSeries T := mk fun n => \u27e8p.coeff n, hp n\u27e9\r\n",
      "body": "```suggestion\r\ndef toSubring : PowerSeries T := mk fun n => \u27e8p.coeff n, hp n\u27e9\r\n```",
      "path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Semiring"
        ]
      }
    },
    {
      "id": 3665,
      "before_code": "simpa using angle_le_angle_add_angle_of_norm_eq_one (norm_normalize_eq_one_iff.mpr hx)\n    (norm_normalize_eq_one_iff.mpr hy) (norm_normalize_eq_one_iff.mpr hz)",
      "suggestion": "\r\n      obtain \u27e8_, \u27e8r2, \u27e8H5, rfl\u27e9\u27e9\u27e9 := H2\r\n      lift r2 to \u211d\u22650 using H5.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n    have H2 : Real.sin (angle x z) \u2260 0 := by\r\n      grind [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi]\r\n    obtain hx | hx := eq_or_ne x 0\r\n    \u00b7 subst x; simp only [angle_zero_left, left_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H3, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H3.le\r\n      rw [\u2190 NNReal.smul_def, Submodule.span_insert_zero, Submodule.span_singleton_smul_eq]\r\n      \u00b7 simp\r\n      norm_cast at H3\r\n      grind [isUnit_iff_ne_zero]\r\n    obtain hz | hz := eq_or_ne z 0\r\n    \u00b7 subst z; simp only [angle_zero_right, right_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H1, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H1.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n",
      "body": "```suggestion\r\n      obtain \u27e8_, \u27e8r2, \u27e8H5, rfl\u27e9\u27e9\u27e9 := H2\r\n      lift r2 to \u211d\u22650 using H5.le\r\n      exact Submodule.smul_mem _ _ (Submodule.mem_span_of_mem (by simp))\r\n    have H2 : Real.sin (angle x z) \u2260 0 := by\r\n      grind [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi]\r\n    obtain hx | hx := eq_or_ne x 0\r\n    \u00b7 subst x; simp only [angle_zero_left, left_eq_add] at H\r\n      rw [angle_eq_zero_iff] at H\r\n      obtain \u27e8_, \u27e8r, \u27e8H3, rfl\u27e9\u27e9\u27e9 := H\r\n      lift r to \u211d\u22650 using H3.le\r\n      rw [\u2190 NNReal.smul_d",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp",
          "norm_cast"
        ],
        "body_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp_all",
          "simp",
          "norm_cast"
        ],
        "new_tactics": [
          "exact",
          "grind",
          "have",
          "obtain",
          "rw",
          "simp",
          "norm_cast"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "simpa",
          "angle_le_angle_add_angle_of_norm_eq_one",
          "using",
          "norm_normalize_eq_one_iff"
        ]
      }
    },
    {
      "id": 3666,
      "before_code": "lemma pow_toEnd_f_eq_zero_of_eq_nat\n    [IsNoetherian R M] [NoZeroSMulDivisors R M] [IsDomain R] [CharZero R]\n    {n : \u2115} (hn : \u03bc = n) : (\u03c8 (n + 1)) = 0 := by",
      "suggestion": "    {n : \u2115} (hn : \u03bc = n) : (\u03c8 (n + 1)) = 0 := by\n",
      "body": "Although, separate from whitespace, I'm not sure why this has the extra parens *outside* of `\u03c8 (n + 1)`. If you want to fix that here too I'm okay with it (although maybe there's some elaboration issue I'm missing about it.\n```suggestion\n    {n : \u2115} (hn : \u03bc = n) : (\u03c8 (n + 1)) = 0 := by\n```",
      "path": "Mathlib/Algebra/Lie/Sl2.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "pow_toEnd_f_eq_zero_of_eq_nat",
          "lemma",
          "IsNoetherian",
          "IsDomain",
          "NoZeroSMulDivisors",
          "CharZero"
        ]
      }
    },
    {
      "id": 3669,
      "before_code": "(H \u2294 K).Connected :=\n  Subgraph.connected_sup hH.preconnected hK.preconnected hn",
      "suggestion": "\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degree_pos_of_nontrivial v\r\n",
      "body": "Even though you know the graph is nonempty I think it's better to assume the weaker `Preconnected` instead of `Connected`.\r\nAlso, the `by_contra` is redundant here.\r\n```suggestion\r\nlemma Preconnected.degree_zero_iff {H : G.Subgraph} (h : H.Preconnected) (v : H.verts)\r\n    [Fintype (H.neighborSet v)] : H.degree v = 0 \u2194 H.verts.Subsingleton := by\r\n  refine \u27e8fun hv \u21a6 Set.not_nontrivial_iff.mp fun hn \u21a6 ?_, (degree_eq_zero_of_subsingleton H _ \u00b7)\u27e9\r\n  have := hn.coe_sort\r\n  simpa [hv] using h.coe.degre",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "refine"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [
          "use_simpa",
          "remove_redundant"
        ],
        "keywords": [
          "Connected",
          "connected_sup",
          "Subgraph",
          "preconnected"
        ]
      }
    },
    {
      "id": 3671,
      "before_code": "have h2 : 0 \u2264 r := nonneg_of_mul_nonneg_left h1 (dist_pos.mpr hab\u2081)\n    exact (sq_eq_sq\u2080 dist_nonneg (mul_nonneg h2 dist_nonneg)).mp h'",
      "suggestion": "\r\ntheorem exterior_angle_eq_angle_add_angle {p\u2081 p\u2082 p\u2083 : P} (p : P) (h : Sbtw \u211d p p\u2081 p\u2082) :\r\n    \u2220 p\u2083 p\u2081 p = \u2220 p\u2081 p\u2083 p\u2082 + \u2220 p\u2083 p\u2082 p\u2081 := by\r\n  have H := (EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n  rw [show \u2220 p\u2083 p\u2081 p\u2082 = \u2220 p\u2082 p\u2081 p\u2083 by simp only [angle_comm],\r\n      add_comm,\r\n      \u2190 angle_add_angle_add_angle_eq_pi p\u2083 ((Sbtw.right_ne h).symm),\r\n      add_assoc] at H\r\n  simp only [add_right_inj] at H\r\n  rw [H]\r\n",
      "body": "Thanks for the PR! I think we can shorten this proof. Here is a suggestion: \r\n```suggestion\r\ntheorem exterior_angle_eq_angle_add_angle {p\u2081 p\u2082 p\u2083 : P} (p : P) (h : Sbtw \u211d p p\u2081 p\u2082) :\r\n    \u2220 p\u2083 p\u2081 p = \u2220 p\u2081 p\u2083 p\u2082 + \u2220 p\u2083 p\u2082 p\u2081 := by\r\n  have H := (EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi p\u2083 (Sbtw.angle\u2081\u2082\u2083_eq_pi h)).symm\r\n  rw [show \u2220 p\u2083 p\u2081 p\u2082 = \u2220 p\u2082 p\u2081 p\u2083 by simp only [angle_comm],\r\n      add_comm,\r\n      \u2190 angle_add_angle_add_angle_eq_pi p\u2083 ((Sbtw.right_ne h).symm),\r\n      add_assoc] at",
      "path": "Mathlib/Geometry/Euclidean/Triangle.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "mpr",
          "nonneg_of_mul_nonneg_left",
          "exact",
          "have",
          "dist_pos",
          "dist_nonneg",
          "mul_nonneg"
        ]
      }
    },
    {
      "id": 3676,
      "before_code": "rw [Set.top_eq_univ, Set.finite_univ_iff, \u2190 @Finset.coe_sort_coe]\n    exact Finite.of_fintype p.support\n  apply Set.Finite.bddAbove <| Set.Finite.subset h_fin _\n  intro x hx\n  obtain \u27e8i, hi\u27e9 := hx\n  rw [\u2190 hi]\n  by_cases hi : i \u2208 p.support\n  \u00b7 left\n    use \u27e8i, hi\u27e9\n    simp [f]\n  \u00b7 right\n    simp [Polynomial.notMem_support_iff.mp hi]",
      "suggestion": "refine Set.Finite.bddAbove <| Set.Finite.subset h_fin _ fun _ \u21a6 ?_\n",
      "body": "````suggestion\nrefine Set.Finite.bddAbove <| Set.Finite.subset h_fin _ fun _ \u21a6 ?_\n````\nPerhaps?",
      "path": "Mathlib/RingTheory/Polynomial/GaussNorm.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "exact",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "apply",
          "exact",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "bddAbove",
          "obtain",
          "Polynomial",
          "coe_sort_coe",
          "apply",
          "right",
          "by_cases",
          "Finset",
          "intro",
          "notMem_support_iff",
          "top_eq_univ",
          "h_fin",
          "of_fintype",
          "simp",
          "use",
          "subset",
          "Finite",
          "finite_univ_iff",
          "support",
          "exact",
          "left",
          "Set"
        ]
      }
    },
    {
      "id": 3681,
      "before_code": "\u00b7 rw [choose_eq_zero_of_lt hk, choose_eq_zero_of_lt (n.lt_succ_self.trans hk), Nat.zero_mul,\n        Nat.zero_mul]",
      "suggestion": "  calc\n    (m * (p + 1) + (p + 1)).choose (p + 1) * ((m * (p + 1))! * (p + 1)!)\n      = (m * (p + 1) + (p + 1)).choose (p + 1) * (m * (p + 1))! * (p + 1)! := by lia\n    _ = (m * (p + 1) + (p + 1))! := by rw [add_choose_mul_factorial_mul_factorial]\n    _ = ((m * (p + 1) + p) + 1)! := by lia\n    _ = ((m * (p + 1) + p) + 1) * (m * (p + 1) + p)! := by rw [factorial_succ]\n    _ = (m * (p + 1) + p)! * ((p + 1) * (m + 1)) := by lia\n    _ = ((m * (p + 1) + p).choose p * (m * (p + 1))! * (p)!) * ((p + 1) * (m + 1)) := by\n      rw [add_choose_mul_factorial_mul_factorial]\n    _ = (m * (p + 1) + p).choose p * (m * (p + 1))! * (((p + 1) * (p)!) * (m + 1)) := by lia\n    _ = (m * (p + 1) + p).choose p * (m * (p + 1))! * ((p + 1)! * (m + 1)) := by rw [factorial_succ]\n    _ = (m + 1) * (m * (p + 1) + p).choose p * ((m * (p + 1))! * (p + 1)!) := by lia\n",
      "body": "```suggestion\n  calc\n    (m * (p + 1) + (p + 1)).choose (p + 1) * ((m * (p + 1))! * (p + 1)!)\n      = (m * (p + 1) + (p + 1)).choose (p + 1) * (m * (p + 1))! * (p + 1)! := by lia\n    _ = (m * (p + 1) + (p + 1))! := by rw [add_choose_mul_factorial_mul_factorial]\n    _ = ((m * (p + 1) + p) + 1)! := by lia\n    _ = ((m * (p + 1) + p) + 1) * (m * (p + 1) + p)! := by rw [factorial_succ]\n    _ = (m * (p + 1) + p)! * ((p + 1) * (m + 1)) := by lia\n    _ = ((m * (p + 1) + p).choose p * (m * (p + 1))! * (p",
      "path": "Mathlib/Data/Nat/Choose/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "lt_succ_self",
          "Nat",
          "choose_eq_zero_of_lt",
          "trans",
          "zero_mul"
        ]
      }
    },
    {
      "id": 3682,
      "before_code": "end Northcott",
      "suggestion": "  have : NeZero n := \u27e8hn\u27e9\n  suffices \u220f x \u2208 primitiveRoots n \u2102, max 1 \u2016x\u2016 = 1 by\n    simpa [mahlerMeasure_eq_leadingCoeff_mul_prod_roots, cyclotomic.monic n \u2102,\n      Polynomial.cyclotomic.roots_eq_primitiveRoots_val]\n  suffices \u2200 a \u2208 primitiveRoots n \u2102, \u2016a\u2016 \u2264 1 from Multiset.prod_eq_one (by simpa)\n  intro z hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le\n",
      "body": "```suggestion\n  have : NeZero n := \u27e8hn\u27e9\n  suffices \u220f x \u2208 primitiveRoots n \u2102, max 1 \u2016x\u2016 = 1 by\n    simpa [mahlerMeasure_eq_leadingCoeff_mul_prod_roots, cyclotomic.monic n \u2102,\n      Polynomial.cyclotomic.roots_eq_primitiveRoots_val]\n  suffices \u2200 a \u2208 primitiveRoots n \u2102, \u2016a\u2016 \u2264 1 from Multiset.prod_eq_one (by simpa)\n  intro z hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "body_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "new_tactics": [
          "simpa",
          "exact",
          "have",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Northcott",
          "end"
        ]
      }
    },
    {
      "id": 3683,
      "before_code": "| none =>\n        cont heq heqType\n\n/--\nThe configuration used by `rw!` to call `dsimp`.\nThis configuration uses only iota reduction (recursor application) to simplify terms.\n-/\nprivate def depRwContext : MetaM Simp.Context :=\n  Simp.mkContext\n    {Lean.Meta.Simp.neutralConfig with\n     etaStruct := .none\n     iota := true\n     failIfUnchanged := false}",
      "suggestion": "/-- Cleanup casts introduced by `rewrite!` in `e`. \nThe result is expected to be defeq to the original expression. -/\n",
      "body": "```suggestion\n/-- Cleanup casts introduced by `rewrite!` in `e`. \nThe result is expected to be defeq to the original expression. -/\n```\nThis is an invariant used elsewhere, so worthwhile to document.",
      "path": "Mathlib/Tactic/DepRewrite.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "etaStruct",
          "MetaM",
          "true",
          "call",
          "simplify",
          "heqType",
          "terms",
          "cont",
          "reduction",
          "This",
          "Lean",
          "private",
          "configuration",
          "heq",
          "false",
          "neutralConfig",
          "Simp",
          "def",
          "Context",
          "used",
          "none",
          "uses",
          "failIfUnchanged",
          "depRwContext",
          "application",
          "dsimp",
          "only",
          "recursor",
          "mkContext",
          "iota",
          "Meta"
        ]
      }
    },
    {
      "id": 3684,
      "before_code": "rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h",
      "suggestion": "\r\n  refine \u27e8fun h hn' \u21a6 ?_, fun h => separable_X_pow_sub_C_unit (Units.mk0 x hx) (IsUnit.mk0 _ h)\u27e9\r\n  exact not_isUnit_of_natDegree_pos (X ^ n - C x) (by simp [hn]) <| by\r\n    simpa [separable_def, derivative_X_pow, hn', isCoprime_zero_right] using h\r\n",
      "body": "````suggestion\r\n  refine \u27e8fun h hn' \u21a6 ?_, fun h => separable_X_pow_sub_C_unit (Units.mk0 x hx) (IsUnit.mk0 _ h)\u27e9\r\n  exact not_isUnit_of_natDegree_pos (X ^ n - C x) (by simp [hn]) <| by\r\n    simpa [separable_def, derivative_X_pow, hn', isCoprime_zero_right] using h\r\n````\r\nI know you copied the proof from the previous lemma, but that old proof is honestly pretty bizzare. Here's a shorter version doing exactly the same steps.",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "simpa",
          "refine",
          "exact",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "refine",
          "exact",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "simp",
          "refine"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "exact",
          "C_0",
          "isCoprime_zero_right",
          "not_isUnit_X_pow_sub_one",
          "zero_mul"
        ]
      }
    },
    {
      "id": 3685,
      "before_code": "rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h",
      "suggestion": "  refine \u27e8?_, fun h => separable_X_pow_sub_C x h hx\u27e9\n",
      "body": "````suggestion\n  refine \u27e8?_, fun h => separable_X_pow_sub_C x h hx\u27e9\n````",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "C_0",
          "isCoprime_zero_right",
          "not_isUnit_X_pow_sub_one",
          "zero_mul"
        ]
      }
    },
    {
      "id": 3686,
      "before_code": "rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]\n  grw [\u2190 le_max_left]",
      "suggestion": "      \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n \u21a6 fn (ni n) x) u (\ud835\udcdd (g x))}) \u21a6 f.1) p \u03bc := by\n",
      "body": "```suggestion\n      \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n \u21a6 fn (ni n) x) u (\ud835\udcdd (g x))}) \u21a6 f.1) p \u03bc := by\n```",
      "path": "Mathlib/MeasureTheory/Function/UniformIntegrable.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "norm_indicator_eq_indicator_norm",
          "grw",
          "le_max_left"
        ]
      }
    },
    {
      "id": 3687,
      "before_code": "exact I.2.choose_spec.2 a ha\n\n/-- The linear equivalence between the fractional ideal `I` and the integral ideal `I.num`\ndefined by mapping `x` to `den I \u2022 x`. -/\nnoncomputable def equivNum [Nontrivial P] [NoZeroSMulDivisors R P]\n    {I : FractionalIdeal S P} (h_nz : (I.den : R) \u2260 0) : I \u2243\u2097[R] I.num := by",
      "suggestion": "\r\ndefined by mapping `x` to `I.den \u2022 x`, assuming scalar multiplication by `I.den` is injective. -/\r\n",
      "body": "```suggestion\r\ndefined by mapping `x` to `I.den \u2022 x`, assuming scalar multiplication by `I.den` is injective. -/\r\n```",
      "path": "Mathlib/RingTheory/FractionalIdeal/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "Nontrivial",
          "den",
          "noncomputable",
          "h_nz",
          "equivalence",
          "ideal",
          "linear",
          "equivNum",
          "choose_spec",
          "num",
          "def",
          "FractionalIdeal",
          "between",
          "defined",
          "fractional",
          "exact",
          "mapping",
          "NoZeroSMulDivisors",
          "integral"
        ]
      }
    },
    {
      "id": 3688,
      "before_code": "exact I.2.choose_spec.2 a ha\n\n/-- The linear equivalence between the fractional ideal `I` and the integral ideal `I.num`\ndefined by mapping `x` to `den I \u2022 x`. -/\nnoncomputable def equivNum [Nontrivial P] [NoZeroSMulDivisors R P]\n    {I : FractionalIdeal S P} (h_nz : (I.den : R) \u2260 0) : I \u2243\u2097[R] I.num := by\n  refine LinearEquiv.trans\n    (LinearEquiv.ofBijective ((DistribMulAction.toLinearMap R P I.den).restrict fun _ hx \u21a6 ?_)\n      \u27e8fun _ _ hxy \u21a6 ?_, fun \u27e8y, hy\u27e9 \u21a6 ?_\u27e9)\n    (Submodule.equivMapOfInjective (Algebra.linearMap R P)\n      (FaithfulSMul.algebraMap_injective R P) (num I)).symm\n  \u00b7 rw [\u2190 den_mul_self_eq_num]\n    exact Submodule.smul_mem_pointwise_smul _ _ _ hx\n  \u00b7 simp_rw [LinearMap.restrict_apply, DistribMulAction.toLinearMap_apply, Subtype.mk.injEq] at hxy\n    rwa [Submonoid.smul_def, Submonoid.smul_def, smul_right_inj h_nz, SetCoe.ext_iff] at hxy\n  \u00b7 rw [\u2190 den_mul_self_eq_num] at hy\n    obtain \u27e8x, hx, hxy\u27e9 := hy\n    exact \u27e8\u27e8x, hx\u27e9, by simp_rw [LinearMap.restrict_apply, Subtype.ext_iff, \u2190 hxy]; rfl\u27e9",
      "suggestion": "\r\ndefined by mapping `x` to `I.den \u2022 x`. -/\r\n",
      "body": "```suggestion\r\ndefined by mapping `x` to `I.den \u2022 x`. -/\r\n```",
      "path": "Mathlib/RingTheory/FractionalIdeal/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "refine"
        ],
        "topics": [
          "equiv",
          "set_theory",
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subtype",
          "rwa",
          "Nontrivial",
          "DistribMulAction",
          "toLinearMap_apply",
          "algebraMap_injective",
          "smul_right_inj",
          "obtain",
          "smul_mem_pointwise_smul",
          "toLinearMap",
          "den",
          "restrict",
          "symm",
          "SetCoe",
          "noncomputable",
          "refine",
          "LinearMap",
          "ofBijective",
          "equivalence",
          "h_nz",
          "FaithfulSMul",
          "Submodule",
          "Submonoid",
          "restrict_apply",
          "ideal",
          "hxy",
          "simp_rw",
          "linear",
          "equivNum",
          "choose_spec",
          "num",
          "def",
          "FractionalIdeal",
          "equivMapOfInjective",
          "linearMap",
          "den_mul_self_eq_num",
          "between",
          "rfl",
          "defined",
          "fractional",
          "ext_iff",
          "integral",
          "exact",
          "LinearEquiv",
          "smul_def",
          "mapping",
          "trans",
          "NoZeroSMulDivisors",
          "Algebra",
          "injEq"
        ]
      }
    },
    {
      "id": 3689,
      "before_code": "simp [LinearMap.comp_assoc]\n\nend Finsupp",
      "suggestion": "    coassoc := by ext; simp [coalgebraStruct] }\n",
      "body": "```suggestion\n    coassoc := by ext; simp [coalgebraStruct] }\n```",
      "path": "Mathlib/RingTheory/Coalgebra/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "simp",
          "ext"
        ],
        "body_tactics": [
          "simp",
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "end",
          "LinearMap",
          "comp_assoc",
          "simp"
        ]
      }
    },
    {
      "id": 3697,
      "before_code": "inf_iInf_nat_succ u\n\ntheorem iUnion_le_nat : \u22c3 n : \u2115, {i | i \u2264 n} = Set.univ :=\n subset_antisymm (Set.subset_univ _)\n   (fun i _ \u21a6 Set.mem_iUnion_of_mem i (Set.mem_setOf.mpr (le_refl _)))",
      "suggestion": "\r\n    fun i _ \u21a6 Set.mem_iUnion_of_mem i (Set.mem_setOf.mpr le_rfl)\r\n",
      "body": "```suggestion\r\n    fun i _ \u21a6 Set.mem_iUnion_of_mem i (Set.mem_setOf.mpr le_rfl)\r\n```",
      "path": "Mathlib/Data/Set/Lattice.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "theorem",
          "univ",
          "inf_iInf_nat_succ",
          "Set",
          "iUnion_le_nat",
          "subset_antisymm",
          "subset_univ",
          "le_refl",
          "mem_setOf",
          "mem_iUnion_of_mem"
        ]
      }
    },
    {
      "id": 3698,
      "before_code": "end Nat",
      "suggestion": "theorem Int.alternating_sum_range_choose_eq_choose {n m : \u2115} :\n",
      "body": "I think distinguishing between these two lemma names just by dropping `range` is great. I admit I'm struggling to find a name I really like here but let's try:\n```suggestion\ntheorem Int.alternating_sum_range_choose_eq_choose {n m : \u2115} :\n```",
      "path": "Mathlib/Data/Nat/Choose/Sum.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Nat",
          "end"
        ]
      }
    },
    {
      "id": 3699,
      "before_code": "rw [this, \u2190 Measure.map_map (by fun_prop) (by fun_prop), gaussianReal_map_neg,\n    gaussianReal_map_const_add, add_comm]\n\nvariable {\u03a9 : Type} [MeasureSpace \u03a9]\n\n/-- If `X` is a real random variable with Gaussian law with mean `\u03bc` and variance `v`, then `X + y`\nhas Gaussian law with mean `\u03bc + y` and variance `v`. -/\nlemma gaussianReal_add_const {X : \u03a9 \u2192 \u211d} (hX : Measure.map X \u2119 = gaussianReal \u03bc v) (y : \u211d) :\n    Measure.map (fun \u03c9 \u21a6 X \u03c9 + y) \u2119 = gaussianReal (\u03bc + y) v := by\n  have hXm : AEMeasurable X := aemeasurable_of_map_neZero (by rw [hX]; infer_instance)\n  change Measure.map ((fun \u03c9 \u21a6 \u03c9 + y) \u2218 X) \u2119 = gaussianReal (\u03bc + y) v\n  rw [\u2190 AEMeasurable.map_map_of_aemeasurable (measurable_id'.add_const _).aemeasurable hXm, hX,\n    gaussianReal_map_add_const y]",
      "suggestion": "    HasLaw (fun \u03c9 \u21a6 X \u03c9 + y) (gaussianReal (\u03bc + y) v) P :=\n  HasLaw.comp \u27e8by fun_prop, gaussianReal_map_add_const y\u27e9 hX\n",
      "body": "Like you did for the mul:\n```suggestion\n    HasLaw (fun \u03c9 \u21a6 X \u03c9 + y) (gaussianReal (\u03bc + y) v) P :=\n  HasLaw.comp \u27e8by fun_prop, gaussianReal_map_add_const y\u27e9 hX\n```\nIn fact you can do the same for all the lemmas.",
      "path": "Mathlib/Probability/Distributions/Gaussian/Real.lean",
      "tags": {
        "before_tactics": [
          "fun_prop",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "have"
        ],
        "topics": [
          "list",
          "real",
          "measurability"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "lemma",
          "add_comm",
          "real",
          "Type",
          "law",
          "hXm",
          "change",
          "gaussianReal",
          "has",
          "fun_prop",
          "variance",
          "infer_instance",
          "have",
          "Measure",
          "map",
          "Gaussian",
          "gaussianReal_map_const_add",
          "gaussianReal_map_add_const",
          "MeasureSpace",
          "variable",
          "then",
          "aemeasurable_of_map_neZero",
          "map_map",
          "gaussianReal_map_neg",
          "aemeasurable",
          "add_const",
          "measurable_id",
          "AEMeasurable",
          "random",
          "mean",
          "this",
          "map_map_of_aemeasurable",
          "gaussianReal_add_const"
        ]
      }
    },
    {
      "id": 3700,
      "before_code": "(h : \u2200 F : Set \u03a9, IsClosed F \u2192\n      limsup (fun i \u21a6 (\u03bcs i : Measure \u03a9).real F) L \u2264 (\u03bc : Measure \u03a9).real F) :\n    Tendsto \u03bcs L (\ud835\udcdd \u03bc) := by\n  refine tendsto_of_forall_isClosed_limsup_le' fun F hF \u21a6 ?_\n  rcases L.eq_or_neBot with rfl | hne\n  \u00b7 simp\n  specialize h F hF\n  simp only [Measure.real_def] at h\n  rwa [ENNReal.limsup_toReal_eq (b := 1) (by simp) (.of_forall fun i \u21a6 prob_le_one),\n    ENNReal.toReal_le_toReal _ (by finiteness)] at h\n  refine ne_top_of_le_ne_top (b := 1) (by simp) ?_\n  refine limsup_le_of_le ?_ (.of_forall fun i \u21a6 prob_le_one)\n  exact isCoboundedUnder_le_of_le L (x := 0) (by simp)",
      "suggestion": "Tendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n",
      "body": "````suggestion\nTendsto \u03bcs L (\ud835\udcdd \u03bc) :=\n  tendsto_of_forall_isClosed_limsup_le (by simpa using h)\n````",
      "path": "Mathlib/MeasureTheory/Measure/Portmanteau.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "simp",
          "refine"
        ],
        "topics": [
          "measurability",
          "order",
          "topology"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "of_forall",
          "rwa",
          "real",
          "rcases",
          "limsup_le_of_le",
          "finiteness",
          "refine",
          "specialize",
          "real_def",
          "Measure",
          "isCoboundedUnder_le_of_le",
          "limsup",
          "eq_or_neBot",
          "hne",
          "Tendsto",
          "simp",
          "prob_le_one",
          "rfl",
          "IsClosed",
          "only",
          "ne_top_of_le_ne_top",
          "ENNReal",
          "exact",
          "Set",
          "tendsto_of_forall_isClosed_limsup_le",
          "limsup_toReal_eq",
          "toReal_le_toReal"
        ]
      }
    },
    {
      "id": 3701,
      "before_code": "refine (e.forall_congr ?_).symm\n    intro i\n    rw [MeasurableEquiv.piCongrLeft_apply_apply e x i]\n  rw [this, pi_pi, Finset.prod_equiv e.symm]\n  \u00b7 simp only [Finset.mem_univ, implies_true]\n  intro i _\n  simp only [s']\n  congr\n  all_goals rw [e.apply_symm_apply]",
      "suggestion": "\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n",
      "body": "````suggestion\r\n  simpa [this] using Fintype.prod_equiv _ (fun i \u21a6 (\u03bc (e i)) (s' i)) _ (congrFun rfl)\r\n````",
      "path": "Mathlib/MeasureTheory/Constructions/Pi.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "refine",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "topics": [
          "measurability",
          "set_theory",
          "finset"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "apply_symm_apply",
          "symm",
          "refine",
          "all_goals",
          "mem_univ",
          "forall_congr",
          "piCongrLeft_apply_apply",
          "Finset",
          "implies_true",
          "pi_pi",
          "congr",
          "this",
          "simp",
          "intro",
          "MeasurableEquiv",
          "prod_equiv",
          "only"
        ]
      }
    },
    {
      "id": 3704,
      "before_code": "end IsTightMeasureSet",
      "suggestion": "  refine ENNReal.tsum_le_tsum fun m \u21a6 tsub_le_iff_tsub_le.mp ?_\n",
      "body": "You can put `intro`s inside `refine`. Please do so at the other places where this appears in the file. You can also combine the lines below:\n```suggestion\n  refine ENNReal.tsum_le_tsum fun m \u21a6 tsub_le_iff_tsub_le.mp ?_\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine",
          "intro"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsTightMeasureSet",
          "end"
        ]
      }
    },
    {
      "id": 3705,
      "before_code": "end IsTightMeasureSet",
      "suggestion": "  rw [\u2190 coe_ofNat, \u2190 ENNReal.coe_zpow (by simp), \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n",
      "body": "Please mind the spacing. You can put the `simp` inside the `rw`. Also you don't need the `ENNReal` namespace.\n```suggestion\n  rw [\u2190 coe_ofNat, \u2190 ENNReal.coe_zpow (by simp), \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "simp"
        ],
        "body_tactics": [
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsTightMeasureSet",
          "end"
        ]
      }
    },
    {
      "id": 3706,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "private lemma lt_geom_series {D : \u2115 \u2192 \ud835\udce7} {\u03b5 : \u211d\u22650\u221e} {\u03bc : ProbabilityMeasure \ud835\udce7} {km : \u2115 \u2192 \u2115}\n    {u : \u2115 \u2192 \u211d} (hu_anti : Antitone u)\n    (hbound : \u2200 k : \u2115, 1 - \u03b5 * 2 ^ (-k : \u2124) < \u03bc (\u22c3 i \u2264 km k, ball (D i) (u k))) :\n    \u2211' (m : \u2115), (1 - \u03bc.toMeasure (\u22c3 i \u2264 km (m + 1), closure (ball (D i) (u m)))) \u2264\n    \u2211' (m : \u2115), (\u03b5 : \u211d\u22650\u221e) * 2 ^ (-((m : \u2124) + 1)) := by\n  refine ENNReal.tsum_le_tsum fun m \u21a6 tsub_le_iff_tsub_le.mp ?_\n  specialize hbound (m+1)\n  apply le_of_lt at hbound\n  simp_all only [neg_add_rev, Int.reduceNeg, tsub_le_iff_right, Nat.cast_add, Nat.cast_one,\n      \u2190 coe_ofNat, \u2190 ennreal_coeFn_eq_coeFn_toMeasure]\n  grw [hbound]\n  gcongr\n  \u00b7 refine apply_mono \u03bc <| iUnion\u2082_mono <| fun i hi \u21a6 ?_\n    grw [\u2190 subset_closure (s := ball (D i) (u m)), ball_subset_ball]\n    exact hu_anti (by grind)\n",
      "body": "Changes:\n- use a generic antitone sequence `u` instead of `1/(m+1)`\n- spacing of the statement\n- some spaces added (after `\u2190`, before `:=`)\n```suggestion\nprivate lemma lt_geom_series {D : \u2115 \u2192 \ud835\udce7} {\u03b5 : \u211d\u22650\u221e} {\u03bc : ProbabilityMeasure \ud835\udce7} {km : \u2115 \u2192 \u2115}\n    {u : \u2115 \u2192 \u211d} (hu_anti : Antitone u)\n    (hbound : \u2200 k : \u2115, 1 - \u03b5 * 2 ^ (-k : \u2124) < \u03bc (\u22c3 i \u2264 km k, ball (D i) (u k))) :\n    \u2211' (m : \u2115), (1 - \u03bc.toMeasure (\u22c3 i \u2264 km (m + 1), closure (ball (D i) (u m)))) \u2264\n    \u2211' (m : \u2115), (\u03b5 : \u211d\u22650\u221e) * 2 ^ (-((m : \u2124) + 1)) ",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "grind",
          "simp_all"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "grind",
          "simp_all"
        ],
        "new_tactics": [
          "apply",
          "gcongr",
          "refine",
          "grind",
          "simp_all"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "cleanup_simp",
          "use_grind"
        ],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3707,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "theorem isTightMeasureSet_of_isCompact_closure (hcomp : IsCompact (closure S)) :\n    IsTightMeasureSet {((\u03bc : ProbabilityMeasure \ud835\udce7) : Measure \ud835\udce7) | \u03bc \u2208 S} := by\n  rw [IsTightMeasureSet_iff_exists_isCompact_measure_compl_le]\n  rcases isEmpty_or_nonempty \ud835\udce7 with hempty | hempty\n  \u00b7 intro \u03b5 \u03b5pos\n    use \u2205\n    constructor\n    \u00b7 exact isCompact_empty\n    rw [\u2190 univ_eq_empty_iff] at hempty\n    simp only [mem_setOf_eq, compl_empty, hempty, measure_empty, zero_le, implies_true]\n  obtain \u27e8D, hD\u27e9 := exists_dense_seq \ud835\udce7\n  obtain \u27e8u, hu_anti, hu_pos, hu\u27e9 : \u2203 u, StrictAnti u \u2227 (\u2200 n, 0 < u n) \u2227 Tendsto u atTop (\ud835\udcdd 0) :=\n    exists_seq_strictAnti_tendsto (0 : \u211d)\n  have hcov (m : \u2115) : \u22c3 i, ball (D i) (u m) = univ := by\n    rw [denseRange_iff] at hD\n    ext p\n    exact \u27e8fun a \u21a6 trivial, fun _ \u21a6 mem_iUnion.mpr <| hD p (u m) (hu_pos m)\u27e9\n  intro \u03b5 \u03b5pos\n  by_cases h\u03b5bound : 1 < \u03b5\n  \u00b7 use \u2205\n    constructor\n    \u00b7 exact isCompact_empty\n    intro \u03bc h\u03bc\n    simp only [mem_setOf_eq] at h\u03bc\n    obtain \u27e8\u03bc', h\u03bc', rfl\u27e9 :=",
      "body": "Changes:\n- use a generic sequence `u` with `StrictAnti u \u2227 (\u2200 n, 0 < u n) \u2227 Tendsto u atTop (\ud835\udcdd 0)` instead of `1/(m+1)`. It leads to shorter expressions and makes it easier to see what are the properties used. Also replace the inverse of delta by `have \u27e8\u03b4_inv, h\u03b4_inv\u27e9 : \u2203 x, u x < \u03b4`.\n- use `simpa` more\n- fix spaces here and there\n- replace instances of `use x; constructor; intro y`... on multiple lines by a one-line `refine`\n```suggestion\ntheorem isTightMeasureSet_of_isCompact_closure (hcomp : ",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "refine",
          "ext",
          "exact",
          "cases",
          "linarith",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "constructor",
          "intro",
          "congr",
          "measurability",
          "ring_nf"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "refine",
          "ext",
          "exact",
          "cases",
          "linarith",
          "have",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "constructor",
          "intro",
          "congr",
          "measurability",
          "ring_nf"
        ],
        "new_tactics": [
          "obtain",
          "rw",
          "simp",
          "congr",
          "measurability",
          "ring_nf",
          "apply",
          "gcongr",
          "refine",
          "ext",
          "cases",
          "have",
          "simpa",
          "constructor",
          "intro",
          "linarith"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [
          "use_simpa",
          "use_linarith",
          "cleanup_simp"
        ],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3708,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  have \u03b5fin : \u03b5 \u2260 \u221e := ne_top_of_le_ne_top (by simp) h\u03b5bound\n",
      "body": "- use `\u221e` for top in ENNReal\n- shorter proof\n```suggestion\n  have \u03b5fin : \u03b5 \u2260 \u221e := ne_top_of_le_ne_top (by simp) h\u03b5bound\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "have",
          "simp"
        ],
        "body_tactics": [
          "have",
          "simp"
        ],
        "new_tactics": [
          "simp",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3709,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "            fun _ d hyp \u21a6 (hyp d (by simp)).trans (by simp)\n",
      "body": "```suggestion\n            fun _ d hyp \u21a6 (hyp d (by simp)).trans (by simp)\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3710,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "      Tendsto.eventually_const_le (v := 1) (by simp; positivity) accumulation\n",
      "body": "```suggestion\n      Tendsto.eventually_const_le (v := 1) (by simp; positivity) accumulation\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "positivity",
          "simp"
        ],
        "body_tactics": [
          "positivity",
          "simp"
        ],
        "new_tactics": [
          "positivity",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3711,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  \u00b7 rw [\u2190 univ_eq_empty_iff] at hempty\n    exact fun \u03b5 \u03b5pos \u21a6 \u27e8\u2205, isCompact_empty, by simp [hempty]\u27e9\n",
      "body": "```suggestion\n  \u00b7 rw [\u2190 univ_eq_empty_iff] at hempty\n    exact fun \u03b5 \u03b5pos \u21a6 \u27e8\u2205, isCompact_empty, by simp [hempty]\u27e9\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 3717,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "theorem continuousOn_arcosh : ContinuousOn arcosh (Ici 1) :=\n  have {x : \u211d} (hx : x \u2208 Ici 1) : 0 < x + \u221a(x ^ 2 - 1) :=\n    add_pos_of_pos_of_nonneg (show 0 < x by grind) (sqrt_nonneg _)\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (fun _ _ => by grind)\n",
      "body": "It's very minor, but why not?\n\n```suggestion\ntheorem continuousOn_arcosh : ContinuousOn arcosh (Ici 1) :=\n  have {x : \u211d} (hx : x \u2208 Ici 1) : 0 < x + \u221a(x ^ 2 - 1) :=\n    add_pos_of_pos_of_nonneg (show 0 < x by grind) (sqrt_nonneg _)\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (fun _ _ => by grind)\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "body_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "new_tactics": [
          "continuity",
          "grind",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 3718,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "\r\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (by grind [MapsTo])\r\n",
      "body": "```suggestion\r\n  continuousOn_log.comp (Continuous.continuousOn (by continuity)) (by grind [MapsTo])\r\n```\r\nThis lets `grind` unfold the definition, instead of invoking it only after the `intro` (or `fun`) unfolds it",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "continuity",
          "grind"
        ],
        "body_tactics": [
          "continuity",
          "grind",
          "intro"
        ],
        "new_tactics": [
          "continuity",
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 3719,
      "before_code": "left_inv' _ hr := arcosh_cosh hr\n  right_inv' _ hr := cosh_arcosh hr",
      "suggestion": "\r\ntheorem differentiableAt_arcosh {x : \u211d} (hx : x \u2208 Ioi 1) : DifferentiableAt \u211d arcosh x :=\r\n  (hasDerivAt_arcosh hx).differentiableAt\r\n\r\ntheorem differentiableOn_arcosh : DifferentiableOn \u211d arcosh (Ioi 1) := fun _ hx =>\r\n  (differentiableAt_arcosh hx).differentiableWithinAt\r\n",
      "body": "```suggestion\r\ntheorem differentiableAt_arcosh {x : \u211d} (hx : x \u2208 Ioi 1) : DifferentiableAt \u211d arcosh x :=\r\n  (hasDerivAt_arcosh hx).differentiableAt\r\n\r\ntheorem differentiableOn_arcosh : DifferentiableOn \u211d arcosh (Ioi 1) := fun _ hx =>\r\n  (differentiableAt_arcosh hx).differentiableWithinAt\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "cosh_arcosh",
          "left_inv",
          "right_inv",
          "arcosh_cosh"
        ]
      }
    },
    {
      "id": 3721,
      "before_code": "end",
      "suggestion": "\r\n  letI gen : M.GeneratingSections :=\r\n    { I := \u03c3\r\n      s := M.freeHomEquiv g\r\n      epi := by simpa using epi_of_isColimit_cofork H'}\r\n  haveI eq_aux : gen.\u03c0 = g := Equiv.symm_apply_apply M.freeHomEquiv g\r\n  haveI comp_zero : f \u226b gen.\u03c0 = 0 := eq_aux \u25b8 H\r\n  { generators := gen\r\n    relations :=\r\n      { I := \u03b9\r\n        s := (kernel gen.\u03c0).freeHomEquiv <| kernel.lift gen.\u03c0 f comp_zero\r\n        epi := by\r\n          let h : cokernel f \u2245 M := (H'.coconePointUniqueUpToIso (colimit.isColimit _)).symm\r\n          let h' : Abelian.image f \u2245 kernel gen.\u03c0 :=\r\n            kernel.mapIso (cokernel.\u03c0 f) gen.\u03c0 (Iso.refl _) h (by simp [h, eq_aux])\r\n          have comp_aux : Abelian.factorThruImage f \u226b h'.hom =\r\n            (kernel.lift gen.\u03c0 f comp_zero) := equalizer.hom_ext <| by simp [h']\r\n          rw [\u2190 comp_aux, Equiv.symm_apply_apply]\r\n          infer_instance }}\r\n",
      "body": "```suggestion\r\n  letI gen : M.GeneratingSections :=\r\n    { I := \u03c3\r\n      s := M.freeHomEquiv g\r\n      epi := by simpa using epi_of_isColimit_cofork H'}\r\n  haveI eq_aux : gen.\u03c0 = g := Equiv.symm_apply_apply M.freeHomEquiv g\r\n  haveI comp_zero : f \u226b gen.\u03c0 = 0 := eq_aux \u25b8 H\r\n  { generators := gen\r\n    relations :=\r\n      { I := \u03b9\r\n        s := (kernel gen.\u03c0).freeHomEquiv <| kernel.lift gen.\u03c0 f comp_zero\r\n        epi := by\r\n          let h : cokernel f \u2245 M := (H'.coconePointUniqueUpToIso (colimit.is",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "simpa",
          "have",
          "rw",
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3722,
      "before_code": "end",
      "suggestion": "\r\ndef Presentation.isColimit {M : SheafOfModules.{u} R} (P : Presentation M) :\r\n    IsColimit (CokernelCofork.of\u03c0\r\n      (f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))\r\n      P.generators.\u03c0 (by simp)) :=\r\n  isCokernelEpiComp (c := CokernelCofork.of\u03c0 _ (kernel.condition P.generators.\u03c0))\r\n      (Abelian.epiIsCokernelOfKernel _ <| limit.isLimit _) _ rfl\r\n",
      "body": "I find it a bit akward to state things using this Sigma-type given that here all the data are explicit and already known:\r\n\r\n```suggestion\r\ndef Presentation.isColimit {M : SheafOfModules.{u} R} (P : Presentation M) :\r\n    IsColimit (CokernelCofork.of\u03c0\r\n      (f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))\r\n      P.generators.\u03c0 (by simp)) :=\r\n  isCokernelEpiComp (c := CokernelCofork.of\u03c0 _ (kernel.condition P.generators.\u03c0))\r\n      (Abelian.epiIsCokernelOfKernel _ <| limit.isLimit _) _ rf",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3723,
      "before_code": "end",
      "suggestion": "\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map f \u226b\r\n    (PreservesCoproduct.iso F _).hom \u226b (Sigma.mapIso fun b \u21a6 hf').hom\r\n  letI g_new := (Sigma.mapIso fun b \u21a6 hf').inv \u226b (PreservesCoproduct.iso F _).inv \u226b F.map g\r\n  haveI H' : f_new \u226b g_new = 0 := by\r\n    simp_rw [f_new, g_new, Category.assoc, Iso.hom_inv_id_assoc,\r\n      Preadditive.IsIso.comp_left_eq_zero, IsHomLift.eq_of_isHomLift F (F.map f \u226b F.map g) (f \u226b g),\r\n      H, Functor.map_zero]\r\n  letI h' : IsColimit (CokernelCofork.of\u03c0 g_new H') := by\r\n    refine IsColimit.ofIsoColimit ((IsColimit.precomposeHom",
      "body": "This suggestion uses the modification suggested above for `Presentation.isColimit`\r\n\r\n```suggestion\r\n@[simps! generators_I relations_I]\r\ndef Presentation.map (P : Presentation M)\r\n    (F : SheafOfModules.{u'} R \u2964 SheafOfModules.{u'} S) [PreservesColimits F]\r\n    (hf' : F.obj (unit R) \u2245 unit S) {M : SheafOfModules.{u'} R} :\r\n    Presentation (F.obj M) :=\r\n  letI f := (freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _)\r\n  letI g := P.generators.\u03c0\r\n  have H : f \u226b g = 0 := by simp [f, g]\r\n  letI f_ne",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "body_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "new_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "cases",
          "have",
          "simp",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3724,
      "before_code": "end",
      "suggestion": "  letI f := (map_free F hf' P.relations.I).inv \u226b F.map ((freeHomEquiv _).symm P.relations.s) \u226b\n    F.map (kernel.\u03b9 _) \u226b (map_free F hf' P.generators.I).hom\n  letI g := (map_free F hf' P.generators.I).inv \u226b F.map (P.generators.\u03c0)\n  presentationOfIsCokernelFree f g (by simp [f, g, \u2190 Functor.map_comp]) <|\n    cokernel.cokernelIso f g ((((cokernel.mapIso (F.map\n      ((freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))) f\n        (map_free F hf' P.relations.I) (map_free F hf' P.generators.I) (by simp [f])).symm) \u226a\u226b\n          (Limits.PreservesCokernel.iso F ((freeHomEquiv _).symm P.relations.s \u226b\n            (kernel.\u03b9 _))).symm) \u226a\u226b F.mapIso (Limits.IsColimit.coconePointUniqueUpToIso\n              (colimit.isColimit _) P.isColimit)) (by simp [\u2190 Functor.map_comp, g])\n",
      "body": "```suggestion\n  letI f := (map_free F hf' P.relations.I).inv \u226b F.map ((freeHomEquiv _).symm P.relations.s) \u226b\n    F.map (kernel.\u03b9 _) \u226b (map_free F hf' P.generators.I).hom\n  letI g := (map_free F hf' P.generators.I).inv \u226b F.map (P.generators.\u03c0)\n  presentationOfIsCokernelFree f g (by simp [f, g, \u2190 Functor.map_comp]) <|\n    cokernel.cokernelIso f g ((((cokernel.mapIso (F.map\n      ((freeHomEquiv _).symm P.relations.s \u226b (kernel.\u03b9 _))) f\n        (map_free F hf' P.relations.I) (map_free F hf' P.generat",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 3733,
      "before_code": "nonrec theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x :=\n  ofReal_inj.1 <| by simp [tanh_eq_sinh_div_cosh]",
      "suggestion": "  rw [tanh_eq_sinh_div_cosh, sinh_eq, cosh_eq, div_div_div_cancel_right\u2080 two_ne_zero]\n",
      "body": "```suggestion\n  rw [tanh_eq_sinh_div_cosh, sinh_eq, cosh_eq, div_div_div_cancel_right\u2080 two_ne_zero]\n```\nor if you want to do it without knowing the lemma name:\n```lean\n  rw [tanh_eq_sinh_div_cosh, sinh_eq, cosh_eq, div_div_div_cancel_right\u2080 (by norm_num)]\n```",
      "path": "Mathlib/Analysis/Complex/Trigonometric.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "norm_num",
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "nonrec",
          "sinh",
          "theorem",
          "tanh",
          "cosh",
          "simp",
          "tanh_eq_sinh_div_cosh",
          "ofReal_inj"
        ]
      }
    },
    {
      "id": 3734,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "\r\n    interpolate s v (fun i => P.eval (v i)) = P := by\r\n",
      "body": "```suggestion\r\n    interpolate s v (fun i => P.eval (v i)) = P := by\r\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3736,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n",
      "body": "```suggestion\n    case bot => simp_all\n    case coe d =>\n      rw [Nat.cast_withBot] at hP \u22a2\n      suffices #s = d + 1 by grind\n      rw [h] at hP\n      simp [\u2190 WithBot.coe_inj, hP]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind",
          "simp_all",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "grind",
          "simp_all",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "grind",
          "rw",
          "simp_all",
          "simp"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3737,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n",
      "body": "```suggestion\n  have s_card : s.card > 0 := by by_contra! h; simp_all\n  have hP' : P.degree < s.card := by grind [Nat.cast_lt]\n```",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind",
          "have",
          "simp_all"
        ],
        "body_tactics": [
          "grind",
          "have",
          "simp_all"
        ],
        "new_tactics": [
          "grind",
          "simp_all",
          "have"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 3740,
      "before_code": "variable {D : Type u'} (F : D \u2192 C)\n\ninstance inducedCategory : Linear.{w, v} R (InducedCategory C F) where\n  homModule X Y := @Linear.homModule R _ C _ _ _ (F X) (F Y)\n  smul_comp _ _ _ _ _ _ := smul_comp _ _ _ _ _ _\n  comp_smul _ _ _ _ _ _ := comp_smul _ _ _ _ _ _",
      "suggestion": "  map_smul' := by cat_disch\n",
      "body": "```suggestion\n  map_smul' := by cat_disch\n```",
      "path": "Mathlib/CategoryTheory/Linear/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "variable",
          "Type",
          "Linear",
          "smul_comp",
          "instance",
          "inducedCategory",
          "comp_smul",
          "homModule",
          "InducedCategory"
        ]
      }
    },
    {
      "id": 3741,
      "before_code": "apply propext\n      constructor\n      \u00b7 rintro \u27e8i, w\u27e9\n        exact \u27e8i \u226b h.hom.left, by rw [Category.assoc, MonoOver.w, w]\u27e9",
      "suggestion": "        exact \u27e8i \u226b h.hom.hom.left, by rw [Category.assoc, Over.w h.hom.hom, w]\u27e9\n",
      "body": "```suggestion\n        exact \u27e8i \u226b h.hom.hom.left, by rw [Category.assoc, Over.w h.hom.hom, w]\u27e9\n```",
      "path": "Mathlib/CategoryTheory/Subobject/FactorThru.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "constructor"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "constructor"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "hom",
          "assoc",
          "MonoOver",
          "exact",
          "Category",
          "left",
          "rintro",
          "propext",
          "constructor"
        ]
      }
    },
    {
      "id": 3742,
      "before_code": "apply propext\n      constructor\n      \u00b7 rintro \u27e8i, w\u27e9\n        exact \u27e8i \u226b h.hom.left, by rw [Category.assoc, MonoOver.w, w]\u27e9\n      \u00b7 rintro \u27e8i, w\u27e9\n        exact \u27e8i \u226b h.inv.left, by rw [Category.assoc, MonoOver.w, w]\u27e9)",
      "suggestion": "        exact \u27e8i \u226b h.inv.hom.left, by rw [Category.assoc, Over.w h.inv.hom, w]\u27e9)\n",
      "body": "```suggestion\n        exact \u27e8i \u226b h.inv.hom.left, by rw [Category.assoc, Over.w h.inv.hom, w]\u27e9)\n```",
      "path": "Mathlib/CategoryTheory/Subobject/FactorThru.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "rw",
          "constructor"
        ],
        "suggestion_tactics": [
          "exact",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "constructor"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "hom",
          "assoc",
          "MonoOver",
          "exact",
          "Category",
          "left",
          "inv",
          "rintro",
          "propext",
          "constructor"
        ]
      }
    },
    {
      "id": 3743,
      "before_code": "intro x hx\n  simp [hx]",
      "suggestion": "  have h\u2081' := h\u2081.to_subtype\n  have h\u2082 : IsOpen s := isOpen_analyticAt \ud835\udd5c f\n  have h\u2083 : ContinuousOn f s := fun z hz \u21a6 hz.continuousAt.continuousWithinAt\n  exact .of_union_range_cover (.subtype_coe h\u2082.measurableSet) (.subtype_coe h\u2081.measurableSet)\n    (by simp [- mem_compl_iff]) h\u2083.restrict.measurable (measurable_of_countable _)\n",
      "body": "I think this is easier. If `s` is a measurable set, and `f` is measurable on both `s` and `s\u1d9c` (the former because it's continuous there, the latter because `s\u1d9c` is countable), then `f` is measurable.\n```suggestion\n  have h\u2081' := h\u2081.to_subtype\n  have h\u2082 : IsOpen s := isOpen_analyticAt \ud835\udd5c f\n  have h\u2083 : ContinuousOn f s := fun z hz \u21a6 hz.continuousAt.continuousWithinAt\n  exact .of_union_range_cover (.subtype_coe h\u2082.measurableSet) (.subtype_coe h\u2081.measurableSet)\n    (by simp [- mem_compl_iff]) h\u2083.rest",
      "path": "Mathlib/Analysis/Meromorphic/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "have"
        ],
        "removed_tactics": [
          "intro"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "intro"
        ]
      }
    },
    {
      "id": 3744,
      "before_code": "(Metric.PiNatEmbed.toPiNatHomeo X Y f continuous_f separating_f).isEmbedding.metrizableSpace\n\nend CompactSpace",
      "suggestion": "/-- Given a separable metric space `X`, `denseSeq X : \u2115 \u2192 X` gives a countable\ndense sequence. This measures the distance between `denseSeq X n` and `x`, truncated to the unit interval `I` so that the distances remain bounded.\n\nThe function `(fun x n \u21a6 distDenseSeq n x) : X \u2192 \u2115 \u2192 I` is a mapping from `X` to the Hilbert cube. -/\nnoncomputable abbrev distDenseSeq (n : \u2115) (x : X) : I :=\n",
      "body": "This is not a good name for this. We don't have anything called `hCube` in Mathlib. And this *isn't* an embedding (at least, not with this argument order), but you use all of them to build one.\nI suggest calling it `distDenseSeq`.\n\nInstead, the docstring should specify exactly what this is:\n```suggestion\n/-- Given a separable metric space `X`, `denseSeq X : \u2115 \u2192 X` gives a countable\ndense sequence. This measures the distance between `denseSeq X n` and `x`, truncated to the unit interval `I` so th",
      "path": "Mathlib/Topology/MetricSpace/PiNat.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "separating_f",
          "isEmbedding",
          "end",
          "metrizableSpace",
          "toPiNatHomeo",
          "Metric",
          "continuous_f",
          "CompactSpace",
          "PiNatEmbed"
        ]
      }
    },
    {
      "id": 3757,
      "before_code": "rw [norm_pow, norm_norm, one_mul, add_pow_two]\n    exact le_add_of_nonneg_left (by positivity)",
      "suggestion": "    rintro - \u27e8y, rfl\u27e9\n    simp only [Set.mem_setOf_eq, t]\n    exact lt_add_of_lt_add_left (c := 0) (by norm_num) (by positivity)\n  have hdiff : ContDiffOn \u211d \u221e (fun x \u21a6 x ^ r) t :=\n    contDiffOn_id.rpow_const_of_ne fun x hx \u21a6 (lt_trans (by norm_num) hx).ne'\n",
      "body": "```suggestion\n    rintro - \u27e8y, rfl\u27e9\n    simp only [Set.mem_setOf_eq, t]\n    exact lt_add_of_lt_add_left (c := 0) (by norm_num) (by positivity)\n  have hdiff : ContDiffOn \u211d \u221e (fun x \u21a6 x ^ r) t :=\n    contDiffOn_id.rpow_const_of_ne fun x hx \u21a6 (lt_trans (by norm_num) hx).ne'\n```",
      "path": "Mathlib/Analysis/Distribution/TemperateGrowth.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "positivity",
          "rw"
        ],
        "suggestion_tactics": [
          "norm_num",
          "positivity",
          "exact",
          "have",
          "simp"
        ],
        "body_tactics": [
          "norm_num",
          "positivity",
          "exact",
          "have",
          "simp"
        ],
        "new_tactics": [
          "norm_num",
          "simp",
          "have"
        ],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [
          "cleanup_simp"
        ],
        "keywords": [
          "norm_pow",
          "positivity",
          "le_add_of_nonneg_left",
          "add_pow_two",
          "exact",
          "norm_norm",
          "one_mul"
        ]
      }
    },
    {
      "id": 3769,
      "before_code": "theorem isCompact_generateFrom' [T : TopologicalSpace X]\n    {S : Set (Set X)} (hTS : T = generateFrom S) {s : Set X}\n    (h : \u2200 (\u03b9 : Type u) (U : \u03b9 \u2192 S), s \u2286 \u22c3 i, U i \u2192 \u2203 J : Set \u03b9, J.Finite \u2227 s \u2286 \u22c3 i \u2208 J, U i) :\n    IsCompact s := by\n  apply isCompact_generateFrom hTS\n  intro P hP hs\n  rw [Set.sUnion_eq_iUnion] at hs\n  obtain \u27e8J, hJ, cover\u27e9 := h P (fun a \u21a6 \u27e8a.1, hP a.2\u27e9) hs\n  refine \u27e8(fun x \u21a6 x.1) '' J, \u27e8by simp, Set.Finite.image _ hJ, ?_\u27e9\u27e9\n  simpa only [Set.sUnion_eq_iUnion, Set.iUnion_coe_set, Set.mem_image, Subtype.exists,\n    exists_and_right, exists_eq_right, Set.iUnion_exists] using cover",
      "suggestion": "\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n",
      "body": "```suggestion\r\n    \u27e8(\u00b7.1) '' J, by simp, hJ.image _, by aesop\u27e9\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "simpa",
          "obtain",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [
          "aesop",
          "simp"
        ],
        "body_tactics": [
          "aesop",
          "simp"
        ],
        "new_tactics": [
          "aesop"
        ],
        "removed_tactics": [
          "apply",
          "refine",
          "simpa",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [
          "use_aesop"
        ],
        "keywords": [
          "Subtype",
          "exists_eq_right",
          "Type",
          "obtain",
          "exists",
          "apply",
          "refine",
          "intro",
          "sUnion_eq_iUnion",
          "IsCompact",
          "hTS",
          "TopologicalSpace",
          "exists_and_right",
          "simp",
          "generateFrom",
          "only",
          "isCompact_generateFrom",
          "Finite",
          "cover",
          "mem_image",
          "theorem",
          "Set",
          "iUnion_coe_set",
          "simpa",
          "image",
          "iUnion_exists",
          "using"
        ]
      }
    },
    {
      "id": 3770,
      "before_code": "\u2203 x, ClusterPt x f := by\n  simpa using isCompact_univ (show f \u2264 \ud835\udcdf univ by simp)\n\nnonrec theorem Ultrafilter.le_nhds_lim [CompactSpace X] (F : Ultrafilter X) : \u2191F \u2264 \ud835\udcdd F.lim := by\n  rcases isCompact_univ.ultrafilter_le_nhds F (by simp) with \u27e8x, -, h\u27e9\n  exact le_nhds_lim \u27e8x, h\u27e9\n\ntheorem CompactSpace.elim_nhds_subcover [CompactSpace X] (U : X \u2192 Set X) (hU : \u2200 x, U x \u2208 \ud835\udcdd x) :\n    \u2203 t : Finset X, \u22c3 x \u2208 t, U x = \u22a4 := by\n  obtain \u27e8t, -, s\u27e9 := IsCompact.elim_nhds_subcover isCompact_univ U fun x _ => hU x\n  exact \u27e8t, top_unique s\u27e9",
      "suggestion": "\r\n  have \u27e8t, _, s\u27e9 := isCompact_univ.elim_nhds_subcover U fun x _ \u21a6 hU x\r\n",
      "body": "```suggestion\r\n  have \u27e8t, _, s\u27e9 := isCompact_univ.elim_nhds_subcover U fun x _ \u21a6 hU x\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [
          "have"
        ],
        "body_tactics": [
          "have"
        ],
        "new_tactics": [
          "have"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "topics": [
          "order",
          "finset",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "show",
          "le_nhds_lim",
          "top_unique",
          "rcases",
          "obtain",
          "nonrec",
          "isCompact_univ",
          "Finset",
          "CompactSpace",
          "ClusterPt",
          "elim_nhds_subcover",
          "IsCompact",
          "univ",
          "ultrafilter_le_nhds",
          "simp",
          "lim",
          "theorem",
          "exact",
          "Set",
          "Ultrafilter",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 3772,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "/-- Let `\u03b1` be a non-zero algebraic integer. Then `\u03b1` has a conjugate `\u03c3 \u03b1` with `\u2016\u03c3 \u03b1\u2016 \u2265 1`. -/\nlemma exists_conjugate_one_le_norm {\u03b1 : \ud835\udcde K} (h\u03b10 : \u03b1 \u2260 0) :\n    \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016 := by\n  obtain \u27e8w, hw\u27e9 : \u2203 w : InfinitePlace K, 1 \u2264 w \u03b1 := by\n    by_contra! h_neg\n    let w\u2080 := Classical.arbitrary (InfinitePlace K)\n    have h_ge_one : 1 \u2264 w\u2080 \u03b1 := InfinitePlace.one_le_of_lt_one h\u03b10 (fun z _ \u21a6 h_neg z)\n    exact (h_neg w\u2080).not_ge h_ge_one\n  use w.embedding\n  rwa [InfinitePlace.norm_embedding_eq]\n",
      "body": "```suggestion\n/-- Let `\u03b1` be a non-zero algebraic integer. Then `\u03b1` has a conjugate `\u03c3 \u03b1` with `\u2016\u03c3 \u03b1\u2016 \u2265 1`. -/\nlemma exists_conjugate_one_le_norm {\u03b1 : \ud835\udcde K} (h\u03b10 : \u03b1 \u2260 0) :\n    \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016 := by\n  obtain \u27e8w, hw\u27e9 : \u2203 w : InfinitePlace K, 1 \u2264 w \u03b1 := by\n    by_contra! h_neg\n    let w\u2080 := Classical.arbitrary (InfinitePlace K)\n    have h_ge_one : 1 \u2264 w\u2080 \u03b1 := InfinitePlace.one_le_of_lt_one h\u03b10 (fun z _ \u21a6 h_neg z)\n    exact (h_neg w\u2080).not_ge h_ge_one\n  use w.embedding\n  rwa [InfinitePlace.n",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "body_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "new_tactics": [
          "exact",
          "obtain",
          "have"
        ],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 3773,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n",
      "body": "```suggestion\nlemma one_le_house_of_isIntegral {\u03b1 : K} (h\u03b1 : IsIntegral \u2124 \u03b1) (h\u03b10 : \u03b1 \u2260 0) :\n    1 \u2264 house \u03b1 := by\n  have \u27e8\u03c3, h\u03c3\u27e9 : \u2203 \u03c3 : K \u2192+* \u2102, 1 \u2264 \u2016\u03c3 \u03b1\u2016\u208a := by\n    apply exists_conjugate_one_le_norm (K := K) (\u03b1 := \u27e8\u03b1, h\u03b1\u27e9)\n    simpa [RingOfIntegers.ext_iff]\n  rw [house_eq_sup']\n  apply h\u03c3.trans (Finset.le_sup' (fun \u03c6 : K \u2192+* \u2102 \u21a6 \u2016\u03c6 \u03b1\u2016\u208a) (Finset.mem_univ \u03c3))\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "simpa",
          "apply",
          "rw",
          "have"
        ],
        "body_tactics": [
          "simpa",
          "apply",
          "rw",
          "have"
        ],
        "new_tactics": [
          "simpa",
          "rw",
          "have"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 3774,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le\n\n@[simp] theorem house_intCast (x : \u2124) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_intCast, Int.cast_abs]",
      "suggestion": "lemma norm_norm_le_norm_mul_house_pow (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) :\n    \u2016Algebra.norm \u211a \u03b1\u2016 \u2264 \u2016\u03c3 \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by\n  classical\n  set \u03c3' := \u03c3.toRatAlgHom\n  calc _ = \u2016\u220f \u03c4 : K \u2192\u2090[\u211a] \u2102, \u03c4 \u03b1\u2016 := ?_\n       _ = \u2016(\u03c3' \u03b1) * \u220f \u03c4 \u2208 univ.erase \u03c3', \u03c4 \u03b1\u2016 := by rw [mul_prod_erase univ (\u00b7 \u03b1) (mem_univ \u03c3')]\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', \u2016\u03c4 \u03b1\u2016 := ?_\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', house \u03b1 := by gcongr; apply norm_embedding_le_house\n       _ = \u2016\u03c3' \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by simp\n  \u00b7 rw [\u2190 Algebra.norm_eq_prod_embeddings, \u2190 Rat.norm_cast_real,\n      Real.norm_eq_abs, eq_ratCast, Complex.norm_ratCast]\n  \u00b7 rw [Complex.norm_mul]\n    gcongr\n    exact norm_prod_le (univ.erase \u03c3') (\u00b7 \u03b1)\n",
      "body": "```suggestion\nlemma norm_norm_le_norm_mul_house_pow (\u03b1 : K) (\u03c3 : K \u2192+* \u2102) :\n    \u2016Algebra.norm \u211a \u03b1\u2016 \u2264 \u2016\u03c3 \u03b1\u2016 * house \u03b1 ^ (Module.finrank \u211a K - 1) := by\n  classical\n  set \u03c3' := \u03c3.toRatAlgHom\n  calc _ = \u2016\u220f \u03c4 : K \u2192\u2090[\u211a] \u2102, \u03c4 \u03b1\u2016 := ?_\n       _ = \u2016(\u03c3' \u03b1) * \u220f \u03c4 \u2208 univ.erase \u03c3', \u03c4 \u03b1\u2016 := by rw [mul_prod_erase univ (\u00b7 \u03b1) (mem_univ \u03c3')]\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', \u2016\u03c4 \u03b1\u2016 := ?_\n       _ \u2264 \u2016\u03c3' \u03b1\u2016 * \u220f \u03c4 \u2208 univ.erase \u03c3', house \u03b1 := by gcongr; apply norm_embedding_le_house\n       _ = \u2016\u03c3' \u03b1\u2016 * house \u03b1 ",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [
          "apply",
          "gcongr",
          "exact",
          "rw",
          "simp"
        ],
        "body_tactics": [
          "apply",
          "gcongr",
          "exact",
          "rw",
          "simp"
        ],
        "new_tactics": [
          "exact",
          "gcongr",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "norm",
          "complex",
          "list",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "cast_abs",
          "theorem",
          "Complex",
          "intCast_def",
          "Int",
          "norm_intCast",
          "pi_norm_const",
          "house_intCast",
          "map_mul",
          "simp",
          "house_mul_le",
          "map_intCast",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 3775,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "    suffices B x y \u2264 0 by simpa [hc, \u2190 hB.le_zero_iff, B.toQuadraticMap_apply]\n    suffices 0 \u2264 \u2211 x \u2208 s with c x < 0, \u2211 i \u2208 s with 0 \u2264 c i, c x * (c i * (B (v i)) (v x)) by\n      simpa [hx, hy, map_neg, Finset.mul_sum]\n",
      "body": "```suggestion\n    suffices B x y \u2264 0 by simpa [hc, \u2190 hB.le_zero_iff, B.toQuadraticMap_apply]\n    suffices 0 \u2264 \u2211 x \u2208 s with c x < 0, \u2211 i \u2208 s with 0 \u2264 c i, c x * (c i * (B (v i)) (v x)) by\n      simpa [hx, hy, map_neg, Finset.mul_sum]\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa"
        ],
        "body_tactics": [
          "simpa"
        ],
        "new_tactics": [
          "simpa"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 3776,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "  rw [\u2190 s.sum_filter_add_sum_filter_not (p := fun i \u21a6 0 \u2264 c i), add_eq_zero_iff_eq_neg] at hc\n  set x := \u2211 i \u2208 s with 0 \u2264 c i, c i \u2022 v i with hx\n  set y := \u2211 i \u2208 s with c i < 0, (-c i) \u2022 v i with hy\n  replace hc : x = y := by simpa [hy] using hc\n",
      "body": "Extreme nitpicking\n```suggestion\n  rw [\u2190 s.sum_filter_add_sum_filter_not (p := fun i \u21a6 0 \u2264 c i), add_eq_zero_iff_eq_neg] at hc\n  set x := \u2211 i \u2208 s with 0 \u2264 c i, c i \u2022 v i with hx\n  set y := \u2211 i \u2208 s with c i < 0, (-c i) \u2022 v i with hy\n  replace hc : x = y := by simpa [hy] using hc\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 3777,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "  apply_fun f at hx hy\n  replace hx : \u2211 i \u2208 s with 0 \u2264 c i, c i * f (v i) = 0 := by simpa [hx\u2080] using hx.symm\n  replace hy : \u2211 i \u2208 s with c i < 0, c i * f (v i) = 0 := by simpa [\u2190 hc, hx\u2080] using hy.symm\n  replace hx (i : \u03b9) (hi : i \u2208 s) : c i \u2264 0 := by\n    rw [Finset.sum_eq_zero_iff_of_nonneg (by grind [mul_nonneg])] at hx\n    by_contra! hi'\n    grind [mul_pos hi' (hp i)]\n  replace hy (i : \u03b9) (hi : i \u2208 s) : 0 \u2264 c i := by\n    rw [Finset.sum_eq_zero_iff_of_nonpos (by grind [mul_nonpos_of_nonpos_of_nonneg])] at hy\n    by_contra! hi'\n    grind [mul_neg_of_neg_of_pos hi' (hp i)]\n",
      "body": "```suggestion\n  apply_fun f at hx hy\n  replace hx : \u2211 i \u2208 s with 0 \u2264 c i, c i * f (v i) = 0 := by simpa [hx\u2080] using hx.symm\n  replace hy : \u2211 i \u2208 s with c i < 0, c i * f (v i) = 0 := by simpa [\u2190 hc, hx\u2080] using hy.symm\n  replace hx (i : \u03b9) (hi : i \u2208 s) : c i \u2264 0 := by\n    rw [Finset.sum_eq_zero_iff_of_nonneg (by grind [mul_nonneg])] at hx\n    by_contra! hi'\n    grind [mul_pos hi' (hp i)]\n  replace hy (i : \u03b9) (hi : i \u2208 s) : 0 \u2264 c i := by\n    rw [Finset.sum_eq_zero_iff_of_nonpos (by grind [mul_nonpo",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "body_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "grind",
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_simpa",
          "use_grind"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 3778,
      "before_code": "variable {G}",
      "suggestion": "\r\n    have : f.NeBot := hf.1\r\n    obtain \u27e8K, K_compact, K_mem\u27e9 := WeaklyLocallyCompactSpace.exists_compact_mem_nhds (1 : G)\r\n    obtain \u27e8x, hx\u27e9 : \u2203 x, \u2200\u1da0 y in f, y / x \u2208 K := by\r\n      rw [cauchy_iff_le, uniformity_eq_comap_nhds_one', \u2190 tendsto_iff_comap] at hf\r\n      exact hf.eventually_mem K_mem |>.curry.exists\r\n    simp_rw [div_eq_mul_inv, \u2190 op_smul_eq_mul, op_inv, \u2190 mem_smul_set_iff_inv_smul_mem] at hx\r\n    have Kx_complete : IsComplete (K <\u2022 x) := K_compact.smul _ |>.isComplete\r\n    obtain \u27e8l, -, hl\u27e9 := Kx_complete f hf (by simpa using hx)\r\n    exact \u27e8l, hl\u27e9\r\n ",
      "body": "Thanks a lot for starting on this! This proof can be cleaned a bit using our filter library, which prevents having to manipulate sets explicitly. I would suggest the following (which needs an `open MulOpposite`) for example:\r\n```suggestion\r\n    have : f.NeBot := hf.1\r\n    obtain \u27e8K, K_compact, K_mem\u27e9 := WeaklyLocallyCompactSpace.exists_compact_mem_nhds (1 : G)\r\n    obtain \u27e8x, hx\u27e9 : \u2203 x, \u2200\u1da0 y in f, y / x \u2208 K := by\r\n      rw [cauchy_iff_le, uniformity_eq_comap_nhds_one', \u2190 tendsto_iff_comap] at hf",
      "path": "Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw"
        ],
        "body_tactics": [
          "exact",
          "have",
          "simpa",
          "obtain",
          "rw"
        ],
        "new_tactics": [
          "simpa",
          "obtain",
          "rw",
          "exact",
          "have"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_simpa",
          "line_break"
        ],
        "keywords": [
          "variable"
        ]
      }
    },
    {
      "id": 3780,
      "before_code": "end MeasureTheory.Measure",
      "suggestion": "/-- Define a tempered distribution from a L^p function. -/\ndef toTemperedDistribution {p : \u211d\u22650\u221e}\n    [hp : Fact (1 \u2264 p)] (f : Lp F p \u03bc) : \ud835\udce2'(E, F) :=\n  haveI := ENNReal.HolderConjugate.inv_one_sub_inv' hp.out\n  haveI : Fact (1 \u2264 (1 - p\u207b\u00b9)\u207b\u00b9) := by simp [fact_iff]\n  toPointwiseConvergenceCLM _ _ _ _ <|\n    (lsmul \u2102 \u2102).flip.lpPairing \u03bc p (1 - p\u207b\u00b9)\u207b\u00b9 f \u2218L toLpCLM \u2102 \u2102 (1 - p\u207b\u00b9)\u207b\u00b9 \u03bc\n",
      "body": "I suggest instead:\n```suggestion\n/-- Define a tempered distribution from a L^p function. -/\ndef toTemperedDistribution {p : \u211d\u22650\u221e}\n    [hp : Fact (1 \u2264 p)] (f : Lp F p \u03bc) : \ud835\udce2'(E, F) :=\n  haveI := ENNReal.HolderConjugate.inv_one_sub_inv' hp.out\n  haveI : Fact (1 \u2264 (1 - p\u207b\u00b9)\u207b\u00b9) := by simp [fact_iff]\n  toPointwiseConvergenceCLM _ _ _ _ <|\n    (lsmul \u2102 \u2102).flip.lpPairing \u03bc p (1 - p\u207b\u00b9)\u207b\u00b9 f \u2218L toLpCLM \u2102 \u2102 (1 - p\u207b\u00b9)\u207b\u00b9 \u03bc\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "simp"
        ],
        "body_tactics": [
          "simp"
        ],
        "new_tactics": [
          "simp"
        ],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "MeasureTheory",
          "Measure"
        ]
      }
    },
    {
      "id": 3781,
      "before_code": "}",
      "suggestion": "\r\n      -- Create `id t` application - this ensures grind sees it as a term, not an e-match candidate\r\n      mkNode ``Lean.Parser.Term.app #[mkIdent `id, mkNullNode #[t]]\r\n    else t\r\n",
      "body": "```suggestion\r\n      -- Create `id t` application - this ensures grind sees it as a term, not an e-match candidate\r\n      mkNode ``Lean.Parser.Term.app #[mkIdent `id, mkNullNode #[t]]\r\n    else t\r\n```\r\njust an indentation fix.",
      "path": "Mathlib/Tactic/TacticAnalysis/Declarations.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": []
      }
    },
    {
      "id": 3782,
      "before_code": "`tacticKind` is the `SyntaxNodeKind` for the tactic's main parser,\nfor example `Mathlib.Tactic.linarith`.\n-/\ndef grindReplacementWith (tacticName : String) (tacticKind : SyntaxNodeKind)",
      "suggestion": "\r\n    (extractArgs : Syntax \u2192 (Syntax.TSepArray `term \",\") := fun _ => \u2205)\r\n",
      "body": "```suggestion\r\n    (extractArgs : Syntax \u2192 (Syntax.TSepArray `term \",\") := fun _ => \u2205)\r\n```\r\nunless you actually wanted to make the distinction between `none` and passing an empty array.",
      "path": "Mathlib/Tactic/TacticAnalysis/Declarations.lean",
      "tags": {
        "before_tactics": [
          "linarith"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "linarith"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "parser",
          "example",
          "Mathlib",
          "def",
          "String",
          "SyntaxNodeKind",
          "main",
          "tactic",
          "linarith",
          "grindReplacementWith",
          "tacticName",
          "tacticKind",
          "Tactic",
          "for"
        ]
      }
    },
    {
      "id": 3783,
      "before_code": "/-- leantar version at https://github.com/digama0/leangz -/\ndef LEANTARVERSION :=\n  \"0.1.15\"",
      "suggestion": "\r\n  \"0.1.16-pre4\"\r\n",
      "body": "```suggestion\r\n  \"0.1.16-pre4\"\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "https",
          "com",
          "def",
          "leangz",
          "github",
          "digama0",
          "leantar",
          "version",
          "LEANTARVERSION"
        ]
      }
    },
    {
      "id": 3784,
      "before_code": "/-- Bump this number to invalidate the cache, in case the existing hashing inputs are insufficient.\nIt is not a global counter, and can be reset to 0 as long as the lean githash or lake manifest has\nchanged since the last time this counter was touched. -/\ndef rootHashGeneration : UInt64 := 0",
      "suggestion": "\r\ndef rootHashGeneration : UInt64 := 4\r\n",
      "body": "```suggestion\r\ndef rootHashGeneration : UInt64 := 4\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "time",
          "was",
          "touched",
          "rootHashGeneration",
          "cache",
          "lean",
          "existing",
          "since",
          "inputs",
          "last",
          "has",
          "lake",
          "case",
          "are",
          "UInt64",
          "githash",
          "long",
          "counter",
          "can",
          "invalidate",
          "def",
          "number",
          "global",
          "Bump",
          "reset",
          "hashing",
          "changed",
          "this",
          "insufficient",
          "manifest"
        ]
      }
    },
    {
      "id": 3785,
      "before_code": "## Mathlib dependencies on upstream projects\n-/\n\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"",
      "suggestion": "\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n",
      "body": "```suggestion\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n```",
      "path": "lakefile.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "community",
          "Mathlib",
          "git",
          "dependencies",
          "testing",
          "nightly",
          "batteries",
          "leanprover",
          "require",
          "upstream",
          "projects"
        ]
      }
    },
    {
      "id": 3786,
      "before_code": "Q3526996:\n  title: Kolmogorov extension theorem",
      "suggestion": "\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n",
      "body": "```suggestion\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "extension",
          "Kolmogorov",
          "Q3526996"
        ]
      }
    },
    {
      "id": 3787,
      "before_code": "Q2027347:\n  title: Optional stopping theorem",
      "suggestion": "\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n",
      "body": "```suggestion\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "stopping",
          "Q2027347",
          "Optional"
        ]
      }
    },
    {
      "id": 3789,
      "before_code": "/-- leantar version at https://github.com/digama0/leangz -/\ndef LEANTARVERSION :=\n  \"0.1.15\"",
      "suggestion": "\r\n  \"0.1.16-pre4\"\r\n",
      "body": "```suggestion\r\n  \"0.1.16-pre4\"\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "https",
          "com",
          "def",
          "leangz",
          "github",
          "digama0",
          "leantar",
          "version",
          "LEANTARVERSION"
        ]
      }
    },
    {
      "id": 3790,
      "before_code": "/-- Bump this number to invalidate the cache, in case the existing hashing inputs are insufficient.\nIt is not a global counter, and can be reset to 0 as long as the lean githash or lake manifest has\nchanged since the last time this counter was touched. -/\ndef rootHashGeneration : UInt64 := 0",
      "suggestion": "\r\ndef rootHashGeneration : UInt64 := 4\r\n",
      "body": "```suggestion\r\ndef rootHashGeneration : UInt64 := 4\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "time",
          "was",
          "touched",
          "rootHashGeneration",
          "cache",
          "lean",
          "existing",
          "since",
          "inputs",
          "last",
          "has",
          "lake",
          "case",
          "are",
          "UInt64",
          "githash",
          "long",
          "counter",
          "can",
          "invalidate",
          "def",
          "number",
          "global",
          "Bump",
          "reset",
          "hashing",
          "changed",
          "this",
          "insufficient",
          "manifest"
        ]
      }
    },
    {
      "id": 3791,
      "before_code": "## Mathlib dependencies on upstream projects\n-/\n\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"",
      "suggestion": "\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n",
      "body": "```suggestion\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n```",
      "path": "lakefile.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "community",
          "Mathlib",
          "git",
          "dependencies",
          "testing",
          "nightly",
          "batteries",
          "leanprover",
          "require",
          "upstream",
          "projects"
        ]
      }
    },
    {
      "id": 3792,
      "before_code": "Q3526996:\n  title: Kolmogorov extension theorem",
      "suggestion": "\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n",
      "body": "```suggestion\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "extension",
          "Kolmogorov",
          "Q3526996"
        ]
      }
    },
    {
      "id": 3793,
      "before_code": "Q2027347:\n  title: Optional stopping theorem",
      "suggestion": "\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n",
      "body": "```suggestion\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "stopping",
          "Q2027347",
          "Optional"
        ]
      }
    },
    {
      "id": 3795,
      "before_code": "/-- leantar version at https://github.com/digama0/leangz -/\ndef LEANTARVERSION :=\n  \"0.1.15\"",
      "suggestion": "\r\n  \"0.1.16-pre4\"\r\n",
      "body": "```suggestion\r\n  \"0.1.16-pre4\"\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "https",
          "com",
          "def",
          "leangz",
          "github",
          "digama0",
          "leantar",
          "version",
          "LEANTARVERSION"
        ]
      }
    },
    {
      "id": 3796,
      "before_code": "/-- Bump this number to invalidate the cache, in case the existing hashing inputs are insufficient.\nIt is not a global counter, and can be reset to 0 as long as the lean githash or lake manifest has\nchanged since the last time this counter was touched. -/\ndef rootHashGeneration : UInt64 := 0",
      "suggestion": "\r\ndef rootHashGeneration : UInt64 := 4\r\n",
      "body": "```suggestion\r\ndef rootHashGeneration : UInt64 := 4\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "time",
          "was",
          "touched",
          "rootHashGeneration",
          "cache",
          "lean",
          "existing",
          "since",
          "inputs",
          "last",
          "has",
          "lake",
          "case",
          "are",
          "UInt64",
          "githash",
          "long",
          "counter",
          "can",
          "invalidate",
          "def",
          "number",
          "global",
          "Bump",
          "reset",
          "hashing",
          "changed",
          "this",
          "insufficient",
          "manifest"
        ]
      }
    },
    {
      "id": 3797,
      "before_code": "## Mathlib dependencies on upstream projects\n-/\n\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"",
      "suggestion": "\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n",
      "body": "```suggestion\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n```",
      "path": "lakefile.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "community",
          "Mathlib",
          "git",
          "dependencies",
          "testing",
          "nightly",
          "batteries",
          "leanprover",
          "require",
          "upstream",
          "projects"
        ]
      }
    },
    {
      "id": 3798,
      "before_code": "Q3526996:\n  title: Kolmogorov extension theorem",
      "suggestion": "\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n",
      "body": "```suggestion\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "extension",
          "Kolmogorov",
          "Q3526996"
        ]
      }
    },
    {
      "id": 3799,
      "before_code": "Q2027347:\n  title: Optional stopping theorem",
      "suggestion": "\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n",
      "body": "```suggestion\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "stopping",
          "Q2027347",
          "Optional"
        ]
      }
    },
    {
      "id": 3801,
      "before_code": "/-- leantar version at https://github.com/digama0/leangz -/\ndef LEANTARVERSION :=\n  \"0.1.15\"",
      "suggestion": "\r\n  \"0.1.16-pre4\"\r\n",
      "body": "```suggestion\r\n  \"0.1.16-pre4\"\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "https",
          "com",
          "def",
          "leangz",
          "github",
          "digama0",
          "leantar",
          "version",
          "LEANTARVERSION"
        ]
      }
    },
    {
      "id": 3802,
      "before_code": "/-- Bump this number to invalidate the cache, in case the existing hashing inputs are insufficient.\nIt is not a global counter, and can be reset to 0 as long as the lean githash or lake manifest has\nchanged since the last time this counter was touched. -/\ndef rootHashGeneration : UInt64 := 0",
      "suggestion": "\r\ndef rootHashGeneration : UInt64 := 4\r\n",
      "body": "```suggestion\r\ndef rootHashGeneration : UInt64 := 4\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "time",
          "was",
          "touched",
          "rootHashGeneration",
          "cache",
          "lean",
          "existing",
          "since",
          "inputs",
          "last",
          "has",
          "lake",
          "case",
          "are",
          "UInt64",
          "githash",
          "long",
          "counter",
          "can",
          "invalidate",
          "def",
          "number",
          "global",
          "Bump",
          "reset",
          "hashing",
          "changed",
          "this",
          "insufficient",
          "manifest"
        ]
      }
    },
    {
      "id": 3803,
      "before_code": "## Mathlib dependencies on upstream projects\n-/\n\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"",
      "suggestion": "\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n",
      "body": "```suggestion\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n```",
      "path": "lakefile.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "community",
          "Mathlib",
          "git",
          "dependencies",
          "testing",
          "nightly",
          "batteries",
          "leanprover",
          "require",
          "upstream",
          "projects"
        ]
      }
    },
    {
      "id": 3804,
      "before_code": "Q3526996:\n  title: Kolmogorov extension theorem",
      "suggestion": "\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n",
      "body": "```suggestion\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "extension",
          "Kolmogorov",
          "Q3526996"
        ]
      }
    },
    {
      "id": 3805,
      "before_code": "Q2027347:\n  title: Optional stopping theorem",
      "suggestion": "\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n",
      "body": "```suggestion\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "stopping",
          "Q2027347",
          "Optional"
        ]
      }
    },
    {
      "id": 3807,
      "before_code": "/-- leantar version at https://github.com/digama0/leangz -/\ndef LEANTARVERSION :=\n  \"0.1.15\"",
      "suggestion": "\r\n  \"0.1.16-pre4\"\r\n",
      "body": "```suggestion\r\n  \"0.1.16-pre4\"\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "https",
          "com",
          "def",
          "leangz",
          "github",
          "digama0",
          "leantar",
          "version",
          "LEANTARVERSION"
        ]
      }
    },
    {
      "id": 3808,
      "before_code": "/-- Bump this number to invalidate the cache, in case the existing hashing inputs are insufficient.\nIt is not a global counter, and can be reset to 0 as long as the lean githash or lake manifest has\nchanged since the last time this counter was touched. -/\ndef rootHashGeneration : UInt64 := 0",
      "suggestion": "\r\ndef rootHashGeneration : UInt64 := 4\r\n",
      "body": "```suggestion\r\ndef rootHashGeneration : UInt64 := 4\r\n```",
      "path": "Cache/IO.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "time",
          "was",
          "touched",
          "rootHashGeneration",
          "cache",
          "lean",
          "existing",
          "since",
          "inputs",
          "last",
          "has",
          "lake",
          "case",
          "are",
          "UInt64",
          "githash",
          "long",
          "counter",
          "can",
          "invalidate",
          "def",
          "number",
          "global",
          "Bump",
          "reset",
          "hashing",
          "changed",
          "this",
          "insufficient",
          "manifest"
        ]
      }
    },
    {
      "id": 3809,
      "before_code": "## Mathlib dependencies on upstream projects\n-/\n\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"",
      "suggestion": "\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n",
      "body": "```suggestion\r\nrequire \"leanprover-community\" / \"batteries\" @ git \"nightly-testing\"\r\n```",
      "path": "lakefile.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "community",
          "Mathlib",
          "git",
          "dependencies",
          "testing",
          "nightly",
          "batteries",
          "leanprover",
          "require",
          "upstream",
          "projects"
        ]
      }
    },
    {
      "id": 3810,
      "before_code": "Q3526996:\n  title: Kolmogorov extension theorem",
      "suggestion": "\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n",
      "body": "```suggestion\r\n  author: R\u00e9my Degenne, Peter Pfaffelhuber\r\n  date: 2023\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "extension",
          "Kolmogorov",
          "Q3526996"
        ]
      }
    },
    {
      "id": 3811,
      "before_code": "Q2027347:\n  title: Optional stopping theorem",
      "suggestion": "\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n",
      "body": "```suggestion\r\n  author: Kexing Ying, R\u00e9my Degenne\r\n```",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "title",
          "stopping",
          "Q2027347",
          "Optional"
        ]
      }
    },
    {
      "id": 3816,
      "before_code": "attribute will add a `to_dual none` tag to an `_assoc` theorem if the original theorem was\nalready tagged with `to_dual`. This also works with `to_dual (attr := reassoc)`.\n\nWhen troubleshooting, you can see what `to_dual` is doing by replacing it with `to_dual?` and/or",
      "suggestion": "\r\nTo be able to translate a term involving such constants, `to_dual` needs to insert casts,\r\n",
      "body": "```suggestion\r\nTo be able to translate a term involving such constants, `to_dual` needs to insert casts,\r\n```",
      "path": "Mathlib/Tactic/Translate/ToDual.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "was",
          "tagged",
          "to_dual",
          "already",
          "troubleshooting",
          "When",
          "add",
          "replacing",
          "This",
          "original",
          "works",
          "tag",
          "see",
          "also",
          "can",
          "attr",
          "none",
          "_assoc",
          "you",
          "will",
          "attribute",
          "theorem",
          "what",
          "reassoc",
          "doing"
        ]
      }
    },
    {
      "id": 3818,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\ndef idealOfVars : Ideal (MvPolynomial \u03c3 R) := .span (Set.range (MvPolynomial.X))\r\n",
      "body": "```suggestion\r\ndef idealOfVars : Ideal (MvPolynomial \u03c3 R) := .span (Set.range (MvPolynomial.X))\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 3819,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\ndef idealOfVars : Ideal (MvPolynomial \u03c3 R) := .span (Set.range X)\r\n",
      "body": "```suggestion\r\ndef idealOfVars : Ideal (MvPolynomial \u03c3 R) := .span (Set.range X)\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 3820,
      "before_code": "refine this.trans ?_\n  simp [Nat.one_le_iff_ne_zero]",
      "suggestion": "\r\ndef idealOfVars : Ideal (MvPolynomial \u03c3 R) := .span (.range X)\r\n",
      "body": "Does this work?\r\n```suggestion\r\ndef idealOfVars : Ideal (MvPolynomial \u03c3 R) := .span (.range X)\r\n```",
      "path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "refine",
          "one_le_iff_ne_zero",
          "Nat",
          "this",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 3821,
      "before_code": "obtain \u27e8a, rfl\u27e9 := (Finsupp.sum_eq_one_iff _).mp hp\n    use a",
      "suggestion": "theorem image_pow_eq_finsuppProd_image {\u03b1 \u03b2 : Type*} [CommMonoid \u03b2] {f : \u03b1 \u2192 \u03b2} {n} {s : Set \u03b1} :\n",
      "body": "```suggestion\ntheorem image_pow_eq_finsuppProd_image {\u03b1 \u03b2 : Type*} [CommMonoid \u03b2] {f : \u03b1 \u2192 \u03b2} {n} {s : Set \u03b1} :\n```",
      "path": "Mathlib/Data/Finsupp/Weight.lean",
      "tags": {
        "before_tactics": [
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "sum_eq_one_iff",
          "obtain",
          "rfl",
          "use"
        ]
      }
    },
    {
      "id": 3822,
      "before_code": "runs-on: ubuntu-latest\n    if: github.repository == 'leanprover-community/mathlib4'\n    steps:",
      "suggestion": "      - name: Generate app token\n        if: ${{ secrets.MATHLIB_TRIAGE_APP_ID  != '' }}\n",
      "body": "This workflow and `maintainer_merge.yml` are a bit unusual in that they support running from forked PRs without access to secrets. We need to make sure that this step does not error out if the secrets aren't present. \n\n```suggestion\n      - name: Generate app token\n        if: ${{ secrets.MATHLIB_TRIAGE_APP_ID  != '' }}\n```",
      "path": ".github/workflows/maintainer_bors.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "community",
          "mathlib4",
          "runs",
          "ubuntu",
          "latest",
          "github",
          "leanprover",
          "repository",
          "steps"
        ]
      }
    },
    {
      "id": 3823,
      "before_code": "contains(format('{0}{1}', github.event.comment.body, github.event.review.body), 'maintainer delegate')\n      )\n    steps:",
      "suggestion": "      - name: Generate app token\n        if: ${{ secrets.MATHLIB_TRIAGE_APP_ID  != '' }}\n",
      "body": "```suggestion\n      - name: Generate app token\n        if: ${{ secrets.MATHLIB_TRIAGE_APP_ID  != '' }}\n```",
      "path": ".github/workflows/maintainer_merge.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "format",
          "delegate",
          "contains",
          "comment",
          "review",
          "github",
          "maintainer",
          "event",
          "steps",
          "body"
        ]
      }
    },
    {
      "id": 3824,
      "before_code": "username: ${{ steps.get-label-actor.outputs.username }}\n          GITHUB_TOKEN: ${{ secrets.MATHLIB_REVIEWERS_TEAM_KEY }} # (Requires scope: `read:org`)\n\n      - if: ${{ contains(steps.PR.outputs.pr_labels, 'auto-merge-after-CI') && (contains(steps.actorTeams.outputs.teams, 'mathlib-maintainers') || contains(steps.actorTeams.outputs.teams, 'bot-users')) }}\n        name: If `auto-merge-after-CI` is present, add a `bors merge` comment.\n        uses: GrantBirki/comment@608e41b19bc973020ec0e189ebfdae935d7fe0cc # v2.1.1\n        with:\n          token: ${{ secrets.AUTO_MERGE_TOKEN }}",
      "suggestion": "          token: ${{ steps.auto-merge-app-token.outputs.token }}\n",
      "body": "```suggestion\n          token: ${{ steps.auto-merge-app-token.outputs.token }}\n```",
      "path": ".github/workflows/build_template.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "GrantBirki",
          "read",
          "after",
          "merge",
          "secrets",
          "add",
          "scope",
          "bors",
          "outputs",
          "users",
          "token",
          "present",
          "username",
          "get",
          "name",
          "label",
          "actor",
          "org",
          "MATHLIB_REVIEWERS_TEAM_KEY",
          "steps",
          "contains",
          "pr_labels",
          "uses",
          "bot",
          "AUTO_MERGE_TOKEN",
          "auto",
          "GITHUB_TOKEN",
          "Requires",
          "teams",
          "comment",
          "actorTeams",
          "mathlib",
          "maintainers"
        ]
      }
    },
    {
      "id": 3825,
      "before_code": "needs: [style_lint, build, post_steps]\n    runs-on: ubuntu-latest\n    steps:",
      "suggestion": "      - name: Generate auto merge app token\n        id: auto-merge-app-token\n",
      "body": "```suggestion\n      - name: Generate auto merge app token\n        id: auto-merge-app-token\n```",
      "path": ".github/workflows/build_template.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "runs",
          "post_steps",
          "latest",
          "needs",
          "build",
          "ubuntu",
          "steps",
          "style_lint"
        ]
      }
    },
    {
      "id": 3826,
      "before_code": "have a_mem := hp.mem_support a\n    have b_mem := hp.mem_support b\n    exact ((p.takeUntil a a_mem).reverse.append <| p.takeUntil b b_mem).reachable\n  nonempty := not_isEmpty_iff.1 fun _ \u21a6 by simpa using hG <| by simp [@Fintype.card_eq_zero]\n\nlemma IsHamiltonian.of_card_eq_one (h : Fintype.card \u03b1 = 1) : G.IsHamiltonian :=\n  (\u00b7 h |>.elim)",
      "suggestion": "  grind [hp.three_le_length, hp.length_eq]\n",
      "body": "```suggestion\n  grind [hp.three_le_length, hp.length_eq]\n```\nimo this makes it clearer what the proof is doing (rather than `trans_eq`) since it says \"it's obvious from these two facts\"",
      "path": "Mathlib/Combinatorics/SimpleGraph/Hamiltonian.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "have",
          "exact",
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "simp",
          "exact",
          "have"
        ],
        "topics": [
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lemma",
          "b_mem",
          "mem_support",
          "nonempty",
          "takeUntil",
          "have",
          "card_eq_zero",
          "reachable",
          "elim",
          "reverse",
          "a_mem",
          "simp",
          "IsHamiltonian",
          "card",
          "exact",
          "append",
          "of_card_eq_one",
          "simpa",
          "Fintype",
          "not_isEmpty_iff",
          "using"
        ]
      }
    },
    {
      "id": 3827,
      "before_code": "instance isRegularEpi_of_extremalEpi (f : X \u27f6 Y) [ExtremalEpi f] : IsRegularEpi f :=\n  \u27e8\u27e8regularEpiOfExtremalEpi f\u27e9\u27e9",
      "suggestion": "    underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n",
      "body": "```suggestion\n    underlying.obj (A' \u2293 (Subobject.pullback f).obj B') \u27f6 underlying.obj ((\u00abexists\u00bb f).obj A' \u2293 B') :=\n```",
      "path": "Mathlib/CategoryTheory/RegularCategory/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsRegularEpi",
          "regularEpiOfExtremalEpi",
          "isRegularEpi_of_extremalEpi",
          "instance",
          "ExtremalEpi"
        ]
      }
    },
    {
      "id": 3828,
      "before_code": "instance isRegularEpi_of_extremalEpi (f : X \u27f6 Y) [ExtremalEpi f] : IsRegularEpi f :=\n  \u27e8\u27e8regularEpiOfExtremalEpi f\u27e9\u27e9",
      "suggestion": "    IsPullback (frobeniusMorphism f A' B')\n      ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))))\n      ((ofLE _ _ (inf_le_left ((\u00abexists\u00bb f).obj A') B')))\n      (imageFactorisation _ _).F.e := by\n",
      "body": "```suggestion\n    IsPullback (frobeniusMorphism f A' B')\n      ((ofLE _ _ (inf_le_left A' ((Subobject.pullback f).obj B'))))\n      ((ofLE _ _ (inf_le_left ((\u00abexists\u00bb f).obj A') B')))\n      (imageFactorisation _ _).F.e := by\n```",
      "path": "Mathlib/CategoryTheory/RegularCategory/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsRegularEpi",
          "regularEpiOfExtremalEpi",
          "isRegularEpi_of_extremalEpi",
          "instance",
          "ExtremalEpi"
        ]
      }
    },
    {
      "id": 3829,
      "before_code": "rintro z \u27e8w, hw1, rfl\u27e9\n    exact (hg w (hs1 hw1)).eventually_constant_or_nhds_le_map_nhds.resolve_left (h w (hs1 hw1))\n        (image_mem_map (hs2.mem_nhds hw1))",
      "suggestion": "theorem AnalyticOnNhd.eq_const_of_re_eq_const {U : Set \u2102} {c\u2080 : \u211d} (h\u2081f : AnalyticOnNhd \u2102 f U)\n",
      "body": "```suggestion\ntheorem AnalyticOnNhd.eq_const_of_re_eq_const {U : Set \u2102} {c\u2080 : \u211d} (h\u2081f : AnalyticOnNhd \u2102 f U)\n```",
      "path": "Mathlib/Analysis/Complex/OpenMapping.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "mem_nhds",
          "eventually_constant_or_nhds_le_map_nhds",
          "hs1",
          "exact",
          "image_mem_map",
          "hs2",
          "rintro",
          "resolve_left",
          "rfl",
          "hw1"
        ]
      }
    },
    {
      "id": 3830,
      "before_code": "rintro z \u27e8w, hw1, rfl\u27e9\n    exact (hg w (hs1 hw1)).eventually_constant_or_nhds_le_map_nhds.resolve_left (h w (hs1 hw1))\n        (image_mem_map (hs2.mem_nhds hw1))",
      "suggestion": "theorem AnalyticOnNhd.eq_const_add_mul_I_of_re_eq_const {U : Set \u2102} {c\u2080 : \u211d} (h\u2081f : AnalyticOnNhd \u2102 f U)\n",
      "body": "As I mentioned on the other PR, we use primes to distinguish similar declarations, but more informative names are always better.\n```suggestion\ntheorem AnalyticOnNhd.eq_const_add_mul_I_of_re_eq_const {U : Set \u2102} {c\u2080 : \u211d} (h\u2081f : AnalyticOnNhd \u2102 f U)\n```",
      "path": "Mathlib/Analysis/Complex/OpenMapping.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "mem_nhds",
          "eventually_constant_or_nhds_le_map_nhds",
          "hs1",
          "exact",
          "image_mem_map",
          "hs2",
          "rintro",
          "resolve_left",
          "rfl",
          "hw1"
        ]
      }
    },
    {
      "id": 3834,
      "before_code": "[\u2200 i, TopologicalSpace (Y i)] {f : (i : \u03b9) \u2192 X i \u2192 Y i} (h : \u2200 i, IsHomeomorph (f i)) :\n    IsHomeomorph (fun (x : \u2200 i, X i) i \u21a6 f i (x i)) :=\n  (Homeomorph.piCongrRight fun i \u21a6 (h i).homeomorph (f i)).isHomeomorph",
      "suggestion": "def Homeomorph.ofDiscrete [DiscreteTopology X] [DiscreteTopology Y] (f : X \u2243 Y) : X \u2243\u209c Y where\n  toEquiv := f\n",
      "body": "the autoparams take care of these.\n```suggestion\ndef Homeomorph.ofDiscrete [DiscreteTopology X] [DiscreteTopology Y] (f : X \u2243 Y) : X \u2243\u209c Y where\n  toEquiv := f\n```",
      "path": "Mathlib/Topology/Homeomorph/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "piCongrRight",
          "homeomorph",
          "TopologicalSpace",
          "IsHomeomorph",
          "Homeomorph",
          "isHomeomorph"
        ]
      }
    },
    {
      "id": 3835,
      "before_code": "[\u2200 i, TopologicalSpace (Y i)] {f : (i : \u03b9) \u2192 X i \u2192 Y i} (h : \u2200 i, IsHomeomorph (f i)) :\n    IsHomeomorph (fun (x : \u2200 i, X i) i \u21a6 f i (x i)) :=\n  (Homeomorph.piCongrRight fun i \u21a6 (h i).homeomorph (f i)).isHomeomorph",
      "suggestion": "theorem Equiv.isHomeomorph_of_discrete [DiscreteTopology X] [DiscreteTopology Y]\n    (f : X \u2243 Y) : IsHomeomorph f :=\n  (Homeomorph.ofDiscrete f).isHomeomorph\n",
      "body": "How about instead:\n```suggestion\ntheorem Equiv.isHomeomorph_of_discrete [DiscreteTopology X] [DiscreteTopology Y]\n    (f : X \u2243 Y) : IsHomeomorph f :=\n  (Homeomorph.ofDiscrete f).isHomeomorph\n```",
      "path": "Mathlib/Topology/Homeomorph/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "piCongrRight",
          "homeomorph",
          "TopologicalSpace",
          "IsHomeomorph",
          "Homeomorph",
          "isHomeomorph"
        ]
      }
    },
    {
      "id": 3837,
      "before_code": "OmegaCompletePartialOrder.lift ContinuousHom.toMono ContinuousHom.\u03c9Sup\n    (fun _ _ h => h) (fun _ => rfl)\n\nnamespace Prod\n\n/-- The application of continuous functions as a continuous function. -/\n@[simps]\ndef apply : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1 \u2192\ud835\udc84 \u03b2 where\n  toFun f := f.1 f.2\n  monotone' x y h := by\n    dsimp\n    trans y.fst x.snd <;> [apply h.1; apply y.1.monotone h.2]\n  map_\u03c9Sup' c := by",
      "suggestion": "    {f : \u03b1 \u2192 \u03b2 \u2192\ud835\udc84 \u03b3} (hf : \u03c9ScottContinuous f) {g : \u03b1 \u2192 \u03b2} (hg : \u03c9ScottContinuous g) :\n",
      "body": "This might be subjective:\n\n```suggestion\n    {f : \u03b1 \u2192 \u03b2 \u2192\ud835\udc84 \u03b3} (hf : \u03c9ScottContinuous f) {g : \u03b1 \u2192 \u03b2} (hg : \u03c9ScottContinuous g) :\n```",
      "path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "lift",
          "snd",
          "apply",
          "fst",
          "monotone",
          "OmegaCompletePartialOrder",
          "Prod",
          "def",
          "toFun",
          "simps",
          "rfl",
          "dsimp",
          "application",
          "namespace",
          "function",
          "ContinuousHom",
          "continuous",
          "trans",
          "toMono",
          "functions"
        ]
      }
    },
    {
      "id": 3838,
      "before_code": "\u2190 permMatrix_mem_rowStochastic, \u2190 permMatrix_mem_colStochastic]\n\n/-- A matrix is doubly stochastic iff its transpose is doubly stochastic -/\nlemma transpose_mem_doublyStochastif_iff :\n    M.transpose \u2208 doublyStochastic R n \u2194 M \u2208 doublyStochastic R n := by\n  grind only [= doublyStochastic_eq_rowStochastic_inf_colStochastic, = Submonoid.mem_inf,\n    = transpose_mem_rowStochastic_iff_mem_colStochastic, = mem_rowStochastic,\n    = transpose_mem_colStochastic_iff_mem_rowStochastic, = mem_colStochastic]",
      "suggestion": "",
      "body": "I don't think we need a deprecation given that #28708 was merged less than 24 hours ago\n```suggestion\n```",
      "path": "Mathlib/Analysis/Convex/DoublyStochasticMatrix.lean",
      "tags": {
        "before_tactics": [
          "grind"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "grind"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "doubly",
          "its",
          "stochastic",
          "transpose_mem_colStochastic_iff_mem_rowStochastic",
          "doublyStochastic_eq_rowStochastic_inf_colStochastic",
          "transpose",
          "grind",
          "permMatrix_mem_colStochastic",
          "mem_inf",
          "iff",
          "doublyStochastic",
          "Submonoid",
          "transpose_mem_rowStochastic_iff_mem_colStochastic",
          "permMatrix_mem_rowStochastic",
          "transpose_mem_doublyStochastif_iff",
          "mem_rowStochastic",
          "only",
          "mem_colStochastic",
          "matrix"
        ]
      }
    },
    {
      "id": 3839,
      "before_code": "g.ker.comap f = (g.comp f).ker :=\n  rfl",
      "suggestion": "  rw [\u2190 comap_ker, comap_equiv_eq_map_symm]\n",
      "body": "```suggestion\n  rw [\u2190 comap_ker, comap_equiv_eq_map_symm]\n```",
      "path": "Mathlib/Algebra/Group/Subgroup/Ker.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "comp",
          "comap",
          "ker"
        ]
      }
    },
    {
      "id": 3840,
      "before_code": "runs-on: ubuntu-latest\n    if: github.repository == 'leanprover-community/mathlib4'\n    steps:",
      "suggestion": "        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1\n",
      "body": "```suggestion\n        uses: actions/create-github-app-token@[user] # v2.2.1\n```",
      "path": ".github/workflows/merge_conflicts.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "community",
          "mathlib4",
          "runs",
          "ubuntu",
          "latest",
          "github",
          "leanprover",
          "repository",
          "steps"
        ]
      }
    },
    {
      "id": 3841,
      "before_code": "runs-on: ubuntu-latest\n    if: github.repository == 'leanprover-community/mathlib4'\n    steps:\n      - name: check if prs are dirty\n        uses: eps1lon/actions-label-merge-conflict@1df065ebe6e3310545d4f4c4e862e43bdca146f0 # v3.0.3\n        with:\n          dirtyLabel: \"merge-conflict\"\n          commentOnDirty: \"This pull request has conflicts, please merge `master` and resolve them.\"\n          repoToken: \"${{ secrets.MERGE_CONFLICTS_TOKEN }}\"",
      "suggestion": "          # The create-github-app-token README states that this token is masked and will not be logged accidentally.\n          repoToken: ${{ steps.app-token.outputs.token }}\n",
      "body": "```suggestion\n          # The create-github-app-token README states that this token is masked and will not be logged accidentally.\n          repoToken: ${{ steps.app-token.outputs.token }}\n```",
      "path": ".github/workflows/merge_conflicts.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "community",
          "merge",
          "github",
          "secrets",
          "has",
          "ubuntu",
          "This",
          "eps1lon",
          "dirty",
          "MERGE_CONFLICTS_TOKEN",
          "latest",
          "dirtyLabel",
          "name",
          "conflict",
          "are",
          "label",
          "request",
          "leanprover",
          "steps",
          "commentOnDirty",
          "mathlib4",
          "prs",
          "resolve",
          "uses",
          "repository",
          "check",
          "runs",
          "conflicts",
          "them",
          "pull",
          "master",
          "repoToken",
          "please",
          "actions"
        ]
      }
    },
    {
      "id": 3842,
      "before_code": "Fourier transform of `f`, under the following hypotheses:\n* `f` is a continuous function `\u211d \u2192 \u2102`.\n* The sum `\u2211 (n : \u2124), \ud835\udcd5 f n` is convergent.\n* For all compacts `K \u2282 \u211d`, the sum `\u2211 (n : \u2124), sup { \u2016f(x + n)\u2016 | x \u2208 K }` is convergent.\n  See `Real.tsum_eq_tsum_fourierIntegral` for this formulation.",
      "suggestion": "\r\n* For all compacts `K \u2282 \u211d`, the sum `\u2211 (n : \u2124), \u2016f(x + n)\u2016` is uniformly convergent on `K`.\r\n  See `Real.tsum_eq_tsum_fourier` for this formulation.\r\n",
      "body": "```suggestion\r\n* For all compacts `K \u2282 \u211d`, the sum `\u2211 (n : \u2124), \u2016f(x + n)\u2016` is uniformly convergent on `K`.\r\n  See `Real.tsum_eq_tsum_fourier` for this formulation.\r\n```",
      "path": "Mathlib/Analysis/Fourier/PoissonSummation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "real",
          "complex",
          "topology",
          "order",
          "finset",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "tsum_eq_tsum_fourierIntegral",
          "sup",
          "For",
          "following",
          "sum",
          "Fourier",
          "compacts",
          "for",
          "See",
          "under",
          "convergent",
          "Real",
          "formulation",
          "hypotheses",
          "function",
          "this",
          "continuous",
          "transform",
          "all"
        ]
      }
    },
    {
      "id": 3843,
      "before_code": "refine (hf.hasFPowerSeriesOnBall hR).hasFPowerSeriesAt.deriv.trans ?_\n  simp only [cauchyPowerSeries_apply, one_div, zpow_neg, pow_one, smul_smul, zpow_two, mul_inv]",
      "suggestion": "    (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e z in C(c, R), (z - c) ^ (-(n + 1) : \u2124) \u2022 f z := by\n",
      "body": "Any reason this isn't \n\n```suggestion\n    (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e z in C(c, R), (z - c) ^ (-(n + 1) : \u2124) \u2022 f z := by\n```\nfollowing `deriv_eq_smul_circleIntegral`'s format?",
      "path": "Mathlib/Analysis/Complex/Liouville.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "only",
          "hasFPowerSeriesOnBall",
          "mul_inv",
          "refine",
          "hasFPowerSeriesAt",
          "deriv",
          "cauchyPowerSeries_apply",
          "trans",
          "simp",
          "zpow_neg",
          "one_div",
          "smul_smul",
          "zpow_two",
          "pow_one"
        ]
      }
    },
    {
      "id": 3844,
      "before_code": "noncomputable def cderiv (r : \u211d) (f : \u2102 \u2192 E) (z : \u2102) : E :=\n  (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e w in C(z, r), ((w - z) ^ 2)\u207b\u00b9 \u2022 f w",
      "suggestion": "  (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e w in C(z, r), ((w - z) ^ (n + 1))\u207b\u00b9 \u2022 f w\n",
      "body": "```suggestion\n  (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e w in C(z, r), ((w - z) ^ (n + 1))\u207b\u00b9 \u2022 f w\n```",
      "path": "Mathlib/Analysis/Complex/LocallyUniformLimit.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "complex"
        ],
        "transforms": [],
        "keywords": [
          "noncomputable",
          "def",
          "cderiv"
        ]
      }
    },
    {
      "id": 3845,
      "before_code": "exact (d z m).differentiableWithinAt\n    exact h _ m",
      "suggestion": "\r\n    div_mul_cancel\u2080 _ (mod_cast n.factorial_ne_zero), mul_inv_cancel\u2080 two_pi_I_ne_zero]\r\n",
      "body": "```suggestion\r\n    div_mul_cancel\u2080 _ (mod_cast n.factorial_ne_zero), mul_inv_cancel\u2080 two_pi_I_ne_zero]\r\n```",
      "path": "Mathlib/Analysis/Complex/CauchyIntegral.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "differentiability"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "differentiableWithinAt"
        ]
      }
    },
    {
      "id": 3850,
      "before_code": "let allNotPx \u2190 mkForallFVars #[x] notPx\n        return (allNotPx, hAllNotPx)",
      "suggestion": "\r\n  .lam .anonymous (binderInfo := .default) (sort u) <|\r\n    .lam .anonymous (binderInfo := .default) (.forallE .anonymous (binderInfo := .default) (.bvar 0) (.sort v)) <|\r\n      .forallE .anonymous (binderInfo := .default) (.bvar 1) (mkApp (.bvar 1) (.bvar 0))\r\n",
      "body": "`mkLambda` and `mkForall` are semi-deprecated, we should use the constructors directly instead:\r\n\r\n```suggestion\r\n  .lam .anonymous (binderInfo := .default) (sort u) <|\r\n    .lam .anonymous (binderInfo := .default) (.forallE .anonymous (binderInfo := .default) (.bvar 0) (.sort v)) <|\r\n      .forallE .anonymous (binderInfo := .default) (.bvar 1) (mkApp (.bvar 1) (.bvar 0))\r\n```",
      "path": "Mathlib/Lean/Expr/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "notPx",
          "hAllNotPx",
          "return",
          "mkForallFVars",
          "allNotPx"
        ]
      }
    },
    {
      "id": 3854,
      "before_code": "theorem mem_coe_iff {s : Nat.Combination \u03b1 n} {a : \u03b1} : a \u2208 (s : Finset \u03b1) \u2194 a \u2208 s := .rfl",
      "suggestion": "\r\n  rw [\u2190 coe_coe, Finset.nontrivial_coe, \u2190 one_lt_card_iff_nontrivial, card_eq]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 coe_coe, Finset.nontrivial_coe, \u2190 one_lt_card_iff_nontrivial, card_eq]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "set_theory",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "Nat",
          "Finset",
          "Combination",
          "rfl",
          "mem_coe_iff"
        ]
      }
    },
    {
      "id": 3855,
      "before_code": "((g \u2022 s : n.Combination \u03b1) : Finset \u03b1) = g \u2022 s :=\n  SubMulAction.val_smul (p := subMulAction G \u03b1 n) g s",
      "suggestion": "\r\n@[to_additive addAction_stabilizer_coe]\r\ntheorem stabilizer_coe [DecidableEq \u03b1] {n : \u2115} (s : n.Combination \u03b1) :\r\n",
      "body": "```suggestion\r\n@[to_additive addAction_stabilizer_coe]\r\ntheorem stabilizer_coe [DecidableEq \u03b1] {n : \u2115} (s : n.Combination \u03b1) :\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "SubMulAction",
          "subMulAction",
          "Finset",
          "val_smul",
          "Combination"
        ]
      }
    },
    {
      "id": 3856,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n  \u00b7 rwa [ncard_eq]\r\n",
      "body": "```suggestion\r\n  \u00b7 rwa [ncard_eq]\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 3857,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n      grind\r\n",
      "body": "```suggestion\r\n      grind\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 3858,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\nprovided `1 \u2264 n < card \u03b1` and `card \u03b1 \u2260 2 * n`. -/\r\n",
      "body": "```suggestion\r\nprovided `1 \u2264 n < card \u03b1` and `card \u03b1 \u2260 2 * n`. -/\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 3859,
      "before_code": "obtain \u27e8a, rfl\u27e9 := Finset.card_eq_one.mp hs\n  exact \u27e8a, rfl\u27e9",
      "suggestion": "\r\n",
      "body": "Seems like this isn't used?\r\n```suggestion\r\n```",
      "path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Combination.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "Finset",
          "card_eq_one",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 3860,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j := by\n",
      "body": "```suggestion\n    \u2211 i, \u03b1 i * \u03b6 ^ i.val = 0 \u2194 \u2200 i j, \u03b1 i = \u03b1 j := by\n```",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 3861,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "a \u211a-linear combination `\u2211_{i < p} \u03b1\u1d62 \u03b6\u2071` vanishes if and only if all coefficients `\u03b1\u1d62` are equal.\n",
      "body": "```suggestion\na \u211a-linear combination `\u2211_{i < p} \u03b1\u1d62 \u03b6\u2071` vanishes if and only if all coefficients `\u03b1\u1d62` are equal.\n```\nOr else it is not true.",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 3862,
      "before_code": "end minpoly\n\nend Polynomial",
      "suggestion": "theorem sum_eq_zero_iff_forall_eq (h\u03b6 : IsPrimitiveRoot \u03b6 p) (\u03b1 : Fin p \u2192 \u211a) :\n",
      "body": "```suggestion\ntheorem sum_eq_zero_iff_forall_eq (h\u03b6 : IsPrimitiveRoot \u03b6 p) (\u03b1 : Fin p \u2192 \u211a) :\n```\n`coeff` is not an identifier that appears in the statement so we should avoid having this in the name.",
      "path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Polynomial",
          "minpoly",
          "end"
        ]
      }
    },
    {
      "id": 3863,
      "before_code": "srcDir := \"scripts\"\n  supportInterpreter := true",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "lakefile.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "supportInterpreter",
          "true",
          "srcDir",
          "scripts"
        ]
      }
    },
    {
      "id": 3864,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "\r\ntheorem piecewise_preimage (t : Set \u03b2) : hs.piecewise f \u207b\u00b9' t = \u22c3 i, s i \u2229 (f i \u207b\u00b9' t) := by\r\n",
      "body": "```suggestion\r\ntheorem piecewise_preimage (t : Set \u03b2) : hs.piecewise f \u207b\u00b9' t = \u22c3 i, s i \u2229 (f i \u207b\u00b9' t) := by\r\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 3865,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "\r\ntheorem range_piecewise : range (hs.piecewise f) = \u22c3 i, f i '' s i := by\r\n",
      "body": "```suggestion\r\ntheorem range_piecewise : range (hs.piecewise f) = \u22c3 i, f i '' s i := by\r\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 3866,
      "before_code": "rw [\u2190 bijOn_univ, \u2190 hs.iUnion, \u2190 ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj",
      "suggestion": "\r\ntheorem range_piecewise_subset : range (hs.piecewise f) \u2286 \u22c3 i, range (f i) :=\r\n",
      "body": "```suggestion\r\ntheorem range_piecewise_subset : range (hs.piecewise f) \u2286 \u22c3 i, range (f i) :=\r\n```",
      "path": "Mathlib/Data/Setoid/Partition.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "iUnion",
          "hg_bij",
          "bijOn_iUnion",
          "hg_inj",
          "bijOn_univ"
        ]
      }
    },
    {
      "id": 3875,
      "before_code": "IsLocalization.algebraMap_eq_map_map_submonoid A\u2070 B K L]\n  rfl",
      "suggestion": "\r\n    Function.Injective (Ideal.map (algebraMap A B)) := by\r\n",
      "body": "```suggestion\r\n    Function.Injective (Ideal.map (algebraMap A B)) := by\r\n```\r\nDoes this not work? (not tested)",
      "path": "Mathlib/RingTheory/FractionalIdeal/Extended.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "rfl",
          "algebraMap_eq_map_map_submonoid",
          "IsLocalization"
        ]
      }
    },
    {
      "id": 3876,
      "before_code": ".of_isLocalization A C A\u2070\n\nend IsIntegralClosure",
      "suggestion": "\r\n    [Module.Finite A B] [IsDomain B] :\r\n",
      "body": "```suggestion\r\n    [Module.Finite A B] [IsDomain B] :\r\n```\r\nThis is enough right?",
      "path": "Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsIntegralClosure",
          "of_isLocalization",
          "end"
        ]
      }
    },
    {
      "id": 3877,
      "before_code": "## Main results\n- `NumberField.absNorm_differentIdeal`:\n  The norm of `differentIdeal \u2124 \ud835\udcaa` is the absolute discriminant.",
      "suggestion": "  Formula for the absolute discriminant of `L` in terms of that of `K` in an extension `L/K`.\n",
      "body": "```suggestion\n  Formula for the absolute discriminant of `L` in terms of that of `K` in an extension `L/K`.\n```",
      "path": "Mathlib/NumberTheory/NumberField/Discriminant/Different.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "differentIdeal",
          "results",
          "norm",
          "absNorm_differentIdeal",
          "Main",
          "discriminant",
          "absolute",
          "NumberField"
        ]
      }
    },
    {
      "id": 3878,
      "before_code": "/-- A recursor for `WithUpperSet`. Use as `induction x`. -/\n@[elab_as_elim, cases_eliminator, induction_eliminator]\nprotected def rec {\u03b2 : WithUpperSet \u03b1 \u2192 Sort*} (h : \u2200 a, \u03b2 (toUpperSet a)) : \u2200 a, \u03b2 a :=\n  fun a => h (ofUpperSet a)",
      "suggestion": "protected def rec {motive : WithUpperSet \u03b1 \u2192 Sort*} (toUpperSet : \u2200 a, motive (toUpperSet a)) :\n    \u2200 a, motive a :=\n",
      "body": "```suggestion\nprotected def rec {motive : WithUpperSet \u03b1 \u2192 Sort*} (toUpperSet : \u2200 a, motive (toUpperSet a)) :\n    \u2200 a, motive a :=\n```",
      "path": "Mathlib/Topology/Order/UpperLowerSetTopology.lean",
      "tags": {
        "before_tactics": [
          "induction"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "induction"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "WithUpperSet",
          "Sort",
          "ofUpperSet",
          "def",
          "elab_as_elim",
          "cases_eliminator",
          "protected",
          "recursor",
          "induction_eliminator",
          "induction",
          "rec",
          "Use",
          "toUpperSet",
          "for"
        ]
      }
    },
    {
      "id": 3879,
      "before_code": "/-- A recursor for `WithLowerSet`. Use as `induction x`. -/\n@[elab_as_elim, cases_eliminator, induction_eliminator]\nprotected def rec {\u03b2 : WithLowerSet \u03b1 \u2192 Sort*} (h : \u2200 a, \u03b2 (toLowerSet a)) : \u2200 a, \u03b2 a :=\n  fun a => h (ofLowerSet a)",
      "suggestion": "protected def rec {motive : WithLowerSet \u03b1 \u2192 Sort*} (toLowerSet : \u2200 a, motive (toLowerSet a)) :\n    \u2200 a, motive a :=\n",
      "body": "```suggestion\nprotected def rec {motive : WithLowerSet \u03b1 \u2192 Sort*} (toLowerSet : \u2200 a, motive (toLowerSet a)) :\n    \u2200 a, motive a :=\n```",
      "path": "Mathlib/Topology/Order/UpperLowerSetTopology.lean",
      "tags": {
        "before_tactics": [
          "induction"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "induction"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Sort",
          "def",
          "elab_as_elim",
          "toLowerSet",
          "cases_eliminator",
          "protected",
          "WithLowerSet",
          "recursor",
          "ofLowerSet",
          "induction_eliminator",
          "induction",
          "rec",
          "Use",
          "for"
        ]
      }
    },
    {
      "id": 3892,
      "before_code": "\u00b7 rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]",
      "suggestion": "    (h : \u22c3\u2080 (J : Set (Set \u03b1)) = \u22c3\u2080 J') :\n",
      "body": "```suggestion\n    (h : \u22c3\u2080 (J : Set (Set \u03b1)) = \u22c3\u2080 J') :\n```",
      "path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "hst",
          "sUnion_insert_disjointOfDiff",
          "coe_insert",
          "rwa"
        ]
      }
    },
    {
      "id": 3893,
      "before_code": "exact exists_inter_eq_singleton hrep h\n\nlemma ncard_eq (hrep : Represents s C) : s.ncard = C.ncard :=\n  hrep.image_eq \u25b8 (Set.ncard_image_of_injOn hrep.injOn).symm",
      "suggestion": "\r\n  hrep.image_eq \u25b8 (hrep.injOn.ncard_image).symm\r\n",
      "body": "```suggestion\r\n  hrep.image_eq \u25b8 (hrep.injOn.ncard_image).symm\r\n```\r\nDo I undestand correctly that we can now write this? A similar case is below",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Represents.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "hrep",
          "lemma",
          "image_eq",
          "ncard",
          "exists_inter_eq_singleton",
          "exact",
          "symm",
          "Set",
          "injOn",
          "Represents",
          "ncard_eq",
          "ncard_image_of_injOn"
        ]
      }
    },
    {
      "id": 3894,
      "before_code": "variable (k : Type u) [Field k]\n\n/-- Typeclass for algebraically closed fields.\n\nTo show `Polynomial.Splits p f` for an arbitrary ring homomorphism `f`,\nsee `IsAlgClosed.splits_domain`.\n-/",
      "suggestion": "\r\n`IsAlgClosed.of_exists_root`. -/\r\n",
      "body": "```suggestion\r\n`IsAlgClosed.of_exists_root`. -/\r\n```\r\n\r\n?",
      "path": "Mathlib/FieldTheory/IsAlgClosed/Basic.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "splits_domain",
          "variable",
          "Typeclass",
          "show",
          "IsAlgClosed",
          "Type",
          "algebraically",
          "Field",
          "Splits",
          "arbitrary",
          "fields",
          "homomorphism",
          "closed",
          "Polynomial",
          "ring",
          "see",
          "for"
        ]
      }
    },
    {
      "id": 3895,
      "before_code": "lemma zero_le_logHeight\u2081 (x : K) : 0 \u2264 logHeight\u2081 x :=\n  Real.log_nonneg <| one_le_mulHeight\u2081 x",
      "suggestion": "\r\n    pure (.nonnegative q(zero_le_logHeight\u2081 $a))\r\n",
      "body": "```suggestion\r\n    pure (.nonnegative q(zero_le_logHeight\u2081 $a))\r\n```",
      "path": "Mathlib/NumberTheory/Height/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "log_nonneg",
          "Real"
        ]
      }
    },
    {
      "id": 3896,
      "before_code": "lemma zero_le_logHeight {x : \u03b9 \u2192 K} : 0 \u2264 logHeight x :=\n  log_nonneg <| one_le_mulHeight x",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/NumberTheory/Height/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "lemma",
          "one_le_mulHeight",
          "zero_le_logHeight",
          "logHeight",
          "log_nonneg"
        ]
      }
    },
    {
      "id": 3899,
      "before_code": "section Continuous\n\n/-! ### Deducing continuity from differentiability -/\n\ntheorem HasFDerivAtFilter.tendsto_nhds (hL : L \u2264 \ud835\udcdd x) (h : HasFDerivAtFilter f f' x L) :",
      "suggestion": "\r\ntheorem HasFDerivAtFilter.tendsto_nhds (hL : L \u2264 \ud835\udcdd x) (h : HasFDerivAtFilter f f' x L) :\r\n",
      "body": "```suggestion\r\ntheorem HasFDerivAtFilter.tendsto_nhds (hL : L \u2264 \ud835\udcdd x) (h : HasFDerivAtFilter f f' x L) :\r\n```",
      "path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
      "tags": {
        "before_tactics": [
          "continuity"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "continuity"
        ],
        "topics": [
          "continuity",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "continuity",
          "Deducing",
          "tendsto_nhds",
          "Continuous",
          "from",
          "HasFDerivAtFilter",
          "differentiability",
          "section"
        ]
      }
    },
    {
      "id": 3900,
      "before_code": "\u2190 mul_assoc (f c ^ n), mul_inv_cancel\u2080 (pow_ne_zero n hc), one_mul, div_eq_mul_inv]\n\n/-- The real-valued function sending `x \u2208 R` to the limit of `(f (x * c^n))/((f c)^n)`. -/\ndef seminormFromConst' (x : R) : \u211d :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n    (seminormFromConst_seq_antitone hf1 hc hpm x)).choose\n\n/-- We prove that `seminormFromConst' hf1 hc hpm x` is the limit of the sequence\n  `seminormFromConst_seq c f x` as `n` tends to infinity. -/\ntheorem seminormFromConst_isLimit (x : R) :\n    Tendsto (seminormFromConst_seq c f x) atTop (\ud835\udcdd (seminormFromConst' hf1 hc hpm x)) :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n      (seminormFromConst_seq_antitone hf1 hc hpm x)).choose_spec\n\n/-- `seminormFromConst' hf1 hc hpm 1 = 1`. -/\ntheorem seminormFromConst_one : seminormFromConst' hf1 hc hpm 1 = 1 := by\n  apply tendsto_nhds_unique_of_eventuallyEq (seminormFromConst_isLimit hf1 hc hpm 1)\n    tendsto_const_nhds\n  simp only [EventuallyEq, eventually_atTop, ge_iff_le]\n  exact \u27e81, seminormFromConst_seq_one hc hpm\u27e9\n\n/-- The function `seminormFromConst` is a `RingSeminorm` on `R`. -/\ndef seminormFromConst : RingSeminorm R where\n  toFun     := seminormFromConst' hf1 hc hpm\n  map_zero' := tendsto_nhds_unique (seminormFromConst_isLimit hf1 hc hpm 0)\n    (by simpa [seminormFromConst_seq_zero c (map_zero _)] using tendsto_const_nhds)\n  add_le' x y := by\n    apply le_of_tendsto_of_tendsto' (seminormFromConst_isLimit hf1 hc hpm (x + y))\n      ((seminormFromConst_isLimit hf1 hc hpm x).add (seminormFromConst_isLimit hf1 hc hpm y))\n    intro n\n    have h_add : f ((x + y) * c ^ n) \u2264 f (x * c ^ n) + f (y * c ^ n) := by\n      simp only [add_mul, map_add_le_add f _ _]\n    simp only [seminormFromConst_seq, \u2190 add_div]\n    gcongr\n  neg' x := by\n    apply tendsto_nhds_unique_of_eventuallyEq (seminormFromConst_isLimit hf1 hc hpm (-x))\n      (seminormFromConst_isLimit hf1 hc hpm x)\n    simp only [EventuallyEq, eventually_atTop]\n  ",
      "suggestion": "\r\n",
      "body": "And this one too.\r\n```suggestion\r\n```",
      "path": "Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "gcongr",
          "refine",
          "exact",
          "have",
          "simpa",
          "rw",
          "simp",
          "intro"
        ],
        "topics": [
          "nat",
          "algebra",
          "list",
          "real",
          "topology",
          "norm",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "map_zero",
          "infinity",
          "tends",
          "seminormFromConst",
          "seminormFromConst_seq_one",
          "hf1",
          "div_mul_div_comm",
          "using",
          "mul",
          "seminormFromConst_seq",
          "add",
          "limit",
          "have",
          "intro",
          "max",
          "ge_iff_le",
          "def",
          "Tendsto",
          "that",
          "mul_comm",
          "simp",
          "choose",
          "IsNonarchimedean",
          "rfl",
          "tendsto_nhds_unique_of_eventuallyEq",
          "theorem",
          "hlim",
          "tendsto_nhds_unique",
          "apply_nonneg",
          "map_neg_eq_map",
          "hna",
          "seminormFromConst_isNonarchimedean",
          "eventually_atTop",
          "add_le",
          "RingSeminorm",
          "nonarchimedean",
          "le_of_tendsto_of_tendsto",
          "apply",
          "seminormFromConst_one_le",
          "Nat",
          "seminormFromConst_isLimit",
          "tendsto_const_nhds",
          "prove",
          "choose_spec",
          "imp",
          "le_of_eq",
          "toFun",
          "hnm",
          "sending"
        ]
      }
    },
    {
      "id": 3901,
      "before_code": "div_self (pow_ne_zero n hc), mul_one]\n    rw [hseq]\n    exact tendsto_const_nhds\n  tendsto_nhds_unique (seminormFromConst_isLimit hf1 hc hpm c) hlim\n\n/-- For every `x : R`, `seminormFromConst' hf1 hc hpm (c * x)` equals the product\n  `seminormFromConst' hf1 hc hpm c * SeminormFromConst' hf1 hc hpm x`. -/",
      "suggestion": "\r\n",
      "body": "And this one.\r\n```suggestion\r\n```",
      "path": "Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "norm",
          "list",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "For",
          "product",
          "hlim",
          "exact",
          "every",
          "seminormFromConst",
          "hseq",
          "equals",
          "hpm",
          "seminormFromConst_isLimit",
          "hf1",
          "div_self",
          "mul_one",
          "tendsto_nhds_unique",
          "tendsto_const_nhds",
          "SeminormFromConst",
          "pow_ne_zero"
        ]
      }
    },
    {
      "id": 3902,
      "before_code": "\u2190 mul_assoc (f c ^ n), mul_inv_cancel\u2080 (pow_ne_zero n hc), one_mul, div_eq_mul_inv]\n\n/-- The real-valued function sending `x \u2208 R` to the limit of `(f (x * c^n))/((f c)^n)`. -/\ndef seminormFromConst' (x : R) : \u211d :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n    (seminormFromConst_seq_antitone hf1 hc hpm x)).choose\n\n/-- We prove that `seminormFromConst' hf1 hc hpm x` is the limit of the sequence\n  `seminormFromConst_seq c f x` as `n` tends to infinity. -/\ntheorem seminormFromConst_isLimit (x : R) :\n    Tendsto (seminormFromConst_seq c f x) atTop (\ud835\udcdd (seminormFromConst' hf1 hc hpm x)) :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n      (seminormFromConst_seq_antitone hf1 hc hpm x)).choose_spec",
      "suggestion": "\r\n@[deprecated (since := \"2026-01-14\")]\r\nalias seminormFromConst_isLimit := tendsTo_seminormFromConst_atTop\r\n",
      "body": "```suggestion\r\n@[deprecated (since := \"2026-01-14\")]\r\nalias seminormFromConst_isLimit := tendsTo_seminormFromConst_atTop\r\n```",
      "path": "Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "real",
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "div_eq_mul_inv",
          "infinity",
          "real",
          "tends",
          "seminormFromConst",
          "hf1",
          "atTop",
          "seminormFromConst_seq",
          "one_mul",
          "limit",
          "seminormFromConst_isLimit",
          "prove",
          "pow_ne_zero",
          "choose_spec",
          "seminormFromConst_seq_antitone",
          "def",
          "Real",
          "sending",
          "Tendsto",
          "sequence",
          "hpm",
          "that",
          "choose",
          "mul_assoc",
          "function",
          "theorem",
          "valued",
          "seminormFromConst_bddBelow",
          "tendsto_of_bddBelow_antitone"
        ]
      }
    },
    {
      "id": 3903,
      "before_code": "\u2190 mul_assoc (f c ^ n), mul_inv_cancel\u2080 (pow_ne_zero n hc), one_mul, div_eq_mul_inv]\n\n/-- The real-valued function sending `x \u2208 R` to the limit of `(f (x * c^n))/((f c)^n)`. -/\ndef seminormFromConst' (x : R) : \u211d :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n    (seminormFromConst_seq_antitone hf1 hc hpm x)).choose\n\n/-- We prove that `seminormFromConst' hf1 hc hpm x` is the limit of the sequence\n  `seminormFromConst_seq c f x` as `n` tends to infinity. -/\ntheorem seminormFromConst_isLimit (x : R) :\n    Tendsto (seminormFromConst_seq c f x) atTop (\ud835\udcdd (seminormFromConst' hf1 hc hpm x)) :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n      (seminormFromConst_seq_antitone hf1 hc hpm x)).choose_spec\n\n/-- `seminormFromConst' hf1 hc hpm 1 = 1`. -/\ntheorem seminormFromConst_one : seminormFromConst' hf1 hc hpm 1 = 1 := by\n  apply tendsto_nhds_unique_of_eventuallyEq (seminormFromConst_isLimit hf1 hc hpm 1)",
      "suggestion": "theorem tendsto_seminormFromConst_seq_atTop (x : R) :\n",
      "body": "```suggestion\ntheorem tendsto_seminormFromConst_seq_atTop (x : R) :\n```",
      "path": "Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "list",
          "real",
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "div_eq_mul_inv",
          "infinity",
          "real",
          "tends",
          "seminormFromConst",
          "hf1",
          "atTop",
          "seminormFromConst_seq",
          "one_mul",
          "apply",
          "limit",
          "seminormFromConst_isLimit",
          "prove",
          "pow_ne_zero",
          "choose_spec",
          "seminormFromConst_seq_antitone",
          "def",
          "Real",
          "sending",
          "Tendsto",
          "sequence",
          "seminormFromConst_one",
          "hpm",
          "that",
          "choose",
          "mul_assoc",
          "function",
          "theorem",
          "tendsto_nhds_unique_of_eventuallyEq",
          "valued",
          "seminormFromConst_bddBelow",
          "tendsto_of_bddBelow_antitone"
        ]
      }
    },
    {
      "id": 3904,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/",
      "suggestion": "@[deprecated tendsto_atTop_ciSup (since := \"2026-01-14\")]\n",
      "body": "I agree these should be deprecated, but rather to:\n```suggestion\n@[deprecated tendsto_atTop_ciSup (since := \"2026-01-14\")]\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "limit",
          "monotone",
          "Monotone",
          "sequence",
          "finite",
          "has",
          "above",
          "bounded",
          "section"
        ]
      }
    },
    {
      "id": 3905,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9",
      "suggestion": "  \u27e8iSup f, tendsto_atTop_ciSup h_mon h_bdd\u27e9\n",
      "body": "```suggestion\n  \u27e8iSup f, tendsto_atTop_ciSup h_mon h_bdd\u27e9\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "obtain",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "exists_isLUB",
          "h_mon",
          "range",
          "Real",
          "Tendsto",
          "sequence",
          "tendsto_of_bddAbove_monotone",
          "tendsto_atTop_isLUB",
          "above",
          "bounded",
          "h_bdd",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set"
        ]
      }
    },
    {
      "id": 3906,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n\n/-- An antitone, bounded below sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/",
      "suggestion": "@[deprecated tendsto_atTop_ciInf (since := \"2026-01-14\")]\n",
      "body": "```suggestion\n@[deprecated tendsto_atTop_ciInf (since := \"2026-01-14\")]\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "antitone",
          "obtain",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "exists_isLUB",
          "h_mon",
          "range",
          "Real",
          "Tendsto",
          "sequence",
          "tendsto_of_bddAbove_monotone",
          "tendsto_atTop_isLUB",
          "above",
          "bounded",
          "h_bdd",
          "below",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set"
        ]
      }
    },
    {
      "id": 3907,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n\n/-- An antitone, bounded below sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddBelow_antitone {f : \u2115 \u2192 \u211d} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9",
      "suggestion": "  \u27e8iInf f, tendsto_atTop_ciInf h_ant h_bdd\u27e9\n",
      "body": "```suggestion\n  \u27e8iInf f, tendsto_atTop_ciInf h_ant h_bdd\u27e9\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "antitone",
          "obtain",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "exists_isLUB",
          "Antitone",
          "h_mon",
          "range",
          "Real",
          "exists_isGLB",
          "Tendsto",
          "sequence",
          "tendsto_of_bddAbove_monotone",
          "tendsto_atTop_isLUB",
          "BddBelow",
          "above",
          "bounded",
          "h_bdd",
          "below",
          "tendsto_atTop_isGLB",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set",
          "h_ant",
          "tendsto_of_bddBelow_antitone"
        ]
      }
    },
    {
      "id": 3908,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n\n/-- An antitone, bounded below sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddBelow_antitone {f : \u2115 \u2192 \u211d} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "antitone",
          "obtain",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "exists_isLUB",
          "Antitone",
          "h_mon",
          "range",
          "Real",
          "exists_isGLB",
          "Tendsto",
          "sequence",
          "tendsto_of_bddAbove_monotone",
          "tendsto_atTop_isLUB",
          "BddBelow",
          "above",
          "bounded",
          "h_bdd",
          "below",
          "tendsto_atTop_isGLB",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set",
          "h_ant",
          "tendsto_of_bddBelow_antitone"
        ]
      }
    },
    {
      "id": 3909,
      "before_code": "section Monotone\n\n/-- A monotone, bounded above sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : \u2115 \u2192 \u211d} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isLUB h_mon hB\u27e9\n\n/-- An antitone, bounded below sequence `f : \u2115 \u2192 \u211d` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddBelow_antitone {f : \u2115 \u2192 \u211d} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : \u2203 r : \u211d, Tendsto f atTop (\ud835\udcdd r) := by\n  obtain \u27e8B, hB\u27e9 := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact \u27e8B, tendsto_atTop_isGLB h_ant hB\u27e9\n\n/-- An antitone sequence `f : \u2115 \u2192 \u211d\u22650` has a finite limit. -/",
      "suggestion": "@[deprecated tendsto_atTop_ciInf (since := \"2026-01-14\")]\n",
      "body": "```suggestion\n@[deprecated tendsto_atTop_ciInf (since := \"2026-01-14\")]\n```",
      "path": "Mathlib/Topology/Instances/NNReal/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "set_theory",
          "real",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "antitone",
          "obtain",
          "finite",
          "range_nonempty",
          "has",
          "atTop",
          "section",
          "limit",
          "_root_",
          "monotone",
          "exists_isLUB",
          "Antitone",
          "h_mon",
          "range",
          "Real",
          "exists_isGLB",
          "Tendsto",
          "sequence",
          "tendsto_of_bddAbove_monotone",
          "tendsto_atTop_isLUB",
          "BddBelow",
          "above",
          "bounded",
          "h_bdd",
          "below",
          "tendsto_atTop_isGLB",
          "theorem",
          "exact",
          "BddAbove",
          "Monotone",
          "Set",
          "h_ant",
          "tendsto_of_bddBelow_antitone"
        ]
      }
    },
    {
      "id": 3910,
      "before_code": "\u2190 mul_assoc (f c ^ n), mul_inv_cancel\u2080 (pow_ne_zero n hc), one_mul, div_eq_mul_inv]\n\n/-- The real-valued function sending `x \u2208 R` to the limit of `(f (x * c^n))/((f c)^n)`. -/\ndef seminormFromConst' (x : R) : \u211d :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n    (seminormFromConst_seq_antitone hf1 hc hpm x)).choose\n\n/-- We prove that `seminormFromConst' hf1 hc hpm x` is the limit of the sequence\n  `seminormFromConst_seq c f x` as `n` tends to infinity. -/\ntheorem seminormFromConst_isLimit (x : R) :\n    Tendsto (seminormFromConst_seq c f x) atTop (\ud835\udcdd (seminormFromConst' hf1 hc hpm x)) :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n      (seminormFromConst_seq_antitone hf1 hc hpm x)).choose_spec\n\n/-- `seminormFromConst' hf1 hc hpm 1 = 1`. -/\ntheorem seminormFromConst_one : seminormFromConst' hf1 hc hpm 1 = 1 := by\n  apply tendsto_nhds_unique_of_eventuallyEq (seminormFromConst_isLimit hf1 hc hpm 1)",
      "suggestion": "  tendsto_atTop_ciInf (seminormFromConst_seq_antitone hf1 hc hpm x)\n    (seminormFromConst_bddBelow c f x)\n",
      "body": "```suggestion\n  tendsto_atTop_ciInf (seminormFromConst_seq_antitone hf1 hc hpm x)\n    (seminormFromConst_bddBelow c f x)\n```",
      "path": "Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "list",
          "real",
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "div_eq_mul_inv",
          "infinity",
          "real",
          "tends",
          "seminormFromConst",
          "hf1",
          "atTop",
          "seminormFromConst_seq",
          "one_mul",
          "apply",
          "limit",
          "seminormFromConst_isLimit",
          "prove",
          "pow_ne_zero",
          "choose_spec",
          "seminormFromConst_seq_antitone",
          "def",
          "Real",
          "sending",
          "Tendsto",
          "sequence",
          "seminormFromConst_one",
          "hpm",
          "that",
          "choose",
          "mul_assoc",
          "function",
          "theorem",
          "tendsto_nhds_unique_of_eventuallyEq",
          "valued",
          "seminormFromConst_bddBelow",
          "tendsto_of_bddBelow_antitone"
        ]
      }
    },
    {
      "id": 3911,
      "before_code": "SchwartzMap.bilinLeftCLM (ContinuousLinearMap.lsmul \ud835\udd5c \ud835\udd5c).flip hg\n  else 0\n\n@[simp]",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "SchwartzMap",
          "else",
          "ContinuousLinearMap",
          "lsmul",
          "flip",
          "simp",
          "bilinLeftCLM"
        ]
      }
    },
    {
      "id": 3912,
      "before_code": "rw [RCLike.real_smul_eq_coe_smul (K := \ud835\udd5c') c, smulLeftCLM_smul hg,\n    \u2190 RCLike.real_smul_eq_coe_smul c]",
      "suggestion": "theorem tsupport_smulLeftCLM_subset_inter (g : E \u2192 \ud835\udd5c) (f : \ud835\udce2(E, F)) :\n    tsupport (smulLeftCLM F g f) \u2286 tsupport g \u2229 tsupport f := by\n  -- Your proof here\n",
      "body": "How about instead we just prove:\n```suggestion\ntheorem tsupport_smulLeftCLM_subset_inter (g : E \u2192 \ud835\udd5c) (f : \ud835\udce2(E, F)) :\n    tsupport (smulLeftCLM F g f) \u2286 tsupport g \u2229 tsupport f := by\n  -- Your proof here\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "RCLike",
          "smulLeftCLM_smul",
          "real_smul_eq_coe_smul"
        ]
      }
    },
    {
      "id": 3913,
      "before_code": "end Zero\n\nsection One\n\nvariable [DecidableEq n] [MulZeroOneClass \u03b1]\nvariable (M : Matrix n n \u03b1)\n\ntheorem hadamard_one : M \u2299 (1 : Matrix n n \u03b1) = diagonal fun i => M i i := by\n  ext i j\n  by_cases h : i = j <;> simp [h]",
      "suggestion": "\r\ntheorem one_hadamard_eq_diagonal_iff {A : Matrix n n \u03b1} : 1 \u2299 A = diagonal d \u2194 A.diag = d := by\r\n",
      "body": "I guess this generalizes to \r\n```suggestion\r\ntheorem one_hadamard_eq_diagonal_iff {A : Matrix n n \u03b1} : 1 \u2299 A = diagonal d \u2194 A.diag = d := by\r\n```\r\nfrom which you can recover this and the others as a special case.",
      "path": "Mathlib/LinearAlgebra/Matrix/Hadamard.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "ext",
          "variable",
          "by_cases",
          "theorem",
          "Matrix",
          "diagonal",
          "hadamard_one",
          "One",
          "DecidableEq",
          "simp",
          "MulZeroOneClass",
          "Zero",
          "section"
        ]
      }
    },
    {
      "id": 3914,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "open Function IntertwiningMap\n",
      "body": "Can we also open `Function` and then drop all the `Function.` prefixes below:\n```suggestion\nopen Function IntertwiningMap\n```",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 3915,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso",
      "suggestion": "theorem bijective_or_eq_zero [IsIrreducible \u03c3] : Bijective f \u2228 f = 0 := by\n",
      "body": "```suggestion\ntheorem bijective_or_eq_zero [IsIrreducible \u03c3] : Bijective f \u2228 f = 0 := by\n```",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 3916,
      "before_code": "rw [isSimpleModule_iff, isIrreducible_iff]\n  exact OrderIso.isSimpleOrder_iff Subrepresentation.submoduleSubrepresentationOrderIso\n\nend",
      "suggestion": "theorem bijective_or_eq_zero [IsIrreducible \u03c3] : Bijective f \u2228 f = 0 := by\n",
      "body": "Style nit:\n```suggestion\ntheorem bijective_or_eq_zero [IsIrreducible \u03c3] : Bijective f \u2228 f = 0 := by\n```",
      "path": "Mathlib/RepresentationTheory/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "submoduleSubrepresentationOrderIso",
          "isIrreducible_iff",
          "isSimpleModule_iff",
          "end",
          "exact",
          "isSimpleOrder_iff",
          "Subrepresentation",
          "OrderIso"
        ]
      }
    },
    {
      "id": 3924,
      "before_code": "refine Continuous.if_le ?_ ?_ (continuous_subtype_val.comp continuous_snd) continuous_const ?_\n  \u00b7 change\n      Continuous ((fun p : \u03b9 \u00d7 \u211d => (\u03b3\u2081 p.1).extend p.2) \u2218 Prod.map id (fun x => 2 * x : I \u2192 \u211d))\n    exact h\u2081'.comp (continuous_id.prodMap <| continuous_const.mul continuous_subtype_val)",
      "suggestion": "\r\n    fun_prop\r\n",
      "body": "What's wrong with\r\n```suggestion\r\n    fun_prop\r\n```\r\n?",
      "path": "Mathlib/Topology/Path.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "refine"
        ],
        "suggestion_tactics": [
          "fun_prop"
        ],
        "body_tactics": [
          "fun_prop"
        ],
        "new_tactics": [
          "fun_prop"
        ],
        "removed_tactics": [
          "exact",
          "refine"
        ],
        "topics": [
          "continuity",
          "real",
          "list"
        ],
        "transforms": [
          "use_fun_prop"
        ],
        "keywords": [
          "continuous_snd",
          "prodMap",
          "refine",
          "continuous_subtype_val",
          "Prod",
          "extend",
          "continuous_id",
          "exact",
          "change",
          "continuous_const",
          "map",
          "if_le",
          "comp",
          "Continuous",
          "mul"
        ]
      }
    },
    {
      "id": 3925,
      "before_code": "instance QuotientGroup.measurableSMul {G : Type*} [Group G] {\u0393 : Subgroup G} [MeasurableSpace G]\n    [TopologicalSpace G] [IsTopologicalGroup G] [BorelSpace G] [BorelSpace (G \u29f8 \u0393)] :\n    MeasurableSMul G (G \u29f8 \u0393) where\n  measurable_const_smul g := (continuous_const_smul g).measurable\n  measurable_smul_const _ := (continuous_id.smul continuous_const).measurable",
      "suggestion": "\r\n",
      "body": "These can disappear now\r\n```suggestion\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Haar/Quotient.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra",
          "continuity",
          "list",
          "topology",
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "Subgroup",
          "smul",
          "IsTopologicalGroup",
          "TopologicalSpace",
          "continuous_id",
          "measurable_smul_const",
          "Type",
          "MeasurableSMul",
          "Group",
          "continuous_const",
          "continuous_const_smul",
          "measurable",
          "BorelSpace",
          "measurableSMul",
          "instance",
          "MeasurableSpace",
          "QuotientGroup",
          "measurable_const_smul"
        ]
      }
    },
    {
      "id": 3926,
      "before_code": "prime_factors_unique (fun x hx => UniqueFactorizationMonoid.irreducible_iff_prime.mp (hf x hx))\n    (fun x hx => UniqueFactorizationMonoid.irreducible_iff_prime.mp (hg x hx)) h",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/RingTheory/UniqueFactorizationDomain/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "irreducible_iff_prime",
          "UniqueFactorizationMonoid",
          "prime_factors_unique"
        ]
      }
    },
    {
      "id": 3927,
      "before_code": "theorem self_symm_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : X \u2245 Z) : \u03b1 \u226a\u226b \u03b1.symm \u226a\u226b \u03b2 = \u03b2 := by\n  rw [\u2190 trans_assoc, self_symm_id, refl_trans]\n\ntheorem inv_comp_eq (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_inv_comp (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f :=\n  (inv_comp_eq \u03b1.symm).symm\n\ntheorem comp_inv_eq (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b \u03b1.inv = g \u2194 f = g \u226b \u03b1.hom :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_comp_inv (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b \u03b1.inv \u2194 g \u226b \u03b1.hom = f :=\n  (comp_inv_eq \u03b1.symm).symm\n\ntheorem inv_eq_inv (f g : X \u2245 Y) : f.inv = g.inv \u2194 f.hom = g.hom :=\n  have : \u2200 {X Y : C} (f g : X \u2245 Y), f.hom = g.hom \u2192 f.inv = g.inv := fun f g h => by rw [ext h]\n  \u27e8this f.symm g.symm, this f g\u27e9\n\ntheorem hom_comp_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : \u03b1.hom \u226b f = \ud835\udfd9 X \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_inv_comp, comp_id]\n\ntheorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_comp_inv, id_comp]\n\ntheorem inv_comp_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : \u03b1.inv \u226b f = \ud835\udfd9 Y \u2194 f = \u03b1.hom :=\n  hom_comp_eq_id \u03b1.symm\n\ntheorem comp_inv_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : f \u226b \u03b1.inv = \ud835\udfd9 X \u2194 f = \u03b1.hom :=\n  comp_hom_eq_id \u03b1.symm\n\ntheorem hom_eq_inv (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 X) : \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv := by\n  rw [\u2190 symm_inv, inv_eq_inv \u03b1.symm \u03b2, eq_comm]\n  rfl\n\nattribute [local grind] Function.LeftInverse Function.RightInverse\n\n/-- The bijection `(Z \u27f6 X) \u2243 (Z \u27f6 Y)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homToEquiv (\u03b1 : X \u2245 Y) {Z : C} : (Z \u27f6 X) \u2243 (Z \u27f6 Y) where\n  toFun f := f \u226b \u03b1.hom\n  invFun g := g \u226b \u03b1.inv\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\n/-- The bijection `(X \u27f6 Z) \u2243 (Y \u27f6 Z)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homFromEquiv (\u03b1 : X \u2245 Y) {Z : C} : (X \u27f6 Z) \u2243 (Y \u27f6 Z) where\n  toFun f := \u03b1.inv \u226b f\n  invFun g := \u03b1.hom \u226b g\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\nend Iso\n\n/-- The `IsIso` t",
      "suggestion": "\r\n@[to_dual (reorder := X Y) comp_hom_eq_id]\r\n",
      "body": "```suggestion\r\n@[to_dual (reorder := X Y) comp_hom_eq_id]\r\n```",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "symm_inv",
          "inferInstance",
          "IsIso",
          "loop",
          "note",
          "lean",
          "Type",
          "make",
          "typeclass",
          "easier",
          "open",
          "epi_of_iso",
          "eq_comm",
          "been",
          "trans_assoc",
          "have",
          "inv_hom_id",
          "Prop",
          "failing",
          "priority",
          "reason",
          "Epi",
          "Iso",
          "cannot",
          "inv_comp_eq_id",
          "Mono",
          "inverse",
          "of_isIso_fac_left",
          "out",
          "arguments",
          "of_isIso_comp_right",
          "def",
          "Here",
          "comp_inv_eq",
          "right_inv",
          "simps",
          "that",
          "had",
          "right_cancellation",
          "simp",
          "choose",
          "rfl",
          "theorem",
          "Without",
          "Category",
          "left",
          "Reinterpret",
          "reassoc",
          "left_inv",
          "isomorphisms"
        ]
      }
    },
    {
      "id": 3928,
      "before_code": "theorem self_symm_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : X \u2245 Z) : \u03b1 \u226a\u226b \u03b1.symm \u226a\u226b \u03b2 = \u03b2 := by\n  rw [\u2190 trans_assoc, self_symm_id, refl_trans]\n\ntheorem inv_comp_eq (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_inv_comp (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f :=\n  (inv_comp_eq \u03b1.symm).symm\n\ntheorem comp_inv_eq (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b \u03b1.inv = g \u2194 f = g \u226b \u03b1.hom :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_comp_inv (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b \u03b1.inv \u2194 g \u226b \u03b1.hom = f :=\n  (comp_inv_eq \u03b1.symm).symm\n\ntheorem inv_eq_inv (f g : X \u2245 Y) : f.inv = g.inv \u2194 f.hom = g.hom :=\n  have : \u2200 {X Y : C} (f g : X \u2245 Y), f.hom = g.hom \u2192 f.inv = g.inv := fun f g h => by rw [ext h]\n  \u27e8this f.symm g.symm, this f g\u27e9\n\ntheorem hom_comp_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : \u03b1.hom \u226b f = \ud835\udfd9 X \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_inv_comp, comp_id]\n\ntheorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_comp_inv, id_comp]\n\ntheorem inv_comp_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : \u03b1.inv \u226b f = \ud835\udfd9 Y \u2194 f = \u03b1.hom :=\n  hom_comp_eq_id \u03b1.symm\n\ntheorem comp_inv_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : f \u226b \u03b1.inv = \ud835\udfd9 X \u2194 f = \u03b1.hom :=\n  comp_hom_eq_id \u03b1.symm\n\ntheorem hom_eq_inv (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 X) : \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv := by\n  rw [\u2190 symm_inv, inv_eq_inv \u03b1.symm \u03b2, eq_comm]\n  rfl\n\nattribute [local grind] Function.LeftInverse Function.RightInverse\n\n/-- The bijection `(Z \u27f6 X) \u2243 (Z \u27f6 Y)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homToEquiv (\u03b1 : X \u2245 Y) {Z : C} : (Z \u27f6 X) \u2243 (Z \u27f6 Y) where\n  toFun f := f \u226b \u03b1.hom\n  invFun g := g \u226b \u03b1.inv\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\n/-- The bijection `(X \u27f6 Z) \u2243 (Y \u27f6 Z)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homFromEquiv (\u03b1 : X \u2245 Y) {Z : C} : (X \u27f6 Z) \u2243 (Y \u27f6 Z) where\n  toFun f := \u03b1.inv \u226b f\n  invFun g := \u03b1.hom \u226b g\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\nend Iso\n\n/-- The `IsIso` t",
      "suggestion": "\r\n@[to_dual (reorder := X Y) comp_inv_eq_id]\r\n",
      "body": "```suggestion\r\n@[to_dual (reorder := X Y) comp_inv_eq_id]\r\n```",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "symm_inv",
          "inferInstance",
          "IsIso",
          "loop",
          "note",
          "lean",
          "Type",
          "make",
          "typeclass",
          "easier",
          "open",
          "epi_of_iso",
          "eq_comm",
          "been",
          "trans_assoc",
          "have",
          "inv_hom_id",
          "Prop",
          "failing",
          "priority",
          "reason",
          "Epi",
          "Iso",
          "cannot",
          "inv_comp_eq_id",
          "Mono",
          "inverse",
          "of_isIso_fac_left",
          "out",
          "arguments",
          "of_isIso_comp_right",
          "def",
          "Here",
          "comp_inv_eq",
          "right_inv",
          "simps",
          "that",
          "had",
          "right_cancellation",
          "simp",
          "choose",
          "rfl",
          "theorem",
          "Without",
          "Category",
          "left",
          "Reinterpret",
          "reassoc",
          "left_inv",
          "isomorphisms"
        ]
      }
    },
    {
      "id": 3929,
      "before_code": "theorem self_symm_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : X \u2245 Z) : \u03b1 \u226a\u226b \u03b1.symm \u226a\u226b \u03b2 = \u03b2 := by\n  rw [\u2190 trans_assoc, self_symm_id, refl_trans]\n\ntheorem inv_comp_eq (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_inv_comp (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f :=\n  (inv_comp_eq \u03b1.symm).symm\n\ntheorem comp_inv_eq (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b \u03b1.inv = g \u2194 f = g \u226b \u03b1.hom :=\n  \u27e8fun H => by simp [H.symm], fun H => by simp [H]\u27e9\n\ntheorem eq_comp_inv (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b \u03b1.inv \u2194 g \u226b \u03b1.hom = f :=\n  (comp_inv_eq \u03b1.symm).symm\n\ntheorem inv_eq_inv (f g : X \u2245 Y) : f.inv = g.inv \u2194 f.hom = g.hom :=\n  have : \u2200 {X Y : C} (f g : X \u2245 Y), f.hom = g.hom \u2192 f.inv = g.inv := fun f g h => by rw [ext h]\n  \u27e8this f.symm g.symm, this f g\u27e9\n\ntheorem hom_comp_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : \u03b1.hom \u226b f = \ud835\udfd9 X \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_inv_comp, comp_id]\n\ntheorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv := by\n  rw [\u2190 eq_comp_inv, id_comp]\n\ntheorem inv_comp_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : \u03b1.inv \u226b f = \ud835\udfd9 Y \u2194 f = \u03b1.hom :=\n  hom_comp_eq_id \u03b1.symm\n\ntheorem comp_inv_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : f \u226b \u03b1.inv = \ud835\udfd9 X \u2194 f = \u03b1.hom :=\n  comp_hom_eq_id \u03b1.symm\n\ntheorem hom_eq_inv (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 X) : \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv := by\n  rw [\u2190 symm_inv, inv_eq_inv \u03b1.symm \u03b2, eq_comm]\n  rfl\n\nattribute [local grind] Function.LeftInverse Function.RightInverse\n\n/-- The bijection `(Z \u27f6 X) \u2243 (Z \u27f6 Y)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homToEquiv (\u03b1 : X \u2245 Y) {Z : C} : (Z \u27f6 X) \u2243 (Z \u27f6 Y) where\n  toFun f := f \u226b \u03b1.hom\n  invFun g := g \u226b \u03b1.inv\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\n/-- The bijection `(X \u27f6 Z) \u2243 (Y \u27f6 Z)` induced by `\u03b1 : X \u2245 Y`. -/\n@[simps]\ndef homFromEquiv (\u03b1 : X \u2245 Y) {Z : C} : (X \u27f6 Z) \u2243 (Y \u27f6 Z) where\n  toFun f := \u03b1.inv \u226b f\n  invFun g := \u03b1.hom \u226b g\n  left_inv := by cat_disch\n  right_inv := by cat_disch\n\nend Iso\n\n/-- The `IsIso` t",
      "suggestion": "\r\n@[to_dual (reorder := X Y) isIso_of_comp_hom_eq_id]\r\n",
      "body": "```suggestion\r\n@[to_dual (reorder := X Y) isIso_of_comp_hom_eq_id]\r\n```",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "aesop",
          "refine",
          "ext",
          "exact",
          "grind",
          "have",
          "rw",
          "simp"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "symm_inv",
          "inferInstance",
          "IsIso",
          "loop",
          "note",
          "lean",
          "Type",
          "make",
          "typeclass",
          "easier",
          "open",
          "epi_of_iso",
          "eq_comm",
          "been",
          "trans_assoc",
          "have",
          "inv_hom_id",
          "Prop",
          "failing",
          "priority",
          "reason",
          "Epi",
          "Iso",
          "cannot",
          "inv_comp_eq_id",
          "Mono",
          "inverse",
          "of_isIso_fac_left",
          "out",
          "arguments",
          "of_isIso_comp_right",
          "def",
          "Here",
          "comp_inv_eq",
          "right_inv",
          "simps",
          "that",
          "had",
          "right_cancellation",
          "simp",
          "choose",
          "rfl",
          "theorem",
          "Without",
          "Category",
          "left",
          "Reinterpret",
          "reassoc",
          "left_inv",
          "isomorphisms"
        ]
      }
    },
    {
      "id": 3930,
      "before_code": "theorem mapIso_refl (F : C \u2964 D) (X : C) : F.mapIso (Iso.refl X) = Iso.refl (F.obj X) :=\n  Iso.ext <| F.map_id X\n\ninstance map_isIso (F : C \u2964 D) (f : X \u27f6 Y) [IsIso f] : IsIso (F.map f) :=\n  (F.mapIso (asIso f)).isIso_hom\n\n@[simp, push \u2190]\ntheorem map_inv (F : C \u2964 D) {X Y : C} (f : X \u27f6 Y) [IsIso f] : F.map (inv f) = inv (F.map f) := by\n  apply eq_inv_of_hom_inv_id\n  simp [\u2190 F.map_comp]\n\n@[reassoc]",
      "suggestion": "\r\n@[to_dual (attr := reassoc) (reorder := X Y) map_inv_hom]\r\n",
      "body": "```suggestion\r\n@[to_dual (attr := reassoc) (reorder := X Y) map_inv_hom]\r\n```",
      "path": "Mathlib/CategoryTheory/Iso.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "push",
          "IsIso",
          "inv",
          "refl",
          "asIso",
          "apply",
          "eq_inv_of_hom_inv_id",
          "ext",
          "mapIso",
          "map_comp",
          "map",
          "isIso_hom",
          "Iso",
          "simp",
          "obj",
          "map_id",
          "map_isIso",
          "theorem",
          "map_inv",
          "reassoc",
          "mapIso_refl",
          "instance"
        ]
      }
    },
    {
      "id": 3931,
      "before_code": "lemma emod_two_eq_zero_or_one (n : \u2124) : n % 2 = 0 \u2228 n % 2 = 1 :=\n  emod_two_eq n",
      "suggestion": "  (mul_ediv_add_emod a n).symm.trans (H0 \u25b8 H1 \u25b8 mul_ediv_add_emod b n)\n",
      "body": "```suggestion\n  (mul_ediv_add_emod a n).symm.trans (H0 \u25b8 H1 \u25b8 mul_ediv_add_emod b n)\n```",
      "path": "Mathlib/Data/Int/Init.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "emod_two_eq",
          "lemma",
          "emod_two_eq_zero_or_one"
        ]
      }
    },
    {
      "id": 3932,
      "before_code": "lemma mod_eq_of_modEq {a b n} (h : a \u2261 b [MOD n]) (hb : b < n) : a % n = b :=\n  Eq.trans h (mod_eq_of_lt hb)",
      "suggestion": "theorem ext_div_modEq {n a b : \u2115} (h0 : a / n = b / n) (h1 : a \u2261 b [MOD n]) : a = b := ext_div_mod\n",
      "body": "```suggestion\ntheorem ext_div_modEq {n a b : \u2115} (h0 : a / n = b / n) (h1 : a \u2261 b [MOD n]) : a = b := ext_div_mod\n```",
      "path": "Mathlib/Data/Nat/ModEq.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "mod_eq_of_lt",
          "MOD",
          "lemma",
          "trans",
          "mod_eq_of_modEq"
        ]
      }
    },
    {
      "id": 3933,
      "before_code": "obtain \u27e8y, rfl, hcodisjoint\u27e9 := exists_inf_eq_and_codisjoint hx\n    exact \u27e8\u27e8y, inf_le_right\u27e9, rfl, hcodisjoint\u27e9",
      "suggestion": "\r\n  rw [\u2190 disjoint_toDual_iff] at hab\r\n",
      "body": "```suggestion\r\n  rw [\u2190 disjoint_toDual_iff] at hab\r\n```",
      "path": "Mathlib/Order/ModularLattice.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hcodisjoint",
          "exact",
          "inf_le_right",
          "exists_inf_eq_and_codisjoint",
          "obtain",
          "rfl"
        ]
      }
    },
    {
      "id": 3934,
      "before_code": "simp_rw [changeLevel_toUnitHom, toUnitHom_eq, ofUnitHom_eq, Equiv.apply_symm_apply, hE,\n      toUnitHom_eq]",
      "suggestion": "theorem factorsThrough_gcd {m : \u2115} [NeZero n] (\u03c8 : DirichletCharacter R m)\n",
      "body": "```suggestion\ntheorem factorsThrough_gcd {m : \u2115} [NeZero n] (\u03c8 : DirichletCharacter R m)\n```",
      "path": "Mathlib/NumberTheory/DirichletCharacter/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "apply_symm_apply",
          "toUnitHom_eq",
          "Equiv",
          "ofUnitHom_eq",
          "simp_rw",
          "changeLevel_toUnitHom"
        ]
      }
    },
    {
      "id": 3939,
      "before_code": "rw [\u2190 h]\n  exact IsIso.hom_inv_id_assoc f k",
      "suggestion": "\r\ncomposable morphisms `f : x \u27f6 y` and `g : y \u27f6 z` in a category `C`,\r\n",
      "body": "```suggestion\r\ncomposable morphisms `f : x \u27f6 y` and `g : y \u27f6 z` in a category `C`,\r\n```\r\nright?",
      "path": "Mathlib/Tactic/CategoryTheory/CancelIso.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "hom_inv_id_assoc",
          "IsIso"
        ]
      }
    },
    {
      "id": 3940,
      "before_code": "rw [\u2190 h]\n  exact IsIso.hom_inv_id_assoc f k",
      "suggestion": "\r\nIf they are inverse, return a proof of `inv f = g`. If any of\r\n",
      "body": "```suggestion\r\nIf they are inverse, return a proof of `inv f = g`. If any of\r\n```",
      "path": "Mathlib/Tactic/CategoryTheory/CancelIso.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "hom_inv_id_assoc",
          "IsIso"
        ]
      }
    },
    {
      "id": 3941,
      "before_code": "rw [\u2190 h]\n  exact IsIso.hom_inv_id_assoc f k",
      "suggestion": "\r\n  let pushed_inv \u2190 Push.pushCore (.const ``CategoryTheory.inv) {} none inv_f\r\n",
      "body": "```suggestion\r\n  let pushed_inv \u2190 Push.pushCore (.const ``CategoryTheory.inv) {} none inv_f\r\n```",
      "path": "Mathlib/Tactic/CategoryTheory/CancelIso.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "hom_inv_id_assoc",
          "IsIso"
        ]
      }
    },
    {
      "id": 3942,
      "before_code": "rw [\u2190 h]\n  exact IsIso.hom_inv_id_assoc f k",
      "suggestion": "\r\n  let pushed_g \u2190 Push.pushCore (.const ``CategoryTheory.inv) {} none g\r\n",
      "body": "```suggestion\r\n  let pushed_g \u2190 Push.pushCore (.const ``CategoryTheory.inv) {} none g\r\n```",
      "path": "Mathlib/Tactic/CategoryTheory/CancelIso.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "hom_inv_id_assoc",
          "IsIso"
        ]
      }
    },
    {
      "id": 3943,
      "before_code": "universe uK uV\nvariable {K : Type uK} {V : Type uV}",
      "suggestion": "\r\n\r\n",
      "body": "```suggestion\r\n\r\n```",
      "path": "Mathlib/LinearAlgebra/Dual/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "universe",
          "Type",
          "variable"
        ]
      }
    },
    {
      "id": 3944,
      "before_code": "{ NonUnitalSubsemiring.center R with\n    one_mem' := Set.one_mem_center }",
      "suggestion": "\r\n    SMulCommClass R \u21a5(Submonoid.center R) M where\r\n",
      "body": "Can you also add the\r\n```suggestion\r\n    SMulCommClass R \u21a5(Submonoid.center R) M where\r\n```\r\nvariant, proved with `SMulCommClass.symm`?",
      "path": "Mathlib/Algebra/Ring/Subsemiring/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "one_mem_center",
          "NonUnitalSubsemiring",
          "Set",
          "one_mem",
          "center"
        ]
      }
    },
    {
      "id": 3945,
      "before_code": "theorem center_toSubsemigroup : (center M).toSubsemigroup = Subsemigroup.center M :=\n  rfl",
      "suggestion": "    SMulCommClass (Submonoid.center M) M \u03b1 where\n",
      "body": "```suggestion\n    SMulCommClass (Submonoid.center M) M \u03b1 where\n```",
      "path": "Mathlib/GroupTheory/Submonoid/Center.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "toSubsemigroup",
          "Subsemigroup",
          "rfl",
          "center_toSubsemigroup",
          "center"
        ]
      }
    },
    {
      "id": 3946,
      "before_code": "theorem center_toSubsemigroup : (center M).toSubsemigroup = Subsemigroup.center M :=\n  rfl",
      "suggestion": "    SMulCommClass M (Submonoid.center M) \u03b1 :=\n",
      "body": "```suggestion\n    SMulCommClass M (Submonoid.center M) \u03b1 :=\n```",
      "path": "Mathlib/GroupTheory/Submonoid/Center.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "toSubsemigroup",
          "Subsemigroup",
          "rfl",
          "center_toSubsemigroup",
          "center"
        ]
      }
    },
    {
      "id": 3949,
      "before_code": "#check Y -- Y : MvPolynomial (Fin 3) R\n```\n-/\nsyntax (name := namePolyVarsOver) \"name_poly_vars \" ident,+ \" over \" term : command",
      "suggestion": "syntax (name := namePolyVarsOver) \"name_poly_vars\" (ppSpace ident),+ \" over \" term : command\n",
      "body": "Let's try this version:\n```suggestion\nsyntax (name := namePolyVarsOver) \"name_poly_vars\" (ppSpace ident),+ \" over \" term : command\n```",
      "path": "Mathlib/Tactic/Ring/NamePolyVars.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "term",
          "MvPolynomial",
          "syntax",
          "over",
          "name",
          "ident",
          "Fin",
          "name_poly_vars",
          "namePolyVarsOver",
          "check",
          "command"
        ]
      }
    },
    {
      "id": 3950,
      "before_code": "DecidablePred (\u00b7 \u2208 C.colorClass c) :=\n  inferInstanceAs <| DecidablePred (\u00b7 \u2208 { v | C v = c })\n\nvariable (G)\n\n/-- Whether a graph can be colored by at most `n` colors. -/\ndef Colorable (n : \u2115) : Prop := Nonempty (G.Coloring (Fin n))",
      "suggestion": "\r\nvariable (G \u03b1) in\r\n",
      "body": "```suggestion\r\nvariable (G \u03b1) in\r\n```\r\nand `variable (G) in` for `colorable_of_isEmpty` below this",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "most",
          "colored",
          "can",
          "graph",
          "Nonempty",
          "variable",
          "def",
          "Coloring",
          "DecidablePred",
          "inferInstanceAs",
          "Prop",
          "Whether",
          "Fin",
          "colors",
          "Colorable",
          "colorClass"
        ]
      }
    },
    {
      "id": 3951,
      "before_code": "/-- If `G` is `n`-colorable, then mapping the vertices of `G` produces an `n`-colorable simple\ngraph. -/\ntheorem Colorable.map {\u03b2 : Type*} (f : V \u21aa \u03b2) [NeZero n] {G : SimpleGraph V} (hc : G.Colorable n) :",
      "suggestion": "\r\ntheorem Colorable.map (f : V \u21aa \u03b2) [NeZero n] (hc : G.Colorable n) :\r\n",
      "body": "```suggestion\r\ntheorem Colorable.map (f : V \u21aa \u03b2) [NeZero n] (hc : G.Colorable n) :\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "graph",
          "simple",
          "then",
          "theorem",
          "Type",
          "NeZero",
          "produces",
          "map",
          "mapping",
          "vertices",
          "colorable",
          "Colorable",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 3952,
      "before_code": "end Semiring",
      "suggestion": "\r\n    (f.restrictScalars R).ker = f.ker.restrictScalars R :=\r\n",
      "body": "```suggestion\r\n    (f.restrictScalars R).ker = f.ker.restrictScalars R :=\r\n```\r\nDoesn't dot notation now work for `LinearMap.ker`?",
      "path": "Mathlib/Algebra/Module/Submodule/Ker.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Semiring"
        ]
      }
    },
    {
      "id": 3953,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=\n  have := f.isEmpty\n  \u27e8injective_of_subsingleton _, IsEmpty.elim \u2039_\u203a\u27e9",
      "suggestion": "\r\ntheorem Function.not_Surjective_of_isEmpty_of_nonempty [IsEmpty \u03b1] [Nonempty \u03b2] (f : \u03b1 \u2192 \u03b2) :\r\n",
      "body": "```suggestion\r\ntheorem Function.not_Surjective_of_isEmpty_of_nonempty [IsEmpty \u03b1] [Nonempty \u03b2] (f : \u03b1 \u2192 \u03b2) :\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "have"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "elim",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "injective_of_subsingleton",
          "theorem",
          "and_true",
          "IsEmpty",
          "have",
          "leftTotal_iff_isEmpty_left",
          "isEmpty",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 3954,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=",
      "suggestion": "\r\ntheorem Function.Surjective.of_isEmpty [IsEmpty \u03b2] (f : \u03b1 \u2192 \u03b2) : f.Surjective :=\r\n  IsEmpty.elim \u2039_\u203a\r\n",
      "body": "```suggestion\r\ntheorem Function.Surjective.of_isEmpty [IsEmpty \u03b2] (f : \u03b1 \u2192 \u03b2) : f.Surjective :=\r\n  IsEmpty.elim \u2039_\u203a\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "theorem",
          "and_true",
          "IsEmpty",
          "leftTotal_iff_isEmpty_left",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 3955,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=\n  have := f.isEmpty\n  \u27e8injective_of_subsingleton _, IsEmpty.elim \u2039_\u203a\u27e9",
      "suggestion": "\r\n  \u27e8injective_of_subsingleton f, .of_isEmpty f\u27e9\r\n",
      "body": "```suggestion\r\n  \u27e8injective_of_subsingleton f, .of_isEmpty f\u27e9\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "have"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "elim",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "injective_of_subsingleton",
          "theorem",
          "and_true",
          "IsEmpty",
          "have",
          "leftTotal_iff_isEmpty_left",
          "isEmpty",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 3956,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=",
      "suggestion": "\r\ntheorem Function.surjective_iff_isEmpty [IsEmpty \u03b1] (f : \u03b1 \u2192 \u03b2) : f.Surjective \u2194 IsEmpty \u03b2 :=\r\n",
      "body": "```suggestion\r\ntheorem Function.surjective_iff_isEmpty [IsEmpty \u03b1] (f : \u03b1 \u2192 \u03b2) : f.Surjective \u2194 IsEmpty \u03b2 :=\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "theorem",
          "and_true",
          "IsEmpty",
          "leftTotal_iff_isEmpty_left",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 3957,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=\n  have := f.isEmpty\n  \u27e8injective_of_subsingleton _, IsEmpty.elim \u2039_\u203a\u27e9",
      "suggestion": "\r\n    \u00acf.Surjective :=\r\n  (not_isEmpty_of_nonempty \u03b2 \u00b7.isEmpty)\r\n",
      "body": "```suggestion\r\n    \u00acf.Surjective :=\r\n  (not_isEmpty_of_nonempty \u03b2 \u00b7.isEmpty)\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "have"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "elim",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "injective_of_subsingleton",
          "theorem",
          "and_true",
          "IsEmpty",
          "have",
          "leftTotal_iff_isEmpty_left",
          "isEmpty",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 3958,
      "before_code": "theorem biTotal_iff_isEmpty_left [IsEmpty \u03b2] : BiTotal R \u2194 IsEmpty \u03b1 := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n\nlemma Function.Bijective.of_isEmpty (f : \u03b1 \u2192 \u03b2) [IsEmpty \u03b2] : f.Bijective :=\n  have := f.isEmpty\n  \u27e8injective_of_subsingleton _, IsEmpty.elim \u2039_\u203a\u27e9",
      "suggestion": "\r\ntheorem Function.not_surjective_of_isEmpty_of_nonempty [IsEmpty \u03b1] [Nonempty \u03b2] (f : \u03b1 \u2192 \u03b2) :\r\n",
      "body": "https://github.com/[user]y/mathlib4/pull/33475#discussion_r2658298523\r\n```suggestion\r\ntheorem Function.not_surjective_of_isEmpty_of_nonempty [IsEmpty \u03b1] [Nonempty \u03b2] (f : \u03b1 \u2192 \u03b2) :\r\n```",
      "path": "Mathlib/Logic/IsEmpty.lean",
      "tags": {
        "before_tactics": [
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "have"
        ],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "biTotal_iff_isEmpty_left",
          "elim",
          "of_isEmpty",
          "lemma",
          "rightTotal_empty",
          "injective_of_subsingleton",
          "theorem",
          "and_true",
          "IsEmpty",
          "have",
          "leftTotal_iff_isEmpty_left",
          "isEmpty",
          "simp",
          "Function",
          "BiTotal",
          "only",
          "Bijective"
        ]
      }
    },
    {
      "id": 3959,
      "before_code": "simp [\u2190 Icc_union_Ioo_eq_Ico le_rfl hab, -singleton_union, f.mono.leftLim_le,\n      measure_union A measurableSet_Ioo, f.mono.le_leftLim hab, \u2190 ENNReal.ofReal_add]\n\ntheorem measure_Iic [NoMinOrder R] {l : \u211d} (hf : Tendsto f atBot (\ud835\udcdd l)) (x : R) :",
      "suggestion": "\r\n  by_cases! hx : \u2203 x : R, IsBot x\r\n",
      "body": "```suggestion\r\n  by_cases! hx : \u2203 x : R, IsBot x\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Stieltjes.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "measurability",
          "order",
          "real"
        ],
        "transforms": [],
        "keywords": [
          "Icc_union_Ioo_eq_Ico",
          "ofReal_add",
          "ENNReal",
          "le_rfl",
          "mono",
          "theorem",
          "atBot",
          "Tendsto",
          "hab",
          "singleton_union",
          "NoMinOrder",
          "simp",
          "measure_Iic",
          "le_leftLim",
          "measure_union",
          "measurableSet_Ioo",
          "leftLim_le"
        ]
      }
    },
    {
      "id": 3960,
      "before_code": "/-- A weakly lower modular lattice is a lattice where `a` and `b` cover `a \u2293 b` if `a \u2294 b` covers\nboth `a` and `b`. -/",
      "suggestion": "\r\n@[to_dual existing]\r\n",
      "body": "Presumably this should be\r\n```suggestion\r\n@[to_dual existing]\r\n```",
      "path": "Mathlib/Order/ModularLattice.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "weakly",
          "cover",
          "modular",
          "both",
          "covers",
          "lower",
          "lattice"
        ]
      }
    },
    {
      "id": 3961,
      "before_code": "/-- A lower modular lattice is a lattice where `a` and `b` both cover `a \u2293 b` if `a \u2294 b` covers\neither `a` or `b`. -/",
      "suggestion": "\r\n@[to_dual existing]\r\n",
      "body": "```suggestion\r\n@[to_dual existing]\r\n```",
      "path": "Mathlib/Order/ModularLattice.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "cover",
          "modular",
          "both",
          "covers",
          "lower",
          "either",
          "lattice"
        ]
      }
    },
    {
      "id": 3962,
      "before_code": "(eq_of_le_of_forall_lt_imp_le_of_dense (abs_nonneg _)) fun _\u03b5 \u03b50 =>\n          mk_near_of_forall_near <| (h _ \u03b50).imp fun _i h j ij => le_of_lt (h j ij)\u27e9",
      "suggestion": "\r\n@[deprecated \"use `\u230ax\u230b`, `Int.floor_le` and `Int.le_floor` directly\" (since := \"2026-01-29\")]\r\n",
      "body": "Let's also point to the replacement proofs.\r\n```suggestion\r\n@[deprecated \"use `\u230ax\u230b`, `Int.floor_le` and `Int.le_floor` directly\" (since := \"2026-01-29\")]\r\n```",
      "path": "Mathlib/Data/Real/Archimedean.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "le_of_lt",
          "imp",
          "abs_nonneg",
          "eq_of_le_of_forall_lt_imp_le_of_dense",
          "mk_near_of_forall_near"
        ]
      }
    },
    {
      "id": 3968,
      "before_code": "if let some m \u2190 tryStrategy m!\"Sphere\"              fromSphere         then return m\n  if let some m \u2190 tryStrategy m!\"NormedField\"         fromNormedField    then return m\n  if let some m \u2190 tryStrategy m!\"InnerProductSpace\"   fromInnerProductSpace then return m\n  throwError \"Could not find a model with corners for `{e}`.",
      "suggestion": "\r\n    throwError m!\"Could not find a model with corners for `{e}`.\r\n",
      "body": "Since this is underneath an `else`:\r\n```suggestion\r\n    throwError m!\"Could not find a model with corners for `{e}`.\r\n```",
      "path": "Mathlib/Geometry/Manifold/Notation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "NormedField",
          "Sphere",
          "then",
          "model",
          "fromInnerProductSpace",
          "throwError",
          "Could",
          "tryStrategy",
          "return",
          "fromNormedField",
          "corners",
          "find",
          "InnerProductSpace",
          "fromSphere",
          "for",
          "some"
        ]
      }
    },
    {
      "id": 3975,
      "before_code": "Indep m\u2081 m\u2083 \u03bc :=\n  Kernel.indep_of_indep_of_le_right h_indep h32",
      "suggestion": "theorem iIndep_of_iIndep_of_le {m\u2081 m\u2082 : \u03b9 \u2192 MeasurableSpace \u03a9} (h_indep : iIndep m\u2082 \u03bc)\n    (h_le : \u2200 i, m\u2081 i \u2264 m\u2082 i) : iIndep m\u2081 \u03bc :=\n",
      "body": "Same remark as previously:\n```suggestion\ntheorem iIndep_of_iIndep_of_le {m\u2081 m\u2082 : \u03b9 \u2192 MeasurableSpace \u03a9} (h_indep : iIndep m\u2082 \u03bc)\n    (h_le : \u2200 i, m\u2081 i \u2264 m\u2082 i) : iIndep m\u2081 \u03bc :=\n```",
      "path": "Mathlib/Probability/Independence/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "indep_of_indep_of_le_right",
          "Kernel",
          "h_indep",
          "h32",
          "Indep"
        ]
      }
    },
    {
      "id": 3976,
      "before_code": "Q574902:\n  title: Tarski's indefinability theorem",
      "suggestion": "\r\n  url: https://github.com/FormalizedFormalLogic/Foundation/blob/7c74089c2442ee211abfa1e2dd5a75091800f57b/Foundation/FirstOrder/Incompleteness/Tarski.lean#L18\r\n",
      "body": "```suggestion\r\n  url: https://github.com/[user]c/Foundation/blob/7c74089c2442ee211abfa1e2dd5a75091800f57b/Foundation/FirstOrder/Incompleteness/Tarski.lean#L18\r\n```\r\nI found it pretty difficult to get to the actual Lean code from the current link",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "Q574902",
          "title",
          "indefinability",
          "Tarski"
        ]
      }
    },
    {
      "id": 3977,
      "before_code": "Q574902:\n  title: Tarski's indefinability theorem",
      "suggestion": "  title: Tarski's undefinability theorem\n",
      "body": "I guess this is the more standard spelling? We may as well fix this here.\n```suggestion\n  title: Tarski's undefinability theorem\n```\n\nThanks!\nbors d+",
      "path": "docs/1000.yaml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "Q574902",
          "title",
          "indefinability",
          "Tarski"
        ]
      }
    },
    {
      "id": 3978,
      "before_code": "def Weird (n : \u2115) : Prop := Abundant n \u2227 \u00ac Pseudoperfect n\n\ntheorem not_pseudoperfect_iff_forall :\n    \u00ac Pseudoperfect n \u2194 n = 0 \u2228 \u2200 s \u2286 properDivisors n, \u2211 i \u2208 s, i \u2260 n := by\n  rw [Pseudoperfect, not_and_or]\n  simp only [not_lt, nonpos_iff_eq_zero, not_exists, not_and, ne_eq]",
      "suggestion": "\r\n    \u00ac Pseudoperfect n \u2194 n = 0 \u2228 \u2200 s \u2286 properDivisors n, \u2211 i \u2208 s, i \u2260 n := by\r\n  grind [Pseudoperfect]\r\n",
      "body": "```suggestion\r\n    \u00ac Pseudoperfect n \u2194 n = 0 \u2228 \u2200 s \u2286 properDivisors n, \u2211 i \u2208 s, i \u2260 n := by\r\n  grind [Pseudoperfect]\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "nat"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "not_lt",
          "not_pseudoperfect_iff_forall",
          "nonpos_iff_eq_zero",
          "Pseudoperfect",
          "not_and_or",
          "def",
          "theorem",
          "properDivisors",
          "Abundant",
          "Prop",
          "Weird",
          "not_exists",
          "ne_eq",
          "simp",
          "not_and",
          "only"
        ]
      }
    },
    {
      "id": 3979,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\ntheorem Abundant.mul (h : Abundant n) (hm : m \u2260 0) : Abundant (m * n) := by\r\n",
      "body": "```suggestion\r\ntheorem Abundant.mul (h : Abundant n) (hm : m \u2260 0) : Abundant (m * n) := by\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain",
          "rw",
          "intro",
          "exact",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3980,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\ntheorem abundancyIndex_le_ofDvd (hn : n \u2260 0) (hd : m \u2223 n) :\r\n",
      "body": "```suggestion\r\ntheorem abundancyIndex_le_ofDvd (hn : n \u2260 0) (hd : m \u2223 n) :\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain",
          "rw",
          "intro",
          "exact",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3981,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\ntheorem Abundant.mul_left (h : Abundant n) (hm : m \u2260 0) : Abundant (m * n) := by\r\n",
      "body": "```suggestion\r\ntheorem Abundant.mul_left (h : Abundant n) (hm : m \u2260 0) : Abundant (m * n) := by\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain",
          "rw",
          "intro",
          "exact",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3982,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\ntheorem Abundant.of_dvd (h : Abundant m) (hd : m \u2223 n) (hn : n \u2260 0) : Abundant n := by\r\n",
      "body": "```suggestion\r\ntheorem Abundant.of_dvd (h : Abundant m) (hd : m \u2223 n) (hn : n \u2260 0) : Abundant n := by\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain",
          "rw",
          "intro",
          "exact",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3983,
      "before_code": "rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain \u27e8p, \u27e8_, h2\u27e9\u27e9 := exists_infinite_primes (max (n + 1) 3)\n  exact \u27e8p, Set.mem_setOf.mpr \u27e8Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2\u27e9, by omega\u27e9",
      "suggestion": "\r\ntheorem abundancyIndex_le_of_dvd (hn : n \u2260 0) (hd : m \u2223 n) :\r\n",
      "body": "```suggestion\r\ntheorem abundancyIndex_le_of_dvd (hn : n \u2260 0) (hd : m \u2223 n) :\r\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "intro",
          "omega"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "obtain",
          "rw",
          "intro",
          "exact",
          "omega"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "symm",
          "exact",
          "Set",
          "infinite_iff_exists_gt",
          "obtain",
          "mem_setOf",
          "exists_infinite_primes",
          "intro",
          "max",
          "odd_of_ne_two",
          "ne_of_lt",
          "Prime",
          "omega",
          "deficient"
        ]
      }
    },
    {
      "id": 3984,
      "before_code": "variable {n m p : \u2115}\n\n/-- `n : \u2115` is _abundant_ if the sum of the proper divisors of `n` is greater than `n`. -/\ndef Abundant (n : \u2115) : Prop := n < \u2211 i \u2208 properDivisors n, i",
      "suggestion": "def Abundant (n : \u2115) : Prop := n < \u2211 i \u2208 properDivisors n, i\nderiving Decidable\n",
      "body": "```suggestion\ndef Abundant (n : \u2115) : Prop := n < \u2211 i \u2208 properDivisors n, i\nderiving Decidable\n```",
      "path": "Mathlib/NumberTheory/FactorisationProperties.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "greater",
          "def",
          "variable",
          "properDivisors",
          "divisors",
          "Abundant",
          "Prop",
          "_abundant_",
          "than",
          "sum",
          "proper"
        ]
      }
    },
    {
      "id": 3985,
      "before_code": "f \u2218L toSpanSingleton R\u2081 x = toSpanSingleton R\u2081 (f x) :=\n  coe_inj.mp <| LinearMap.comp_toSpanSingleton _ _",
      "suggestion": "\r\ntheorem toSpanSingleton_comp_eq_smulRight (f : M\u2081 \u2192L[R\u2081] R\u2081) (g : M\u2082) :\r\n",
      "body": "or\r\n```suggestion\r\ntheorem toSpanSingleton_comp_eq_smulRight (f : M\u2081 \u2192L[R\u2081] R\u2081) (g : M\u2082) :\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/LinearMap.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "comp_toSpanSingleton",
          "toSpanSingleton",
          "LinearMap",
          "coe_inj"
        ]
      }
    },
    {
      "id": 3986,
      "before_code": "-- Note that (continuous) linear equivalences are not an abelian group, so are not a model with\n  -- corners as a normed space. Merely linear maps are not a normed space either.\n  fromCLM : TermElabM Expr := do\n    match_expr e with\n    | ContinuousLinearMap k S _ _ _\u03c3 _E _ _ _F _ _ _ _ =>\n      trace[Elab.DiffGeo.MDiff] \"`{e}` is a space of continuous linear maps\"\n      -- If `S` were a copy of `k` with a non-standard topology or smooth structure\n      -- (such as, imposed deliberately through a type synonym), we do not want to infer\n      -- the standard model with corners.\n      -- Therefore, we only check definitional equality at reducible transparency.\n      if \u2190 withReducible <| isDefEq k S then\n        -- TODO: check if \u03c3 is actually the identity!\n        let eK : Term \u2190 Term.exprToSyntax k\n        let eT : Term \u2190 Term.exprToSyntax e\n        let iTerm : Term \u2190 ``(\ud835\udcd8($eK, $eT))\n        Term.elabTerm iTerm none\n      else\n        throwError \"Coefficients `{k}` and `{S}` of `{e}` are not reducibly definitionally equal\"\n    | _ => throwError \"`{e}` is not a space of continuous linear maps\"\n  /-- Attempt to find a model with corners on a closed interval of real numbers -/",
      "suggestion": "    let some (k, _E, _F) \u2190 isCLMReduciblyDefeqCoefficients e\n",
      "body": "Nit:\n```suggestion\n    let some (k, _E, _F) \u2190 isCLMReduciblyDefeqCoefficients e\n```",
      "path": "Mathlib/Geometry/Manifold/Notation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra",
          "continuity",
          "equiv",
          "norm",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "fromCLM",
          "trace",
          "reducible",
          "Expr",
          "elabTerm",
          "TermElabM",
          "Attempt",
          "real",
          "actually",
          "transparency",
          "find",
          "infer",
          "type",
          "either",
          "TODO",
          "equal",
          "MDiff",
          "else",
          "match_expr",
          "structure",
          "Therefore",
          "Note",
          "standard",
          "topology",
          "synonym",
          "equivalences",
          "equality",
          "closed",
          "withReducible",
          "are",
          "Coefficients",
          "smooth",
          "such",
          "identity",
          "linear",
          "reducibly",
          "normed",
          "Elab",
          "then",
          "ContinuousLinearMap",
          "throwError",
          "Term",
          "none",
          "abelian",
          "deliberately",
          "that",
          "corners",
          "non",
          "DiffGeo",
          "group"
        ]
      }
    },
    {
      "id": 3987,
      "before_code": "let c \u2190 Term.exprToSyntax (mkConst `Complex)\n      Term.elabTerm (\u2190 `(\ud835\udcd8($c))) none\n    else throwError \"`{e}` is not the complex upper half plane\"",
      "suggestion": "      if let some E \u2190 searchIPSpace then\n",
      "body": "Nit:\n```suggestion\n      if let some E \u2190 searchIPSpace then\n```",
      "path": "Mathlib/Geometry/Manifold/Notation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "half",
          "else",
          "Complex",
          "elabTerm",
          "mkConst",
          "none",
          "Term",
          "exprToSyntax",
          "throwError",
          "complex",
          "plane",
          "upper"
        ]
      }
    },
    {
      "id": 3988,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n      (\u27e8-N / z, im_pnat_div_pos N z\u27e9))\r\n",
      "body": "```suggestion\r\n      (\u27e8-N / z, im_pnat_div_pos N z\u27e9))\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3989,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    rwa [\u2190 tendsto_comp_val_Ioi_atTop]\r\n",
      "body": "```suggestion\r\n    rwa [\u2190 tendsto_comp_val_Ioi_atTop]\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3990,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n  refine aux_tendsto_tsum_cexp_pnat z |>.const_mul _ |>.const_sub _ |>.add (.const_mul _ ?_)\r\n",
      "body": "```suggestion\r\n  refine aux_tendsto_tsum_cexp_pnat z |>.const_mul _ |>.const_sub _ |>.add (.const_mul _ ?_)\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "refine"
        ],
        "body_tactics": [
          "refine"
        ],
        "new_tactics": [
          "refine"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3991,
      "before_code": "rw [G2, tsum_symmetricIcc_eq_tsum_symmetricIco (summable_e2Summand_symmetricIcc z)]\n  simpa using (tendsto_e2Summand_atTop_nhds_zero z).neg.comp tendsto_natCast_atTop_atTop",
      "suggestion": "\r\n    grind\r\n",
      "body": "```suggestion\r\n    grind\r\n```\r\n(could inline into prev line)",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/E2/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "neg",
          "summable_e2Summand_symmetricIcc",
          "tsum_symmetricIcc_eq_tsum_symmetricIco",
          "simpa",
          "comp",
          "tendsto_e2Summand_atTop_nhds_zero",
          "tendsto_natCast_atTop_atTop",
          "using"
        ]
      }
    },
    {
      "id": 3994,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n  \u00b7 rw [Subgroup.closure_le]\r\n",
      "body": "```suggestion\r\n  \u00b7 rw [Subgroup.closure_le]\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 3995,
      "before_code": "(hl b (List.mem_cons_of_mem a List.mem_cons_self)))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)",
      "suggestion": "\r\n  \u00b7 rw [\u2190 Equiv.Perm.closure_three_cycles_eq_alternating, Subgroup.closure_le]\r\n",
      "body": "```suggestion\r\n  \u00b7 rw [\u2190 Equiv.Perm.closure_three_cycles_eq_alternating, Subgroup.closure_le]\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "list",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mem_cons_self",
          "mem_cons_of_mem",
          "List"
        ]
      }
    },
    {
      "id": 3996,
      "before_code": "theorem mapRange_zero {f : M \u2192 N} {hf : f 0 = 0} : mapRange f hf (0 : \u03b1 \u2192\u2080 M) = 0 :=\n  ext fun _ => by simp only [hf, zero_apply, mapRange_apply]",
      "suggestion": "\r\ntheorem mapRange_eq_zero {a : \u03b1 \u2192\u2080 M} {f : M \u2192 N} (hf : f.Injective) (h) :\r\n    mapRange f h a = 0 \u2194 a = 0 := by\r\n",
      "body": "```suggestion\r\ntheorem mapRange_eq_zero {a : \u03b1 \u2192\u2080 M} {f : M \u2192 N} (hf : f.Injective) (h) :\r\n    mapRange f h a = 0 \u2194 a = 0 := by\r\n```",
      "path": "Mathlib/Data/Finsupp/Defs.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "mapRange_apply",
          "ext",
          "theorem",
          "zero_apply",
          "mapRange_zero",
          "simp",
          "mapRange",
          "only"
        ]
      }
    },
    {
      "id": 3997,
      "before_code": "M\u1d34.PosSemidef \u2194 M.PosSemidef :=\n  \u27e8(by simpa using \u00b7.conjTranspose), .conjTranspose\u27e9\n\nprotected lemma zero : PosSemidef (0 : Matrix n n R) :=\n  \u27e8isHermitian_zero, by simp\u27e9\n\nprotected lemma one [StarOrderedRing R] [DecidableEq n] : PosSemidef (1 : Matrix n n R) :=\n  \u27e8isHermitian_one, fun x => by\n    rw [one_mulVec]; exact Fintype.sum_nonneg fun i => star_mul_self_nonneg _\u27e9\n\nprotected theorem natCast [StarOrderedRing R] [DecidableEq n] (d : \u2115) :\n    PosSemidef (d : Matrix n n R) :=\n  \u27e8isHermitian_natCast _, fun x => by\n    rw [natCast_mulVec, Nat.cast_smul_eq_nsmul, dotProduct_smul]\n    exact nsmul_nonneg (dotProduct_star_self_nonneg _) _\u27e9\n\nprotected theorem ofNat [StarOrderedRing R] [DecidableEq n] (d : \u2115) [d.AtLeastTwo] :\n    PosSemidef (ofNat(d) : Matrix n n R) :=\n  .natCast d\n\nprotected theorem intCast [StarOrderedRing R] [DecidableEq n] (d : \u2124) (hd : 0 \u2264 d) :\n    PosSemidef (d : Matrix n n R) :=\n  \u27e8isHermitian_intCast _, fun x => by\n    rw [intCast_mulVec, Int.cast_smul_eq_zsmul, dotProduct_smul]\n    exact zsmul_nonneg (dotProduct_star_self_nonneg _) hd\u27e9\n\n@[simp]\nprotected theorem _root_.Matrix.posSemidef_intCast_iff\n    [StarOrderedRing R] [DecidableEq n] [Nonempty n] [Nontrivial R] (d : \u2124) :\n    PosSemidef (d : Matrix n n R) \u2194 0 \u2264 d :=\n  posSemidef_diagonal_iff.trans <| by simp",
      "suggestion": "## Finite positive semidefinite matrices\n",
      "body": "```suggestion\n## Finite positive semidefinite matrices\n```",
      "path": "Mathlib/LinearAlgebra/Matrix/PosDef.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw",
          "simp",
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "rw",
          "simp",
          "exact"
        ],
        "topics": [
          "finset",
          "nat",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "isHermitian_intCast",
          "lemma",
          "ofNat",
          "Nontrivial",
          "dotProduct_smul",
          "dotProduct_star_self_nonneg",
          "natCast",
          "posSemidef_diagonal_iff",
          "_root_",
          "Nat",
          "nsmul_nonneg",
          "protected",
          "intCast",
          "DecidableEq",
          "posSemidef_intCast_iff",
          "natCast_mulVec",
          "PosSemidef",
          "one",
          "intCast_mulVec",
          "star_mul_self_nonneg",
          "Int",
          "AtLeastTwo",
          "conjTranspose",
          "isHermitian_natCast",
          "simp",
          "cast_smul_eq_nsmul",
          "isHermitian_one",
          "zero",
          "sum_nonneg",
          "zsmul_nonneg",
          "Nonempty",
          "theorem",
          "StarOrderedRing",
          "exact",
          "cast_smul_eq_zsmul",
          "isHermitian_zero",
          "simpa",
          "one_mulVec",
          "trans",
          "Fintype",
          "Matrix",
          "using"
        ]
      }
    },
    {
      "id": 3998,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero\n\nsection MultiplicativeNotation\n\n/-- Notation for `WithZero (Multiplicative \u2115)` -/\nscoped[Multiplicative] notation \"\u2115\u2098\u2080\" => WithZero (Multiplicative \u2115)\n\n/-- Notation for `WithZero (Multiplicative \u2124)` -/\nscoped[Multiplicative] notation \"\u2124\u2098\u2080\" => WithZero (Multiplicative \u2124)\n\nend MultiplicativeNotation",
      "suggestion": "\r\n  (zpow_left_injOn hn).eq_iff ha.bot_lt hb.bot_lt\r\n",
      "body": "nit:\r\n```suggestion\r\n  (zpow_left_injOn hn).eq_iff ha.bot_lt hb.bot_lt\r\n```",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "int",
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "Notation",
          "scoped",
          "WithZero",
          "MultiplicativeNotation",
          "instLinearOrderedCommMonoidWithZero",
          "Multiplicative",
          "notation",
          "commGroupWithZero",
          "section",
          "for"
        ]
      }
    },
    {
      "id": 3999,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero\n\nsection MultiplicativeNotation\n\n/-- Notation for `WithZero (Multiplicative \u2115)` -/\nscoped[Multiplicative] notation \"\u2115\u2098\u2080\" => WithZero (Multiplicative \u2115)\n\n/-- Notation for `WithZero (Multiplicative \u2124)` -/\nscoped[Multiplicative] notation \"\u2124\u2098\u2080\" => WithZero (Multiplicative \u2124)\n\nend MultiplicativeNotation",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "int",
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "Notation",
          "scoped",
          "WithZero",
          "MultiplicativeNotation",
          "instLinearOrderedCommMonoidWithZero",
          "Multiplicative",
          "notation",
          "commGroupWithZero",
          "section",
          "for"
        ]
      }
    },
    {
      "id": 4000,
      "before_code": "__ := instLinearOrderedCommMonoidWithZero\n  __ := commGroupWithZero\n\nend WithZero\n\nsection MultiplicativeNotation\n\n/-- Notation for `WithZero (Multiplicative \u2115)` -/\nscoped[Multiplicative] notation \"\u2115\u2098\u2080\" => WithZero (Multiplicative \u2115)\n\n/-- Notation for `WithZero (Multiplicative \u2124)` -/\nscoped[Multiplicative] notation \"\u2124\u2098\u2080\" => WithZero (Multiplicative \u2124)\n\nend MultiplicativeNotation",
      "suggestion": "\r\ntheorem lt_succ_iff_le {x : \u2124\u2098\u2080} {m : Multiplicative \u2124} : x < m * ofAdd (1 : \u2124) \u2194 x \u2264 m := by\r\n",
      "body": "This statement looks really convoluted. What about something like\r\n```suggestion\r\ntheorem lt_succ_iff_le {x : \u2124\u2098\u2080} {m : Multiplicative \u2124} : x < m * ofAdd (1 : \u2124) \u2194 x \u2264 m := by\r\n```",
      "path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "int",
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "Notation",
          "scoped",
          "WithZero",
          "MultiplicativeNotation",
          "instLinearOrderedCommMonoidWithZero",
          "Multiplicative",
          "notation",
          "commGroupWithZero",
          "section",
          "for"
        ]
      }
    },
    {
      "id": 4001,
      "before_code": "rw [zpow_natCast]\n  apply one_le_pow_of_one_le' H",
      "suggestion": "\r\ntheorem one_lt_zpow {x : G} (hg : 1 < g) {n : \u2124} (hn : 0 < n) : 1 < x ^ n := by\r\n",
      "body": "```suggestion\r\ntheorem one_lt_zpow {x : G} (hg : 1 < g) {n : \u2124} (hn : 0 < n) : 1 < x ^ n := by\r\n```\r\nto match the rest of the file",
      "path": "Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "apply",
          "zpow_natCast",
          "one_le_pow_of_one_le"
        ]
      }
    },
    {
      "id": 4002,
      "before_code": "right_inv _ := rfl\n  map_mul' _ _ := coe_inj.mp <| by simp only [Units.val_mul, coe_unzero, coe_mul]",
      "suggestion": "\r\n  unitsWithZeroEquiv.toEquiv.surjective.nontrivial\r\n",
      "body": "```suggestion\r\n  unitsWithZeroEquiv.toEquiv.surjective.nontrivial\r\n```",
      "path": "Mathlib/Algebra/GroupWithZero/WithZero.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Units",
          "coe_inj",
          "val_mul",
          "right_inv",
          "coe_mul",
          "map_mul",
          "coe_unzero",
          "simp",
          "rfl",
          "only"
        ]
      }
    },
    {
      "id": 4008,
      "before_code": "lemma stdSimplexHomeomorphUnitInterval_one :\n    stdSimplexHomeomorphUnitInterval \u27e8_, single_mem_stdSimplex _ 1\u27e9 = 1 := rfl",
      "suggestion": "\r\n  grind [Real.dist_eq]\r\n",
      "body": "```suggestion\r\n  grind [Real.dist_eq]\r\n```",
      "path": "Mathlib/Analysis/Convex/StdSimplex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "lemma",
          "rfl",
          "single_mem_stdSimplex",
          "stdSimplexHomeomorphUnitInterval",
          "stdSimplexHomeomorphUnitInterval_one"
        ]
      }
    },
    {
      "id": 4009,
      "before_code": "variable {G H : Type*} [Monoid G] [Monoid H] (f : G \u2192* H)\n\n/-- The functor from `Action V H` to `Action V G` induced by a morphism `f : G \u2192 H` is faithful. -/\ninstance : (res V f).Faithful where\n  map_injective {X} {Y} g\u2081 g\u2082 h := by\n    ext\n    rw [\u2190 res_map_hom _ f g\u2081, \u2190 res_map_hom _ f g\u2082, h]\n\n/-- The functor from `Action V H` to `Action V G` induced by a morphism `f : G \u2192 H` is full\nif `f` is surjective. -/",
      "suggestion": "`f : G \u2192* H` is full if `f` is surjective. -/\n",
      "body": "```suggestion\n`f : G \u2192* H` is full if `f` is surjective. -/\n```",
      "path": "Mathlib/CategoryTheory/Action/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "ext"
        ],
        "topics": [
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Action",
          "res",
          "Monoid",
          "ext",
          "variable",
          "functor",
          "morphism",
          "Faithful",
          "map_injective",
          "Type",
          "induced",
          "res_map_hom",
          "from",
          "instance",
          "faithful",
          "surjective",
          "full"
        ]
      }
    },
    {
      "id": 4010,
      "before_code": "\u2203 c \u2208 Ioo a b, IsLocalExtr f c :=\n  let \u27e8c, cmem, hc\u27e9 := exists_isExtrOn_Ioo_of_tendsto hab hfc ha hb\n  \u27e8c, cmem, hc.isLocalExtr <| Ioo_mem_nhds cmem.1 cmem.2\u27e9",
      "suggestion": "\r\ntheorem exists_uIoo_isExtrOn_uIcc (hab : a \u2260 b) (hfc : ContinuousOn f (uIcc a b)) (hfI : f a = f b) :\r\n",
      "body": "```suggestion\r\ntheorem exists_uIoo_isExtrOn_uIcc (hab : a \u2260 b) (hfc : ContinuousOn f (uIcc a b)) (hfI : f a = f b) :\r\n```",
      "path": "Mathlib/Topology/Order/Rolle.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "Ioo_mem_nhds",
          "exists_isExtrOn_Ioo_of_tendsto",
          "isLocalExtr",
          "hfc",
          "hab",
          "Ioo",
          "cmem",
          "IsLocalExtr"
        ]
      }
    },
    {
      "id": 4011,
      "before_code": "\u2203 c \u2208 Ioo a b, IsLocalExtr f c :=\n  let \u27e8c, cmem, hc\u27e9 := exists_isExtrOn_Ioo_of_tendsto hab hfc ha hb\n  \u27e8c, cmem, hc.isLocalExtr <| Ioo_mem_nhds cmem.1 cmem.2\u27e9",
      "suggestion": "theorem exists_uIoo_isExtrOn_uIcc (hab : a \u2260 b) (hfc : ContinuousOn f (uIcc a b)) \n    (hfI : f a = f b) :\n    \u2203 c \u2208 uIoo a b, IsExtrOn f (uIcc a b) c :=\n",
      "body": "```suggestion\ntheorem exists_uIoo_isExtrOn_uIcc (hab : a \u2260 b) (hfc : ContinuousOn f (uIcc a b)) \n    (hfI : f a = f b) :\n    \u2203 c \u2208 uIoo a b, IsExtrOn f (uIcc a b) c :=\n```",
      "path": "Mathlib/Topology/Order/Rolle.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "Ioo_mem_nhds",
          "exists_isExtrOn_Ioo_of_tendsto",
          "isLocalExtr",
          "hfc",
          "hab",
          "Ioo",
          "cmem",
          "IsLocalExtr"
        ]
      }
    },
    {
      "id": 4012,
      "before_code": "\u2203 c \u2208 Ioo a b, IsLocalExtr f c :=\n  let \u27e8c, cmem, hc\u27e9 := exists_isExtrOn_Ioo_of_tendsto hab hfc ha hb\n  \u27e8c, cmem, hc.isLocalExtr <| Ioo_mem_nhds cmem.1 cmem.2\u27e9",
      "suggestion": "    exists_uIoo_isExtrOn_uIcc hab (continuousOn_uIcc_extendFrom_uIoo hab hfc ha hb)\n",
      "body": "```suggestion\n    exists_uIoo_isExtrOn_uIcc hab (continuousOn_uIcc_extendFrom_uIoo hab hfc ha hb)\n```",
      "path": "Mathlib/Topology/Order/Rolle.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "Ioo_mem_nhds",
          "exists_isExtrOn_Ioo_of_tendsto",
          "isLocalExtr",
          "hfc",
          "hab",
          "Ioo",
          "cmem",
          "IsLocalExtr"
        ]
      }
    },
    {
      "id": 4013,
      "before_code": "uniformOn Set.univ s = Measure.count s / Fintype.card \u03a9 := by\n  simp [uniformOn, cond_apply, \u2190 ENNReal.div_eq_inv_mul]",
      "suggestion": "theorem isProbabilityMeasure_uniformOn' {s : Set \u03a9}\n",
      "body": "```suggestion\ntheorem isProbabilityMeasure_uniformOn' {s : Set \u03a9}\n```\nor maybe\n```suggestion\ntheorem isProbabilityMeasure_uniformOn_of_measurableSet {s : Set \u03a9}\n```",
      "path": "Mathlib/Probability/UniformOn.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "ENNReal",
          "univ",
          "div_eq_inv_mul",
          "count",
          "Set",
          "Measure",
          "Fintype",
          "simp",
          "cond_apply",
          "uniformOn",
          "card"
        ]
      }
    },
    {
      "id": 4014,
      "before_code": "uniformOn Set.univ s = Measure.count s / Fintype.card \u03a9 := by\n  simp [uniformOn, cond_apply, \u2190 ENNReal.div_eq_inv_mul]\n\nvariable [MeasurableSingletonClass \u03a9]\n\ntheorem uniformOn_isProbabilityMeasure {s : Set \u03a9} (hs : s.Finite) (hs' : s.Nonempty) :\n    IsProbabilityMeasure (uniformOn s) := by\n  apply cond_isProbabilityMeasure_of_finite\n  \u00b7 rwa [Measure.count_ne_zero_iff]\n  \u00b7 exact (Measure.count_apply_lt_top.2 hs).ne",
      "suggestion": "alias uniformOn_isProbabilityMeasure := isProbabilityMeasure_uniformOn\n",
      "body": "```suggestion\nalias uniformOn_isProbabilityMeasure := isProbabilityMeasure_uniformOn\n```",
      "path": "Mathlib/Probability/UniformOn.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "apply",
          "simp"
        ],
        "topics": [
          "set_theory",
          "measurability",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "rwa",
          "count",
          "count_apply_lt_top",
          "apply",
          "IsProbabilityMeasure",
          "div_eq_inv_mul",
          "Measure",
          "cond_isProbabilityMeasure_of_finite",
          "variable",
          "univ",
          "count_ne_zero_iff",
          "simp",
          "card",
          "Finite",
          "ENNReal",
          "MeasurableSingletonClass",
          "Nonempty",
          "theorem",
          "uniformOn_isProbabilityMeasure",
          "exact",
          "Set",
          "Fintype",
          "cond_apply",
          "uniformOn"
        ]
      }
    },
    {
      "id": 4018,
      "before_code": "end PartialOrder",
      "suggestion": "minimal structure that satisfies this requirement as of now. -/\n",
      "body": "```suggestion\nminimal structure that satisfies this requirement as of now. -/\n```",
      "path": "Mathlib/Order/Minimal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "PartialOrder",
          "end"
        ]
      }
    },
    {
      "id": 4019,
      "before_code": "/-!\n# Asymptotics in a Topological Vector Space\n\nThis file defines `Asymptotics.IsLittleOTVS` and `Asymptotics.IsBigOTVS`\nas generalizations of `Asymptotics.IsLittleO` and `Asymptotics.IsBigO`\nfrom normed spaces to topological spaces.",
      "suggestion": "\r\nfrom normed spaces to topological vector spaces.\r\n",
      "body": "```suggestion\r\nfrom normed spaces to topological vector spaces.\r\n```",
      "path": "Mathlib/Analysis/Asymptotics/TVS.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "file",
          "generalizations",
          "normed",
          "This",
          "Asymptotics",
          "IsLittleO",
          "IsLittleOTVS",
          "Topological",
          "spaces",
          "IsBigO",
          "IsBigOTVS",
          "topological",
          "Vector",
          "Space",
          "from",
          "defines"
        ]
      }
    },
    {
      "id": 4024,
      "before_code": "diff_eq_sUnion' : \u2200 s \u2208 C, \u2200 t \u2208 C,\n    \u2203 I : Finset (Set \u03b1), \u2191I \u2286 C \u2227 PairwiseDisjoint (I : Set (Set \u03b1)) id \u2227 s \\ t = \u22c3\u2080 I\n\nnamespace IsSetSemiring\n\nlemma isPiSystem (hC : IsSetSemiring C) : IsPiSystem C := fun s hs t ht _ \u21a6 hC.inter_mem s hs t ht",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/MeasureTheory/SetSemiring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "namespace",
          "lemma",
          "PairwiseDisjoint",
          "diff_eq_sUnion",
          "Finset",
          "Set",
          "IsPiSystem",
          "IsSetSemiring",
          "inter_mem",
          "isPiSystem"
        ]
      }
    },
    {
      "id": 4027,
      "before_code": "end InjectiveResolution",
      "suggestion": "",
      "body": "This does not seem to be necessary:\n```suggestion\n```",
      "path": "Mathlib/CategoryTheory/Abelian/Injective/Resolution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "function"
        ],
        "transforms": [],
        "keywords": [
          "InjectiveResolution",
          "end"
        ]
      }
    },
    {
      "id": 4028,
      "before_code": "let \u27e8x, _, y, _, h\u27e9 := Finset.exists_ne_map_eq_of_card_lt_of_maps_to h fun x _ => mem_univ (f x)\n  \u27e8x, y, h\u27e9",
      "suggestion": "    \u00acFunction.Injective f :=\n  (Fintype.card_le_of_injective f).mt h.not_ge\n",
      "body": "```suggestion\n    \u00acFunction.Injective f :=\n  (Fintype.card_le_of_injective f).mt h.not_ge\n```\nOne might even consider inlining this...",
      "path": "Mathlib/Data/Fintype/Pigeonhole.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "Finset",
          "exists_ne_map_eq_of_card_lt_of_maps_to",
          "mem_univ"
        ]
      }
    },
    {
      "id": 4036,
      "before_code": "simp_rw [card_filter_univ_succ', Vector.get_cons_zero, Vector.toList_cons, Vector.get_cons_succ,\n      hxs, List.count_cons, add_comm (ite (x = a) 1 0), beq_iff_eq]",
      "suggestion": "\r\n    (hp : Antitone p) :\r\n",
      "body": "What do you think of\r\n```suggestion\r\n    (hp : Antitone p) :\r\n```",
      "path": "Mathlib/Data/Fintype/Fin.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "card_filter_univ_succ",
          "toList_cons",
          "hxs",
          "beq_iff_eq",
          "add_comm",
          "get_cons_succ",
          "count_cons",
          "Vector",
          "get_cons_zero",
          "List",
          "simp_rw",
          "ite"
        ]
      }
    },
    {
      "id": 4037,
      "before_code": "let \u27e8f, hfm, hf\u27e9 := hg\n  \u27e8(bind \u00b7 f), measurable_bind' hfm, (ae_ae_of_ae_join hf).mono fun _ \u21a6 bind_congr_right\u27e9",
      "suggestion": "\r\ntheorem bind_sum {\u03b9 : Type*} (m : \u03b9 \u2192 Measure \u03b1) (f : \u03b1 \u2192 Measure \u03b2)\r\n",
      "body": "```suggestion\r\ntheorem bind_sum {\u03b9 : Type*} (m : \u03b9 \u2192 Measure \u03b1) (f : \u03b1 \u2192 Measure \u03b2)\r\n```\r\nFor consistency with `join_sum`",
      "path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "bind",
          "mono",
          "hfm",
          "measurable_bind",
          "ae_ae_of_ae_join",
          "bind_congr_right"
        ]
      }
    },
    {
      "id": 4039,
      "before_code": "fun \u27e8y, hy, hfy\u27e9 \u21a6 \u27e8y - k, by simpa [tsub_add_cancel_of_le hy] using hfy\u27e9\u27e9\n\nend Set",
      "suggestion": "\r\ntheorem lt_add_iff_lt_left_or_exists_lt [AddLeftReflectLT \u03b1] [IsLeftCancelAdd \u03b1] {a b c : \u03b1} :\r\n",
      "body": "How about\r\n```suggestion\r\ntheorem lt_add_iff_lt_left_or_exists_lt [AddLeftReflectLT \u03b1] [IsLeftCancelAdd \u03b1] {a b c : \u03b1} :\r\n```\r\nwhere `left` refers to `b`?",
      "path": "Mathlib/Algebra/Order/Monoid/Canonical/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "tsub_add_cancel_of_le",
          "Set",
          "simpa",
          "hfy",
          "using"
        ]
      }
    },
    {
      "id": 4040,
      "before_code": "url           = {https://emilyriehl.github.io/files/elements.pdf}\n}",
      "suggestion": "  pages         = {195--222}\n",
      "body": "```suggestion\n  pages         = {195--222}\n```",
      "path": "docs/references.bib",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "https",
          "pdf",
          "files",
          "github",
          "emilyriehl",
          "url",
          "elements"
        ]
      }
    },
    {
      "id": 4041,
      "before_code": "url           = {https://emilyriehl.github.io/files/elements.pdf}\n}",
      "suggestion": "  fjournal      = {Transactions of the American Mathematical Society},\n",
      "body": "```suggestion\n  fjournal      = {Transactions of the American Mathematical Society},\n```\nor\n```suggestion\n  journal       = {Trans. Amer. Math. Soc.},\n  fjournal      = {Transactions of the American Mathematical Society},\n```",
      "path": "docs/references.bib",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "https",
          "pdf",
          "files",
          "github",
          "emilyriehl",
          "url",
          "elements"
        ]
      }
    },
    {
      "id": 4043,
      "before_code": "\u2203 (\u03c6 : \u03b1 \u2192 \u03b2) (_ : Tendsto \u03c6 l (\ud835\udcdd 1)), u =\u1da0[l] \u03c6 * v :=\n  isEquivalent_iff_exists_eq_mul.mp huv\n\ntheorem isEquivalent_of_tendsto_one (hz : \u2200\u1da0 x in l, v x = 0 \u2192 u x = 0)\n    (huv : Tendsto (u / v) l (\ud835\udcdd 1)) : u ~[l] v := by\n  rw [isEquivalent_iff_exists_eq_mul]\n  exact \u27e8u / v, huv, hz.mono fun x hz' \u21a6 (div_mul_cancel_of_imp hz').symm\u27e9\n\ntheorem isEquivalent_of_tendsto_one' (hz : \u2200 x, v x = 0 \u2192 u x = 0) (huv : Tendsto (u / v) l (\ud835\udcdd 1)) :\n    u ~[l] v :=\n  isEquivalent_of_tendsto_one (Eventually.of_forall hz) huv",
      "suggestion": "\n@[deprecated (since := \"2026-01-26\")] alias isEquivalent_of_tendsto_one' := isEquivalent_of_tendsto_one\n\n",
      "body": "Let's add a deprecation\n```suggestion\n\n@[deprecated (since := \"2026-01-26\")] alias isEquivalent_of_tendsto_one' := isEquivalent_of_tendsto_one\n\n```",
      "path": "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "of_forall",
          "symm",
          "isEquivalent_iff_exists_eq_mul",
          "mono",
          "theorem",
          "exact",
          "Tendsto",
          "div_mul_cancel_of_imp",
          "isEquivalent_of_tendsto_one",
          "huv",
          "Eventually"
        ]
      }
    },
    {
      "id": 4044,
      "before_code": "simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b\u2081, h, \u2190 mul_assoc, mul_comm _ (f a)]",
      "suggestion": "  rw [\u2190 prod_filter_ne_one, \u2190 this, prod_biUnion]\n  swap\n  \u00b7 intro i hi j hj hij a hai haj k hk\n",
      "body": "I think I'd prefer\n```suggestion\n  rw [\u2190 prod_filter_ne_one, \u2190 this, prod_biUnion]\n  swap\n  \u00b7 intro i hi j hj hij a hai haj k hk\n```",
      "path": "Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "rw",
          "intro"
        ],
        "body_tactics": [
          "rw",
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mul_assoc",
          "not_true_eq_false",
          "false_and",
          "mem_erase",
          "ne_eq",
          "not_false_eq_true",
          "simp",
          "mul_comm",
          "only",
          "prod_insert"
        ]
      }
    },
    {
      "id": 4045,
      "before_code": "universe uK uV\nvariable {K : Type uK} {V : Type uV}",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/LinearAlgebra/Dual/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "universe",
          "Type",
          "variable"
        ]
      }
    },
    {
      "id": 4046,
      "before_code": "{V : Type*} [AddCommMonoid V] [Module R V]\n    {W : Type*} [AddCommMonoid W] [Module R W] [Module S W] [IsScalarTower R S W]\n    {\u03b9 : Type*}",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/RingTheory/TensorProduct/IsBaseChangeFree.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "AddCommMonoid",
          "Type",
          "IsScalarTower"
        ]
      }
    },
    {
      "id": 4047,
      "before_code": "(transvection hf).symm = transvection hf' := by\n  ext; simp [LinearEquiv.symm_apply_eq, comp_of_right_eq_apply hf]",
      "suggestion": "\r\ntheorem inv_mem_dilatransvections_iff (e : V \u2243\u2097[R] V) :\r\n",
      "body": "```suggestion\r\ntheorem inv_mem_dilatransvections_iff (e : V \u2243\u2097[R] V) :\r\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "LinearEquiv",
          "comp_of_right_eq_apply",
          "transvection",
          "simp",
          "symm_apply_eq"
        ]
      }
    },
    {
      "id": 4048,
      "before_code": "(transvection hf).symm = transvection hf' := by\n  ext; simp [LinearEquiv.symm_apply_eq, comp_of_right_eq_apply hf]",
      "suggestion": "\r\ndef dilatransvections : Set (V \u2243\u2097[R] V) :=\r\n",
      "body": "```suggestion\r\ndef dilatransvections : Set (V \u2243\u2097[R] V) :=\r\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "LinearEquiv",
          "comp_of_right_eq_apply",
          "transvection",
          "simp",
          "symm_apply_eq"
        ]
      }
    },
    {
      "id": 4049,
      "before_code": "ext;\n  simp [symm_apply_eq, comp_of_left_eq_apply hv']\n\ntheorem symm_eq' {f : Dual R V} {v : V}\n    (hf : f v = 0) (hf' : (-f) v = 0 := by simp [hf]) :\n    (transvection hf).symm = transvection hf' := by\n  ext; simp [symm_apply_eq, comp_of_right_eq_apply hf]\n\nend LinearEquiv.transvection",
      "suggestion": "\r\n`LinearMap.transvection`, i.e., are of the form `x \u21a6 x + f x \u2022 v` for `f : Dual R V` and `v : V`.\r\n",
      "body": "```suggestion\r\n`LinearMap.transvection`, i.e., are of the form `x \u21a6 x + f x \u2022 v` for `f : Dual R V` and `v : V`.\r\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "comp_of_left_eq_apply",
          "symm",
          "end",
          "ext",
          "theorem",
          "LinearEquiv",
          "comp_of_right_eq_apply",
          "symm_eq",
          "transvection",
          "simp",
          "Dual",
          "symm_apply_eq"
        ]
      }
    },
    {
      "id": 4050,
      "before_code": "end id",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 4051,
      "before_code": "end Inequalities\n\n/-- A discrete hitting time is a stopping time. -/\ntheorem hittingBtwn_isStoppingTime [ConditionallyCompleteLinearOrder \u03b9] [WellFoundedLT \u03b9]\n    [Countable \u03b9] [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2]\n    {f : Filtration \u03b9 m} {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2} {s : Set \u03b2} {n n' : \u03b9} (hu : StronglyAdapted f u)\n    (hs : MeasurableSet s) : IsStoppingTime f (fun \u03c9 \u21a6 (hittingBtwn u s n n' \u03c9 : \u03b9)) := by",
      "suggestion": "    [Countable \u03b9] {m\u03b2 : MeasurableSpace \u03b2} {f : Filtration \u03b9 m} {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2} {s : Set \u03b2} {n n' : \u03b9}\n",
      "body": "```suggestion\n    [Countable \u03b9] {m\u03b2 : MeasurableSpace \u03b2} {f : Filtration \u03b9 m} {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2} {s : Set \u03b2} {n n' : \u03b9}\n```\nMaking that argument implicit ensures that it always matches the `MeasurableSpace` used in `hs`.",
      "path": "Mathlib/Probability/Process/HittingTime.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "time",
          "end",
          "Countable",
          "Inequalities",
          "discrete",
          "Filtration",
          "MeasurableSet",
          "BorelSpace",
          "hitting",
          "StronglyAdapted",
          "TopologicalSpace",
          "ConditionallyCompleteLinearOrder",
          "hittingBtwn",
          "hittingBtwn_isStoppingTime",
          "PseudoMetrizableSpace",
          "MeasurableSpace",
          "IsStoppingTime",
          "theorem",
          "WellFoundedLT",
          "Set",
          "stopping"
        ]
      }
    },
    {
      "id": 4052,
      "before_code": "end Inequalities\n\n/-- A discrete hitting time is a stopping time. -/\ntheorem hittingBtwn_isStoppingTime [ConditionallyCompleteLinearOrder \u03b9] [WellFoundedLT \u03b9]\n    [Countable \u03b9] [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2]\n    {f : Filtration \u03b9 m} {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2} {s : Set \u03b2} {n n' : \u03b9} (hu : StronglyAdapted f u)\n    (hs : MeasurableSet s) : IsStoppingTime f (fun \u03c9 \u21a6 (hittingBtwn u s n n' \u03c9 : \u03b9)) := by\n  intro i\n  rcases le_or_gt n' i with hi | hi\n  \u00b7 have h_le : \u2200 \u03c9, hittingBtwn u s n n' \u03c9 \u2264 i := fun x => (hittingBtwn_le x).trans hi\n    simp [h_le]\n  \u00b7 have h_set_eq_Union : {\u03c9 | hittingBtwn u s n n' \u03c9 \u2264 i} = \u22c3 j \u2208 Set.Icc n i, u j \u207b\u00b9' s := by\n      ext x\n      rw [Set.mem_setOf_eq, hittingBtwn_le_iff_of_lt _ hi]\n      simp only [Set.mem_Icc, exists_prop, Set.mem_iUnion, Set.mem_preimage]\n    simp_rw [WithTop.coe_le_coe, h_set_eq_Union]\n    exact MeasurableSet.iUnion fun j =>\n      MeasurableSet.iUnion fun hj => f.mono hj.2 _ ((hu j).measurable hs)\n\n@[deprecated (since := \"2025-10-25\")] alias hitting_isStoppingTime := hittingBtwn_isStoppingTime\n\n/-- A discrete hitting time is a stopping time. -/\ntheorem hittingAfter_isStoppingTime [ConditionallyCompleteLinearOrder \u03b9] [WellFoundedLT \u03b9]\n    [Countable \u03b9] [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2]\n    {f : Filtration \u03b9 m} {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2} {s : Set \u03b2} {n : \u03b9}\n    (hu : StronglyAdapted f u) (hs : MeasurableSet s) :",
      "suggestion": "    [WellFoundedLT \u03b9] [Countable \u03b9] {m\u03b2 : MeasurableSpace \u03b2} {f : Filtration \u03b9 m} {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2}\n",
      "body": "```suggestion\n    [WellFoundedLT \u03b9] [Countable \u03b9] {m\u03b2 : MeasurableSpace \u03b2} {f : Filtration \u03b9 m} {u : \u03b9 \u2192 \u03a9 \u2192 \u03b2}\n```",
      "path": "Mathlib/Probability/Process/HittingTime.lean",
      "tags": {
        "before_tactics": [
          "ext",
          "exact",
          "cases",
          "have",
          "rw",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "simp",
          "ext",
          "intro",
          "exact",
          "cases",
          "have"
        ],
        "topics": [
          "set_theory",
          "measurability",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "time",
          "end",
          "h_set_eq_Union",
          "Countable",
          "rcases",
          "since",
          "Inequalities",
          "discrete",
          "alias",
          "WithTop",
          "ext",
          "mono",
          "Filtration",
          "have",
          "MeasurableSet",
          "BorelSpace",
          "hitting",
          "StronglyAdapted",
          "intro",
          "simp_rw",
          "coe_le_coe",
          "hittingBtwn_le",
          "h_le",
          "mem_iUnion",
          "TopologicalSpace",
          "ConditionallyCompleteLinearOrder",
          "hittingBtwn",
          "iUnion",
          "hittingBtwn_isStoppingTime",
          "PseudoMetrizableSpace",
          "exists_prop",
          "simp",
          "MeasurableSpace",
          "hitting_isStoppingTime",
          "only",
          "IsStoppingTime",
          "theorem",
          "mem_setOf_eq",
          "WellFoundedLT",
          "mem_Icc",
          "le_or_gt",
          "exact",
          "Set",
          "hittingBtwn_le_iff_of_lt",
          "stopping",
          "trans",
          "mem_preimage",
          "Icc",
          "hittingAfter_isStoppingTime",
          "deprecated"
        ]
      }
    },
    {
      "id": 4053,
      "before_code": "theorem linearEquivFunOnFinite_symm_coe (f : \u03b1 \u2192\u2080 M) : (linearEquivFunOnFinite R M \u03b1).symm f = f :=\n  (linearEquivFunOnFinite R M \u03b1).symm_apply_apply f",
      "suggestion": "\r\n    (linearEquivFunOnFinite R M \u03b1).symm f = f :=\r\n",
      "body": "I'd argue for\r\n```suggestion\r\n    (linearEquivFunOnFinite R M \u03b1).symm f = f :=\r\n```",
      "path": "Mathlib/LinearAlgebra/Finsupp/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "theorem",
          "symm_apply_apply",
          "linearEquivFunOnFinite_symm_coe",
          "linearEquivFunOnFinite"
        ]
      }
    },
    {
      "id": 4054,
      "before_code": "theorem Iio_castSucc (i : Fin n) : Iio (castSucc i) = (Iio i).map Fin.castSuccEmb := by simp",
      "suggestion": "\r\ntheorem card_filter_val_lt {m : \u2115} : #{i : Fin n | i.val < m} = min m n := by\r\n",
      "body": "```suggestion\r\ntheorem card_filter_val_lt {m : \u2115} : #{i : Fin n | i.val < m} = min m n := by\r\n```\r\nfor clarity, perhaps?",
      "path": "Mathlib/Data/Fintype/Fin.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Iio",
          "theorem",
          "map",
          "simp",
          "Iio_castSucc",
          "Fin",
          "castSuccEmb",
          "castSucc"
        ]
      }
    },
    {
      "id": 4055,
      "before_code": "theorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this",
      "suggestion": "\r\ntheorem pos_iff (h : v\u2081.IsEquiv v\u2082) {x : R} : 0 < v\u2081 x \u2194 0 < v\u2082 x := by\r\n",
      "body": "```suggestion\r\ntheorem pos_iff (h : v\u2081.IsEquiv v\u2082) {x : R} : 0 < v\u2081 x \u2194 0 < v\u2082 x := by\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "have"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "have"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "map_zero",
          "rwa",
          "le_antisymm_iff",
          "theorem",
          "IsEquiv",
          "have",
          "ne_zero",
          "this",
          "val_eq",
          "simpa",
          "and_congr",
          "not_congr",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 4056,
      "before_code": "v\u2081 x \u2264 1 \u2194 v\u2082 x \u2264 1 := by\n  rw [\u2190 v\u2081.map_one, h, map_one]\n\nlemma eq_one_iff_eq_one (h : v\u2081.IsEquiv v\u2082) {x : R} :\n    v\u2081 x = 1 \u2194 v\u2082 x = 1 := by\n  rw [\u2190 v\u2081.map_one, h.val_eq, map_one]\n\nlemma lt_one_iff_lt_one (h : v\u2081.IsEquiv v\u2082) {x : R} :\n    v\u2081 x < 1 \u2194 v\u2082 x < 1 := by\n  rw [\u2190 v\u2081.map_one, h.lt_iff_lt, map_one]\n\nlemma pos_iff (h : v\u2081.IsEquiv v\u2082) {x : R} :\n    0 < v\u2081 x \u2194 0 < v\u2082 x := by\n  rw [zero_lt_iff, zero_lt_iff, h.ne_zero]\n\nend IsEquiv",
      "suggestion": "\r\nend IsEquiv\r\n",
      "body": "That comment feels unhelpful?\r\n```suggestion\r\nend IsEquiv\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "map_one",
          "lt_iff_lt",
          "lemma",
          "end",
          "zero_lt_iff",
          "IsEquiv",
          "pos_iff",
          "ne_zero",
          "val_eq",
          "eq_one_iff_eq_one",
          "lt_one_iff_lt_one"
        ]
      }
    },
    {
      "id": 4057,
      "before_code": "v\u2081 x \u2264 1 \u2194 v\u2082 x \u2264 1 := by\n  rw [\u2190 v\u2081.map_one, h, map_one]\n\nlemma eq_one_iff_eq_one (h : v\u2081.IsEquiv v\u2082) {x : R} :\n    v\u2081 x = 1 \u2194 v\u2082 x = 1 := by\n  rw [\u2190 v\u2081.map_one, h.val_eq, map_one]\n\nlemma lt_one_iff_lt_one (h : v\u2081.IsEquiv v\u2082) {x : R} :\n    v\u2081 x < 1 \u2194 v\u2082 x < 1 := by\n  rw [\u2190 v\u2081.map_one, h.lt_iff_lt, map_one]\n\nlemma pos_iff (h : v\u2081.IsEquiv v\u2082) {x : R} :\n    0 < v\u2081 x \u2194 0 < v\u2082 x := by\n  rw [zero_lt_iff, zero_lt_iff, h.ne_zero]\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by",
      "suggestion": "\r\ntheorem isEquiv_of_val_le_one (h : \u2200 x, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\r\n",
      "body": "I don't think we generally bother specifying the implicitness of variables within hypotheses like this.\r\n```suggestion\r\ntheorem isEquiv_of_val_le_one (h : \u2200 x, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "ring",
          "rw",
          "simp"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "map_one",
          "le_iff_le",
          "lemma",
          "end",
          "isEquiv_of_map_strictMono",
          "Ring",
          "LinearOrderedCommGroupWithZero",
          "lt_one_iff_lt_one",
          "section",
          "lt_iff_lt",
          "LinearOrderedCommMonoidWithZero",
          "isEquiv_of_val_le_one",
          "monotone",
          "Valuation",
          "map",
          "eq_one_iff_eq_one",
          "IsEquiv",
          "ne_zero",
          "forall_comm",
          "le_iff_le_iff_lt_iff_lt",
          "simp",
          "only",
          "namespace",
          "isEquiv_iff_val_lt_val",
          "StrictMono",
          "zero_lt_iff",
          "theorem",
          "exact",
          "pos_iff",
          "val_eq"
        ]
      }
    },
    {
      "id": 4058,
      "before_code": "v\u2081 x < 1 \u2194 v\u2082 x < 1 := by\n  rw [\u2190 v\u2081.map_one, h.lt_iff_lt, map_one]\n\nlemma pos_iff (h : v\u2081.IsEquiv v\u2082) {x : R} :\n    0 < v\u2081 x \u2194 0 < v\u2082 x := by\n  rw [zero_lt_iff, zero_lt_iff, h.ne_zero]\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by",
      "suggestion": "\r\ntheorem IsEquiv.isNontrivial_iff (h : v.IsEquiv v') :\r\n",
      "body": "```suggestion\r\ntheorem IsEquiv.isNontrivial_iff (h : v.IsEquiv v') :\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ring",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "ring",
          "rw",
          "simp"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "map_one",
          "le_iff_le",
          "lemma",
          "end",
          "isEquiv_of_map_strictMono",
          "Ring",
          "LinearOrderedCommGroupWithZero",
          "section",
          "lt_iff_lt",
          "LinearOrderedCommMonoidWithZero",
          "isEquiv_of_val_le_one",
          "monotone",
          "Valuation",
          "map",
          "IsEquiv",
          "ne_zero",
          "forall_comm",
          "le_iff_le_iff_lt_iff_lt",
          "simp",
          "only",
          "namespace",
          "isEquiv_iff_val_lt_val",
          "StrictMono",
          "zero_lt_iff",
          "theorem",
          "exact",
          "pos_iff"
        ]
      }
    },
    {
      "id": 4061,
      "before_code": "lemma localized'_top : (\u22a4 : Submodule R M).localized' S p f = \u22a4 :=\n  SetLike.ext' (by apply SetLike.ext'_iff.mp <| Submodule.localized\u2080_top p f)",
      "suggestion": "\r\nnoncomputable def localized'FrameHom :\r\n",
      "body": "```suggestion\r\nnoncomputable def localized'FrameHom :\r\n```",
      "path": "Mathlib/Algebra/Module/LocalizedModule/Submodule.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "ext"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "lemma",
          "ext",
          "SetLike",
          "_iff",
          "_top",
          "Submodule",
          "localized"
        ]
      }
    },
    {
      "id": 4062,
      "before_code": "\u00b7 exact fun e h \u21a6 isNoetherianRing_of_ringEquiv _ (.piCongrLeft _ e)\n  \u00b7 infer_instance\n  \u00b7 exact fun ih \u21a6 isNoetherianRing_of_ringEquiv _ (.symm .piOptionEquivProd)",
      "suggestion": "\r\ntheorem FG.of_le_of_isNoetherian {S T : Submodule R M} [IsNoetherian R T] (hST : S \u2264 T) : S.FG :=\r\n",
      "body": "```suggestion\r\ntheorem FG.of_le_of_isNoetherian {S T : Submodule R M} [IsNoetherian R T] (hST : S \u2264 T) : S.FG :=\r\n```",
      "path": "Mathlib/RingTheory/Noetherian/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "piCongrLeft",
          "infer_instance",
          "exact",
          "piOptionEquivProd",
          "isNoetherianRing_of_ringEquiv"
        ]
      }
    },
    {
      "id": 4063,
      "before_code": "end IsNontrivial",
      "suggestion": "\r\ntheorem IsTrivialOnConstants.valuation_algebraMap_le_one : \u2200 a : A, v (algebraMap A B a) \u2264 1 := by\r\n",
      "body": "```suggestion\r\ntheorem IsTrivialOnConstants.valuation_algebraMap_le_one : \u2200 a : A, v (algebraMap A B a) \u2264 1 := by\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsNontrivial",
          "end"
        ]
      }
    },
    {
      "id": 4065,
      "before_code": "end IsNontrivial",
      "suggestion": "\r\ntheorem IsTrivialOn.valuation_algebraMap_le_one (a : A) : v (algebraMap A B a) \u2264 1 := by\r\n",
      "body": "```suggestion\r\ntheorem IsTrivialOn.valuation_algebraMap_le_one (a : A) : v (algebraMap A B a) \u2264 1 := by\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsNontrivial",
          "end"
        ]
      }
    },
    {
      "id": 4066,
      "before_code": "simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]",
      "suggestion": "theorem Nat.nontrivial_primeFactors_of_two_le_of_not_isPrimePow {n : \u2115} (hn : 2 \u2264 n)\n",
      "body": "```suggestion\ntheorem Nat.nontrivial_primeFactors_of_two_le_of_not_isPrimePow {n : \u2115} (hn : 2 \u2264 n)\n```",
      "path": "Mathlib/Data/Nat/Factorization/PrimePow.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "nat",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "support_factorization",
          "Nat",
          "pos_iff_ne_zero",
          "card_support_eq_one",
          "simp_rw",
          "isPrimePow_iff_factorization_eq_single"
        ]
      }
    },
    {
      "id": 4067,
      "before_code": "simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]",
      "suggestion": "    \u00ac IsPrimePow n \u2194 n.primeFactors.Nontrivial := by\n  rw [isPrimePow_iff_card_primeFactors_eq_one, \u2190 Finset.one_lt_card_iff_nontrivial]\n  grind [primeFactors_eq_empty]\n",
      "body": "```suggestion\n    \u00ac IsPrimePow n \u2194 n.primeFactors.Nontrivial := by\n  rw [isPrimePow_iff_card_primeFactors_eq_one, \u2190 Finset.one_lt_card_iff_nontrivial]\n  grind [primeFactors_eq_empty]\n```",
      "path": "Mathlib/Data/Nat/Factorization/PrimePow.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind",
          "rw"
        ],
        "body_tactics": [
          "grind",
          "rw"
        ],
        "new_tactics": [
          "grind",
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "nat",
          "order",
          "finset"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Finsupp",
          "support_factorization",
          "Nat",
          "pos_iff_ne_zero",
          "card_support_eq_one",
          "simp_rw",
          "isPrimePow_iff_factorization_eq_single"
        ]
      }
    },
    {
      "id": 4068,
      "before_code": "parallelScanAux as (L.drop 3).copy (M.drop 3).copy else\n  if L.take 2 == \"--\".toSlice then\n    let newL := L.dropWhile (\u00b7 != '\\n')\n    let diff := L.length - newL.copy.length",
      "suggestion": "\r\n    let diff := L.positions.count - newL.positions.count\r\n",
      "body": "There are still a lot of `.copy`s in this function, maybe that is the reason why? For example, we should also change:\r\n```suggestion\r\n    let diff := L.positions.count - newL.positions.count\r\n```",
      "path": "Mathlib/Tactic/Linter/Whitespace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "length",
          "take",
          "else",
          "then",
          "copy",
          "dropWhile",
          "parallelScanAux",
          "diff",
          "newL",
          "toSlice",
          "drop"
        ]
      }
    },
    {
      "id": 4070,
      "before_code": "rw [PrimeSpectrum.isClosed_singleton_iff_isMaximal, closedPoint]\n  infer_instance",
      "suggestion": "\r\n    (x : PrimeSpectrum R) : x = \u22a5 \u2228 x = \u22a4 :=\r\n  Order.krullDim_le_one_iff_of_boundedOrder.mp Order.KrullDimLE.krullDim_le _\r\n",
      "body": "```suggestion\r\n    (x : PrimeSpectrum R) : x = \u22a5 \u2228 x = \u22a4 :=\r\n  Order.krullDim_le_one_iff_of_boundedOrder.mp Order.KrullDimLE.krullDim_le _\r\n```",
      "path": "Mathlib/RingTheory/Spectrum/Prime/Topology.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "PrimeSpectrum",
          "isClosed_singleton_iff_isMaximal",
          "closedPoint",
          "infer_instance"
        ]
      }
    },
    {
      "id": 4071,
      "before_code": "instance [Nontrivial M] : Nontrivial P.invtRootSubmodule where\n  exists_pair_ne := \u27e8\u22a5, \u22a4, by rw [ne_eq, Subtype.ext_iff]; exact bot_ne_top\u27e9",
      "suggestion": "",
      "body": "Not needed here:\n```suggestion\n```",
      "path": "Mathlib/LinearAlgebra/RootSystem/Irreducible.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "Subtype",
          "ext_iff",
          "Nontrivial",
          "exact",
          "invtRootSubmodule",
          "ne_eq",
          "exists_pair_ne",
          "instance",
          "bot_ne_top"
        ]
      }
    },
    {
      "id": 4072,
      "before_code": "this.trans <| iSup\u2082_mono fun \u03b1 h\u03b1 \u21a6 le_sup_right\n  simp\n\nsection IsSimple",
      "suggestion": "    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    invtSubmoduleToLieIdeal q hq = \u22a4 \u2194 q = \u22a4 := by\n",
      "body": "```suggestion\n    (hq : \u2200 i, q \u2208 End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    invtSubmoduleToLieIdeal q hq = \u22a4 \u2194 q = \u22a4 := by\n```",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "le_sup_right",
          "this",
          "IsSimple",
          "trans",
          "simp",
          "section"
        ]
      }
    },
    {
      "id": 4073,
      "before_code": "this.trans <| iSup\u2082_mono fun \u03b1 h\u03b1 \u21a6 le_sup_right\n  simp\n\nsection IsSimple\n\nvariable [IsSimple K L]",
      "suggestion": "    (hq : \u2200 i, q \u2208 Module.End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    invtSubmoduleToLieIdeal q hq = \u22a5 \u2194 q = \u22a5 := by\n",
      "body": "```suggestion\n    (hq : \u2200 i, q \u2208 Module.End.invtSubmodule ((rootSystem H).reflection i).toLinearMap) :\n    invtSubmoduleToLieIdeal q hq = \u22a5 \u2194 q = \u22a5 := by\n```",
      "path": "Mathlib/Algebra/Lie/Weights/IsSimple.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "variable",
          "le_sup_right",
          "this",
          "IsSimple",
          "trans",
          "simp",
          "section"
        ]
      }
    },
    {
      "id": 4074,
      "before_code": "theorem lid_symm_apply (m : M) : (TensorProduct.lid R M).symm m = 1 \u2297\u209c m :=\n  rfl",
      "suggestion": "\r\n    (1 : S) \u2297\u209c[R] (TensorProduct.lid R M) m =\r\n      (LinearMap.rTensor M (Algebra.algHom R R S).toLinearMap) m := by\r\n",
      "body": "The line break should be after the infix operator:\r\n```suggestion\r\n    (1 : S) \u2297\u209c[R] (TensorProduct.lid R M) m =\r\n      (LinearMap.rTensor M (Algebra.algHom R R S).toLinearMap) m := by\r\n```",
      "path": "Mathlib/LinearAlgebra/TensorProduct/Associator.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "symm",
          "theorem",
          "lid_symm_apply",
          "TensorProduct",
          "lid",
          "rfl"
        ]
      }
    },
    {
      "id": 4078,
      "before_code": "## Main definitions\n\n  - `FundamentalGroupoidFunctor.homotopicMapsNatIso H` The natural isomorphism\n    between the induced functors `f : \u03c0(X) \u2964 \u03c0(Y)` and `g : \u03c0(X) \u2964 \u03c0(Y)`, given a homotopy\n    `H : f \u223c g`\n\n  - `FundamentalGroupoidFunctor.equivOfHomotopyEquiv hequiv` The equivalence of the categories\n    `\u03c0(X)` and `\u03c0(Y)` given a homotopy equivalence `hequiv : X \u2243\u2095 Y` between them.\n\n## Implementation notes\n  - In order to be more universe polymorphic, we define `ContinuousMap.Homotopy.uliftMap`\n  which lifts a homotopy from `I \u00d7 X \u2192 Y` to `(TopCat.of ((ULift I) \u00d7 X)) \u2192 Y`. This is because\n  this construction uses `FundamentalGroupoidFunctor.prodToProdTop` to convert between\n  pairs of paths in I and X and the corresponding path after passing through a homotopy `H`.\n  But `FundamentalGroupoidFunctor.prodToProdTop` requires two spaces in the same universe.\n-/\n\n@[expose] public section\n\n\nnoncomputable section\n\nuniverse u\n\nopen FundamentalGroupoid\n\nopen CategoryTheory",
      "suggestion": "functors `map f` and `map g` on fundamental groupoids. -/\n",
      "body": "```suggestion\nfunctors `map f` and `map g` on fundamental groupoids. -/\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "equiv",
          "list",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "FundamentalGroupoid",
          "natural",
          "homotopicMapsNatIso",
          "convert",
          "expose",
          "after",
          "which",
          "But",
          "isomorphism",
          "CategoryTheory",
          "Main",
          "open",
          "section",
          "paths",
          "equivOfHomotopyEquiv",
          "This",
          "noncomputable",
          "universe",
          "corresponding",
          "notes",
          "equivalence",
          "requires",
          "spaces",
          "more",
          "passing",
          "TopCat",
          "pairs",
          "two",
          "homotopy",
          "public",
          "path",
          "definitions",
          "ULift",
          "uses",
          "induced",
          "prodToProdTop",
          "FundamentalGroupoidFunctor",
          "between",
          "Homotopy",
          "given",
          "construction",
          "uliftMap",
          "categories",
          "functors",
          "them",
          "through",
          "Implementation",
          "same",
          "hequiv",
          "this"
        ]
      }
    },
    {
      "id": 4079,
      "before_code": "rw [totient_mul _, totient_prime hp]\n  simpa [h] using coprime_or_dvd_of_prime hp n",
      "suggestion": "\r\n  totient_mul_of_prime_of_dvd prime_two hn.two_dvd\r\n",
      "body": "```suggestion\r\n  totient_mul_of_prime_of_dvd prime_two hn.two_dvd\r\n```\r\nSame below",
      "path": "Mathlib/Data/Nat/Totient.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simpa",
          "totient_mul",
          "totient_prime",
          "coprime_or_dvd_of_prime",
          "using"
        ]
      }
    },
    {
      "id": 4080,
      "before_code": "TensorProduct.map_map_comp_assoc_eq]\n\ninstance instIsCocomm [IsCocomm R A] : IsCocomm R (\u03b9 \u2192\u2080 A) where\n  comm_comp_comul := by\n    ext i : 1\n    -- TODO: Add `reassoc` for `LinearMap`. Then we wouldn't need to reassociate back and forth.\n    simp only [comp_assoc, comul_comp_lsingle]\n    simp only [\u2190 comp_assoc, \u2190 TensorProduct.map_comp_comm_eq]\n    simp [LinearMap.comp_assoc]\n\nend Finsupp",
      "suggestion": "\r\n    comul (R := R) (A := \u03a0 i, A i) \u2218\u2097 DFinsupp.coeFnLinearMap =\r\n",
      "body": "```suggestion\r\n    comul (R := R) (A := \u03a0 i, A i) \u2218\u2097 DFinsupp.coeFnLinearMap =\r\n```\r\nI think is the preferred spelling",
      "path": "Mathlib/RingTheory/Coalgebra/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "forth",
          "end",
          "comm_comp_comul",
          "back",
          "comp_assoc",
          "map_comp_comm_eq",
          "TODO",
          "wouldn",
          "ext",
          "LinearMap",
          "IsCocomm",
          "for",
          "Finsupp",
          "need",
          "TensorProduct",
          "reassociate",
          "simp",
          "comul_comp_lsingle",
          "Add",
          "only",
          "instIsCocomm",
          "reassoc",
          "map_map_comp_assoc_eq",
          "Then",
          "instance"
        ]
      }
    },
    {
      "id": 4081,
      "before_code": "* When `f : Module.Dual R V` and `v : V`,\n  `LinearMap.transvection f v` is the linear map given by `x \u21a6 x + f x \u2022 v`,",
      "suggestion": "\r\n\r\n",
      "body": "```suggestion\r\n\r\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "When",
          "Module",
          "LinearMap",
          "transvection",
          "map",
          "given",
          "Dual",
          "linear"
        ]
      }
    },
    {
      "id": 4082,
      "before_code": "* When `f : Module.Dual R V` and `v : V`,\n  `LinearMap.transvection f v` is the linear map given by `x \u21a6 x + f x \u2022 v`,",
      "suggestion": "\r\n* `LinearMap.transvection.det` shows that the determinant of\r\n  `LinearMap.transvection f v` is equal to `1 + f v`.\r\n",
      "body": "```suggestion\r\n* `LinearMap.transvection.det` shows that the determinant of\r\n  `LinearMap.transvection f v` is equal to `1 + f v`.\r\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "When",
          "Module",
          "LinearMap",
          "transvection",
          "map",
          "given",
          "Dual",
          "linear"
        ]
      }
    },
    {
      "id": 4085,
      "before_code": "let \u27e8k, hks, hk\u27e9 := h.exists_gt n\n    (hn k hks).not_gt hk",
      "suggestion": "\r\ntheorem sSup_of_not_bddAbove {s : Set \u2115} (h : \u00acBddAbove s) : sSup s = 0 :=\r\n",
      "body": "```suggestion\r\ntheorem sSup_of_not_bddAbove {s : Set \u2115} (h : \u00acBddAbove s) : sSup s = 0 :=\r\n```",
      "path": "Mathlib/Data/Nat/Lattice.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hks",
          "not_gt",
          "exists_gt"
        ]
      }
    },
    {
      "id": 4086,
      "before_code": "theorem coe_one : (\u2191(1 : FractionalIdeal S P) : Submodule R P) = 1 := by\n  rw [coe_one_eq_coeSubmodule_top, coeSubmodule_top]",
      "suggestion": "\r\ntheorem mem_one {x : P} : x \u2208 (1 : FractionalIdeal S P) \u2194 \u2203 y, algebraMap R P y = x := by\r\n",
      "body": "```suggestion\r\ntheorem mem_one {x : P} : x \u2208 (1 : FractionalIdeal S P) \u2194 \u2203 y, algebraMap R P y = x := by\r\n```",
      "path": "Mathlib/RingTheory/FractionalIdeal/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "coeSubmodule_top",
          "theorem",
          "coe_one",
          "FractionalIdeal",
          "Submodule",
          "coe_one_eq_coeSubmodule_top"
        ]
      }
    },
    {
      "id": 4087,
      "before_code": "theorem Irrational.ne_rational {x : \u211d} (hx : Irrational x) (a b : \u2124) : x \u2260 a / b := by\n  rintro rfl; exact hx \u27e8a / b, by simp\u27e9",
      "suggestion": "theorem exists_rat_of_not_irrational {x : \u211d} (hx : \u00ac Irrational x) : \u2203 (q : \u211a), x = q := by\n",
      "body": "```suggestion\ntheorem exists_rat_of_not_irrational {x : \u211d} (hx : \u00ac Irrational x) : \u2203 (q : \u211a), x = q := by\n```",
      "path": "Mathlib/NumberTheory/Real/Irrational.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp"
        ],
        "topics": [
          "real",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "exact",
          "rintro",
          "simp",
          "rfl",
          "ne_rational",
          "Irrational"
        ]
      }
    },
    {
      "id": 4088,
      "before_code": "bot := \u27e8\u22a5, by simp\u27e9\n  bot_le _ _ := by simp +contextual",
      "suggestion": "\r\n    letI _ : Module A[G] W := \u03c1.instModuleMonoidAlgebraAsModule\r\n",
      "body": "```suggestion\r\n    letI _ : Module A[G] W := \u03c1.instModuleMonoidAlgebraAsModule\r\n```\r\nDoes this not work?",
      "path": "Mathlib/RepresentationTheory/Subrepresentation.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "contextual",
          "bot_le",
          "simp",
          "bot"
        ]
      }
    },
    {
      "id": 4089,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "theorem eval_iterate_derivative_eq_sum (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < #s)\n    {k : \u2115} (hk : k < #s) (x : F) :\n    (derivative^[k] P).eval x =\n      k.factorial * \u2211 i \u2208 s, (P.eval (v i) / \u220f j \u2208 s.erase i, (v i - v j)) *\n        \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (x - v a) := by\n",
      "body": "```suggestion\ntheorem eval_iterate_derivative_eq_sum (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < #s)\n    {k : \u2115} (hk : k < #s) (x : F) :\n    (derivative^[k] P).eval x =\n      k.factorial * \u2211 i \u2208 s, (P.eval (v i) / \u220f j \u2208 s.erase i, (v i - v j)) *\n        \u2211 t \u2208 (s.erase i).powersetCard (#s - (k + 1)), \u220f a \u2208 t, (x - v a) := by\n```\nSimilar to the above.",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 4090,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9",
      "suggestion": "  nth_rewrite 1 [eq_interpolate hvs hP]\n",
      "body": "```suggestion\n  nth_rewrite 1 [eq_interpolate hvs hP]\n```\nslightly less cumbersome?",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "sdiff_singleton_eq_erase",
          "exact",
          "insert_subset_iff",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 4096,
      "before_code": "variable [Abelian C]",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Algebra/Homology/ShortComplex/Exact.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Abelian",
          "variable"
        ]
      }
    },
    {
      "id": 4097,
      "before_code": "\u00b7 exact algebraMap_ne_zero (denom_ne_zero x)\n  \u00b7 exact algebraMap_ne_zero (denom_ne_zero y)",
      "suggestion": "  nth_rw 1 [\u2190 x.num_div_denom]\n",
      "body": "```suggestion\n  nth_rw 1 [\u2190 x.num_div_denom]\n```",
      "path": "Mathlib/FieldTheory/RatFunc/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "algebraMap_ne_zero",
          "denom_ne_zero"
        ]
      }
    },
    {
      "id": 4098,
      "before_code": "\u00b7 exact algebraMap_ne_zero (denom_ne_zero x)\n  \u00b7 exact algebraMap_ne_zero (denom_ne_zero y)",
      "suggestion": "  nth_rw 1 [\u2190 x.num_div_denom]\n",
      "body": "```suggestion\n  nth_rw 1 [\u2190 x.num_div_denom]\n```",
      "path": "Mathlib/FieldTheory/RatFunc/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "algebraMap_ne_zero",
          "denom_ne_zero"
        ]
      }
    },
    {
      "id": 4099,
      "before_code": "\u00b7 exact algebraMap_ne_zero (denom_ne_zero x)\n  \u00b7 exact algebraMap_ne_zero (denom_ne_zero y)",
      "suggestion": "theorem associated_denom_inv {x : RatFunc K} (hx : x \u2260 0) : Associated (denom x\u207b\u00b9) (num x) := by\n",
      "body": "Same here:\n```suggestion\ntheorem associated_denom_inv {x : RatFunc K} (hx : x \u2260 0) : Associated (denom x\u207b\u00b9) (num x) := by\n```",
      "path": "Mathlib/FieldTheory/RatFunc/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "algebraMap_ne_zero",
          "denom_ne_zero"
        ]
      }
    },
    {
      "id": 4100,
      "before_code": "lemma IsMulIndecomposable.apply_ne_one_iff_mem_closure\n    [Finite \u03b9] [InvolutiveInv \u03b9] [CommGroup S] [IsOrderedMonoid S]\n    (v : \u03b9 \u2192 G) (f : G \u2192* S) (i : \u03b9) (hi : v i \u2260 1) (hi' : v i\u207b\u00b9 = (v i)\u207b\u00b9) :\n    f (v i) \u2260 1 \u2194 v i    \u2208 closure (v '' baseOf v f) \u2228\n                 (v i)\u207b\u00b9 \u2208 closure (v '' baseOf v f) :=",
      "suggestion": "    f (v i) \u2260 1 \u2194 v i \u2208 closure (v '' baseOf v f) \u2228 (v i)\u207b\u00b9 \u2208 closure (v '' baseOf v f) :=\n",
      "body": "```suggestion\n    f (v i) \u2260 1 \u2194 v i \u2208 closure (v '' baseOf v f) \u2228 (v i)\u207b\u00b9 \u2208 closure (v '' baseOf v f) :=\n```",
      "path": "Mathlib/Algebra/Group/Irreducible/Indecomposable.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "IsMulIndecomposable",
          "Finite",
          "IsOrderedMonoid",
          "lemma",
          "InvolutiveInv",
          "closure",
          "CommGroup",
          "baseOf",
          "apply_ne_one_iff_mem_closure"
        ]
      }
    },
    {
      "id": 4101,
      "before_code": "theorem X_ne_zero : (X : RatFunc K) \u2260 0 :=\n  RatFunc.algebraMap_ne_zero Polynomial.X_ne_zero",
      "suggestion": "theorem eq_C_iff (f : RatFunc K) :\n    (\u2203 c, f = C c) \u2194 f.num.natDegree = 0 \u2227 f.denom.natDegree = 0 := by\n",
      "body": "I think this is more readable as\n```suggestion\ntheorem eq_C_iff (f : RatFunc K) :\n    (\u2203 c, f = C c) \u2194 f.num.natDegree = 0 \u2227 f.denom.natDegree = 0 := by\n```",
      "path": "Mathlib/FieldTheory/RatFunc/AsPolynomial.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "algebraMap_ne_zero",
          "RatFunc",
          "X_ne_zero",
          "Polynomial"
        ]
      }
    },
    {
      "id": 4102,
      "before_code": "theorem X_ne_zero : (X : RatFunc K) \u2260 0 :=\n  RatFunc.algebraMap_ne_zero Polynomial.X_ne_zero",
      "suggestion": "  rw [\u2190 num_div_denom f, \u2190 ha, \u2190 hb, algebraMap_C, algebraMap_C, map_div\u2080]\n",
      "body": "```suggestion\n  rw [\u2190 num_div_denom f, \u2190 ha, \u2190 hb, algebraMap_C, algebraMap_C, map_div\u2080]\n```",
      "path": "Mathlib/FieldTheory/RatFunc/AsPolynomial.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "theorem",
          "algebraMap_ne_zero",
          "RatFunc",
          "X_ne_zero",
          "Polynomial"
        ]
      }
    },
    {
      "id": 4103,
      "before_code": "open TensorProduct",
      "suggestion": "",
      "body": "This should no longer be necessary since your PR.\n```suggestion\n```",
      "path": "Mathlib/RingTheory/Etale/QuasiFinite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "TensorProduct",
          "open"
        ]
      }
    },
    {
      "id": 4104,
      "before_code": "Over an artinian ring, an algebra is quasi-finite iff it is module-finite.\n- `Algebra.QuasiFinite.iff_finite_comap_preimage_singleton`: For a finite-type `R`-algebra `S`,\n  `S` is quasi-finite if and only if `Spec S \u2192 Spec R` has finite fibers.",
      "suggestion": "- `Algebra.QuasiFiniteAt`: If `S` is an `R`-algebra and `p` a prime of `S`, we say that `S` is `R`-quasi-finite at `p`\n  if `S\u209a` is `R`-quasi-finite.\n",
      "body": "```suggestion\n- `Algebra.QuasiFiniteAt`: If `S` is an `R`-algebra and `p` a prime of `S`, we say that `S` is `R`-quasi-finite at `p`\n  if `S\u209a` is `R`-quasi-finite.\n```\nI find \"The class of primes that is quasi-finite\" confusing, because it is not really a property of an ideal, but a property of an algebra wrt. to some ideal. So how about just removing that sentence?",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "only",
          "iff_finite_comap_preimage_singleton",
          "For",
          "Spec",
          "algebra",
          "Over",
          "fibers",
          "module",
          "Algebra",
          "iff",
          "artinian",
          "finite",
          "quasi",
          "QuasiFinite",
          "type",
          "ring",
          "has"
        ]
      }
    },
    {
      "id": 4105,
      "before_code": "end QuasiFinite",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 4106,
      "before_code": "end QuasiFinite\n\nend Algebra",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/RingTheory/QuasiFinite/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Algebra",
          "QuasiFinite",
          "end"
        ]
      }
    },
    {
      "id": 4107,
      "before_code": "defined as `{0}` and `\u2293` defined as intersection of the underlying carrier.\nIf `p` and `q` are submodules of a module, `p \u2264 q` means that `p \u2286 q`.\n\nMany results about operations on this lattice structure are defined in `LinearAlgebra/Basic.lean`,\nmost notably those which use `span`.",
      "suggestion": "",
      "body": "I don't think this comment is really helping anyone and is in danger of breaking again, let's just excise it.\n```suggestion\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Lattice.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "those",
          "results",
          "which",
          "lean",
          "intersection",
          "lattice",
          "operations",
          "most",
          "submodules",
          "Basic",
          "structure",
          "are",
          "notably",
          "LinearAlgebra",
          "underlying",
          "module",
          "span",
          "that",
          "defined",
          "use",
          "about",
          "this",
          "means",
          "carrier",
          "Many"
        ]
      }
    },
    {
      "id": 4109,
      "before_code": "/-- A line contains a space before a semicolon -/\n  | semicolon\n  /-- A line contains a non-breaking space character -/\n  | nonbreakingSpace",
      "suggestion": "\r\n  | nonbreakingSpace\r\n",
      "body": "```suggestion\r\n  | nonbreakingSpace\r\n```",
      "path": "Mathlib/Tactic/Linter/TextBased.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "breaking",
          "space",
          "contains",
          "character",
          "semicolon",
          "non",
          "nonbreakingSpace",
          "line",
          "before"
        ]
      }
    },
    {
      "id": 4110,
      "before_code": "end",
      "suggestion": "\r\n@[inherit_doc linter.unicodeLinter]\r\n",
      "body": "```suggestion\r\n@[inherit_doc linter.unicodeLinter]\r\n```",
      "path": "Mathlib/Tactic/Linter/TextBased.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 4114,
      "before_code": "It will also reorder arguments of certain functions, using `reorderFn`:\ne.g. `g x\u2081 x\u2082 x\u2083 ... x\u2099` becomes `g x\u2082 x\u2081 x\u2083 ... x\u2099` if `reorderFn g = some [1]`.\n-/\ndef applyReplacementFun (t : TranslateData) (e : Expr) (dontTranslate : Array FVarId := #[]) :\n    MetaM Expr := do\n  let e' := aux (\u2190 getEnv) (\u2190 getBoolOption `trace.translate_detail) (\u2190 expand t e)\n  -- Make sure any new reserved names in the expr are realized; this needs to be done outside of\n  -- `aux` as it is monadic.\n  e'.getUsedConstants.forM fun n => do\n    if !(\u2190 hasConst (skipRealize := false) n) && isReservedName (\u2190 getEnv) n then\n      executeReservedNameAction n\n  return e'\nwhere /-- Implementation of `applyReplacementFun`. -/\n  aux (env : Environment) (trace : Bool) : Expr \u2192 Expr :=\n  memoFix fun r e \u21a6 Id.run do\n    if trace then\n      dbg_trace s!\"replacing at {e}\"\n    if !(e matches .const .. | .app ..) then\n      e.traverseChildren r\n    else e.withApp fun f args \u21a6 do\n      let .const n\u2080 ls\u2080 := f | return mkAppN (\u2190 r f) (\u2190 args.mapM r)",
      "suggestion": "\r\n      let e \u2190 visit (e.instantiateRev fvars)\r\n      withLCtx lctx {} do mkForallFVars fvars e\r\n",
      "body": "```suggestion\r\n      let e \u2190 visit (e.instantiateRev fvars)\r\n      withLCtx lctx {} do mkForallFVars fvars e\r\n```\r\nIMO combining the lines makes this harder to read, same above",
      "path": "Mathlib/Tactic/Translate/Core.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "withApp",
          "done",
          "trace",
          "isReservedName",
          "translate_detail",
          "MetaM",
          "Expr",
          "mapM",
          "expand",
          "dbg_trace",
          "reorderFn",
          "run",
          "traverseChildren",
          "const",
          "becomes",
          "dontTranslate",
          "TranslateData",
          "new",
          "FVarId",
          "applyReplacementFun",
          "using",
          "aux",
          "replacing",
          "else",
          "outside",
          "Array",
          "needs",
          "monadic",
          "are",
          "false",
          "skipRealize",
          "also",
          "Environment",
          "arguments",
          "getBoolOption",
          "Make",
          "def",
          "realized",
          "then",
          "getEnv",
          "sure",
          "mkAppN",
          "app",
          "return",
          "names",
          "env",
          "hasConst",
          "memoFix",
          "will",
          "certain"
        ]
      }
    },
    {
      "id": 4115,
      "before_code": "characteristic f \u22a4 - characteristic (f \u00b7 - a\u2080) \u22a4 = proximity f \u22a4 - proximity (f \u00b7 - a\u2080) \u22a4 := by\n  simp [\u2190 Pi.sub_def, characteristic, logCounting_sub_const h]",
      "suggestion": "\r\ntheorem characteristic_even {a : WithTop E} :\r\n    (characteristic f a).Even := proximity_even.add logCounting_even\r\n",
      "body": "You can use dot notation a lot in this PR. Some opportunities elsewhere too.\r\n```suggestion\r\ntheorem characteristic_even {a : WithTop E} :\r\n    (characteristic f a).Even := proximity_even.add logCounting_even\r\n```",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CharacteristicFunction.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "logCounting_sub_const",
          "proximity",
          "sub_def",
          "characteristic",
          "simp"
        ]
      }
    },
    {
      "id": 4116,
      "before_code": "isLocalizedModule_iff_isLocalization.mp inferInstance\n  inferInstance",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nthis one was doing nothing it seems",
      "path": "Mathlib/RingTheory/Kaehler/TensorProduct.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "isLocalizedModule_iff_isLocalization",
          "inferInstance"
        ]
      }
    },
    {
      "id": 4117,
      "before_code": "rw [direction_altitude]\n  exact (Submodule.isOrtho_orthogonal_right _).mono_right inf_le_left",
      "suggestion": "\r\n    (s.restrict S hS).altitude i = (s.altitude i).comap S.subtype := by\r\n",
      "body": "nit:\r\n```suggestion\r\n    (s.restrict S hS).altitude i = (s.altitude i).comap S.subtype := by\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Altitude.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "direction_altitude",
          "exact",
          "isOrtho_orthogonal_right",
          "mono_right",
          "Submodule",
          "inf_le_left"
        ]
      }
    },
    {
      "id": 4118,
      "before_code": "\u00b7 rw [Finset.sum_comp_equiv]\n    simp",
      "suggestion": "\r\n  ext i : 1\r\n",
      "body": "fwiw, this can also be spelt as\r\n```suggestion\r\n  ext i : 1\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Incenter.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "sum_comp_equiv",
          "Finset",
          "simp"
        ]
      }
    },
    {
      "id": 4119,
      "before_code": "rw [direction_altitude]\n  exact (Submodule.isOrtho_orthogonal_right _).mono_right inf_le_left",
      "suggestion": "\r\n    (s.restrict S hS).altitude i = (s.altitude i).comap S.subtype := by\r\n",
      "body": "```suggestion\r\n    (s.restrict S hS).altitude i = (s.altitude i).comap S.subtype := by\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Altitude.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "direction_altitude",
          "exact",
          "isOrtho_orthogonal_right",
          "mono_right",
          "Submodule",
          "inf_le_left"
        ]
      }
    },
    {
      "id": 4120,
      "before_code": "(fun i hi => \u27e8b x i, \u27e8(hbasis x).mem_of_mem hi, hconnected x i hi\u27e9, subset_rfl\u27e9) fun s hs =>\n      \u27e8(hbasis x).index s hs.1, \u27e8(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1\u27e9\u27e9",
      "suggestion": "\r\ntheorem IsTopologicalBasis.isOpen_isPreconnected [LocallyConnectedSpace \u03b1] :\r\n",
      "body": "WDYT about this name to allow the new-style dot notation?\r\n```suggestion\r\ntheorem IsTopologicalBasis.isOpen_isPreconnected [LocallyConnectedSpace \u03b1] :\r\n```\r\nAlso, WDYT about adding a version with `IsConnected`?",
      "path": "Mathlib/Topology/Connected/LocallyConnected.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "property_index",
          "index",
          "mem_of_mem",
          "set_index_subset",
          "subset_rfl",
          "hconnected",
          "hbasis"
        ]
      }
    },
    {
      "id": 4121,
      "before_code": "-- The attribute removal was confined to the previous section: this test confirms it.\nexample {a b : \u211d\u22650\u221e} (_ha : a \u2260 \u221e) (_hb : b \u2260 \u221e) : max a b < \u221e := by finiteness",
      "suggestion": "\r\n    (if c \u2260 37 \u2228 \u00acp then c + a else b + 1) < \u221e := by\r\n  finiteness\r\n",
      "body": "```suggestion\r\n    (if c \u2260 37 \u2228 \u00acp then c + a else b + 1) < \u221e := by\r\n  finiteness\r\n```",
      "path": "MathlibTest/finiteness.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "_hb",
          "finiteness",
          "example",
          "confirms",
          "was",
          "previous",
          "test",
          "this",
          "removal",
          "confined",
          "_ha",
          "max",
          "attribute",
          "section"
        ]
      }
    },
    {
      "id": 4122,
      "before_code": "-- The attribute removal was confined to the previous section: this test confirms it.\nexample {a b : \u211d\u22650\u221e} (_ha : a \u2260 \u221e) (_hb : b \u2260 \u221e) : max a b < \u221e := by finiteness",
      "suggestion": "\r\n    (if _ : a \u2260 \u221e then c + a else b + 1) < \u221e := by\r\n  finiteness\r\n\r\nexample {a b c : \u211d\u22650\u221e} (hb : b \u2260 \u221e) (hc : c \u2260 \u221e) :\r\n    (if a \u2260 \u221e then c + a else b + 1) < \u221e := by\r\n  finiteness\r\n",
      "body": "```suggestion\r\n    (if _ : a \u2260 \u221e then c + a else b + 1) < \u221e := by\r\n  finiteness\r\n\r\nexample {a b c : \u211d\u22650\u221e} (hb : b \u2260 \u221e) (hc : c \u2260 \u221e) :\r\n    (if a \u2260 \u221e then c + a else b + 1) < \u221e := by\r\n  finiteness\r\n```",
      "path": "MathlibTest/finiteness.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "_hb",
          "finiteness",
          "example",
          "confirms",
          "was",
          "previous",
          "test",
          "this",
          "removal",
          "confined",
          "_ha",
          "max",
          "attribute",
          "section"
        ]
      }
    },
    {
      "id": 4123,
      "before_code": "convert ((open_iff i subset_rfl).mp open_V).inter open_W using 1\n    refine Set.ext fun e \u21a6 and_right_comm.trans (and_congr_right fun \u27e8hV, hU\u27e9 \u21a6 ?_)\n    rw [Set.mem_preimage, dif_pos hV, inj i (inv_U i _) hU (f_inv i _)]",
      "suggestion": "\r\n  -- since f is a closed map, the union of the V\u2091' contains the preimage of a neighborhood U of x\r\n",
      "body": "```suggestion\r\n  -- since f is a closed map, the union of the V\u2091' contains the preimage of a neighborhood U of x\r\n```",
      "path": "Mathlib/Topology/Covering/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "refine",
          "ext"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "and_right_comm",
          "refine",
          "ext",
          "convert",
          "f_inv",
          "open_iff",
          "dif_pos",
          "inter",
          "and_congr_right",
          "subset_rfl",
          "open_W",
          "inv_U",
          "Set",
          "trans",
          "mem_preimage",
          "using",
          "open_V",
          "inj"
        ]
      }
    },
    {
      "id": 4126,
      "before_code": "theorem adjoin_eq_top_of_algebra (hS : Algebra.adjoin F S = \u22a4) : adjoin F S = \u22a4 :=\n  top_le_iff.mp (hS.symm.trans_le <| algebra_adjoin_le_adjoin F S)",
      "suggestion": "end FG\n\n",
      "body": "```suggestion\nend FG\n\n```",
      "path": "Mathlib/FieldTheory/IntermediateField/Adjoin/Algebra.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "trans_le",
          "symm",
          "algebra_adjoin_le_adjoin",
          "theorem",
          "adjoin",
          "Algebra",
          "adjoin_eq_top_of_algebra",
          "top_le_iff"
        ]
      }
    },
    {
      "id": 4127,
      "before_code": "variable {F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]\n\n/-- An intermediate field `S` is finitely generated if there exists `t : Finset E` such that\n`IntermediateField.adjoin F t = S`. -/",
      "suggestion": "We use the class `Algebra.EssFiniteType F E` instead of `(\u22a4 : IntermediateField F E).FG` to say that\n`E` is finitely generated as an `F` extension.\nSee `IntermediateField.fg_top_iff`. -/\n",
      "body": "How about something like:\n```suggestion\nWe use the class `Algebra.EssFiniteType F E` instead of `(\u22a4 : IntermediateField F E).FG` to say that\n`E` is finitely generated as an `F` extension.\nSee `IntermediateField.fg_top_iff`. -/\n```\nTo make it clearer that this is the preferred form.",
      "path": "Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "variable",
          "IntermediateField",
          "Finset",
          "Type",
          "generated",
          "Field",
          "that",
          "exists",
          "there",
          "finitely",
          "adjoin",
          "Algebra",
          "such",
          "intermediate",
          "field"
        ]
      }
    },
    {
      "id": 4128,
      "before_code": "rw [\u2190 Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]",
      "suggestion": "\r\ntheorem center_eq_bot_of_odd_ne_one (hodd : Odd n) (hne1 : n \u2260 1) :\r\n",
      "body": "```suggestion\r\ntheorem center_eq_bot_of_odd_ne_one (hodd : Odd n) (hne1 : n \u2260 1) :\r\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "finset",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "two_pos",
          "mul_div_mul_left",
          "mul_pos",
          "card_comm_eq_card_conjClasses_mul_card",
          "card_commute_odd",
          "Nat",
          "pos",
          "mul_div_left",
          "mul_comm",
          "nat_card"
        ]
      }
    },
    {
      "id": 4130,
      "before_code": "rintro \u27e8i, hi, x, hx, rfl\u27e9\n      have := heq \u25b8 mem_sSup.mpr \u27e8i.1, i.2, hx\u27e9\n      exact this",
      "suggestion": "\r\n    \u2203 (W : Set X), IsCompact W \u2227 IsOpen W \u2227 K \u2286 W \u2227 W \u2286 U := by\r\n",
      "body": "```suggestion\r\n    \u2203 (W : Set X), IsCompact W \u2227 IsOpen W \u2227 K \u2286 W \u2227 W \u2286 U := by\r\n```\r\n\r\noptional suggestion: I personally find it nicer to read this way.",
      "path": "Mathlib/Topology/Spectral/Prespectral.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "have"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "mem_sSup",
          "mpr",
          "exact",
          "have",
          "this",
          "rintro",
          "heq",
          "rfl"
        ]
      }
    },
    {
      "id": 4131,
      "before_code": "/-- `0` is right-absorbing. -/\n  lcm_zero_right : \u2200 a, lcm a 0 = 0\n\n/-- Normalized GCD monoid: a `CancelCommMonoidWithZero` with normalization and `gcd`\n(greatest common divisor) and `lcm` (least common multiple) operations. In this setting `gcd` and\n`lcm` form a bounded lattice on the associated elements where `gcd` is the infimum, `lcm` is the\nsupremum, `1` is bottom, and `0` is top. The type class focuses on `gcd` and we derive the\ncorresponding `lcm` facts from `gcd`.\n-/\nclass NormalizedGCDMonoid (\u03b1 : Type*) [CancelCommMonoidWithZero \u03b1] extends NormalizationMonoid \u03b1,\n  GCDMonoid \u03b1 where",
      "suggestion": "\r\nclass NormalizedGCDMonoid (\u03b1 : Type*) [CommMonoidWithZero \u03b1] extends NormalizationMonoid \u03b1,\r\n    GCDMonoid \u03b1, IsCancelMulZero \u03b1 where\r\n",
      "body": "Why not\r\n```suggestion\r\nclass NormalizedGCDMonoid (\u03b1 : Type*) [CommMonoidWithZero \u03b1] extends NormalizationMonoid \u03b1,\r\n    GCDMonoid \u03b1, IsCancelMulZero \u03b1 where\r\n```",
      "path": "Mathlib/Algebra/GCDMonoid/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "GCDMonoid",
          "top",
          "Type",
          "class",
          "type",
          "elements",
          "bottom",
          "facts",
          "operations",
          "lattice",
          "lcm_zero_right",
          "form",
          "right",
          "corresponding",
          "associated",
          "NormalizedGCDMonoid",
          "normalization",
          "lcm",
          "Normalized",
          "infimum",
          "setting",
          "common",
          "supremum",
          "CancelCommMonoidWithZero",
          "least",
          "monoid",
          "greatest",
          "bounded",
          "derive",
          "GCD",
          "gcd",
          "multiple",
          "this",
          "extends",
          "divisor",
          "from",
          "NormalizationMonoid",
          "absorbing",
          "focuses"
        ]
      }
    },
    {
      "id": 4133,
      "before_code": "example (a : \u211d) : (ENNReal.ofReal (1 + a ^ 2))\u207b\u00b9 < \u221e := by finiteness",
      "suggestion": "\r\n-- `finiteness_nonterminal` is allowed to close goals.\r\n-- (In practice, this is a code smell; `finiteness` should be used directly.)\r\n",
      "body": "```suggestion\r\n-- `finiteness_nonterminal` is allowed to close goals.\r\n-- (In practice, this is a code smell; `finiteness` should be used directly.)\r\n```",
      "path": "MathlibTest/finiteness.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "finiteness",
          "example",
          "ENNReal",
          "ofReal"
        ]
      }
    },
    {
      "id": 4140,
      "before_code": "(S.map F).exact_and_mono_f_iff_f_is_kernel |>.2 \u27e8KernelFork.mapIsLimit _ hS.fIsKernel F\u27e9\n  tfae_finish",
      "suggestion": "\r\n  (Functor.preservesFiniteLimits_tfae F).out 3 0\r\n",
      "body": "```suggestion\r\n  (Functor.preservesFiniteLimits_tfae F).out 3 0\r\n```",
      "path": "Mathlib/Algebra/Homology/ShortComplex/ExactFunctor.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact_and_mono_f_iff_f_is_kernel",
          "fIsKernel",
          "mapIsLimit",
          "map",
          "tfae_finish",
          "KernelFork"
        ]
      }
    },
    {
      "id": 4141,
      "before_code": "| \u27e8h1, h2\u27e9, _, h => h.map F\n  tfae_finish",
      "suggestion": "\r\n  (Functor.preservesFiniteColimits_tfae F).out 3 0\r\n",
      "body": "```suggestion\r\n  (Functor.preservesFiniteColimits_tfae F).out 3 0\r\n```",
      "path": "Mathlib/Algebra/Homology/ShortComplex/ExactFunctor.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "map",
          "tfae_finish"
        ]
      }
    },
    {
      "id": 4142,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "theorem cyclotomic_dvd_of_mahlerMeasure_eq_one (hX : \u00ac X \u2223 p) (hpdeg : p.degree \u2260 0) :\n",
      "body": "The theorem name \"cyclotomomic_dvd_of_mahlerMeasure_eq_one\" has a typo. It should be \"cyclotomic_dvd_of_mahlerMeasure_eq_one\" (missing an 'm').\n```suggestion\ntheorem cyclotomic_dvd_of_mahlerMeasure_eq_one (hX : \u00ac X \u2223 p) (hpdeg : p.degree \u2260 0) :\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 4143,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  let : NumberField K := {\n",
      "body": "```suggestion\n  let : NumberField K := {\n```\nNo need to inline this (and `let` nowadays does not insist on a name...)",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 4144,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  -- `y` is `z` as an element of `K`\n",
      "body": "```suggestion\n  -- `y` is `z` as an element of `K`\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 4145,
      "before_code": "intro _ hz\n  exact (IsPrimitiveRoot.norm'_eq_one (isPrimitiveRoot_of_mem_primitiveRoots hz) hn).le",
      "suggestion": "  rw [cyclotomic_eq_minpoly h_prim h_m_pos]\n",
      "body": "```suggestion\n  rw [cyclotomic_eq_minpoly h_prim h_m_pos]\n```",
      "path": "Mathlib/NumberTheory/MahlerMeasure.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "intro"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "intro"
        ],
        "topics": [
          "set_theory",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "_eq_one",
          "isPrimitiveRoot_of_mem_primitiveRoots",
          "exact",
          "norm",
          "intro",
          "IsPrimitiveRoot"
        ]
      }
    },
    {
      "id": 4146,
      "before_code": "ext\n  simp",
      "suggestion": "\r\n    [IsLocalizedModule S g\u2081] [IsLocalizedModule S g\u2082] (l : M \u2192\u2097[R] N) :\r\n",
      "body": "```suggestion\r\n    [IsLocalizedModule S g\u2081] [IsLocalizedModule S g\u2082] (l : M \u2192\u2097[R] N) :\r\n```",
      "path": "Mathlib/RingTheory/Localization/Module.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 4147,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 4148,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 4149,
      "before_code": "refine \u27e8inferInstance, \u27e8Empty, Module.Basis.empty \u03a9[S\u2044R], ?_\u27e9\u27e9\n  simp [Set.range_subset_iff]",
      "suggestion": "\r\n  \u00b7 grind\r\n",
      "body": "```suggestion\r\n  \u00b7 grind\r\n```\r\nOr just merge it into the refine.",
      "path": "Mathlib/RingTheory/Smooth/StandardSmoothOfFree.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind",
          "refine"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp",
          "refine"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Module",
          "inferInstance",
          "empty",
          "Basis",
          "refine",
          "Empty",
          "Set",
          "simp",
          "range_subset_iff"
        ]
      }
    },
    {
      "id": 4150,
      "before_code": "guard_hyp f : \u03b1 \u2192 \u03b1 \u00d7 \u03b1\n  guard_hyp h : \u2200 (i : \u03b1), p i \u2192 p (f i).1\n  trivial",
      "suggestion": "\r\n  choose (n : Nat) (hn : n > 0 + 0) using h\r\n",
      "body": "Can you add a test with\r\n```suggestion\r\n  choose (n : Nat) (hn : n > 0 + 0) using h\r\n```\r\nto record\r\n* whether this succeeds, and\r\n* what the type of `hn` is when it does?",
      "path": "MathlibTest/choose.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "guard_hyp",
          "trivial"
        ]
      }
    },
    {
      "id": 4151,
      "before_code": "guard_hyp f : \u03b1 \u2192 \u03b1 \u00d7 \u03b1\n  guard_hyp h : \u2200 (i : \u03b1), p i \u2192 p (f i).1\n  trivial",
      "suggestion": "\r\n  choose n (hn : n < _) using h\r\n",
      "body": "Could you include\r\n```suggestion\r\n  choose n (hn : n < _) using h\r\n```\r\nas a test as well?",
      "path": "MathlibTest/choose.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "guard_hyp",
          "trivial"
        ]
      }
    },
    {
      "id": 4152,
      "before_code": "instance : HasFiniteProducts C := hasFiniteProducts_of_has_binary_and_terminal\ninstance : HasFiniteCoproducts C := hasFiniteCoproducts_of_has_binary_and_initial\ninstance : HasFiniteBiproducts C := HasFiniteBiproducts.of_hasFiniteProducts",
      "suggestion": "\r\n",
      "body": "It compiles just fine on my machine without this\r\n```suggestion\r\n```",
      "path": "Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hasFiniteCoproducts_of_has_binary_and_initial",
          "of_hasFiniteProducts",
          "hasFiniteProducts_of_has_binary_and_terminal",
          "HasFiniteProducts",
          "HasFiniteCoproducts",
          "HasFiniteBiproducts",
          "instance"
        ]
      }
    },
    {
      "id": 4153,
      "before_code": "obtain \u27e8u, hut, hu, hu'\u27e9 := decomposition_erase_inf ht\n  exact \u27e8u, hu, fun _ hi \u21a6 ht' (hut hi), ht''.mono hut, hu'\u27e9\n\nlemma IsLasker.minimal [DecidableEq (Ideal R)] (h : IsLasker R) (I : Ideal R) :\n    \u2203 t : Finset (Ideal R), t.inf id = I \u2227 (\u2200 \u2983J\u2984, J \u2208 t \u2192 J.IsPrimary) \u2227\n      ((t : Set (Ideal R)).Pairwise ((\u00b7 \u2260 \u00b7) on radical)) \u2227\n      (\u2200 \u2983J\u2984, J \u2208 t \u2192 \u00ac (t.erase J).inf id \u2264 J) := by\n  obtain \u27e8s, hs, hs'\u27e9 := h I\n  exact exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs hs'",
      "suggestion": "\r\n    (I : Ideal R) (t : Finset (Ideal R)) : Prop where\r\n",
      "body": "```suggestion\r\n    (I : Ideal R) (t : Finset (Ideal R)) : Prop where\r\n```",
      "path": "Mathlib/RingTheory/Lasker.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "IsLasker",
          "erase",
          "lemma",
          "Ideal",
          "mono",
          "radical",
          "exact",
          "inf",
          "Finset",
          "hut",
          "Set",
          "IsPrimary",
          "obtain",
          "Pairwise",
          "minimal",
          "DecidableEq",
          "exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition",
          "decomposition_erase_inf"
        ]
      }
    },
    {
      "id": 4154,
      "before_code": "alias order_mul_ge := le_order_mul\n\ntheorem order_ne_zero_iff_constCoeff_eq_zero {\u03c6 : R\u27e6X\u27e7} :\n    \u03c6.order \u2260 0 \u2194 \u03c6.constantCoeff = 0 := by\n  constructor\n  \u00b7 intro h\n    rw [\u2190 PowerSeries.coeff_zero_eq_constantCoeff]\n    apply coeff_of_lt_order\n    simpa using pos_of_ne_zero h\n  \u00b7 intro h\n    refine ENat.one_le_iff_ne_zero.mp <| PowerSeries.le_order _ _ fun d hd \u21a6 ?_\n    rw [Nat.cast_lt_one] at hd\n    simp [hd, h]",
      "suggestion": "\r\n    \u03c6.order \u2260 0 \u2194 \u03c6.constantCoeff = 0 := by\r\n  rw [\u2190 ENat.one_le_iff_ne_zero, one_le_order_iff_constCoeff_eq_zero]\r\n",
      "body": "```suggestion\r\n    \u03c6.order \u2260 0 \u2194 \u03c6.constantCoeff = 0 := by\r\n  rw [\u2190 ENat.one_le_iff_ne_zero, one_le_order_iff_constCoeff_eq_zero]\r\n```",
      "path": "Mathlib/RingTheory/PowerSeries/Order.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "refine",
          "simpa",
          "constructor",
          "simp",
          "intro"
        ],
        "topics": [
          "list",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "le_order",
          "order_mul_ge",
          "coeff_zero_eq_constantCoeff",
          "alias",
          "apply",
          "refine",
          "Nat",
          "cast_lt_one",
          "constructor",
          "order_ne_zero_iff_constCoeff_eq_zero",
          "intro",
          "constantCoeff",
          "PowerSeries",
          "simp",
          "pos_of_ne_zero",
          "coeff_of_lt_order",
          "le_order_mul",
          "theorem",
          "one_le_iff_ne_zero",
          "simpa",
          "order",
          "ENat",
          "using"
        ]
      }
    },
    {
      "id": 4155,
      "before_code": "(f : \u03b9 \u2192 MvPowerSeries \u03c3 R) (s : Finset \u03b9) : \u2211 i \u2208 s, (f i).order \u2264 (\u220f i \u2208 s, f i).order :=\n  le_weightedOrder_prod _ _ _\n\ntheorem order_ne_zero_iff_constCoeff_eq_zero :\n    f.order \u2260 0 \u2194 f.constantCoeff = 0 := by\n  constructor\n  \u00b7 intro h\n    apply coeff_of_lt_order\n    simpa using pos_of_ne_zero h\n  \u00b7 intro h\n    refine ENat.one_le_iff_ne_zero.mp <| MvPowerSeries.le_order fun d hd \u21a6 ?_\n    rw [Nat.cast_lt_one] at hd\n    simp [(degree_eq_zero_iff d).mp hd, h]",
      "suggestion": "\r\n  rw [\u2190 ENat.one_le_iff_ne_zero, one_le_order_iff_constCoeff_eq_zero]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 ENat.one_le_iff_ne_zero, one_le_order_iff_constCoeff_eq_zero]\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Order.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "refine",
          "simpa",
          "constructor",
          "simp",
          "intro"
        ],
        "topics": [
          "list",
          "nat",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "le_order",
          "apply",
          "refine",
          "Nat",
          "Finset",
          "cast_lt_one",
          "constructor",
          "order_ne_zero_iff_constCoeff_eq_zero",
          "intro",
          "constantCoeff",
          "degree_eq_zero_iff",
          "simp",
          "pos_of_ne_zero",
          "coeff_of_lt_order",
          "theorem",
          "le_weightedOrder_prod",
          "one_le_iff_ne_zero",
          "MvPowerSeries",
          "simpa",
          "order",
          "ENat",
          "using"
        ]
      }
    },
    {
      "id": 4156,
      "before_code": "(f : \u03b9 \u2192 MvPowerSeries \u03c3 R) (s : Finset \u03b9) : \u2211 i \u2208 s, (f i).order \u2264 (\u220f i \u2208 s, f i).order :=\n  le_weightedOrder_prod _ _ _\n\ntheorem order_ne_zero_iff_constCoeff_eq_zero :\n    f.order \u2260 0 \u2194 f.constantCoeff = 0 := by\n  constructor\n  \u00b7 intro h\n    apply coeff_of_lt_order\n    simpa using pos_of_ne_zero h\n  \u00b7 intro h\n    refine ENat.one_le_iff_ne_zero.mp <| MvPowerSeries.le_order fun d hd \u21a6 ?_\n    rw [Nat.cast_lt_one] at hd\n    simp [(degree_eq_zero_iff d).mp hd, h]",
      "suggestion": "\r\ntheorem le_order_pow_of_constantCoeff_eq_zero (n : \u2115) (hf : f.constantCoeff = 0) :\r\n",
      "body": "```suggestion\r\ntheorem le_order_pow_of_constantCoeff_eq_zero (n : \u2115) (hf : f.constantCoeff = 0) :\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Order.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "simpa",
          "rw",
          "simp",
          "constructor",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "apply",
          "rw",
          "refine",
          "simp",
          "constructor",
          "intro"
        ],
        "topics": [
          "list",
          "nat",
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "le_order",
          "apply",
          "refine",
          "Nat",
          "Finset",
          "cast_lt_one",
          "constructor",
          "order_ne_zero_iff_constCoeff_eq_zero",
          "intro",
          "constantCoeff",
          "degree_eq_zero_iff",
          "simp",
          "pos_of_ne_zero",
          "coeff_of_lt_order",
          "theorem",
          "le_weightedOrder_prod",
          "one_le_iff_ne_zero",
          "MvPowerSeries",
          "simpa",
          "order",
          "ENat",
          "using"
        ]
      }
    },
    {
      "id": 4157,
      "before_code": "finsum (fun d \u21a6 coeff d f \u2022 (constantCoeff (d.prod fun s e => (a s) ^ e))) := by\n  simp only [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_subst ha f 0]",
      "suggestion": "\r\ntheorem constantCoeff_subst_eq_zero [Fintype \u03c3] (ha : \u2200 i, (a i).constantCoeff = 0)\r\n",
      "body": "```suggestion\r\ntheorem constantCoeff_subst_eq_zero [Fintype \u03c3] (ha : \u2200 i, (a i).constantCoeff = 0)\r\n```\r\nYou should assume `HasSubst a` instead of `Fintype` here.",
      "path": "Mathlib/RingTheory/MvPowerSeries/Substitution.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "coeff",
          "prod",
          "coeff_zero_eq_constantCoeff_apply",
          "coeff_subst",
          "simp",
          "finsum",
          "constantCoeff",
          "only"
        ]
      }
    },
    {
      "id": 4158,
      "before_code": "@[deprecated (since := \"2025-12-20\")] alias SRel.trans := vlt.trans\n\nlemma vle_mul_right_iff (hc : 0 <\u1d65 c) : a * c \u2264\u1d65 b * c \u2194 a \u2264\u1d65 b :=\n  \u27e8vle_mul_cancel hc, vle_mul_right _\u27e9\n\n@[deprecated (since := \"2025-12-20\")] alias rel_mul_right_iff := vle_mul_right_iff\n\nlemma vle_mul_left_iff (hc : 0 <\u1d65 c) : c * a \u2264\u1d65 c * b \u2194 a \u2264\u1d65 b := by\n  simp [mul_comm c, vle_mul_right_iff hc]\n\n@[deprecated (since := \"2025-12-20\")] alias rel_mul_left_iff := vle_mul_left_iff\n\nlemma vlt_mul_right_iff (hc : 0 <\u1d65 c) : a * c <\u1d65 b * c \u2194 a <\u1d65 b :=\n  (vle_mul_right_iff hc).not\n\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_right_iff := vlt_mul_right_iff\n\n@[gcongr] alias \u27e8_, vlt_mul_right\u27e9 := vlt_mul_right_iff\n\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_right := vlt_mul_right",
      "suggestion": "\r\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_right := mul_vlt_mul_right\r\n",
      "body": "```suggestion\r\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_right := mul_vlt_mul_right\r\n```\r\nI thought `vlt_mul_right` is deprecated to `mul_vlt_mul_right`? Why doesn't the linter complain here?",
      "path": "Mathlib/RingTheory/Valuation/ValuativeRel/Basic.lean",
      "tags": {
        "before_tactics": [
          "gcongr",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "gcongr",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "vlt_mul_right_iff",
          "srel_mul_right",
          "since",
          "alias",
          "gcongr",
          "srel_mul_right_iff",
          "vle_mul_right",
          "mul_comm",
          "vle_mul_right_iff",
          "simp",
          "vle_mul_cancel",
          "vlt_mul_right",
          "rel_mul_right_iff",
          "vlt",
          "SRel",
          "trans",
          "rel_mul_left_iff",
          "vle_mul_left_iff",
          "deprecated"
        ]
      }
    },
    {
      "id": 4159,
      "before_code": "@[deprecated (since := \"2025-12-20\")] alias SRel.trans := vlt.trans\n\nlemma vle_mul_right_iff (hc : 0 <\u1d65 c) : a * c \u2264\u1d65 b * c \u2194 a \u2264\u1d65 b :=\n  \u27e8vle_mul_cancel hc, vle_mul_right _\u27e9\n\n@[deprecated (since := \"2025-12-20\")] alias rel_mul_right_iff := vle_mul_right_iff\n\nlemma vle_mul_left_iff (hc : 0 <\u1d65 c) : c * a \u2264\u1d65 c * b \u2194 a \u2264\u1d65 b := by\n  simp [mul_comm c, vle_mul_right_iff hc]\n\n@[deprecated (since := \"2025-12-20\")] alias rel_mul_left_iff := vle_mul_left_iff\n\nlemma vlt_mul_right_iff (hc : 0 <\u1d65 c) : a * c <\u1d65 b * c \u2194 a <\u1d65 b :=\n  (vle_mul_right_iff hc).not\n\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_right_iff := vlt_mul_right_iff\n\n@[gcongr] alias \u27e8_, vlt_mul_right\u27e9 := vlt_mul_right_iff\n\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_right := vlt_mul_right\n\nlemma vlt_mul_left_iff (hc : 0 <\u1d65 c) : c * a <\u1d65 c * b \u2194 a <\u1d65 b :=\n  (vle_mul_left_iff hc).not\n\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_left_iff := vlt_mul_left_iff\n\n@[gcongr] alias \u27e8_, vlt_mul_left\u27e9 := vlt_mul_left_iff\n\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_left := vlt_mul_left",
      "suggestion": "\r\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_left := mul_vlt_mul_right\r\n",
      "body": "```suggestion\r\n@[deprecated (since := \"2025-12-20\")] alias srel_mul_left := mul_vlt_mul_right\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuativeRel/Basic.lean",
      "tags": {
        "before_tactics": [
          "gcongr",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "gcongr",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "vlt_mul_right_iff",
          "srel_mul_left",
          "srel_mul_right",
          "since",
          "vlt_mul_left_iff",
          "alias",
          "gcongr",
          "srel_mul_right_iff",
          "vle_mul_right",
          "srel_mul_left_iff",
          "vlt_mul_left",
          "mul_comm",
          "vle_mul_right_iff",
          "simp",
          "vle_mul_cancel",
          "vlt_mul_right",
          "rel_mul_right_iff",
          "vlt",
          "SRel",
          "trans",
          "rel_mul_left_iff",
          "vle_mul_left_iff",
          "deprecated"
        ]
      }
    },
    {
      "id": 4161,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "",
      "body": "```suggestion\n```\nNot needed",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 4162,
      "before_code": "(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) {i j : \u03b9} (hij : i \u2260 j) :\n    V i \u27c2 V j :=\n  hV.pairwise hij",
      "suggestion": "  Submodule.mem_orthogonal' K.toSubmodule v\n",
      "body": "```suggestion\n  Submodule.mem_orthogonal' K.toSubmodule v\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pairwise",
          "OrthogonalFamily",
          "hij"
        ]
      }
    },
    {
      "id": 4163,
      "before_code": "map_comp g g' := Precomp.map_comp F f (leOfHom g) (leOfHom g')\n\n/-- Constructor for `ComposableArrows C 2`. -/\n@[simp]\ndef mk\u2082 {X\u2080 X\u2081 X\u2082 : C} (f : X\u2080 \u27f6 X\u2081) (g : X\u2081 \u27f6 X\u2082) : ComposableArrows C 2 :=\n  (mk\u2081 g).precomp f",
      "suggestion": "abbrev mk\u2082 {X\u2080 X\u2081 X\u2082 : C} (f : X\u2080 \u27f6 X\u2081) (g : X\u2081 \u27f6 X\u2082) : ComposableArrows C 2 :=\n  (mk\u2081 g).precomp f\n",
      "body": "```suggestion\nabbrev mk\u2082 {X\u2080 X\u2081 X\u2082 : C} (f : X\u2080 \u27f6 X\u2081) (g : X\u2081 \u27f6 X\u2082) : ComposableArrows C 2 :=\n  (mk\u2081 g).precomp f\n```\nIs there a reason why you are using `@[reducible]` instead of `abbrev`?",
      "path": "Mathlib/CategoryTheory/ComposableArrows/Basic.lean",
      "tags": {
        "before_tactics": [
          "constructor",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "constructor",
          "simp"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "ComposableArrows",
          "def",
          "leOfHom",
          "map_comp",
          "Constructor",
          "precomp",
          "simp",
          "Precomp",
          "for"
        ]
      }
    },
    {
      "id": 4164,
      "before_code": "apply HomologicalComplex.isZero_single_obj_X\n      simp",
      "suggestion": "\r\n  \u03b9_f_zero_comp_hom : I.\u03b9.f 0 \u226b hom.f 0 = ((single\u2080 C).map f).f 0 \u226b I'.\u03b9.f 0\r\n",
      "body": "```suggestion\r\n  \u03b9_f_zero_comp_hom : I.\u03b9.f 0 \u226b hom.f 0 = ((single\u2080 C).map f).f 0 \u226b I'.\u03b9.f 0\r\n```\r\nsame kind of suggestion applies for other fields of structures like this one.",
      "path": "Mathlib/CategoryTheory/Preadditive/Injective/Resolution.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "apply",
          "HomologicalComplex",
          "simp",
          "isZero_single_obj_X"
        ]
      }
    },
    {
      "id": 4165,
      "before_code": "apply HomologicalComplex.isZero_single_obj_X\n      simp",
      "suggestion": "\r\nvariable {I I'}\r\n\r\n",
      "body": "```suggestion\r\nvariable {I I'}\r\n\r\n```\r\nI guess there should be a line break if it\u2019s not a `variable \u2026 in`.",
      "path": "Mathlib/CategoryTheory/Preadditive/Injective/Resolution.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [],
        "transforms": [
          "line_break"
        ],
        "keywords": [
          "apply",
          "HomologicalComplex",
          "simp",
          "isZero_single_obj_X"
        ]
      }
    },
    {
      "id": 4166,
      "before_code": "/-!\n# Adapted and progressively measurable processes\n\nThis file defines the related notions of a process `u` being `StronglyAdapted` or `ProgMeasurable`\n(progressively measurable) with respect to a filtration `f`, and proves some basic facts about them.\n\n## Main definitions\n\n* `MeasureTheory.StronglyAdapted`: a sequence of functions `u` is said to be strongly adapted to a",
      "suggestion": "* `MeasureTheory.StronglyAdapted`: a sequence of functions `u` is said to be strongly adapted to a\n",
      "body": "```suggestion\n* `MeasureTheory.StronglyAdapted`: a sequence of functions `u` is said to be strongly adapted to a\n```",
      "path": "Mathlib/Probability/Process/Adapted.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "file",
          "filtration",
          "said",
          "notions",
          "Main",
          "strongly",
          "facts",
          "This",
          "being",
          "ProgMeasurable",
          "StronglyAdapted",
          "processes",
          "respect",
          "related",
          "proves",
          "basic",
          "definitions",
          "sequence",
          "progressively",
          "defines",
          "process",
          "Adapted",
          "about",
          "them",
          "MeasureTheory",
          "adapted",
          "functions",
          "measurable",
          "some"
        ]
      }
    },
    {
      "id": 4167,
      "before_code": "**Uniform Boundedness Principle**. Fix `E` a barrelled space and `F` a TVS satisfying\n  `WithSeminorms q` for some `q`. Any family `\ud835\udcd5 : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F` of continuous linear maps\n  that is pointwise bounded is (uniformly) equicontinuous. Here, pointwise bounded means that\n  for all `k` and `x`, the family of real numbers `i \u21a6 q k (\ud835\udcd5 i x)` is bounded above,\n  which is equivalent to requiring that `\ud835\udcd5` is pointwise Von Neumann bounded\n  (see `WithSeminorms.image_isVonNBounded_iff_seminorm_bounded`).",
      "suggestion": "\r\n  Any family `\ud835\udcd5 : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F` of continuous linear maps that is pointwise von Neumann bounded\r\n",
      "body": "```suggestion\r\n  Any family `\ud835\udcd5 : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F` of continuous linear maps that is pointwise von Neumann bounded\r\n```",
      "path": "Mathlib/Analysis/LocallyConvex/Barrelled.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "order",
          "equiv",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "equicontinuous",
          "real",
          "which",
          "family",
          "barrelled",
          "Von",
          "Principle",
          "Uniform",
          "image_isVonNBounded_iff_seminorm_bounded",
          "satisfying",
          "WithSeminorms",
          "equivalent",
          "Boundedness",
          "see",
          "Fix",
          "linear",
          "for",
          "Here",
          "that",
          "requiring",
          "above",
          "Any",
          "bounded",
          "uniformly",
          "pointwise",
          "maps",
          "space",
          "continuous",
          "Neumann",
          "means",
          "TVS",
          "numbers",
          "all",
          "some"
        ]
      }
    },
    {
      "id": 4168,
      "before_code": "macro \"set!\" rest:setArgsRest : tactic => `(tactic| set ! $rest:setArgsRest)\n\nelab_rules : tactic\n| `(tactic| set%$tk $[!%$rw]? $a:ident $[: $ty:term]? := $val:term $[with $[\u2190%$rev]? $h:ident]?) =>\n  withMainContext do",
      "suggestion": "\r\n      | _ => `(ident| x)\r\n",
      "body": "```suggestion\r\n      | _ => `(ident| x)\r\n```\r\nShould we use the same name as `let`, for consistency?",
      "path": "Mathlib/Tactic/Set.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "term",
          "withMainContext",
          "macro",
          "rest",
          "setArgsRest",
          "set",
          "ident",
          "tactic",
          "val",
          "rev",
          "elab_rules"
        ]
      }
    },
    {
      "id": 4169,
      "before_code": "end Functor",
      "suggestion": "\r\n    letI := hF.hasShift s i\r\n    letI := CommShift.ofHasShiftOfFullyFaithful hF s i\r\n",
      "body": "```suggestion\r\n    letI := hF.hasShift s i\r\n    letI := CommShift.ofHasShiftOfFullyFaithful hF s i\r\n```",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Functor"
        ]
      }
    },
    {
      "id": 4170,
      "before_code": "end Functor",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Functor"
        ]
      }
    },
    {
      "id": 4172,
      "before_code": "simpa using ((mem_ball_iff K hc).mp ha).le\n\nend ArchimedeanClass",
      "suggestion": "\r\nThis has the same carrier as `FiniteArchimedeanClass.addSubgroup`. -/\r\n",
      "body": "```suggestion\r\nThis has the same carrier as `FiniteArchimedeanClass.addSubgroup`. -/\r\n```",
      "path": "Mathlib/Algebra/Order/Module/Archimedean.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "ArchimedeanClass",
          "simpa",
          "mem_ball_iff",
          "using"
        ]
      }
    },
    {
      "id": 4175,
      "before_code": "section Semiring\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {N N\u2081 N\u2082 P P\u2081 P\u2082 : Submodule R M}\n\n/-- `N.colon P` is the ideal of all elements `r : R` such that `r \u2022 P \u2286 N`. -/\ndef colon (N P : Submodule R M) : Ideal R where\n  carrier := {r : R | (r \u2022 P : Set M) \u2286 N}\n  add_mem' ha hb :=\n    (Set.add_smul_subset _ _ _).trans ((Set.add_subset_add ha hb).trans_eq (by simp))\n  zero_mem' := by simp [Set.zero_smul_set P.nonempty]\n  smul_mem' r := by\n    simp only [Set.mem_setOf_eq, smul_eq_mul, mul_smul, Set.smul_set_subset_iff]\n    intro x hx y hy\n    exact N.smul_mem _ (hx hy)\n\ntheorem mem_colon {r} : r \u2208 N.colon P \u2194 \u2200 p \u2208 P, r \u2022 p \u2208 N := Set.smul_set_subset_iff\n\ninstance (priority := low) : (N.colon P).IsTwoSided where\n  mul_mem_of_left {r} s hr p hp := by\n    obtain \u27e8p, hp, rfl\u27e9 := hp\n    exact hr \u27e8_, P.smul_mem _ hp, (mul_smul ..).symm\u27e9\n\n@[simp]\ntheorem colon_top {I : Ideal R} [I.IsTwoSided] : I.colon \u22a4 = I := by\n  simp_rw [SetLike.ext_iff, mem_colon, smul_eq_mul]\n  exact fun x \u21a6 \u27e8fun h \u21a6 mul_one x \u25b8 h 1 trivial, fun h _ _ \u21a6 I.mul_mem_right _ h\u27e9\n\n@[simp]\ntheorem colon_bot : colon \u22a5 N = N.annihilator := by\n  simp_rw [SetLike.ext_iff, mem_colon, mem_annihilator, mem_bot, forall_const]\n\ntheorem colon_mono (hn : N\u2081 \u2264 N\u2082) (hp : P\u2081 \u2264 P\u2082) : N\u2081.colon P\u2082 \u2264 N\u2082.colon P\u2081 := fun _ hrnp =>\n  mem_colon.2 fun p\u2081 hp\u2081 => hn <| mem_colon.1 hrnp p\u2081 <| hp hp\u2081\n\ntheorem _root_.Ideal.le_colon {I J : Ideal R} [I.IsTwoSided] : I \u2264 I.colon J := by\n  calc I = I.colon \u22a4 := colon_top.symm\n       _ \u2264 I.colon J := colon_mono (le_refl I) le_top",
      "suggestion": "\r\ntheorem iInf_colon_iUnion (\u03b9\u2081 : Sort*) (f : \u03b9\u2081 \u2192 Submodule R M) (\u03b9\u2082 : Sort*)\r\n    (g : \u03b9\u2082 \u2192 Set M) : (\u2a05 i, f i).colon (\u22c3 j, g j) = \u2a05 (i) (j), (f i).colon (g j) := by\r\n",
      "body": "```suggestion\r\ntheorem iInf_colon_iUnion (\u03b9\u2081 : Sort*) (f : \u03b9\u2081 \u2192 Submodule R M) (\u03b9\u2082 : Sort*)\r\n    (g : \u03b9\u2082 \u2192 Set M) : (\u2a05 i, f i).colon (\u22c3 j, g j) = \u2a05 (i) (j), (f i).colon (g j) := by\r\n```\r\nThe notation we use for unions in sets is `\u22c3` and is called `iUnion`.",
      "path": "Mathlib/RingTheory/Ideal/Colon.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mul_mem_of_left",
          "colon",
          "calc",
          "smul_set_subset_iff",
          "le_refl",
          "colon_bot",
          "add_smul_subset",
          "obtain",
          "annihilator",
          "nonempty",
          "zero_mem",
          "elements",
          "add_subset_add",
          "section",
          "symm",
          "Ideal",
          "_root_",
          "mem_annihilator",
          "colon_mono",
          "le_top",
          "colon_top",
          "Submodule",
          "priority",
          "intro",
          "ideal",
          "simp_rw",
          "such",
          "smul_eq_mul",
          "trivial",
          "def",
          "variable",
          "trans_eq",
          "SetLike",
          "forall_const",
          "Semiring",
          "mem_bot",
          "that",
          "mul_one",
          "simp",
          "rfl",
          "mul_mem_right",
          "IsTwoSided",
          "only",
          "low",
          "AddCommMonoid",
          "mem_setOf_eq",
          "theorem",
          "ext_iff",
          "exact"
        ]
      }
    },
    {
      "id": 4176,
      "before_code": "section Semiring\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {N N\u2081 N\u2082 P P\u2081 P\u2082 : Submodule R M}\n\n/-- `N.colon P` is the ideal of all elements `r : R` such that `r \u2022 P \u2286 N`. -/\ndef colon (N P : Submodule R M) : Ideal R where\n  carrier := {r : R | (r \u2022 P : Set M) \u2286 N}\n  add_mem' ha hb :=\n    (Set.add_smul_subset _ _ _).trans ((Set.add_subset_add ha hb).trans_eq (by simp))\n  zero_mem' := by simp [Set.zero_smul_set P.nonempty]\n  smul_mem' r := by\n    simp only [Set.mem_setOf_eq, smul_eq_mul, mul_smul, Set.smul_set_subset_iff]\n    intro x hx y hy\n    exact N.smul_mem _ (hx hy)\n\ntheorem mem_colon {r} : r \u2208 N.colon P \u2194 \u2200 p \u2208 P, r \u2022 p \u2208 N := Set.smul_set_subset_iff\n\ninstance (priority := low) : (N.colon P).IsTwoSided where\n  mul_mem_of_left {r} s hr p hp := by\n    obtain \u27e8p, hp, rfl\u27e9 := hp\n    exact hr \u27e8_, P.smul_mem _ hp, (mul_smul ..).symm\u27e9\n\n@[simp]\ntheorem colon_top {I : Ideal R} [I.IsTwoSided] : I.colon \u22a4 = I := by\n  simp_rw [SetLike.ext_iff, mem_colon, smul_eq_mul]\n  exact fun x \u21a6 \u27e8fun h \u21a6 mul_one x \u25b8 h 1 trivial, fun h _ _ \u21a6 I.mul_mem_right _ h\u27e9\n\n@[simp]\ntheorem colon_bot : colon \u22a5 N = N.annihilator := by\n  simp_rw [SetLike.ext_iff, mem_colon, mem_annihilator, mem_bot, forall_const]\n\ntheorem colon_mono (hn : N\u2081 \u2264 N\u2082) (hp : P\u2081 \u2264 P\u2082) : N\u2081.colon P\u2082 \u2264 N\u2082.colon P\u2081 := fun _ hrnp =>\n  mem_colon.2 fun p\u2081 hp\u2081 => hn <| mem_colon.1 hrnp p\u2081 <| hp hp\u2081\n\ntheorem _root_.Ideal.le_colon {I J : Ideal R} [I.IsTwoSided] : I \u2264 I.colon J := by\n  calc I = I.colon \u22a4 := colon_top.symm\n       _ \u2264 I.colon J := colon_mono (le_refl I) le_top",
      "suggestion": "\r\n    N.colon S = \u22a4 := by\r\n",
      "body": "```suggestion\r\n    N.colon S = \u22a4 := by\r\n```",
      "path": "Mathlib/RingTheory/Ideal/Colon.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mul_mem_of_left",
          "colon",
          "calc",
          "smul_set_subset_iff",
          "le_refl",
          "colon_bot",
          "add_smul_subset",
          "obtain",
          "annihilator",
          "nonempty",
          "zero_mem",
          "elements",
          "add_subset_add",
          "section",
          "symm",
          "Ideal",
          "_root_",
          "mem_annihilator",
          "colon_mono",
          "le_top",
          "colon_top",
          "Submodule",
          "priority",
          "intro",
          "ideal",
          "simp_rw",
          "such",
          "smul_eq_mul",
          "trivial",
          "def",
          "variable",
          "trans_eq",
          "SetLike",
          "forall_const",
          "Semiring",
          "mem_bot",
          "that",
          "mul_one",
          "simp",
          "rfl",
          "mul_mem_right",
          "IsTwoSided",
          "only",
          "low",
          "AddCommMonoid",
          "mem_setOf_eq",
          "theorem",
          "ext_iff",
          "exact"
        ]
      }
    },
    {
      "id": 4177,
      "before_code": "section Semiring\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {N N\u2081 N\u2082 P P\u2081 P\u2082 : Submodule R M}\n\n/-- `N.colon P` is the ideal of all elements `r : R` such that `r \u2022 P \u2286 N`. -/\ndef colon (N P : Submodule R M) : Ideal R where\n  carrier := {r : R | (r \u2022 P : Set M) \u2286 N}\n  add_mem' ha hb :=\n    (Set.add_smul_subset _ _ _).trans ((Set.add_subset_add ha hb).trans_eq (by simp))\n  zero_mem' := by simp [Set.zero_smul_set P.nonempty]\n  smul_mem' r := by\n    simp only [Set.mem_setOf_eq, smul_eq_mul, mul_smul, Set.smul_set_subset_iff]\n    intro x hx y hy\n    exact N.smul_mem _ (hx hy)\n\ntheorem mem_colon {r} : r \u2208 N.colon P \u2194 \u2200 p \u2208 P, r \u2022 p \u2208 N := Set.smul_set_subset_iff\n\ninstance (priority := low) : (N.colon P).IsTwoSided where\n  mul_mem_of_left {r} s hr p hp := by\n    obtain \u27e8p, hp, rfl\u27e9 := hp\n    exact hr \u27e8_, P.smul_mem _ hp, (mul_smul ..).symm\u27e9\n\n@[simp]\ntheorem colon_top {I : Ideal R} [I.IsTwoSided] : I.colon \u22a4 = I := by\n  simp_rw [SetLike.ext_iff, mem_colon, smul_eq_mul]\n  exact fun x \u21a6 \u27e8fun h \u21a6 mul_one x \u25b8 h 1 trivial, fun h _ _ \u21a6 I.mul_mem_right _ h\u27e9\n\n@[simp]\ntheorem colon_bot : colon \u22a5 N = N.annihilator := by\n  simp_rw [SetLike.ext_iff, mem_colon, mem_annihilator, mem_bot, forall_const]",
      "suggestion": "\r\n@[deprecated (since := \"2026-01-11\")] alias colon_top := colon_univ\r\n",
      "body": "```suggestion\r\n@[deprecated (since := \"2026-01-11\")] alias colon_top := colon_univ\r\n```\r\nYour code also worked but this is enough I think.",
      "path": "Mathlib/RingTheory/Ideal/Colon.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "topics": [
          "list",
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mul_mem_of_left",
          "colon",
          "smul_set_subset_iff",
          "colon_bot",
          "add_smul_subset",
          "obtain",
          "annihilator",
          "nonempty",
          "zero_mem",
          "elements",
          "add_subset_add",
          "section",
          "symm",
          "Ideal",
          "mem_annihilator",
          "colon_top",
          "Submodule",
          "priority",
          "intro",
          "ideal",
          "simp_rw",
          "such",
          "smul_eq_mul",
          "trivial",
          "def",
          "variable",
          "trans_eq",
          "SetLike",
          "forall_const",
          "Semiring",
          "mem_bot",
          "that",
          "mul_one",
          "simp",
          "rfl",
          "mul_mem_right",
          "IsTwoSided",
          "only",
          "low",
          "AddCommMonoid",
          "mem_setOf_eq",
          "theorem",
          "ext_iff",
          "exact",
          "mem_colon",
          "Set",
          "zero_smul_set",
          "trans",
          "add_mem"
        ]
      }
    },
    {
      "id": 4178,
      "before_code": "section Semiring\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {N N\u2081 N\u2082 P P\u2081 P\u2082 : Submodule R M}\n\n/-- `N.colon P` is the ideal of all elements `r : R` such that `r \u2022 P \u2286 N`. -/\ndef colon (N P : Submodule R M) : Ideal R where\n  carrier := {r : R | (r \u2022 P : Set M) \u2286 N}\n  add_mem' ha hb :=\n    (Set.add_smul_subset _ _ _).trans ((Set.add_subset_add ha hb).trans_eq (by simp))\n  zero_mem' := by simp [Set.zero_smul_set P.nonempty]\n  smul_mem' r := by\n    simp only [Set.mem_setOf_eq, smul_eq_mul, mul_smul, Set.smul_set_subset_iff]\n    intro x hx y hy\n    exact N.smul_mem _ (hx hy)\n\ntheorem mem_colon {r} : r \u2208 N.colon P \u2194 \u2200 p \u2208 P, r \u2022 p \u2208 N := Set.smul_set_subset_iff\n\ninstance (priority := low) : (N.colon P).IsTwoSided where\n  mul_mem_of_left {r} s hr p hp := by\n    obtain \u27e8p, hp, rfl\u27e9 := hp\n    exact hr \u27e8_, P.smul_mem _ hp, (mul_smul ..).symm\u27e9\n\n@[simp]\ntheorem colon_top {I : Ideal R} [I.IsTwoSided] : I.colon \u22a4 = I := by\n  simp_rw [SetLike.ext_iff, mem_colon, smul_eq_mul]\n  exact fun x \u21a6 \u27e8fun h \u21a6 mul_one x \u25b8 h 1 trivial, fun h _ _ \u21a6 I.mul_mem_right _ h\u27e9\n\n@[simp]\ntheorem colon_bot : colon \u22a5 N = N.annihilator := by\n  simp_rw [SetLike.ext_iff, mem_colon, mem_annihilator, mem_bot, forall_const]\n\ntheorem colon_mono (hn : N\u2081 \u2264 N\u2082) (hp : P\u2081 \u2264 P\u2082) : N\u2081.colon P\u2082 \u2264 N\u2082.colon P\u2081 := fun _ hrnp =>\n  mem_colon.2 fun p\u2081 hp\u2081 => hn <| mem_colon.1 hrnp p\u2081 <| hp hp\u2081\n\ntheorem _root_.Ideal.le_colon {I J : Ideal R} [I.IsTwoSided] : I \u2264 I.colon J := by\n  calc I = I.colon \u22a4 := colon_top.symm\n       _ \u2264 I.colon J := colon_mono (le_refl I) le_top",
      "suggestion": "\r\n@[deprecated (since := \"2026-01-11\")] alias iInf_colon_iSup := iInf_colon_iUnion\r\n",
      "body": "```suggestion\r\n@[deprecated (since := \"2026-01-11\")] alias iInf_colon_iSup := iInf_colon_iUnion\r\n```",
      "path": "Mathlib/RingTheory/Ideal/Colon.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "simp",
          "intro"
        ],
        "topics": [
          "list",
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mul_mem_of_left",
          "colon",
          "calc",
          "smul_set_subset_iff",
          "le_refl",
          "colon_bot",
          "add_smul_subset",
          "obtain",
          "annihilator",
          "nonempty",
          "zero_mem",
          "elements",
          "add_subset_add",
          "section",
          "symm",
          "Ideal",
          "_root_",
          "mem_annihilator",
          "colon_mono",
          "le_top",
          "colon_top",
          "Submodule",
          "priority",
          "intro",
          "ideal",
          "simp_rw",
          "such",
          "smul_eq_mul",
          "trivial",
          "def",
          "variable",
          "trans_eq",
          "SetLike",
          "forall_const",
          "Semiring",
          "mem_bot",
          "that",
          "mul_one",
          "simp",
          "rfl",
          "mul_mem_right",
          "IsTwoSided",
          "only",
          "low",
          "AddCommMonoid",
          "mem_setOf_eq",
          "theorem",
          "ext_iff",
          "exact"
        ]
      }
    },
    {
      "id": 4179,
      "before_code": "apply iInf_neBot_of_directed _ _\n    \u00b7 change Directed GE.ge (fun x \u21a6 (\u03c6 \u2218 (fun (a : s) \u21a6 f \u2191a)) x)\n      exact Directed.mono_comp GE.ge (fun x y hxy \u21a6\n        principal_mono.mpr (inter_subset_inter_right _ (preimage_mono <| Iic_subset_Iic.mpr hxy))\n        ) (IsTotal.directed _)",
      "suggestion": "\r\n        (IsTotal.directed _)\r\n",
      "body": "```suggestion\r\n        (IsTotal.directed _)\r\n```",
      "path": "Mathlib/Topology/Semicontinuity/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "apply"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "preimage_mono",
          "apply",
          "IsTotal",
          "mpr",
          "inter_subset_inter_right",
          "iInf_neBot_of_directed",
          "exact",
          "Iic_subset_Iic",
          "change",
          "directed",
          "hxy",
          "principal_mono",
          "mono_comp",
          "Directed"
        ]
      }
    },
    {
      "id": 4180,
      "before_code": "ext x\n  simp_all\n\ntheorem smul_mem_rootSet [CommRing S] [Algebra S R]\n    {G : Type*} [Monoid G] [MulSemiringAction G R] [SMulCommClass G S R] {f : S[X]}\n    (g : G) {x : R} (hx : x \u2208 f.rootSet R) : g \u2022 x \u2208 f.rootSet R := by\n  simp [mem_rootSet', aeval_smul, aeval_eq_zero_of_mem_rootSet hx, (mem_rootSet'.mp hx).1]\n\ninstance [CommRing S] [Algebra S R]\n    (G : Type*) [Monoid G] [MulSemiringAction G R] [SMulCommClass G S R] (f : S[X]) :\n    MulAction G (f.rootSet R) where\n  smul g x := \u27e8g \u2022 x.1, smul_mem_rootSet g x.2\u27e9\n  one_smul x := Subtype.ext (one_smul G x.1)\n  mul_smul g h x := Subtype.ext (mul_smul g h x.1)\n\n@[simp]\ntheorem rootSet.coe_smul [CommRing S] [Algebra S R] {G : Type*} [Monoid G] [MulSemiringAction G R]\n    [SMulCommClass G S R] {f : S[X]} (g : G) (x : f.rootSet R) :\n    (g \u2022 x : f.rootSet R) = g \u2022 (x : R) :=\n  rfl",
      "suggestion": "\r\n  smul_comm g h x := Subtype.ext <| smul_comm _ _ _\r\n",
      "body": "Or even just\r\n```suggestion\r\n  smul_comm g h x := Subtype.ext <| smul_comm _ _ _\r\n```\r\nand below",
      "path": "Mathlib/Algebra/Polynomial/Roots.lean",
      "tags": {
        "before_tactics": [
          "simp_all",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "simp_all"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subtype",
          "smul",
          "Monoid",
          "aeval_eq_zero_of_mem_rootSet",
          "Type",
          "MulSemiringAction",
          "simp_all",
          "SMulCommClass",
          "ext",
          "smul_mem_rootSet",
          "one_smul",
          "rootSet",
          "MulAction",
          "CommRing",
          "aeval_smul",
          "simp",
          "rfl",
          "theorem",
          "coe_smul",
          "mem_rootSet",
          "mul_smul",
          "instance",
          "Algebra"
        ]
      }
    },
    {
      "id": 4181,
      "before_code": "its group of units, the general linear group GL(`\ud835\udd5c`, `V`), as demonstrated by:\n```\nexample {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] [CompleteSpace V] :",
      "suggestion": "\r\nexample {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] [CompleteSpace V] (n : WithTop \u2115\u221e) :\r\n",
      "body": "```suggestion\r\nexample {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] [CompleteSpace V] (n : WithTop \u2115\u221e) :\r\n```",
      "path": "Mathlib/Geometry/Manifold/Instances/UnitsOfNormedAlgebra.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "example",
          "CompleteSpace",
          "its",
          "Type",
          "demonstrated",
          "units",
          "NormedSpace",
          "group",
          "NormedAddCommGroup",
          "general",
          "linear"
        ]
      }
    },
    {
      "id": 4182,
      "before_code": "rw [contMDiffAt_iff_contDiffAt]\n    exact contDiffAt_ringInverse _ _",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Geometry/Manifold/Instances/UnitsOfNormedAlgebra.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [
          "continuity"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "contMDiffAt_iff_contDiffAt",
          "contDiffAt_ringInverse"
        ]
      }
    },
    {
      "id": 4185,
      "before_code": "@[expose] public section\n\nopen Set",
      "suggestion": "\r\n  \u2200 (s : Set \u03b1) (u : \u03b1), s.Nonempty \u2192 DirectedOn (\u00b7 \u2264 \u00b7) s \u2192 IsLUB s u \u2192 k \u2264 u \u2192 \u2203 x \u2208 s, k \u2264 x\r\n",
      "body": "```suggestion\r\n  \u2200 (s : Set \u03b1) (u : \u03b1), s.Nonempty \u2192 DirectedOn (\u00b7 \u2264 \u00b7) s \u2192 IsLUB s u \u2192 k \u2264 u \u2192 \u2203 x \u2208 s, k \u2264 x\r\n```",
      "path": "Mathlib/Order/CompactlyGenerated/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "expose",
          "public",
          "Set",
          "open",
          "section"
        ]
      }
    },
    {
      "id": 4188,
      "before_code": "Push.push (\u2190 Push.elabPushConfig cfg) none (.const ``Not) (.targets #[(negHygName)] false)\n          (failIfUnchanged := false)\n\n/-- `wlog h : P` will add an assumption `h : P` to the main goal, and add a side goal that requires\nshowing that the case `h : \u00ac P` can be reduced to the case where `P` holds (typically by symmetry).\n\nThe side goal will be at the top of the stack. In this side goal, there will be two additional\nassumptions:\n- `h : \u00ac P`: the assumption that `P` does not hold\n- `this`: which is the statement that in the old context `P` suffices to prove the goal.\n  By default, the name `this` is used, but the idiom `with H` can be added to specify the name:\n  `wlog h : P with H`.\n\nTypically, it is useful to use the variant `wlog h : P generalizing x y`,\nto revert certain parts of the context before creating the new goal.\nIn this way, the wlog-claim `this` can be applied to `x` and `y` in different orders\n(exploiting symmetry, which is the typical use case).\n\nBy default, the entire context is reverted. -/",
      "suggestion": "\r\n  `wlog! +distrib h : P \u2227 Q` will transform `\u00ac (P \u2227 Q)` to `\u00acP \u2228 \u00acQ`.\r\n",
      "body": "Oops, yes!\r\n\r\n```suggestion\r\n  `wlog! +distrib h : P \u2227 Q` will transform `\u00ac (P \u2227 Q)` to `\u00acP \u2228 \u00acQ`.\r\n```",
      "path": "Mathlib/Tactic/WLOG.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "push",
          "different",
          "parts",
          "typically",
          "added",
          "assumption",
          "which",
          "elabPushConfig",
          "showing",
          "const",
          "negHygName",
          "but",
          "there",
          "new",
          "main",
          "idiom",
          "side",
          "claim",
          "add",
          "Push",
          "stack",
          "entire",
          "requires",
          "does",
          "orders",
          "way",
          "name",
          "case",
          "context",
          "false",
          "assumptions",
          "prove",
          "before",
          "two",
          "can",
          "typical",
          "old",
          "hold",
          "used",
          "none",
          "reverted",
          "additional",
          "that",
          "wlog",
          "default",
          "failIfUnchanged",
          "will",
          "creating",
          "use",
          "symmetry"
        ]
      }
    },
    {
      "id": 4189,
      "before_code": "macro \"push_neg\" cfg:optConfig : conv => `(conv| push $cfg Not)\n\n/--\nThe syntax is `#push head e`, where `head` is a constant and `e` is an expression,\nwhich will print the `push head` form of `e`.",
      "suggestion": "\r\nprints the `push head` form of `e`.\r\n",
      "body": "```suggestion\r\nprints the `push head` form of `e`.\r\n```",
      "path": "Mathlib/Tactic/Push.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "push",
          "print",
          "constant",
          "conv",
          "cfg",
          "macro",
          "head",
          "which",
          "syntax",
          "optConfig",
          "push_neg",
          "will",
          "expression",
          "form"
        ]
      }
    },
    {
      "id": 4190,
      "before_code": "`(command| #conv%$tk push $cfg $[$disch?:discharger]? $head:term => $e)\n\n/--\nThe syntax is `#push_neg e`, where `e` is an expression,\nwhich will print the `push_neg` form of `e`.",
      "suggestion": "\r\nprints the `push_neg` form of `e`.\r\n",
      "body": "```suggestion\r\nprints the `push_neg` form of `e`.\r\n```",
      "path": "Mathlib/Tactic/Push.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "push",
          "print",
          "term",
          "conv",
          "cfg",
          "head",
          "discharger",
          "which",
          "syntax",
          "push_neg",
          "will",
          "disch",
          "expression",
          "command",
          "form"
        ]
      }
    },
    {
      "id": 4191,
      "before_code": "theorem mk_sub_stdPart_pos (f : \u211d \u2192+*o K) (hx : 0 \u2264 mk x) : 0 < mk (x - f (stdPart x)) :=\n  (mk_sub_pos_iff f hx).2 rfl\n\ntheorem stdPart_eq (f : \u211d \u2192+*o K) {x : K} {r : \u211d} (hl : \u2200 s < r, f s \u2264 x) (hr : \u2200 s > r, x \u2264 f s) :",
      "suggestion": "\r\ntheorem le_stdPart_of_le (f : \u211d \u2192+*o K) {r : \u211d} (hx : 0 \u2264 mk x) (h : f r \u2264 x) : r \u2264 stdPart x :=\r\n",
      "body": "```suggestion\r\ntheorem le_stdPart_of_le (f : \u211d \u2192+*o K) {r : \u211d} (hx : 0 \u2264 mk x) (h : f r \u2264 x) : r \u2264 stdPart x :=\r\n```",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "stdPart_eq",
          "stdPart",
          "theorem",
          "mk_sub_stdPart_pos",
          "mk_sub_pos_iff",
          "rfl"
        ]
      }
    },
    {
      "id": 4192,
      "before_code": "end Scott\n\n/-- A Scott topological space is defined on preorders\nsuch that their open sets, seen as a function `\u03b1 \u2192 Prop`,\npreserves the joins of \u03c9-chains. -/\n@[deprecated WithScott (since := \"2025-07-02\")]\nabbrev Scott (\u03b1 : Type u) := \u03b1\n\nset_option linter.deprecated false in\n/-- Deprecated, use `WithScott`. -/\n@[deprecated Topology.WithScott.instTopologicalSpace (since := \"2025-07-02\")]\nabbrev Scott.topologicalSpace (\u03b1 : Type u) [OmegaCompletePartialOrder \u03b1] :\n    TopologicalSpace (Scott \u03b1) where\n  IsOpen := Scott.IsOpen \u03b1\n  isOpen_univ := Scott.isOpen_univ \u03b1\n  isOpen_inter := Scott.IsOpen.inter \u03b1\n  isOpen_sUnion := Scott.isOpen_sUnion \u03b1\n\nattribute [local instance] Scott.topologicalSpace",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Topology/OmegaCompletePartialOrder.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "preorders",
          "preserves",
          "end",
          "isOpen_inter",
          "Topology",
          "Type",
          "since",
          "open",
          "local",
          "seen",
          "isOpen_univ",
          "linter",
          "inter",
          "Prop",
          "false",
          "isOpen_sUnion",
          "OmegaCompletePartialOrder",
          "such",
          "TopologicalSpace",
          "abbrev",
          "instTopologicalSpace",
          "sets",
          "that",
          "their",
          "attribute",
          "Scott",
          "defined",
          "Deprecated",
          "use",
          "topologicalSpace",
          "function",
          "space",
          "joins",
          "topological",
          "WithScott",
          "chains",
          "IsOpen",
          "instance",
          "deprecated",
          "set_option"
        ]
      }
    },
    {
      "id": 4194,
      "before_code": "lemma abv_nonneg (x) : 0 \u2264 abv x := abv_nonneg' x\n\nopen Lean Meta Mathlib Meta Positivity Qq in\n/-- The `positivity` extension which identifies expressions of the form `abv a`. -/\n@[positivity _]\nmeta def Mathlib.Meta.Positivity.evalAbv : PositivityExt where eval {_ _\u03b1} _z\u03b1 _p\u03b1 e := do\n  let (.app f a) \u2190 whnfR e | throwError \"not abv \u00b7\"",
      "suggestion": "\r\n  if !f.isFVar then\r\n",
      "body": "```suggestion\r\n  if !f.isFVar then\r\n```",
      "path": "Mathlib/Algebra/Order/AbsoluteValue/Basic.lean",
      "tags": {
        "before_tactics": [
          "positivity"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "positivity"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Positivity",
          "lemma",
          "which",
          "abv_nonneg",
          "eval",
          "open",
          "identifies",
          "form",
          "positivity",
          "Lean",
          "Mathlib",
          "extension",
          "whnfR",
          "expressions",
          "def",
          "evalAbv",
          "throwError",
          "app",
          "abv",
          "Meta",
          "meta",
          "PositivityExt"
        ]
      }
    },
    {
      "id": 4195,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm",
      "suggestion": "    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < #s) :\n",
      "body": "```suggestion\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < #s) :\n```\nIt's equivalent, but a more standard formulation.",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "eval",
          "Polynomial",
          "open",
          "symm",
          "scoped",
          "eq_interpolate",
          "interpolate",
          "insert_subset_iff",
          "InjOn",
          "sdiff_singleton_eq_erase",
          "hvs",
          "card",
          "Classical",
          "interpolate_poly_eq_self",
          "theorem",
          "exact",
          "Set",
          "degree",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 4196,
      "before_code": "sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr \u27e8hi, singleton_subset_iff.mpr hj\u27e9\n\nopen scoped Classical in\ntheorem interpolate_poly_eq_self\n    (hvs : Set.InjOn v s) {P : Polynomial F} (hP : P.degree < s.card) :\n    interpolate s v (fun i => P.eval (v i)) = P := (eq_interpolate hvs hP).symm",
      "suggestion": "    P.coeff (#s - 1) = \u2211 i \u2208 s, (P.eval (v i)) / \u220f j \u2208 s.erase i, (v i - v j) := by\n",
      "body": "```suggestion\n    P.coeff (#s - 1) = \u2211 i \u2208 s, (P.eval (v i)) / \u220f j \u2208 s.erase i, (v i - v j) := by\n```\n(untested)\nSame thing below.",
      "path": "Mathlib/LinearAlgebra/Lagrange.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "eval",
          "Polynomial",
          "open",
          "symm",
          "scoped",
          "eq_interpolate",
          "interpolate",
          "insert_subset_iff",
          "InjOn",
          "sdiff_singleton_eq_erase",
          "hvs",
          "card",
          "Classical",
          "interpolate_poly_eq_self",
          "theorem",
          "exact",
          "Set",
          "degree",
          "singleton_subset_iff"
        ]
      }
    },
    {
      "id": 4197,
      "before_code": "also unify with `Nat.ModEq`.\n-/\n\n@[expose] public section\n\nassert_not_exists Module\n\nnamespace AddCommGroup\n\nvariable {\u03b1 : Type*}\n\nsection AddCommGroup\n\nvariable [AddCommGroup \u03b1] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1} {n : \u2115} {z : \u2124}\n\n/-- `a \u2261 b [PMOD p]` means that `b` is congruent to `a` modulo `p`.\n\nEquivalently (as shown in `Algebra.Order.ToIntervalMod`), `b` does not lie in the open interval\n`(a, a + p)` modulo `p`, or `toIcoMod hp a` disagrees with `toIocMod hp a` at `b`, or\n`toIcoDiv hp a` disagrees with `toIocDiv hp a` at `b`. -/\ndef ModEq (p a b : \u03b1) : Prop :=\n  \u2203 z : \u2124, b - a = z \u2022 p\n\n@[inherit_doc]\nnotation:50 a \" \u2261 \" b \" [PMOD \" p \"]\" => ModEq p a b\n\n@[refl, simp]\ntheorem modEq_refl (a : \u03b1) : a \u2261 a [PMOD p] :=\n  \u27e80, by simp\u27e9\n\ntheorem modEq_rfl : a \u2261 a [PMOD p] :=\n  modEq_refl _\n\ntheorem modEq_comm : a \u2261 b [PMOD p] \u2194 b \u2261 a [PMOD p] :=\n  (Equiv.neg _).exists_congr_left.trans <| by simp [ModEq, \u2190 neg_eq_iff_eq_neg]\n\nalias \u27e8ModEq.symm, _\u27e9 := modEq_comm\n\nattribute [symm] ModEq.symm\n\n@[trans]\ntheorem ModEq.trans : a \u2261 b [PMOD p] \u2192 b \u2261 c [PMOD p] \u2192 a \u2261 c [PMOD p] := fun \u27e8m, hm\u27e9 \u27e8n, hn\u27e9 =>\n  \u27e8m + n, by simp [add_zsmul, \u2190 hm, \u2190 hn]\u27e9\n\ninstance : IsTrans \u03b1 (ModEq p) where\n  trans _ _ _ := ModEq.trans\n\ninstance : Std.Refl (ModEq p) :=\n  \u27e8modEq_refl\u27e9\n\n@[simp]\ntheorem neg_modEq_neg : -a \u2261 -b [PMOD p] \u2194 a \u2261 b [PMOD p] :=\n  modEq_comm.trans <| by simp [ModEq, neg_add_eq_sub]\n\nalias \u27e8ModEq.of_neg, ModEq.neg\u27e9 := neg_modEq_neg\n\n@[simp]\ntheorem modEq_neg : a \u2261 b [PMOD -p] \u2194 a \u2261 b [PMOD p] :=\n  modEq_comm.trans <| by simp [ModEq, \u2190 neg_eq_iff_eq_neg]\n\nalias \u27e8ModEq.of_neg', ModEq.neg'\u27e9 := modEq_neg\n\ntheorem modEq_sub (a b : \u03b1) : a \u2261 b [PMOD b - a] :=\n  \u27e81, by simp\u27e9\n\n@[simp]\ntheorem modEq_zero : a \u2261 b [PMOD 0] \u2194 a = b := by simp [ModEq, sub_eq_zero, eq_comm]\n\n@[simp]\ntheorem self_modEq_zero : p \u2261 0 [PMOD p] :=\n  \u27e8-1, by simp\u27e9",
      "suggestion": "\r\nsection AddCommGroup\r\nvariable {G : Type*} [AddCommGroup G] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : G} {n : \u2115} {z : \u2124}\r\n",
      "body": "nit: I think we prefer\r\n```suggestion\r\nsection AddCommGroup\r\nvariable {G : Type*} [AddCommGroup G] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : G} {n : \u2115} {z : \u2124}\r\n```\r\n(as we did in Lean 3), and these blank lines at the start of sections are mathportisms.",
      "path": "Mathlib/Algebra/ModEq.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "nat",
          "algebra",
          "equiv",
          "set_theory",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "congruent",
          "Module",
          "modEq_zero",
          "neg",
          "expose",
          "shown",
          "Type",
          "refl",
          "ModEq",
          "modEq_comm",
          "modEq_rfl",
          "open",
          "section",
          "instance",
          "modulo",
          "alias",
          "eq_comm",
          "IsTrans",
          "symm",
          "modEq_sub",
          "toIcoDiv",
          "Nat",
          "does",
          "Prop",
          "toIocDiv",
          "AddCommGroup",
          "Equiv",
          "toIocMod",
          "self_modEq_zero",
          "also",
          "lie",
          "neg_modEq_neg",
          "neg_eq_iff_eq_neg",
          "def",
          "variable",
          "Order",
          "assert_not_exists",
          "of_neg",
          "modEq_neg",
          "public",
          "toIcoMod",
          "that",
          "unify",
          "PMOD",
          "modEq_refl",
          "inherit_doc",
          "simp",
          "ToIntervalMod",
          "notation",
          "attribute"
        ]
      }
    },
    {
      "id": 4202,
      "before_code": "calc \u27e6p\u2081\u27e7\n      _ = trans (trans \u27e6p\u2081\u27e7 (symm \u27e6p\u2082\u27e7)) \u27e6p\u2082\u27e7 := by simp\n      _ = \u27e6p\u2082\u27e7 := by grind",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "grind",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "symm",
          "calc",
          "grind",
          "trans",
          "simp"
        ]
      }
    },
    {
      "id": 4203,
      "before_code": "s.inf f \u2264 P \u2194 \u2203 i \u2208 s, f i \u2264 P :=\n  \u27e8fun h \u21a6 hp.prod_le.1 <| prod_le_inf.trans h, fun \u27e8_, his, hip\u27e9 \u21a6 (Finset.inf_le his).trans hip\u27e9",
      "suggestion": "\r\ntheorem IsPrime.eq_of_inf_eq {s : Finset \u03b9} {f : \u03b9 \u2192 Ideal R} (hp : IsPrime (s.inf f)) :\r\n    \u2203 i \u2208 s, f i = s.inf f := by\r\n",
      "body": "Should this say\r\n```suggestion\r\ntheorem IsPrime.eq_of_inf_eq {s : Finset \u03b9} {f : \u03b9 \u2192 Ideal R} (hp : IsPrime (s.inf f)) :\r\n    \u2203 i \u2208 s, f i = s.inf f := by\r\n```\r\n?",
      "path": "Mathlib/RingTheory/Ideal/Operations.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "inf",
          "prod_le",
          "Finset",
          "prod_le_inf",
          "inf_le",
          "his",
          "trans",
          "hip"
        ]
      }
    },
    {
      "id": 4204,
      "before_code": "## Behaviour under Arithmetic Operations\n-/",
      "suggestion": "\r\ncharacteristic functions of `f` and `g`, respectively, plus `log 2` (where `2` is the number of\r\nsummands).\r\n",
      "body": "We did this for `proximity` too.\r\n```suggestion\r\ncharacteristic functions of `f` and `g`, respectively, plus `log 2` (where `2` is the number of\r\nsummands).\r\n```\r\nLikewise below.",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CharacteristicFunction.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Behaviour",
          "Operations",
          "Arithmetic",
          "under"
        ]
      }
    },
    {
      "id": 4205,
      "before_code": "## Behaviour under Arithmetic Operations\n-/",
      "suggestion": "\r\n  filter_upwards [Filter.eventually_ge_atTop 1] with r hr using characteristic_add_top_le h\u2081f\u2081 h\u2081f\u2082 hr\r\n",
      "body": "untested, but again the main point is to showcase features of `filter_upwards` to make sure you're aware of them.\r\n```suggestion\r\n  filter_upwards [Filter.eventually_ge_atTop 1] with r hr using characteristic_add_top_le h\u2081f\u2081 h\u2081f\u2082 hr\r\n```",
      "path": "Mathlib/Analysis/Complex/ValueDistribution/CharacteristicFunction.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Behaviour",
          "Operations",
          "Arithmetic",
          "under"
        ]
      }
    },
    {
      "id": 4206,
      "before_code": "ext1 f\n  simp [hg\u2081, hg\u2082]",
      "suggestion": "\r\ntheorem _root_.MeasureTheory.Lp.toTemperedDistribution_smul_eq {p q r : \u211d\u22650\u221e} [p.HolderTriple q r]\r\n",
      "body": "```suggestion\r\ntheorem _root_.MeasureTheory.Lp.toTemperedDistribution_smul_eq {p q r : \u211d\u22650\u221e} [p.HolderTriple q r]\r\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ext1",
          "simp"
        ]
      }
    },
    {
      "id": 4207,
      "before_code": "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]\n  {p : \ud835\udd5c} (hp : 0 < p) (a x : \ud835\udd5c)\n\ntheorem continuous_right_toIcoMod : ContinuousWithinAt (toIcoMod hp a) (Ici x) x := by\n  intro s h\n  rw [Filter.mem_map, mem_nhdsWithin_iff_exists_mem_nhds_inter]\n  haveI : Nontrivial \ud835\udd5c := \u27e8\u27e80, p, hp.ne\u27e9\u27e9\n  simp_rw [mem_nhds_iff_exists_Ioo_subset] at h \u22a2\n  obtain \u27e8l, u, hxI, hIs\u27e9 := h\n  let d := toIcoDiv hp a x \u2022 p\n  have hd := toIcoMod_mem_Ico hp a x\n  simp_rw [subset_def, mem_inter_iff]\n  refine \u27e8_, \u27e8l + d, min (a + p) u + d, ?_, fun x => id\u27e9, fun y => ?_\u27e9 <;>\n    simp_rw [\u2190 sub_mem_Ioo_iff_left, mem_Ioo, lt_min_iff]\n  \u00b7 exact \u27e8hxI.1, hd.2, hxI.2\u27e9\n  \u00b7 rintro \u27e8h, h'\u27e9\n    apply hIs\n    rw [\u2190 toIcoMod_sub_zsmul, (toIcoMod_eq_self _).2]\n    exacts [\u27e8h.1, h.2.2\u27e9, \u27e8hd.1.trans (sub_le_sub_right h' _), h.2.1\u27e9]\n\ntheorem continuous_left_toIocMod : ContinuousWithinAt (toIocMod hp a) (Iic x) x := by\n  rw [(funext fun y => Eq.trans (by rw [neg_neg]) <| toIocMod_neg _ _ _ :\n      toIocMod hp a = (fun x => p - x) \u2218 toIcoMod hp (-a) \u2218 Neg.neg)]\n  exact\n    (continuous_sub_left _).continuousAt.comp_continuousWithinAt <|\n      (continuous_right_toIcoMod _ _ _).comp continuous_neg.continuousWithinAt fun y => neg_le_neg",
      "suggestion": "theorem continuousWithinAt_toIcoMod_Ici : ContinuousWithinAt (toIcoMod hp a) (Ici x) x :=\n  continuousWithinAt_id.sub <| \n    (continuousWithinAt_toIcoDiv_Ici hp a x).smul continuousWithinAt_const\n",
      "body": "Why do you come back to filter statements instead of using directly continuousWithinAt_toIcoDiv_Ici, like\n```suggestion\ntheorem continuousWithinAt_toIcoMod_Ici : ContinuousWithinAt (toIcoMod hp a) (Ici x) x :=\n  continuousWithinAt_id.sub <| \n    (continuousWithinAt_toIcoDiv_Ici hp a x).smul continuousWithinAt_const\n```\nSame thing below.",
      "path": "Mathlib/Topology/Instances/AddCircle/Defs.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "funext",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "funext",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "continuity",
          "set_theory",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "funext",
          "subset_def",
          "neg",
          "Nontrivial",
          "sub_le_sub_right",
          "neg_le_neg",
          "rintro",
          "Iic",
          "obtain",
          "exacts",
          "apply",
          "refine",
          "Neg",
          "toIcoDiv",
          "continuousAt",
          "toIcoMod_sub_zsmul",
          "have",
          "sub_mem_Ioo_iff_left",
          "mem_Ioo",
          "Filter",
          "continuous_left_toIocMod",
          "toIocMod",
          "intro",
          "mem_nhds_iff_exists_Ioo_subset",
          "simp_rw",
          "OrderTopology",
          "TopologicalSpace",
          "lt_min_iff",
          "toIcoMod_eq_self",
          "hIs",
          "toIcoMod",
          "continuousWithinAt",
          "comp",
          "Ici",
          "continuous_right_toIcoMod",
          "ContinuousWithinAt",
          "mem_nhdsWithin_iff_exists_mem_nhds_inter",
          "theorem",
          "exact",
          "hxI",
          "continuous_neg",
          "mem_map",
          "min",
          "mem_inter_iff",
          "toIcoMod_mem_Ico",
          "trans",
          "toIocMod_neg",
          "neg_neg",
          "continuous_sub_left",
          "comp_continuousWithinAt"
        ]
      }
    },
    {
      "id": 4208,
      "before_code": "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]\n  {p : \ud835\udd5c} (hp : 0 < p) (a x : \ud835\udd5c)\n\ntheorem continuous_right_toIcoMod : ContinuousWithinAt (toIcoMod hp a) (Ici x) x := by\n  intro s h\n  rw [Filter.mem_map, mem_nhdsWithin_iff_exists_mem_nhds_inter]\n  haveI : Nontrivial \ud835\udd5c := \u27e8\u27e80, p, hp.ne\u27e9\u27e9\n  simp_rw [mem_nhds_iff_exists_Ioo_subset] at h \u22a2\n  obtain \u27e8l, u, hxI, hIs\u27e9 := h\n  let d := toIcoDiv hp a x \u2022 p\n  have hd := toIcoMod_mem_Ico hp a x\n  simp_rw [subset_def, mem_inter_iff]\n  refine \u27e8_, \u27e8l + d, min (a + p) u + d, ?_, fun x => id\u27e9, fun y => ?_\u27e9 <;>\n    simp_rw [\u2190 sub_mem_Ioo_iff_left, mem_Ioo, lt_min_iff]\n  \u00b7 exact \u27e8hxI.1, hd.2, hxI.2\u27e9\n  \u00b7 rintro \u27e8h, h'\u27e9\n    apply hIs\n    rw [\u2190 toIcoMod_sub_zsmul, (toIcoMod_eq_self _).2]\n    exacts [\u27e8h.1, h.2.2\u27e9, \u27e8hd.1.trans (sub_le_sub_right h' _), h.2.1\u27e9]\n\ntheorem continuous_left_toIocMod : ContinuousWithinAt (toIocMod hp a) (Iic x) x := by\n  rw [(funext fun y => Eq.trans (by rw [neg_neg]) <| toIocMod_neg _ _ _ :\n      toIocMod hp a = (fun x => p - x) \u2218 toIcoMod hp (-a) \u2218 Neg.neg)]\n  exact\n    (continuous_sub_left _).continuousAt.comp_continuousWithinAt <|\n      (continuous_right_toIcoMod _ _ _).comp continuous_neg.continuousWithinAt fun y => neg_le_neg\n\nvariable {x}",
      "suggestion": "\r\ntheorem eventuallyEq_toIcoDiv_nhds (hx : \u00acx \u2261 a [PMOD p]) :\r\n",
      "body": "I think the canonical spelling is\r\n```suggestion\r\ntheorem eventuallyEq_toIcoDiv_nhds (hx : \u00acx \u2261 a [PMOD p]) :\r\n```\r\n(the purpose of `AddCommGroup.ModEq` was to chose a canonical spelling here)",
      "path": "Mathlib/Topology/Instances/AddCircle/Defs.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "funext",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "funext",
          "refine",
          "exact",
          "have",
          "obtain",
          "rw",
          "intro"
        ],
        "topics": [
          "continuity",
          "set_theory",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "funext",
          "subset_def",
          "neg",
          "Nontrivial",
          "sub_le_sub_right",
          "neg_le_neg",
          "rintro",
          "Iic",
          "obtain",
          "exacts",
          "apply",
          "refine",
          "Neg",
          "toIcoDiv",
          "continuousAt",
          "toIcoMod_sub_zsmul",
          "have",
          "sub_mem_Ioo_iff_left",
          "mem_Ioo",
          "Filter",
          "continuous_left_toIocMod",
          "toIocMod",
          "intro",
          "mem_nhds_iff_exists_Ioo_subset",
          "simp_rw",
          "OrderTopology",
          "TopologicalSpace",
          "lt_min_iff",
          "toIcoMod_eq_self",
          "variable",
          "hIs",
          "toIcoMod",
          "continuousWithinAt",
          "comp",
          "Ici",
          "continuous_right_toIcoMod",
          "ContinuousWithinAt",
          "mem_nhdsWithin_iff_exists_mem_nhds_inter",
          "theorem",
          "exact",
          "hxI",
          "continuous_neg",
          "mem_map",
          "min",
          "mem_inter_iff",
          "toIcoMod_mem_Ico",
          "trans",
          "toIocMod_neg",
          "neg_neg",
          "continuous_sub_left"
        ]
      }
    },
    {
      "id": 4209,
      "before_code": "UniformSpace.secondCountable_of_separable (NonemptyCompacts \u03b1)\n\ntheorem isometry_singleton : Isometry ({\u00b7} : \u03b1 \u2192 NonemptyCompacts \u03b1) :=\n  fun _ _ => hausdorffEdist_singleton\n\ntheorem lipschitz_sup :\n    LipschitzWith 1 fun p : NonemptyCompacts \u03b1 \u00d7 NonemptyCompacts \u03b1 => p.1 \u2294 p.2 :=\n  .of_edist_le fun _ _ => hausdorffEdist_union_le\n\ntheorem lipschitz_prod :\n    LipschitzWith 1 fun p : NonemptyCompacts \u03b1 \u00d7 NonemptyCompacts \u03b2 => p.1 \u00d7\u02e2 p.2 :=\n  .of_edist_le fun _ _ => hausdorffEdist_prod_le\n\nend NonemptyCompacts\n\nend",
      "suggestion": "alias NonemptyCompacts.isUniformEmbedding_toCloseds := TopologicalSpace.NonemptyCompacts.isUniformEmbedding_toCloseds\n",
      "body": "```suggestion\nalias NonemptyCompacts.isUniformEmbedding_toCloseds := TopologicalSpace.NonemptyCompacts.isUniformEmbedding_toCloseds\n```",
      "path": "Mathlib/Topology/MetricSpace/Closeds.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "hausdorffEdist_union_le",
          "Isometry",
          "lipschitz_sup",
          "isometry_singleton",
          "end",
          "UniformSpace",
          "theorem",
          "NonemptyCompacts",
          "of_edist_le",
          "LipschitzWith",
          "hausdorffEdist_singleton",
          "secondCountable_of_separable",
          "hausdorffEdist_prod_le",
          "lipschitz_prod"
        ]
      }
    },
    {
      "id": 4210,
      "before_code": "exact le_trans dist_nonneg this\n  exact ne_top_of_le_ne_top ENNReal.ofReal_ne_top this\n\n/-- The Hausdorff distance between a set and itself is zero. -/\n@[simp]\ntheorem hausdorffDist_self_zero : hausdorffDist s s = 0 := by simp [hausdorffDist]\n\n/-- The Hausdorff distances from `s` to `t` and from `t` to `s` coincide. -/\ntheorem hausdorffDist_comm : hausdorffDist s t = hausdorffDist t s := by\n  simp [hausdorffDist, hausdorffEdist_comm]\n\n/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue `\u221e` instead, use `EMetric.hausdorffEdist`, which takes values in `\u211d\u22650\u221e`). -/",
      "suggestion": "\r\nvalue `\u221e` instead, use `Metric.hausdorffEDist`, which takes values in `\u211d\u22650\u221e`). -/\r\n",
      "body": "```suggestion\r\nvalue `\u221e` instead, use `Metric.hausdorffEDist`, which takes values in `\u211d\u22650\u221e`). -/\r\n```",
      "path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp",
          "have"
        ],
        "topics": [
          "real",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "which",
          "dist_nonneg",
          "EMetric",
          "want",
          "hausdorffEdist",
          "coincide",
          "itself",
          "empty",
          "ofReal_ne_top",
          "hausdorffDist_comm",
          "have",
          "set",
          "more",
          "hausdorffDist",
          "hausdorffDist_self_zero",
          "you",
          "vanishes",
          "between",
          "simp",
          "zero",
          "distance",
          "use",
          "Hausdorff",
          "ne_top_of_le_ne_top",
          "takes",
          "ENNReal",
          "theorem",
          "hausdorffEdist_comm",
          "exact",
          "reasonable",
          "instead",
          "distances",
          "values",
          "this",
          "from",
          "value",
          "le_trans"
        ]
      }
    },
    {
      "id": 4211,
      "before_code": "exact le_trans dist_nonneg this\n  exact ne_top_of_le_ne_top ENNReal.ofReal_ne_top this\n\n/-- The Hausdorff distance between a set and itself is zero. -/\n@[simp]\ntheorem hausdorffDist_self_zero : hausdorffDist s s = 0 := by simp [hausdorffDist]\n\n/-- The Hausdorff distances from `s` to `t` and from `t` to `s` coincide. -/\ntheorem hausdorffDist_comm : hausdorffDist s t = hausdorffDist t s := by\n  simp [hausdorffDist, hausdorffEdist_comm]\n\n/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue `\u221e` instead, use `EMetric.hausdorffEdist`, which takes values in `\u211d\u22650\u221e`). -/\n@[simp]\ntheorem hausdorffDist_empty : hausdorffDist s \u2205 = 0 := by\n  rcases s.eq_empty_or_nonempty with h | h\n  \u00b7 simp [h]\n  \u00b7 simp [hausdorffDist, hausdorffEdist_empty h]\n\n/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue `\u221e` instead, use `EMetric.hausdorffEdist`, which takes values in `\u211d\u22650\u221e`). -/",
      "suggestion": "\r\nvalue `\u221e` instead, use `Metric.hausdorffEDist`, which takes values in `\u211d\u22650\u221e`). -/\r\n",
      "body": "```suggestion\r\nvalue `\u221e` instead, use `Metric.hausdorffEDist`, which takes values in `\u211d\u22650\u221e`). -/\r\n```",
      "path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "have",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "cases",
          "have",
          "simp"
        ],
        "topics": [
          "real",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "which",
          "dist_nonneg",
          "EMetric",
          "rcases",
          "want",
          "hausdorffEdist",
          "coincide",
          "itself",
          "empty",
          "ofReal_ne_top",
          "hausdorffDist_comm",
          "eq_empty_or_nonempty",
          "have",
          "set",
          "more",
          "hausdorffDist",
          "hausdorffEdist_empty",
          "hausdorffDist_self_zero",
          "you",
          "vanishes",
          "between",
          "simp",
          "zero",
          "distance",
          "use",
          "Hausdorff",
          "ne_top_of_le_ne_top",
          "takes",
          "hausdorffDist_empty",
          "ENNReal",
          "theorem",
          "hausdorffEdist_comm",
          "exact",
          "reasonable",
          "instead",
          "distances",
          "values",
          "this",
          "from",
          "value",
          "le_trans"
        ]
      }
    },
    {
      "id": 4212,
      "before_code": "Then their properties follow readily from the corresponding properties in `\u211d\u22650\u221e`,\nmodulo some tedious rewriting of inequalities from one to the other. -/\n\n--namespace\nnamespace Metric\n\nsection\n\nvariable [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {s t u : Set \u03b1} {x y : \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}\n\nopen EMetric\n\n/-! ### Distance of a point to a set as a function into `\u211d`. -/\n\n/-- The minimal distance of a point to a set -/\ndef infDist (x : \u03b1) (s : Set \u03b1) : \u211d :=\n  ENNReal.toReal (infEdist x s)\n\ntheorem infDist_eq_iInf : infDist x s = \u2a05 y : s, dist x y := by\n  rw [infDist, infEdist, iInf_subtype', ENNReal.toReal_iInf]\n  \u00b7 simp only [dist_edist]\n  \u00b7 finiteness\n\n/-- The minimal distance is always nonnegative -/\ntheorem infDist_nonneg : 0 \u2264 infDist x s := toReal_nonneg\n\n/-- The minimal distance to the empty set is 0 (if you want to have the more reasonable\nvalue `\u221e` instead, use `EMetric.infEdist`, which takes values in `\u211d\u22650\u221e`) -/",
      "suggestion": "\r\nvalue `\u221e` instead, use `Metric.infEDist`, which takes values in `\u211d\u22650\u221e`) -/\r\n",
      "body": "```suggestion\r\nvalue `\u221e` instead, use `Metric.infEDist`, which takes values in `\u211d\u22650\u221e`) -/\r\n```",
      "path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean",
      "tags": {
        "before_tactics": [
          "have",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "rw",
          "have"
        ],
        "topics": [
          "real",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "which",
          "Metric",
          "EMetric",
          "want",
          "toReal_nonneg",
          "nonnegative",
          "open",
          "properties",
          "section",
          "modulo",
          "finiteness",
          "empty",
          "infDist_eq_iInf",
          "infDist_nonneg",
          "corresponding",
          "have",
          "set",
          "more",
          "readily",
          "point",
          "minimal",
          "follow",
          "into",
          "one",
          "other",
          "variable",
          "def",
          "iInf_subtype",
          "you",
          "tedious",
          "their",
          "simp",
          "distance",
          "toReal",
          "dist_edist",
          "inequalities",
          "Distance",
          "only",
          "namespace",
          "rewriting",
          "use",
          "takes",
          "ENNReal",
          "function",
          "theorem",
          "PseudoMetricSpace",
          "reasonable",
          "instead",
          "dist",
          "Set"
        ]
      }
    },
    {
      "id": 4213,
      "before_code": "section Diag\n\nvariable [DecidableEq \u03b1] (s t : Finset \u03b1)\n\n/-- Given a finite set `s`, the diagonal, `s.diag` is the set of pairs of the form `(a, a)` for\n`a \u2208 s`. -/\ndef diag :=",
      "suggestion": "\r\ndef diag : Finset (\u03b1 \u00d7 \u03b1) :=\r\n",
      "body": "```suggestion\r\ndef diag : Finset (\u03b1 \u00d7 \u03b1) :=\r\n```",
      "path": "Mathlib/Data/Finset/Prod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "pairs",
          "variable",
          "def",
          "Finset",
          "Diag",
          "diag",
          "set",
          "Given",
          "finite",
          "DecidableEq",
          "diagonal",
          "section",
          "for",
          "form"
        ]
      }
    },
    {
      "id": 4215,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "    (path : Path) (loc : Option Name) (xs : Syntax.TSepArray ``enterArg \",\" := {}) :\n",
      "body": "Style:\n```suggestion\n    (path : Path) (loc : Option Name) (xs : Syntax.TSepArray ``enterArg \",\" := {}) :\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "String",
          "zooming",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "arguments",
          "def",
          "reach",
          "listRest",
          "return",
          "nextExp",
          "length",
          "conv",
          "through",
          "goal",
          "List",
          "isApp",
          "meta",
          "appFn",
          "end",
          "our",
          "head",
          "match",
          "explicit",
          "forallE",
          "explicitList",
          "has",
          "implicit",
          "enter",
          "Nat",
          "inferType",
          "subtracting",
          "false",
          "reverse",
          "path",
          "number",
          "application",
          "toString",
          "Name",
          "counting"
        ]
      }
    },
    {
      "id": 4216,
      "before_code": "a `conv` call zooming to the subexpression selected in the goal.\n-/\n\npublic meta section\n\n\nopen Lean Meta Server ProofWidgets\n\nprivate structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat\n\nprivate def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    -- we go through the application until we reach the end, counting how many explicit arguments\n    -- it has and noting whether they are explicit or implicit\n    while descExp.isApp do\n      if (\u2190 Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    -- we get the correct `enter` command by subtracting the number of `true`s in our list\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count, listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { exp",
      "suggestion": "    \"Use shift-click to select one sub-expression in the goal or local context that you want to \\\n    zoom in on.\"\n",
      "body": "May as well take this chance to improve the help message slightly:\n```suggestion\n    \"Use shift-click to select one sub-expression in the goal or local context that you want to \\\n    zoom in on.\"\n```",
      "path": "Mathlib/Tactic/Widget/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "SolveReturn",
          "locations",
          "String",
          "server_rpc_method",
          "character",
          "zooming",
          "Return",
          "until",
          "many",
          "mut",
          "correct",
          "open",
          "while",
          "else",
          "private",
          "name",
          "panic",
          "lam",
          "selected",
          "select",
          "arguments",
          "res",
          "Conv",
          "def",
          "mkSelectionPanelRPC",
          "something",
          "reach",
          "listRest",
          "throwError",
          "return",
          "that",
          "pure",
          "nextExp",
          "valid",
          "expression",
          "enterval",
          "length",
          "conv",
          "below",
          "through",
          "goal",
          "widget",
          "unusedArguments",
          "commands",
          "List",
          "value",
          "isApp",
          "meta",
          "appFn",
          "end"
        ]
      }
    },
    {
      "id": 4221,
      "before_code": "ext1 f\n  exact smulLeftCLM_smulLeftCLM_apply hg\u2081 hg\u2082 f",
      "suggestion": "    smulLeftCLM F (-g) = -smulLeftCLM F g := by\n",
      "body": "```suggestion\n    smulLeftCLM F (-g) = -smulLeftCLM F g := by\n```",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "ext1",
          "smulLeftCLM_smulLeftCLM_apply"
        ]
      }
    },
    {
      "id": 4222,
      "before_code": "theorem smul_sup' (a : \u03b1) (S T : Submodule R M) : a \u2022 (S \u2294 T) = a \u2022 S \u2294 a \u2022 T :=\n  map_sup _ _ _",
      "suggestion": "\r\n    a \u2022 \u2a06 i, f i = \u2a06 i, a \u2022 f i :=\r\n  map_iSup _ _\r\n",
      "body": "(Nitpick, just to match the proofs around)\r\n```suggestion\r\n    a \u2022 \u2a06 i, f i = \u2a06 i, a \u2022 f i :=\r\n  map_iSup _ _\r\n```",
      "path": "Mathlib/Algebra/Module/Submodule/Pointwise.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "map_sup",
          "Submodule",
          "theorem",
          "smul_sup"
        ]
      }
    },
    {
      "id": 4223,
      "before_code": "theorem IsSemireal.not_isSumSq_neg_one [AddGroup R] [One R] [Mul R] [IsSemireal R] :\n    \u00ac IsSumSq (-1 : R) := (by simpa using one_add_ne_zero \u00b7)",
      "suggestion": "\r\n  mp := .not_isSumSq_neg_one\r\n",
      "body": "Does this work?\r\n```suggestion\r\n  mp := .not_isSumSq_neg_one\r\n```",
      "path": "Mathlib/Algebra/Ring/Semireal/Defs.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "AddGroup",
          "theorem",
          "not_isSumSq_neg_one",
          "simpa",
          "one_add_ne_zero",
          "One",
          "IsSumSq",
          "IsSemireal",
          "Mul",
          "using"
        ]
      }
    },
    {
      "id": 4229,
      "before_code": "theorem measure_smul (c : G) (s : Set \u03b1) : \u03bc (c \u2022 s) = \u03bc s := by\n  simpa only [preimage_smul_inv] using measure_preimage_smul \u03bc c\u207b\u00b9 s",
      "suggestion": "\r\n  rw [\u2190 measure_smul _ c (s \u2229 c\u207b\u00b9 \u2022 t), smul_set_inter, smul_smul, mul_inv_cancel, one_smul]\r\n",
      "body": "```suggestion\r\n  rw [\u2190 measure_smul _ c (s \u2229 c\u207b\u00b9 \u2022 t), smul_set_inter, smul_smul, mul_inv_cancel, one_smul]\r\n```\r\nSame below",
      "path": "Mathlib/MeasureTheory/Group/Action.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "measure_preimage_smul",
          "measure_smul",
          "theorem",
          "Set",
          "preimage_smul_inv",
          "simpa",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 4230,
      "before_code": "alias \u27e8IsCompact.ultrafilter_le_nhds', _\u27e9 := isCompact_iff_ultrafilter_le_nhds'",
      "suggestion": "\r\ntheorem Ultrafilter.tendsto_of_eventually_mem_isCompact {g : \u03b9 \u2192 X} {s : Set X} (f : Ultrafilter \u03b9)\r\n",
      "body": "```suggestion\r\ntheorem Ultrafilter.tendsto_of_eventually_mem_isCompact {g : \u03b9 \u2192 X} {s : Set X} (f : Ultrafilter \u03b9)\r\n```",
      "path": "Mathlib/Topology/Compactness/Compact.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "alias",
          "ultrafilter_le_nhds",
          "IsCompact",
          "isCompact_iff_ultrafilter_le_nhds"
        ]
      }
    },
    {
      "id": 4232,
      "before_code": "/-!\n# Adapted and progressively measurable processes\n\nThis file defines some standard definition from the theory of stochastic processes including\nfiltrations and stopping times. These definitions are used to model the amount of information\nat a specific time and are the first step in formalizing stochastic processes.",
      "suggestion": "(progressively measurable) with respect to a filtration `f`, and proves some basic facts about them.\n",
      "body": "We rather use \"filtration\".\n```suggestion\n(progressively measurable) with respect to a filtration `f`, and proves some basic facts about them.\n```",
      "path": "Mathlib/Probability/Process/Adapted.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "time",
          "file",
          "stochastic",
          "specific",
          "This",
          "These",
          "filtrations",
          "formalizing",
          "step",
          "standard",
          "times",
          "are",
          "processes",
          "used",
          "definitions",
          "progressively",
          "definition",
          "defines",
          "amount",
          "first",
          "Adapted",
          "model",
          "stopping",
          "theory",
          "from",
          "information",
          "including",
          "measurable",
          "some"
        ]
      }
    },
    {
      "id": 4233,
      "before_code": "/-!\n# Adapted and progressively measurable processes\n\nThis file defines some standard definition from the theory of stochastic processes including\nfiltrations and stopping times. These definitions are used to model the amount of information\nat a specific time and are the first step in formalizing stochastic processes.\n\n## Main definitions\n\n* `MeasureTheory.Adapted`: a sequence of functions `u` is said to be adapted to a",
      "suggestion": "* `MeasureTheory.StronglyAdapted`: a sequence of functions `u` is said to be strongly adapted to a\n",
      "body": "```suggestion\n* `MeasureTheory.StronglyAdapted`: a sequence of functions `u` is said to be strongly adapted to a\n```",
      "path": "Mathlib/Probability/Process/Adapted.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "time",
          "file",
          "said",
          "stochastic",
          "Main",
          "specific",
          "This",
          "These",
          "filtrations",
          "formalizing",
          "step",
          "standard",
          "times",
          "are",
          "processes",
          "used",
          "definitions",
          "sequence",
          "progressively",
          "definition",
          "defines",
          "amount",
          "first",
          "Adapted",
          "model",
          "MeasureTheory",
          "stopping",
          "theory",
          "from",
          "adapted",
          "information",
          "including",
          "functions",
          "measurable",
          "some"
        ]
      }
    },
    {
      "id": 4234,
      "before_code": "## Main results\n\n* `Adapted.progMeasurable_of_continuous`: a continuous adapted process is progressively measurable.",
      "suggestion": "  progressively measurable.\n",
      "body": "```suggestion\n  progressively measurable.\n```",
      "path": "Mathlib/Probability/Process/Adapted.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "Adapted",
          "progMeasurable_of_continuous",
          "results",
          "continuous",
          "progressively",
          "adapted",
          "Main",
          "measurable",
          "process"
        ]
      }
    },
    {
      "id": 4235,
      "before_code": "## Main results\n\n* `MeasureTheory.hittingBtwn_isStoppingTime`: a discrete hitting time of an adapted process is a\n  stopping time\n* `MeasureTheory.hittingAfter_isStoppingTime`: a discrete hitting time of an adapted process is a\n  stopping time",
      "suggestion": "  is a stopping time\n",
      "body": "```suggestion\n  is a stopping time\n```",
      "path": "Mathlib/Probability/Process/HittingTime.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "time",
          "discrete",
          "results",
          "hittingBtwn_isStoppingTime",
          "MeasureTheory",
          "stopping",
          "hitting",
          "Main",
          "hittingAfter_isStoppingTime",
          "adapted",
          "process"
        ]
      }
    },
    {
      "id": 4236,
      "before_code": "## Main results\n\n* `MeasureTheory.hittingBtwn_isStoppingTime`: a discrete hitting time of an adapted process is a\n  stopping time\n* `MeasureTheory.hittingAfter_isStoppingTime`: a discrete hitting time of an adapted process is a\n  stopping time",
      "suggestion": "  is a stopping time\n",
      "body": "```suggestion\n  is a stopping time\n```",
      "path": "Mathlib/Probability/Process/HittingTime.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "time",
          "discrete",
          "results",
          "hittingBtwn_isStoppingTime",
          "MeasureTheory",
          "stopping",
          "hitting",
          "Main",
          "hittingAfter_isStoppingTime",
          "adapted",
          "process"
        ]
      }
    },
    {
      "id": 4237,
      "before_code": "namespace Supermartingale\n\nprotected theorem adapted [LE E] (hf : Supermartingale f \u2131 \u03bc) : Adapted \u2131 f :=",
      "suggestion": "protected theorem stronglyAdapted [LE E] (hf : Supermartingale f \u2131 \u03bc) : StronglyAdapted \u2131 f :=\n",
      "body": "```suggestion\nprotected theorem stronglyAdapted [LE E] (hf : Supermartingale f \u2131 \u03bc) : StronglyAdapted \u2131 f :=\n```",
      "path": "Mathlib/Probability/Martingale/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Adapted",
          "theorem",
          "protected",
          "adapted",
          "Supermartingale",
          "namespace"
        ]
      }
    },
    {
      "id": 4238,
      "before_code": "section",
      "suggestion": "\r\n  congr($(hfg.iteratedFDerivWithin_eq hfg' n) _)\r\n",
      "body": "```suggestion\r\n  congr($(hfg.iteratedFDerivWithin_eq hfg' n) _)\r\n```\r\nseems to work",
      "path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "congr"
        ],
        "body_tactics": [
          "congr"
        ],
        "new_tactics": [
          "congr"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "section"
        ]
      }
    },
    {
      "id": 4239,
      "before_code": "end Over",
      "suggestion": "def Limits.Cone.overPost\n    {J C : Type*} [Category* J] [Category* C] {D : J \u2964 C} (c : Cone D) (j : J) :\n    Cone (Over.post (X := j) D) where\n",
      "body": "```suggestion\ndef Limits.Cone.overPost\n    {J C : Type*} [Category* J] [Category* C] {D : J \u2964 C} (c : Cone D) (j : J) :\n    Cone (Over.post (X := j) D) where\n```",
      "path": "Mathlib/CategoryTheory/Comma/Over/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Over",
          "end"
        ]
      }
    },
    {
      "id": 4240,
      "before_code": "refine cfc_congr fun x hx => ?_\n  grind [Real.exp_log]",
      "suggestion": "\r\n    [IsometricContinuousFunctionalCalculus \u211d A IsSelfAdjoint] [ContinuousStar A] [CompleteSpace A] :\r\n    ContinuousOn log {a : A | IsStrictlyPositive a} :=\r\n",
      "body": "```suggestion\r\n    [IsometricContinuousFunctionalCalculus \u211d A IsSelfAdjoint] [ContinuousStar A] [CompleteSpace A] :\r\n    ContinuousOn log {a : A | IsStrictlyPositive a} :=\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/ExpLog/Basic.lean",
      "tags": {
        "before_tactics": [
          "grind",
          "refine"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "grind",
          "refine"
        ],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "refine",
          "grind",
          "Real",
          "exp_log",
          "cfc_congr"
        ]
      }
    },
    {
      "id": 4241,
      "before_code": "theorem restrictScalars_eq_top_iff {p : Submodule R M} : restrictScalars S p = \u22a4 \u2194 p = \u22a4 := by\n  simp [SetLike.ext_iff]\n\n/-- If ring `S` acts on a ring `R` and `M` is a module over both (compatibly with this action) then\nwe can turn an `R`-submodule into an `S`-submodule by forgetting the action of `R`. -/\ndef restrictScalarsLatticeHom : CompleteLatticeHom (Submodule R M) (Submodule S M) where\n  toFun := restrictScalars S\n  map_sInf' s := by ext; simp\n  map_sSup' s := by rw [\u2190 toAddSubmonoid_inj, toAddSubmonoid_sSup, \u2190 Set.image_comp]; simp",
      "suggestion": "\r\n    (s \u2294 t).restrictScalars S = s.restrictScalars S \u2294 t.restrictScalars S := by\r\n",
      "body": "```suggestion\r\n    (s \u2294 t).restrictScalars S = s.restrictScalars S \u2294 t.restrictScalars S := by\r\n```",
      "path": "Mathlib/Algebra/Module/Submodule/RestrictScalars.lean",
      "tags": {
        "before_tactics": [
          "ring",
          "rw",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring",
          "rw",
          "simp",
          "ext"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "map_sInf",
          "CompleteLatticeHom",
          "restrictScalarsLatticeHom",
          "forgetting",
          "turn",
          "toAddSubmonoid_sSup",
          "map_sSup",
          "compatibly",
          "restrictScalars",
          "ext",
          "Submodule",
          "toAddSubmonoid_inj",
          "into",
          "action",
          "can",
          "submodule",
          "then",
          "SetLike",
          "def",
          "image_comp",
          "both",
          "toFun",
          "module",
          "over",
          "simp",
          "ring",
          "restrictScalars_eq_top_iff",
          "theorem",
          "ext_iff",
          "Set",
          "this",
          "acts"
        ]
      }
    },
    {
      "id": 4242,
      "before_code": "theorem coe_sqrt {x : \u211d\u22650} : (NNReal.sqrt x : \u211d) = \u221a(x : \u211d) := by\n  rw [Real.sqrt, Real.toNNReal_coe]\n\n@[continuity]\ntheorem continuous_sqrt : Continuous (\u221a\u00b7 : \u211d \u2192 \u211d) := by\n  unfold sqrt\n  exact NNReal.continuous_coe.comp <| NNReal.continuous_sqrt.comp continuous_real_toNNReal",
      "suggestion": "\r\n  unfold sqrt\r\n  change map (NNReal.toReal \u2218 NNReal.sqrt \u2218 Real.toNNReal) atTop = atTop\r\n",
      "body": "```suggestion\r\n  unfold sqrt\r\n  change map (NNReal.toReal \u2218 NNReal.sqrt \u2218 Real.toNNReal) atTop = atTop\r\n```\r\nseems at lower risk of unfolding more than necessary, same below.",
      "path": "Mathlib/Data/Real/Sqrt.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "continuity",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "continuity",
          "rw"
        ],
        "topics": [
          "continuity",
          "real"
        ],
        "transforms": [],
        "keywords": [
          "unfold",
          "sqrt",
          "theorem",
          "continuous_coe",
          "toNNReal_coe",
          "continuity",
          "continuous_sqrt",
          "exact",
          "Real",
          "continuous_real_toNNReal",
          "comp",
          "Continuous",
          "coe_sqrt",
          "NNReal"
        ]
      }
    },
    {
      "id": 4243,
      "before_code": "unitIso := NatIso.ofComponents (fun A \u21a6 Over.isoMk (F.unitIso.app A.left))\n  counitIso := NatIso.ofComponents (fun A \u21a6 Over.isoMk (F.counitIso.app A.left))",
      "suggestion": "\r\nfunctor `Over.iteratedSliceForward : Over f \u2964 Over f.left`. -/\r\n",
      "body": "```suggestion\r\nfunctor `Over.iteratedSliceForward : Over f \u2964 Over f.left`. -/\r\n```",
      "path": "Mathlib/CategoryTheory/Comma/Over/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Over",
          "ofComponents",
          "left",
          "isoMk",
          "app",
          "NatIso",
          "counitIso",
          "unitIso"
        ]
      }
    },
    {
      "id": 4244,
      "before_code": "rw [homMk_comp_homMk ((Edge.CompStruct.idComp ex).tensor (Edge.CompStruct.compId ey)),\n    homMk_comp_homMk ((Edge.CompStruct.compId ex).tensor (Edge.CompStruct.idComp ey))]",
      "suggestion": "\r\n",
      "body": "On my machine it compiles just fine without this\r\n```suggestion\r\n```\r\nRemnants of a previous version?",
      "path": "Mathlib/AlgebraicTopology/SimplicialSet/HoFunctorMonoidal.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Edge",
          "tensor",
          "CompStruct",
          "idComp",
          "compId",
          "homMk_comp_homMk"
        ]
      }
    },
    {
      "id": 4245,
      "before_code": "rw [homMk_comp_homMk ((Edge.CompStruct.idComp ex).tensor (Edge.CompStruct.compId ey)),\n    homMk_comp_homMk ((Edge.CompStruct.compId ex).tensor (Edge.CompStruct.idComp ey))]",
      "suggestion": "\r\n    CategoryTheory.Prod.snd _ _ = Functor.prod (isoTerminal X).inv.toFunctor (\ud835\udfed _) \u22d9\r\n",
      "body": "```suggestion\r\n    CategoryTheory.Prod.snd _ _ = Functor.prod (isoTerminal X).inv.toFunctor (\ud835\udfed _) \u22d9\r\n```",
      "path": "Mathlib/AlgebraicTopology/SimplicialSet/HoFunctorMonoidal.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Edge",
          "tensor",
          "CompStruct",
          "idComp",
          "compId",
          "homMk_comp_homMk"
        ]
      }
    },
    {
      "id": 4246,
      "before_code": "rw [homMk_comp_homMk ((Edge.CompStruct.idComp ex).tensor (Edge.CompStruct.compId ey)),\n    homMk_comp_homMk ((Edge.CompStruct.compId ex).tensor (Edge.CompStruct.idComp ey))]",
      "suggestion": "\r\n    CategoryTheory.Prod.fst _ _ = Functor.prod (\ud835\udfed _) (isoTerminal Y).inv.toFunctor \u22d9\r\n",
      "body": "```suggestion\r\n    CategoryTheory.Prod.fst _ _ = Functor.prod (\ud835\udfed _) (isoTerminal Y).inv.toFunctor \u22d9\r\n```",
      "path": "Mathlib/AlgebraicTopology/SimplicialSet/HoFunctorMonoidal.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Edge",
          "tensor",
          "CompStruct",
          "idComp",
          "compId",
          "homMk_comp_homMk"
        ]
      }
    },
    {
      "id": 4247,
      "before_code": "namespace Mathlib.Tactic.Conv\nopen Lean Parser.Tactic Parser.Tactic.Conv Elab.Tactic Meta\n\nsyntax (name := convLHS) \"conv_lhs\" (\" at \" ident)? (\" in \" (occs)? term)? \" => \" convSeq : tactic\nmacro_rules\n  | `(tactic| conv_lhs $[at $id]? $[in $[$occs]? $pat]? => $seq) =>\n    `(tactic| conv $[at $id]? $[in $[$occs]? $pat]? => lhs; ($seq:convSeq))",
      "suggestion": "\r\nIt is a synonym for `conv => arg -1; cs`.\r\n",
      "body": "```suggestion\r\nIt is a synonym for `conv => arg -1; cs`.\r\n```",
      "path": "Mathlib/Tactic/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pat",
          "seq",
          "conv_lhs",
          "open",
          "occs",
          "Mathlib",
          "Lean",
          "lhs",
          "syntax",
          "convSeq",
          "name",
          "macro_rules",
          "Conv",
          "Elab",
          "ident",
          "tactic",
          "namespace",
          "term",
          "conv",
          "Parser",
          "Meta",
          "convLHS",
          "Tactic"
        ]
      }
    },
    {
      "id": 4248,
      "before_code": "namespace Mathlib.Tactic.Conv\nopen Lean Parser.Tactic Parser.Tactic.Conv Elab.Tactic Meta\n\nsyntax (name := convLHS) \"conv_lhs\" (\" at \" ident)? (\" in \" (occs)? term)? \" => \" convSeq : tactic\nmacro_rules\n  | `(tactic| conv_lhs $[at $id]? $[in $[$occs]? $pat]? => $seq) =>\n    `(tactic| conv $[at $id]? $[in $[$occs]? $pat]? => lhs; ($seq:convSeq))",
      "suggestion": "\r\n* `conv_rhs at h => cs` runs `cs` on the right hand side of hypothesis `h`.\r\n",
      "body": "```suggestion\r\n* `conv_rhs at h => cs` runs `cs` on the right hand side of hypothesis `h`.\r\n```",
      "path": "Mathlib/Tactic/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pat",
          "seq",
          "conv_lhs",
          "open",
          "occs",
          "Mathlib",
          "Lean",
          "lhs",
          "syntax",
          "convSeq",
          "name",
          "macro_rules",
          "Conv",
          "Elab",
          "ident",
          "tactic",
          "namespace",
          "term",
          "conv",
          "Parser",
          "Meta",
          "convLHS",
          "Tactic"
        ]
      }
    },
    {
      "id": 4249,
      "before_code": "namespace Mathlib.Tactic.Conv\nopen Lean Parser.Tactic Parser.Tactic.Conv Elab.Tactic Meta\n\nsyntax (name := convLHS) \"conv_lhs\" (\" at \" ident)? (\" in \" (occs)? term)? \" => \" convSeq : tactic\nmacro_rules\n  | `(tactic| conv_lhs $[at $id]? $[in $[$occs]? $pat]? => $seq) =>\n    `(tactic| conv $[at $id]? $[in $[$occs]? $pat]? => lhs; ($seq:convSeq))",
      "suggestion": "\r\n* `conv_rhs in pat => cs` first looks for a subexpression matching `pat` (see the `pattern`\r\n",
      "body": "```suggestion\r\n* `conv_rhs in pat => cs` first looks for a subexpression matching `pat` (see the `pattern`\r\n```",
      "path": "Mathlib/Tactic/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pat",
          "seq",
          "conv_lhs",
          "open",
          "occs",
          "Mathlib",
          "Lean",
          "lhs",
          "syntax",
          "convSeq",
          "name",
          "macro_rules",
          "Conv",
          "Elab",
          "ident",
          "tactic",
          "namespace",
          "term",
          "conv",
          "Parser",
          "Meta",
          "convLHS",
          "Tactic"
        ]
      }
    },
    {
      "id": 4250,
      "before_code": "namespace Mathlib.Tactic.Conv\nopen Lean Parser.Tactic Parser.Tactic.Conv Elab.Tactic Meta\n\nsyntax (name := convLHS) \"conv_lhs\" (\" at \" ident)? (\" in \" (occs)? term)? \" => \" convSeq : tactic\nmacro_rules\n  | `(tactic| conv_lhs $[at $id]? $[in $[$occs]? $pat]? => $seq) =>\n    `(tactic| conv $[at $id]? $[in $[$occs]? $pat]? => lhs; ($seq:convSeq))",
      "suggestion": "\r\nIn general, for an `n`-ary operator as the target, it traverses into the last argument.\r\n",
      "body": "```suggestion\r\nIn general, for an `n`-ary operator as the target, it traverses into the last argument.\r\n```",
      "path": "Mathlib/Tactic/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pat",
          "seq",
          "conv_lhs",
          "open",
          "occs",
          "Mathlib",
          "Lean",
          "lhs",
          "syntax",
          "convSeq",
          "name",
          "macro_rules",
          "Conv",
          "Elab",
          "ident",
          "tactic",
          "namespace",
          "term",
          "conv",
          "Parser",
          "Meta",
          "convLHS",
          "Tactic"
        ]
      }
    },
    {
      "id": 4251,
      "before_code": "namespace Mathlib.Tactic.Conv\nopen Lean Parser.Tactic Parser.Tactic.Conv Elab.Tactic Meta\n\nsyntax (name := convLHS) \"conv_lhs\" (\" at \" ident)? (\" in \" (occs)? term)? \" => \" convSeq : tactic\nmacro_rules\n  | `(tactic| conv_lhs $[at $id]? $[in $[$occs]? $pat]? => $seq) =>\n    `(tactic| conv $[at $id]? $[in $[$occs]? $pat]? => lhs; ($seq:convSeq))",
      "suggestion": "\r\nIn general, for an `n`-ary operator as the target, it traverses into the last argument.\r\n",
      "body": "```suggestion\r\nIn general, for an `n`-ary operator as the target, it traverses into the last argument.\r\n```",
      "path": "Mathlib/Tactic/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pat",
          "seq",
          "conv_lhs",
          "open",
          "occs",
          "Mathlib",
          "Lean",
          "lhs",
          "syntax",
          "convSeq",
          "name",
          "macro_rules",
          "Conv",
          "Elab",
          "ident",
          "tactic",
          "namespace",
          "term",
          "conv",
          "Parser",
          "Meta",
          "convLHS",
          "Tactic"
        ]
      }
    },
    {
      "id": 4252,
      "before_code": "namespace Mathlib.Tactic.Conv\nopen Lean Parser.Tactic Parser.Tactic.Conv Elab.Tactic Meta\n\nsyntax (name := convLHS) \"conv_lhs\" (\" at \" ident)? (\" in \" (occs)? term)? \" => \" convSeq : tactic\nmacro_rules\n  | `(tactic| conv_lhs $[at $id]? $[in $[$occs]? $pat]? => $seq) =>\n    `(tactic| conv $[at $id]? $[in $[$occs]? $pat]? => lhs; ($seq:convSeq))",
      "suggestion": "\r\nIt is a synonym for `conv => arg -1; cs`.\r\n",
      "body": "```suggestion\r\nIt is a synonym for `conv => arg -1; cs`.\r\n```",
      "path": "Mathlib/Tactic/Conv.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pat",
          "seq",
          "conv_lhs",
          "open",
          "occs",
          "Mathlib",
          "Lean",
          "lhs",
          "syntax",
          "convSeq",
          "name",
          "macro_rules",
          "Conv",
          "Elab",
          "ident",
          "tactic",
          "namespace",
          "term",
          "conv",
          "Parser",
          "Meta",
          "convLHS",
          "Tactic"
        ]
      }
    },
    {
      "id": 4255,
      "before_code": "that of a functor `T : X \u2964 A`, a functor `L : X \u2964 C`, and a `CatCommSqOver T L F G`.\nNote that this is *exactly* what an object of\n`((whiskeringRight X A B).obj F) \u22a1 ((whiskeringRight X C B).obj G)` is,\nso `CatCommSqOver F G X` is in fact an abbreviation for\n`((whiskeringRight X A B).obj F) \u22a1 ((whiskeringRight X C B).obj G)`. -/\nabbrev CatCommSqOver :=\n  (whiskeringRight X A B |>.obj F) \u22a1 (whiskeringRight X C B |>.obj G)\n\nnamespace CatCommSqOver",
      "suggestion": "    (h\u2081 : f.fst = g.fst) (h\u2082 : f.snd = g.snd) : f = g :=\n  Hom.ext h\u2081 h\u2082\n",
      "body": "```suggestion\n    (h\u2081 : f.fst = g.fst) (h\u2082 : f.snd = g.snd) : f = g :=\n  Hom.ext h\u2081 h\u2082\n```",
      "path": "Mathlib/CategoryTheory/Limits/Shapes/Pullback/Categorical/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "object",
          "whiskeringRight",
          "abbrev",
          "functor",
          "exactly",
          "what",
          "Note",
          "this",
          "that",
          "CatCommSqOver",
          "abbreviation",
          "obj",
          "fact",
          "for",
          "namespace"
        ]
      }
    },
    {
      "id": 4256,
      "before_code": "/-- `span` is a semiring homomorphism (recall multiplication is pointwise multiplication of subsets\non either side). -/\n@[simps]\nnoncomputable def span.ringHom : SetSemiring A \u2192+* Submodule R A where\n  toFun s := Submodule.span R (SetSemiring.down s)\n  map_zero' := span_empty\n  map_one' := one_eq_span.symm\n  map_add' := span_union\n  map_mul' s t := by simp_rw [SetSemiring.down_mul, span_mul_span]",
      "suggestion": "\r\ntheorem mker_spanSingleton :\r\n",
      "body": "```suggestion\r\ntheorem mker_spanSingleton :\r\n```",
      "path": "Mathlib/Algebra/Algebra/Operations.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "map_one",
          "recall",
          "map_zero",
          "multiplication",
          "down_mul",
          "either",
          "side",
          "symm",
          "span_union",
          "noncomputable",
          "subsets",
          "map_mul",
          "Submodule",
          "span_empty",
          "simp_rw",
          "def",
          "SetSemiring",
          "toFun",
          "span",
          "simps",
          "map_add",
          "homomorphism",
          "pointwise",
          "down",
          "one_eq_span",
          "span_mul_span",
          "semiring",
          "ringHom"
        ]
      }
    },
    {
      "id": 4258,
      "before_code": "\u00b7 exact Or.inl \u27e8m, h\u27e9\n    \u00b7 exact Or.inr (mem_radical_of_pow_mem h)\u27e9",
      "suggestion": "\r\n   by_cases h : I + span {y} = \u22a4\r\n",
      "body": "```suggestion\r\n   by_cases h : I + span {y} = \u22a4\r\n```\r\nI think this is much clearer.",
      "path": "Mathlib/RingTheory/Ideal/IsPrimary.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "inl",
          "inr",
          "mem_radical_of_pow_mem"
        ]
      }
    },
    {
      "id": 4259,
      "before_code": "\u00b7 exact Or.inl \u27e8m, h\u27e9\n    \u00b7 exact Or.inr (mem_radical_of_pow_mem h)\u27e9",
      "suggestion": "\r\n    by_cases h : I + span {y} = \u22a4\r\n",
      "body": "```suggestion\r\n    by_cases h : I + span {y} = \u22a4\r\n```",
      "path": "Mathlib/RingTheory/Ideal/IsPrimary.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "inl",
          "inr",
          "mem_radical_of_pow_mem"
        ]
      }
    },
    {
      "id": 4260,
      "before_code": "\u2190 ringKrullDim_eq_of_ringEquiv (polyEquivTensor R (p.asIdeal.ResidueField)).toRingEquiv,\n      \u2190 Ring.krullDimLE_iff]\n    infer_instance",
      "suggestion": "\r\nSee `Polynomial.height_eq_height_add_one` for the more general version that does not assume `p` is\r\n",
      "body": "```suggestion\r\nSee `Polynomial.height_eq_height_add_one` for the more general version that does not assume `p` is\r\n```",
      "path": "Mathlib/RingTheory/KrullDimension/Polynomial.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "krullDimLE_iff",
          "ResidueField",
          "asIdeal",
          "polyEquivTensor",
          "infer_instance",
          "Ring",
          "ringKrullDim_eq_of_ringEquiv",
          "toRingEquiv"
        ]
      }
    },
    {
      "id": 4264,
      "before_code": "return\n  let srcDecl \u2190 withoutExporting do getConstInfo src\n  -- we first unfold all auxlemmas, since they are not always able to be translated on their own\n  let srcDecl \u2190 withoutExporting do MetaM.run' do declUnfoldAuxLemmas srcDecl\n  -- we then transform all auxiliary declarations generated when elaborating `pre`\n  for n in findAuxDecls srcDecl.type pre do\n    transformDeclRec t ref pre tgt_pre n\n  if let some value := srcDecl.value? (allowOpaque := true) then\n    for n in findAuxDecls value pre do\n      transformDeclRec t ref pre tgt_pre n",
      "suggestion": "\r\n  for n in withoutExporting <| findAuxDecls srcDecl.type pre do\r\n",
      "body": "```suggestion\r\n  for n in withoutExporting <| findAuxDecls srcDecl.type pre do\r\n```\r\nIs this cleaner? Up to you.",
      "path": "Mathlib/Tactic/Translate/Core.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "MetaM",
          "own",
          "true",
          "run",
          "srcDecl",
          "since",
          "when",
          "type",
          "withoutExporting",
          "findAuxDecls",
          "auxlemmas",
          "declarations",
          "are",
          "transformDeclRec",
          "translated",
          "for",
          "able",
          "getConstInfo",
          "then",
          "pre",
          "generated",
          "return",
          "src",
          "their",
          "tgt_pre",
          "first",
          "allowOpaque",
          "elaborating",
          "unfold",
          "declUnfoldAuxLemmas",
          "auxiliary",
          "ref",
          "they",
          "transform",
          "value",
          "always",
          "all",
          "some"
        ]
      }
    },
    {
      "id": 4265,
      "before_code": "\u2200\u1d50 (x : \u211d), x \u2208 uIcc a b \u2192 DifferentiableAt \u211d f x :=\n  hf.boundedVariationOn.ae_differentiableAt_of_mem_uIcc",
      "suggestion": "absolutely continuous on `uIcc a b`. -/\n",
      "body": "```suggestion\nabsolutely continuous on `uIcc a b`. -/\n```",
      "path": "Mathlib/MeasureTheory/Function/AbsolutelyContinuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "set_theory",
          "differentiability"
        ],
        "transforms": [],
        "keywords": [
          "uIcc",
          "ae_differentiableAt_of_mem_uIcc",
          "boundedVariationOn",
          "DifferentiableAt"
        ]
      }
    },
    {
      "id": 4266,
      "before_code": "AEStronglyMeasurable f (\u03bc.restrict (Ioc b a)) :=\n  h.2.aestronglyMeasurable",
      "suggestion": "protected theorem aestronglyMeasurable_restrict_uIoc (h : IntervalIntegrable f \u03bc a b) :\n",
      "body": "```suggestion\nprotected theorem aestronglyMeasurable_restrict_uIoc (h : IntervalIntegrable f \u03bc a b) :\n```",
      "path": "Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "aestronglyMeasurable",
          "restrict",
          "AEStronglyMeasurable",
          "Ioc"
        ]
      }
    },
    {
      "id": 4267,
      "before_code": "\u2200\u1d50 (x : \u211d), x \u2208 uIcc a b \u2192 DifferentiableAt \u211d f x :=\n  hf.boundedVariationOn.ae_differentiableAt_of_mem_uIcc",
      "suggestion": "",
      "body": "```suggestion\n```\nNot needed since you've given the type.",
      "path": "Mathlib/MeasureTheory/Function/AbsolutelyContinuous.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "set_theory",
          "differentiability"
        ],
        "transforms": [
          "remove_redundant"
        ],
        "keywords": [
          "uIcc",
          "ae_differentiableAt_of_mem_uIcc",
          "boundedVariationOn",
          "DifferentiableAt"
        ]
      }
    },
    {
      "id": 4269,
      "before_code": "IsOpenMap f \u2194 LowerHemicontinuous (f \u207b\u00b9' {\u00b7}) := by\n  rw [isOpenMap_iff_kernImage, lowerHemicontinuous_iff_isClosed_preimage_Iic]\n  aesop",
      "suggestion": "",
      "body": "Keep this if you like but I'd drop it, unless you want to actually point to a specific reference\n```suggestion\n```",
      "path": "Mathlib/Topology/Semicontinuity/Hemicontinuity.lean",
      "tags": {
        "before_tactics": [
          "aesop",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "aesop",
          "rw"
        ],
        "topics": [
          "continuity",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "IsOpenMap",
          "aesop",
          "LowerHemicontinuous",
          "isOpenMap_iff_kernImage",
          "lowerHemicontinuous_iff_isClosed_preimage_Iic"
        ]
      }
    },
    {
      "id": 4270,
      "before_code": "Tendsto (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm (f \u00d7\u02e2 (g \u00d7\u02e2 h)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) :=\n  (prod_assoc_symm f g h).le",
      "suggestion": "  rw [eventually_assoc_iff]\n",
      "body": "```suggestion\n  rw [eventually_assoc_iff]\n```",
      "path": "Mathlib/Order/Filter/Prod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "prod_assoc_symm",
          "prodAssoc",
          "Tendsto",
          "Equiv"
        ]
      }
    },
    {
      "id": 4271,
      "before_code": "Tendsto (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm (f \u00d7\u02e2 (g \u00d7\u02e2 h)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) :=\n  (prod_assoc_symm f g h).le",
      "suggestion": "theorem eventually_assoc_iff' {\u03b1 \u03b2 \u03b3 : Type*}\n",
      "body": "```suggestion\ntheorem eventually_assoc_iff' {\u03b1 \u03b2 \u03b3 : Type*}\n```",
      "path": "Mathlib/Order/Filter/Prod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "prod_assoc_symm",
          "prodAssoc",
          "Tendsto",
          "Equiv"
        ]
      }
    },
    {
      "id": 4272,
      "before_code": "We also define a predicate `MeasureTheory.OuterMeasure.IsMetric` which says that an outer measure\nis additive on metric separated pairs of sets: `\u03bc (s \u222a t) = \u03bc s + \u03bc t` provided that\n`\u2a05 (x \u2208 s) (y \u2208 t), edist x y \u2260 0`. This is the property required for the Carath\u00e9odory theorem",
      "suggestion": "\r\n`\u2a05 (x \u2208 s) (y \u2208 t), edist x y \u2260 0`. This is the property required for Carath\u00e9odory's theorem\r\n",
      "body": "```suggestion\r\n`\u2a05 (x \u2208 s) (y \u2208 t), edist x y \u2260 0`. This is the property required for Carath\u00e9odory's theorem\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "which",
          "says",
          "separated",
          "This",
          "provided",
          "required",
          "also",
          "for",
          "pairs",
          "IsMetric",
          "that",
          "OuterMeasure",
          "metric",
          "additive",
          "predicate",
          "theorem",
          "property",
          "MeasureTheory",
          "measure",
          "edist",
          "sets",
          "define",
          "outer"
        ]
      }
    },
    {
      "id": 4273,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences",
      "suggestion": "\r\n            seqs.insert range\r\n",
      "body": "```suggestion\r\n            seqs.insert range\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "children",
          "getKind",
          "byTactic",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "Similarly",
          "getting",
          "original",
          "syntax",
          "Array",
          "context",
          "getHeadInfo",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "filterMap",
          "visitM",
          "Tactic",
          "surrounding",
          "childTactics",
          "fileMap",
          "new",
          "snd",
          "child",
          "collect",
          "get",
          "into",
          "then"
        ]
      }
    },
    {
      "id": 4274,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences",
      "suggestion": "\r\n            containers.insert range\r\n",
      "body": "```suggestion\r\n            containers.insert range\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "children",
          "getKind",
          "byTactic",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "Similarly",
          "getting",
          "original",
          "syntax",
          "Array",
          "context",
          "getHeadInfo",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "filterMap",
          "visitM",
          "Tactic",
          "surrounding",
          "childTactics",
          "fileMap",
          "new",
          "snd",
          "child",
          "collect",
          "get",
          "into",
          "then"
        ]
      }
    },
    {
      "id": 4275,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences",
      "suggestion": "\r\n              fails.insert range\r\n",
      "body": "```suggestion\r\n              fails.insert range\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "children",
          "getKind",
          "byTactic",
          "ctx",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "Similarly",
          "getting",
          "original",
          "syntax",
          "Array",
          "context",
          "getHeadInfo",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers",
          "skip",
          "filterMap",
          "visitM",
          "Tactic",
          "surrounding",
          "childTactics",
          "fileMap",
          "new",
          "snd",
          "child",
          "collect",
          "get",
          "into",
          "then"
        ]
      }
    },
    {
      "id": 4276,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n              (seqs, tacs.insertIfNew range (ctx, ti), fails, containers)\r\n",
      "body": "```suggestion\r\n              (seqs, tacs.insertIfNew range (ctx, ti), fails, containers)\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 4277,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nif you accept the `Hash{Set, Map}` change, then this is no longer needed.",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 4278,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n        failRange.start \u2264 tacRange.start && tacRange.stop \u2264 failRange.stop\r\n",
      "body": "```suggestion\r\n        failRange.start \u2264 tacRange.start && tacRange.stop \u2264 failRange.stop\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 4279,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n      containerRange.start < tacRange.start && tacRange.stop \u2264 containerRange.stop &&\r\n",
      "body": "```suggestion\r\n      containerRange.start < tacRange.start && tacRange.stop \u2264 containerRange.stop &&\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 4280,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n        nestedContainer.start < tacRange.start && tacRange.stop \u2264 nestedContainer.stop\r\n",
      "body": "```suggestion\r\n        nestedContainer.start < tacRange.start && tacRange.stop \u2264 nestedContainer.stop\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 4281,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n      (seqRange.start \u2264 tacRange.start && tacRange.stop \u2264 seqRange.stop) &&\r\n",
      "body": "```suggestion\r\n      (seqRange.start \u2264 tacRange.start && tacRange.stop \u2264 seqRange.stop) &&\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 4282,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n        nestedRange.start \u2264 tacRange.start && tacRange.stop \u2264 nestedRange.stop &&\r\n",
      "body": "```suggestion\r\n        nestedRange.start \u2264 tacRange.start && tacRange.stop \u2264 nestedRange.stop &&\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 4283,
      "before_code": "Similarly, a declaration with multiple `by` blocks results in each of the blocks getting its\nown sequence.\n-/\ndef findTacticSeqs (tree : InfoTree) : CommandElabM (Array (Array TacticNode)) := do\n  -- Turn the CommandElabM into a surrounding context for traversing the tree.\n  let ctx \u2190 read\n  let state \u2190 get\n  let ctxInfo := { env := state.env, fileMap := ctx.fileMap, ngen := state.ngen }\n  let out \u2190 tree.visitM (m := CommandElabM) (ctx? := some ctxInfo)\n    (fun _ _ _ => pure true) -- Assumption: a tactic can occur as a child of any piece of syntax.\n    (fun ctx i _c cs => do\n      let relevantChildren := (cs.filterMap id).toArray\n      let childTactics := relevantChildren.filterMap Prod.fst\n      let childSequences := (relevantChildren.map Prod.snd).flatten\n      let stx := i.stx\n      if let some (.original _ _ _ _) := stx.getHeadInfo? then\n        -- Punctuation: skip this.\n        if stx.getKind \u2208 [`\u00ab;\u00bb, `Lean.cdotTk, `\u00ab]\u00bb, nullKind, `\u00abby\u00bb] then\n          return (none, childSequences)\n        -- Tactic modifiers: return the children unmodified.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.withAnnotateState] then\n          return (childTactics[0]?, childSequences)\n        -- Tactic sequencing operators: collect all the child tactics into a new sequence.\n        if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticSeq, ``Lean.Parser.Tactic.tacticSeq1Indented,\n            ``Lean.Parser.Term.byTactic] then\n          return (none, if childTactics.isEmpty then\n              childSequences\n            else\n              childSequences.push childTactics)\n\n        -- Remaining options: plain pieces of syntax.\n        -- We discard `childTactics` here, because those are either already picked up by a\n        -- sequencing operator, or come from macros.\n        if let .ofTacticInfo i := i then\n          let childSequences :=\n            -- This tactic accepts the failure of its children.\n            if stx.getKind \u2208 [``Lean.Parser.Tactic.tacticTry_, ``Lean.Parser.Tactic.anyGoals]",
      "suggestion": "\r\n        seqRange.start \u2264 containerRange.start && containerRange.stop \u2264 seqRange.stop &&\r\n        containerRange.start < tacRange.start && tacRange.stop \u2264 containerRange.stop))\r\n",
      "body": "```suggestion\r\n        seqRange.start \u2264 containerRange.start && containerRange.stop \u2264 seqRange.stop &&\r\n        containerRange.start < tacRange.start && tacRange.stop \u2264 containerRange.stop))\r\n```",
      "path": "Mathlib/Tactic/TacticAnalysis.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "read",
          "results",
          "piece",
          "flatten",
          "findTacticSeqs",
          "discard",
          "children",
          "plain",
          "getKind",
          "Remaining",
          "byTactic",
          "else",
          "tacticTry_",
          "ctx",
          "getD",
          "out",
          "def",
          "return",
          "env",
          "pure",
          "state",
          "blocks",
          "Assumption",
          "Parser",
          "tactics",
          "any",
          "from",
          "operators",
          "tacticSeq",
          "own",
          "relevantChildren",
          "mayFail",
          "Similarly",
          "getting",
          "already",
          "either",
          "original",
          "here",
          "syntax",
          "Array",
          "failure",
          "context",
          "getHeadInfo",
          "macros",
          "false",
          "tree",
          "Prod",
          "nullKind",
          "Term",
          "modifiers"
        ]
      }
    },
    {
      "id": 4284,
      "before_code": "lemma isNowhereDense_empty : IsNowhereDense (\u2205 : Set X) := by\n  rw [IsNowhereDense, closure_empty, interior_empty]",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```\r\nI'm not sure the `gcongr` tag is useful here, it probably won't be able to figure which `s` to use. (I would also make `s` an explicit parameter, typically one will need to supply it explicitly.)",
      "path": "Mathlib/Topology/GDelta/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [
          "gcongr"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsNowhereDense",
          "isNowhereDense_empty",
          "lemma",
          "Set",
          "closure_empty",
          "interior_empty"
        ]
      }
    },
    {
      "id": 4285,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable.definable {f : (\u03b1 \u2192 M) \u2192 M} (h : A.TermDefinable L f) :\r\n",
      "body": "```suggestion\r\ntheorem TermDefinable.definable {f : (\u03b1 \u2192 M) \u2192 M} (h : A.TermDefinable L f) :\r\n```\r\n\r\nAlso, since it's proving `f`'s graph is definable, maybe it's better to name it as `tupleGraph_definable`?",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 4286,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081.definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n",
      "body": "```suggestion\r\ntheorem TermDefinable\u2081.definable\u2082 {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n```\r\n\r\nSame as above, you may name it as `graph_definable\u2082`.",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 4287,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n  \u2203 \u03c6 : L[[A]].Term (Fin 1), f = \u03c6.realize \u2218 Function.const _\r\n",
      "body": "Would it be better to align it with `Definable\u2081` as\r\n```suggestion\r\n  \u2203 \u03c6 : L[[A]].Term (Fin 1), f = \u03c6.realize \u2218 Function.const _\r\n```\r\n? I'm not sure.",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 4288,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\n",
      "body": "An extra line here\r\n```suggestion\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 4289,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable.definable_tupleGraph {f : (\u03b1 \u2192 M) \u2192 M} (h : A.TermDefinable L f) :\r\n",
      "body": "```suggestion\r\ntheorem TermDefinable.definable_tupleGraph {f : (\u03b1 \u2192 M) \u2192 M} (h : A.TermDefinable L f) :\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 4290,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem termDefinable_empty_iff :\r\n",
      "body": "```suggestion\r\ntheorem termDefinable_empty_iff :\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 4291,
      "before_code": "end Language\n\nend FirstOrder",
      "suggestion": "\r\ntheorem TermDefinable\u2081.definable\u2082_graph {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n",
      "body": "```suggestion\r\ntheorem TermDefinable\u2081.definable\u2082_graph {f : M \u2192 M} (h : A.TermDefinable\u2081 L f) :\r\n```",
      "path": "Mathlib/ModelTheory/Definability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "FirstOrder",
          "end",
          "Language"
        ]
      }
    },
    {
      "id": 4294,
      "before_code": "variable (f : M \u2192 N) (g : N \u2192 P) (g' : P \u2192 P')\n\n/-- The maps `f` and `g` form an exact pair :\n  `g y = 0` iff `y` belongs to the image of `f` -/\ndef Exact [Zero P] : Prop := \u2200 y, g y = 0 \u2194 y \u2208 Set.range f\n\nvariable {f g}",
      "suggestion": "\r\nvariable {f g}\r\n",
      "body": "```suggestion\r\nvariable {f g}\r\n```\r\nprobably solves the CI error",
      "path": "Mathlib/Algebra/Exact.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "maps",
          "range",
          "image",
          "variable",
          "def",
          "exact",
          "pair",
          "Set",
          "iff",
          "Prop",
          "form",
          "Zero",
          "Exact",
          "belongs"
        ]
      }
    },
    {
      "id": 4299,
      "before_code": "section CommGroup",
      "suggestion": "theorem not_mem_zpowers_sq {g : \u03b1} (horder : orderOf g = 0) :\n",
      "body": "```suggestion\ntheorem not_mem_zpowers_sq {g : \u03b1} (horder : orderOf g = 0) :\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "CommGroup",
          "section"
        ]
      }
    },
    {
      "id": 4300,
      "before_code": "section CommGroup",
      "suggestion": "theorem not_mem_zpowers_pow {g : \u03b1} {k : \u2115} (horder : orderOf g = 0) (hk : 1 < k) :\n",
      "body": "```suggestion\ntheorem not_mem_zpowers_pow {g : \u03b1} {k : \u2115} (horder : orderOf g = 0) (hk : 1 < k) :\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "CommGroup",
          "section"
        ]
      }
    },
    {
      "id": 4301,
      "before_code": "section CommGroup",
      "suggestion": "    g \u2209 (Subgroup.zpowers (g ^ 2)) :=\n  not_mem_zpowers_pow horder (Nat.one_lt_two)\n",
      "body": "```suggestion\n    g \u2209 (Subgroup.zpowers (g ^ 2)) :=\n  not_mem_zpowers_pow horder (Nat.one_lt_two)\n```",
      "path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "CommGroup",
          "section"
        ]
      }
    },
    {
      "id": 4302,
      "before_code": "abbrev CartesianMonoidalCategory.ofReflective [CartesianMonoidalCategory C] [Reflective i] :\n    CartesianMonoidalCategory D :=\n  .ofChosenFiniteProducts\n    ({  cone := Limits.asEmptyCone <| (reflector i).obj (\ud835\udfd9_ C)",
      "suggestion": "    ({  cone := Limits.asEmptyCone <| (reflector i).obj (\ud835\udfd9_ C)\n",
      "body": "```suggestion\n    ({  cone := Limits.asEmptyCone <| (reflector i).obj (\ud835\udfd9_ C)\n```",
      "path": "Mathlib/CategoryTheory/Monoidal/Closed/Ideal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "reflector",
          "Limits",
          "abbrev",
          "ofChosenFiniteProducts",
          "ofReflective",
          "Reflective",
          "cone",
          "asEmptyCone",
          "CartesianMonoidalCategory",
          "obj"
        ]
      }
    },
    {
      "id": 4303,
      "before_code": "instance : HasForget\u2082 (TopModuleCat R) TopCat where\n  forget\u2082 :=\n  { obj M := .of M\n    map \u03c6   := TopCat.ofHom \u27e8\u03c6, \u03c6.1.2\u27e9 }",
      "suggestion": "    map \u03c6 := TopCat.ofHom \u27e8\u03c6, \u03c6.1.2\u27e9 }\n",
      "body": "```suggestion\n    map \u03c6 := TopCat.ofHom \u27e8\u03c6, \u03c6.1.2\u27e9 }\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Topology/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "map",
          "TopModuleCat",
          "TopCat",
          "ofHom",
          "instance",
          "obj"
        ]
      }
    },
    {
      "id": 4304,
      "before_code": "(hf : HasFTaylorSeriesUpToOn n f p s) (g : G \u2192\u1d2c[\ud835\udd5c] E) :\n    HasFTaylorSeriesUpToOn n (f \u2218 g)\n      (fun x k => (p (g x) k).compContinuousLinearMap fun _ => g.contLinear) (g \u207b\u00b9' s) := by\n  let A : \u2200 m : \u2115, (E[\u00d7m]\u2192L[\ud835\udd5c] F) \u2192 G[\u00d7m]\u2192L[\ud835\udd5c] F :=\n    fun m h => h.compContinuousLinearMap fun _ => g.contLinear",
      "suggestion": "  let A : \u2200 m : \u2115, (E[\u00d7m]\u2192L[\ud835\udd5c] F) \u2192 G[\u00d7m]\u2192L[\ud835\udd5c] F :=\n",
      "body": "```suggestion\n  let A : \u2200 m : \u2115, (E[\u00d7m]\u2192L[\ud835\udd5c] F) \u2192 G[\u00d7m]\u2192L[\ud835\udd5c] F :=\n```",
      "path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "compContinuousLinearMap",
          "contLinear",
          "HasFTaylorSeriesUpToOn"
        ]
      }
    },
    {
      "id": 4305,
      "before_code": "instance (priority := 100) ofContractible (Y : Type u) [TopologicalSpace Y] [ContractibleSpace Y] :\n    SimplyConnectedSpace Y where\n  equiv_unit :=\n    let H : TopCat.of Y \u2243\u2095 TopCat.of PUnit.{u+1} := (ContractibleSpace.hequiv Y PUnit.{u+1}).some",
      "suggestion": "    let H : TopCat.of Y \u2243\u2095 TopCat.of PUnit.{u+1} := (ContractibleSpace.hequiv Y PUnit.{u+1}).some\n",
      "body": "```suggestion\n    let H : TopCat.of Y \u2243\u2095 TopCat.of PUnit.{u+1} := (ContractibleSpace.hequiv Y PUnit.{u+1}).some\n```",
      "path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "ContractibleSpace",
          "TopologicalSpace",
          "ofContractible",
          "Type",
          "equiv_unit",
          "hequiv",
          "priority",
          "instance",
          "TopCat",
          "PUnit",
          "SimplyConnectedSpace",
          "some"
        ]
      }
    },
    {
      "id": 4306,
      "before_code": "id: lint\n        run: |\n          cd pr-branch\n          env LEAN_ABORT_ON_PANIC=1 lake exe runLinter --trace Mathlib",
      "suggestion": "          if ! env LEAN_ABORT_ON_PANIC=1 lake exe runLinter --trace Mathlib 2>&1 | tee .lake/lint_output.txt; then\n",
      "body": "We can't write to /tmp from within `landrun`: https://github.com/[user]y/mathlib4/actions/runs/20768866800/job/59640606450#step:37:30\n```suggestion\n          if ! env LEAN_ABORT_ON_PANIC=1 lake exe runLinter --trace Mathlib 2>&1 | tee .lake/lint_output.txt; then\n```\n\nbors r-\nbors d+",
      "path": ".github/workflows/bors.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "runLinter",
          "lake",
          "trace",
          "LEAN_ABORT_ON_PANIC",
          "Mathlib",
          "run",
          "env",
          "lint",
          "branch",
          "exe"
        ]
      }
    },
    {
      "id": 4313,
      "before_code": "structure WithSeminorms (p : SeminormFamily \ud835\udd5c E \u03b9) [topology : TopologicalSpace E] : Prop where\n  topology_eq_withSeminorms : topology = p.moduleFilterBasis.topology",
      "suggestion": "class IsPolynormableSpace [topology : TopologicalSpace E] : Prop where\n",
      "body": "How about:\n```suggestion\nclass IsPolynormableSpace [topology : TopologicalSpace E] : Prop where\n```",
      "path": "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "algebra",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "moduleFilterBasis",
          "topology_eq_withSeminorms",
          "TopologicalSpace",
          "structure",
          "topology",
          "Prop",
          "WithSeminorms",
          "SeminormFamily"
        ]
      }
    },
    {
      "id": 4314,
      "before_code": "return splitCase (s.extract i\u2081 s.endPos) 0 <| (s.extract 0 i\u2081)::r\n  return splitCase s i\u2081 r\n\n/-- Helper for `capitalizeLike`. -/\npartial def capitalizeLikeAux (s : String) (i : String.Pos := 0) (p : String) : String :=\n  if p.atEnd i || s.atEnd i then\n    p\n  else\n    let j := p.next i\n    if (s.get i).isLower then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toLower)\n    else if (s.get i).isUpper then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toUpper)\n    else\n      capitalizeLikeAux s j p\n\n/-- Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. -/\ndef capitalizeLike (r : String) (s : String) :=\n  capitalizeLikeAux r 0 s\n\n/-- Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. -/\ndef capitalizeFirstLike (s : String) : List String \u2192 List String\n  | x :: r => capitalizeLike s x :: r",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Tactic/ToAdditive/GuessName.lean",
      "tags": {
        "before_tactics": [
          "cases"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases"
        ],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "examples",
          "isUpper",
          "String",
          "Capitalize",
          "leaves",
          "char",
          "isLower",
          "next",
          "hAdd",
          "else",
          "toUpper",
          "cases",
          "Helper",
          "Note",
          "toLower",
          "set",
          "like",
          "get",
          "capitalizeLike",
          "for",
          "characters",
          "def",
          "then",
          "list",
          "need",
          "capitalize",
          "untouched",
          "HMul",
          "return",
          "that",
          "capitalizeFirstLike",
          "capitalizeLikeAux",
          "First",
          "Capitalizes",
          "Pos",
          "extract",
          "multiple",
          "atEnd",
          "element",
          "partial",
          "endPos",
          "List",
          "splitCase",
          "tail",
          "longer",
          "some"
        ]
      }
    },
    {
      "id": 4315,
      "before_code": "return splitCase (s.extract i\u2081 s.endPos) 0 <| (s.extract 0 i\u2081)::r\n  return splitCase s i\u2081 r\n\n/-- Helper for `capitalizeLike`. -/\npartial def capitalizeLikeAux (s : String) (i : String.Pos := 0) (p : String) : String :=\n  if p.atEnd i || s.atEnd i then\n    p\n  else\n    let j := p.next i\n    if (s.get i).isLower then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toLower)\n    else if (s.get i).isUpper then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toUpper)\n    else\n      capitalizeLikeAux s j p\n\n/-- Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. -/\ndef capitalizeLike (r : String) (s : String) :=\n  capitalizeLikeAux r 0 s\n\n/-- Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. -/\ndef capitalizeFirstLike (s : String) : List String \u2192 List String\n  | x :: r => capitalizeLike s x :: r\n  | [] => []\n\n/--\nDictionary used by `guessName` to autogenerate names.\n\nNote: `guessName` capitalizes first element of the output according to\ncapitalization of the input. Input and first element should therefore be lower-case,\n2nd element should be capitalized properly.",
      "suggestion": "\r\nIn order for this to work, the input should always start with a lower case letter, and the output\r\nshould always start with an upper case letter.\r\n",
      "body": "```suggestion\r\nIn order for this to work, the input should always start with a lower case letter, and the output\r\nshould always start with an upper case letter.\r\n```",
      "path": "Mathlib/Tactic/ToAdditive/GuessName.lean",
      "tags": {
        "before_tactics": [
          "cases"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases"
        ],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "examples",
          "isUpper",
          "String",
          "Capitalize",
          "leaves",
          "char",
          "isLower",
          "next",
          "Input",
          "hAdd",
          "therefore",
          "capitalized",
          "guessName",
          "else",
          "properly",
          "toUpper",
          "cases",
          "autogenerate",
          "Helper",
          "Note",
          "toLower",
          "set",
          "like",
          "get",
          "lower",
          "case",
          "capitalizeLike",
          "for",
          "capitalization",
          "characters",
          "def",
          "then",
          "capitalize",
          "need",
          "used",
          "untouched",
          "HMul",
          "list",
          "capitalizes",
          "return",
          "that",
          "names",
          "capitalizeLikeAux",
          "output",
          "input",
          "capitalizeFirstLike",
          "First",
          "first",
          "Capitalizes",
          "Pos"
        ]
      }
    },
    {
      "id": 4316,
      "before_code": "Nat.cast_mul]\n      ring",
      "suggestion": "",
      "body": "I'm dubious about having this variant. Can't we just rely on the version above?\n```suggestion\n```",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Nat",
          "ring",
          "cast_mul"
        ]
      }
    },
    {
      "id": 4317,
      "before_code": "public import Mathlib.Algebra.Category.ModuleCat.Basic\npublic import Mathlib.LinearAlgebra.Matrix.Module\n\n/-!\n# Morita Equivalece between `R` and `M\u2099(R)`\n\n## Main definitions\n- `ModuleCat.toMatrixModCat`: The functor from `Mod-R` to `Mod-M\u2099(R)` induced by\n  `LinearMap.mapMatrixModule` and `Matrix.Module.matrixModule`.\n\n## TODO (Edison)\n- Prove `R` and `M\u2099(R)` are morita-equivalent.\n-/\n\n@[expose] public section\n\nuniverse u\n\nvariable (R \u03b9 : Type*) [Ring R] [Fintype \u03b9] [DecidableEq \u03b9]\n\nopen CategoryTheory Matrix.Module\n\n/-- The functor from `Mod-R` to `Mod-M\u2099(R)` induced by `LinearMap.mapModule` and\n  `Matrix.matrixModule`. -/\n@[simps]\ndef ModuleCat.toMatrixModCat : ModuleCat R \u2964 ModuleCat (Matrix \u03b9 \u03b9 R) where",
      "suggestion": "\r\ndef ModuleCat.toMatrixModCat : ModuleCat R \u2964 ModuleCat (Matrix \u03b9 \u03b9 R) where\r\n",
      "body": "```suggestion\r\ndef ModuleCat.toMatrixModCat : ModuleCat R \u2964 ModuleCat (Matrix \u03b9 \u03b9 R) where\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "import",
          "expose",
          "Ring",
          "Type",
          "CategoryTheory",
          "mapModule",
          "Main",
          "open",
          "section",
          "TODO",
          "ModuleCat",
          "Basic",
          "Mathlib",
          "LinearMap",
          "functor",
          "universe",
          "mapMatrixModule",
          "equivalent",
          "are",
          "morita",
          "DecidableEq",
          "Prove",
          "LinearAlgebra",
          "variable",
          "public",
          "def",
          "definitions",
          "induced",
          "simps",
          "between",
          "Morita",
          "toMatrixModCat",
          "Mod",
          "matrixModule",
          "Equivalece",
          "Edison",
          "Category",
          "Fintype",
          "from",
          "Matrix",
          "Algebra"
        ]
      }
    },
    {
      "id": 4318,
      "before_code": "public import Mathlib.Algebra.Category.ModuleCat.Basic\npublic import Mathlib.LinearAlgebra.Matrix.Module\n\n/-!\n# Morita Equivalece between `R` and `M\u2099(R)`\n\n## Main definitions\n- `ModuleCat.toMatrixModCat`: The functor from `Mod-R` to `Mod-M\u2099(R)` induced by\n  `LinearMap.mapMatrixModule` and `Matrix.Module.matrixModule`.\n\n## TODO (Edison)\n- Prove `R` and `M\u2099(R)` are morita-equivalent.\n-/\n\n@[expose] public section\n\nuniverse u\n\nvariable (R \u03b9 : Type*) [Ring R] [Fintype \u03b9] [DecidableEq \u03b9]\n\nopen CategoryTheory Matrix.Module\n\n/-- The functor from `Mod-R` to `Mod-M\u2099(R)` induced by `LinearMap.mapModule` and\n  `Matrix.matrixModule`. -/\n@[simps]\ndef ModuleCat.toMatrixModCat : ModuleCat R \u2964 ModuleCat (Matrix \u03b9 \u03b9 R) where\n  obj M := ModuleCat.of (Matrix \u03b9 \u03b9 R) (\u03b9 \u2192 M)\n  map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\ndef MatrixModCat.unitIso :\r\n",
      "body": "```suggestion\r\ndef MatrixModCat.unitIso :\r\n```\r\nmaybe?",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "hom",
          "import",
          "expose",
          "Ring",
          "Type",
          "CategoryTheory",
          "mapModule",
          "Main",
          "open",
          "section",
          "TODO",
          "ModuleCat",
          "Basic",
          "Mathlib",
          "LinearMap",
          "functor",
          "universe",
          "map_comp",
          "mapMatrixModule",
          "map",
          "equivalent",
          "are",
          "morita",
          "DecidableEq",
          "mapMatrixModule_comp",
          "Prove",
          "LinearAlgebra",
          "variable",
          "public",
          "def",
          "definitions",
          "induced",
          "simps",
          "between",
          "Morita",
          "toMatrixModCat",
          "Mod",
          "ofHom",
          "obj",
          "map_id",
          "hom_ext",
          "matrixModule",
          "Equivalece",
          "Edison",
          "Category",
          "mapMatrixModule_id",
          "Fintype",
          "from",
          "Matrix"
        ]
      }
    },
    {
      "id": 4319,
      "before_code": "map f := ModuleCat.ofHom <| f.hom.mapMatrixModule \u03b9\n  map_id _ := ModuleCat.hom_ext <| LinearMap.mapMatrixModule_id\n  map_comp f g := ModuleCat.hom_ext (LinearMap.mapMatrixModule_comp f.hom g.hom)",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "LinearMap",
          "map_comp",
          "mapMatrixModule",
          "mapMatrixModule_id",
          "map",
          "ModuleCat",
          "hom_ext",
          "ofHom",
          "mapMatrixModule_comp",
          "map_id"
        ]
      }
    },
    {
      "id": 4320,
      "before_code": "module\n\npublic import Mathlib.Algebra.Category.ModuleCat.Basic\npublic import Mathlib.LinearAlgebra.Matrix.Module",
      "suggestion": "\r\n\r\n",
      "body": "```suggestion\r\n\r\n```",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "LinearAlgebra",
          "Module",
          "Basic",
          "import",
          "Mathlib",
          "public",
          "Category",
          "module",
          "Matrix",
          "Algebra",
          "ModuleCat"
        ]
      }
    },
    {
      "id": 4321,
      "before_code": "module\n\npublic import Mathlib.Algebra.Category.ModuleCat.Basic\npublic import Mathlib.LinearAlgebra.Matrix.Module\n\n/-!\n# Morita Equivalece between `R` and `M\u2099(R)`\n\n## Main definitions\n- `ModuleCat.toMatrixModCat`: The functor from `Mod-R` to `Mod-M\u2099(R)` induced by\n  `LinearMap.mapMatrixModule` and `Matrix.Module.matrixModule`.",
      "suggestion": "\r\n  the image of `E\u1d62\u1d62 \u2022 \u00b7` where `E\u1d62\u1d62` is the elementary matrix.\r\n",
      "body": "```suggestion\r\n  the image of `E\u1d62\u1d62 \u2022 \u00b7` where `E\u1d62\u1d62` is the elementary matrix.\r\n```\r\nand throughout",
      "path": "Mathlib/RingTheory/Morita/Matrix.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "import",
          "Main",
          "ModuleCat",
          "Basic",
          "Mathlib",
          "LinearMap",
          "functor",
          "mapMatrixModule",
          "LinearAlgebra",
          "public",
          "module",
          "definitions",
          "induced",
          "between",
          "Morita",
          "toMatrixModCat",
          "Mod",
          "matrixModule",
          "Equivalece",
          "Category",
          "from",
          "Matrix",
          "Algebra"
        ]
      }
    },
    {
      "id": 4322,
      "before_code": "lemma measurable_densityProcess_left (\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u03b2)) (\u03bd : Kernel \u03b1 \u03b3) (n : \u2115)\n    (x : \u03b3) {s : Set \u03b2} (hs : MeasurableSet s) :\n    Measurable (fun a \u21a6 densityProcess \u03ba \u03bd n a x s) :=\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_id.prodMk measurable_const):)",
      "suggestion": "\r\n  (measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_id.prodMk measurable_const) :)\r\n",
      "body": "```suggestion\r\n  (measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_id.prodMk measurable_const) :)\r\n```",
      "path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "measurability",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "measurable_densityProcess",
          "lemma",
          "Kernel",
          "Set",
          "measurable_densityProcess_left",
          "MeasurableSet",
          "comp",
          "densityProcess",
          "prodMk",
          "measurable_id",
          "measurable_const",
          "Measurable"
        ]
      }
    },
    {
      "id": 4323,
      "before_code": "lemma measurable_densityProcess_left (\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u03b2)) (\u03bd : Kernel \u03b1 \u03b3) (n : \u2115)\n    (x : \u03b3) {s : Set \u03b2} (hs : MeasurableSet s) :\n    Measurable (fun a \u21a6 densityProcess \u03ba \u03bd n a x s) :=\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_id.prodMk measurable_const):)\n\nlemma measurable_densityProcess_right (\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u03b2)) (\u03bd : Kernel \u03b1 \u03b3) (n : \u2115)\n    {s : Set \u03b2} (a : \u03b1) (hs : MeasurableSet s) :\n    Measurable (fun x \u21a6 densityProcess \u03ba \u03bd n a x s) :=\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_const.prodMk measurable_id):)",
      "suggestion": "\r\n  (measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_const.prodMk measurable_id) :)\r\n",
      "body": "```suggestion\r\n  (measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_const.prodMk measurable_id) :)\r\n```",
      "path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "measurability",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "measurable_densityProcess_right",
          "measurable_densityProcess",
          "lemma",
          "Kernel",
          "measurable_densityProcess_left",
          "Set",
          "MeasurableSet",
          "comp",
          "densityProcess",
          "prodMk",
          "measurable_id",
          "measurable_const",
          "Measurable"
        ]
      }
    },
    {
      "id": 4324,
      "before_code": "lemma measurable_densityProcess_left (\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u03b2)) (\u03bd : Kernel \u03b1 \u03b3) (n : \u2115)\n    (x : \u03b3) {s : Set \u03b2} (hs : MeasurableSet s) :\n    Measurable (fun a \u21a6 densityProcess \u03ba \u03bd n a x s) :=\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_id.prodMk measurable_const):)",
      "suggestion": "\r\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_id.prodMk measurable_const) :)\r\n",
      "body": "```suggestion\r\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_id.prodMk measurable_const) :)\r\n```",
      "path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "measurability",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "measurable_densityProcess",
          "lemma",
          "Kernel",
          "Set",
          "measurable_densityProcess_left",
          "MeasurableSet",
          "comp",
          "densityProcess",
          "prodMk",
          "measurable_id",
          "measurable_const",
          "Measurable"
        ]
      }
    },
    {
      "id": 4325,
      "before_code": "lemma measurable_densityProcess_left (\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u03b2)) (\u03bd : Kernel \u03b1 \u03b3) (n : \u2115)\n    (x : \u03b3) {s : Set \u03b2} (hs : MeasurableSet s) :\n    Measurable (fun a \u21a6 densityProcess \u03ba \u03bd n a x s) :=\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_id.prodMk measurable_const):)\n\nlemma measurable_densityProcess_right (\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u03b2)) (\u03bd : Kernel \u03b1 \u03b3) (n : \u2115)\n    {s : Set \u03b2} (a : \u03b1) (hs : MeasurableSet s) :\n    Measurable (fun x \u21a6 densityProcess \u03ba \u03bd n a x s) :=\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_const.prodMk measurable_id):)",
      "suggestion": "\r\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_const.prodMk measurable_id) :)\r\n",
      "body": "```suggestion\r\n  ((measurable_densityProcess \u03ba \u03bd n hs).comp (measurable_const.prodMk measurable_id) :)\r\n```",
      "path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list",
          "measurability",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "measurable_densityProcess_right",
          "measurable_densityProcess",
          "lemma",
          "Kernel",
          "measurable_densityProcess_left",
          "Set",
          "MeasurableSet",
          "comp",
          "densityProcess",
          "prodMk",
          "measurable_id",
          "measurable_const",
          "Measurable"
        ]
      }
    },
    {
      "id": 4326,
      "before_code": "(sumLexDualAntidistrib \u03b1 \u03b2).symm (inr (toDual a)) = toDual (inl a) :=\n  rfl",
      "suggestion": "\r\n    Lex (\u03b1 \u2295 \u03b2) \u2243o \u03b1 := RelIso.sumLexEmpty ..\r\n",
      "body": "```suggestion\r\n    Lex (\u03b1 \u2295 \u03b2) \u2243o \u03b1 := RelIso.sumLexEmpty ..\r\n```",
      "path": "Mathlib/Data/Sum/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "sumLexDualAntidistrib",
          "symm",
          "rfl",
          "toDual",
          "inl",
          "inr"
        ]
      }
    },
    {
      "id": 4327,
      "before_code": "theorem uniqueProd_apply [Preorder \u03b1] [Unique \u03b1] [LE \u03b2] (x : \u03b1 \u00d7\u2097 \u03b2) :\n    uniqueProd \u03b1 \u03b2 x = (ofLex x).2 := rfl",
      "suggestion": "\r\ndef prodLexCongr {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [LinearOrder \u03b1] [LinearOrder \u03b2]\r\n",
      "body": "```suggestion\r\ndef prodLexCongr {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [LinearOrder \u03b1] [LinearOrder \u03b2]\r\n```",
      "path": "Mathlib/Order/Hom/Lex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ofLex",
          "theorem",
          "uniqueProd",
          "Preorder",
          "rfl",
          "Unique",
          "uniqueProd_apply"
        ]
      }
    },
    {
      "id": 4328,
      "before_code": "@[gcongr]\ntheorem vertexCoverNum_mono (h : G \u2264 G') : vertexCoverNum G \u2264 vertexCoverNum G' :=\n  vertexCoverNum_le_vertexCoverNum_of_injective (Hom.ofLE h) Function.injective_id\n\ntheorem vertexCoverNum_congr (f : G \u2243g H) : vertexCoverNum G = vertexCoverNum H :=\n  le_antisymm (vertexCoverNum_le_vertexCoverNum_of_injective f.toHom f.injective)\n    (vertexCoverNum_le_vertexCoverNum_of_injective f.symm.toHom f.symm.injective)",
      "suggestion": "\r\n  le_antisymm f.isIndContained.isContained.vertexCoverNum_le_vertexCoverNum\r\n",
      "body": "```suggestion\r\n  le_antisymm f.isIndContained.isContained.vertexCoverNum_le_vertexCoverNum\r\n```\r\nSame below. Maybe you can even introduce `Iso.isContained` to avoid having to go through `IsIndContained`",
      "path": "Mathlib/Combinatorics/SimpleGraph/VertexCover.lean",
      "tags": {
        "before_tactics": [
          "gcongr"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "gcongr"
        ],
        "topics": [
          "order",
          "function",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "gcongr",
          "symm",
          "vertexCoverNum_mono",
          "vertexCoverNum_congr",
          "theorem",
          "ofLE",
          "le_antisymm",
          "vertexCoverNum",
          "vertexCoverNum_le_vertexCoverNum_of_injective",
          "Hom",
          "Function",
          "injective",
          "toHom",
          "injective_id"
        ]
      }
    },
    {
      "id": 4329,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n  grind [L.weierstrassPExcept_add \u27e8_, hl\u2080\u27e9]\r\n",
      "body": "And here:\r\n```suggestion\r\n  grind [L.weierstrassPExcept_add \u27e8_, hl\u2080\u27e9]\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 4330,
      "before_code": "end derivWeierstrassP",
      "suggestion": "\r\n  grind [weierstrassPSummand, weierstrassPExceptSummand]\r\n",
      "body": "```suggestion\r\n  grind [weierstrassPSummand, weierstrassPExceptSummand]\r\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Elliptic/Weierstrass.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "derivWeierstrassP",
          "end"
        ]
      }
    },
    {
      "id": 4331,
      "before_code": "gcongr\n\n/-- If `s` is codiscrete within `U`, then `s\u1d9c \u2229 U` has discrete topology. -/\ntheorem discreteTopology_of_codiscreteWithin {U s : Set X} (h : s \u2208 Filter.codiscreteWithin U) :\n    DiscreteTopology ((s\u1d9c \u2229 U) : Set X) := by\n  rw [(by simp : ((s\u1d9c \u2229 U) : Set X) = ((s \u222a U\u1d9c)\u1d9c : Set X)), discreteTopology_subtype_iff]",
      "suggestion": "theorem isDiscrete_of_codiscreteWithin {U s : Set X} (h : s\u1d9c \u2208 Filter.codiscreteWithin U) :\n    IsDiscrete (s \u2229 U) := by\n",
      "body": "I realize that this is a pre-existing theorem, but I think it shoul dbe changed to:\n\n```suggestion\ntheorem isDiscrete_of_codiscreteWithin {U s : Set X} (h : s\u1d9c \u2208 Filter.codiscreteWithin U) :\n    IsDiscrete (s \u2229 U) := by\n```\nsince the conclusion will match more things.",
      "path": "Mathlib/Topology/DiscreteSubset.lean",
      "tags": {
        "before_tactics": [
          "gcongr",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "gcongr",
          "rw",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "gcongr",
          "discreteTopology_of_codiscreteWithin",
          "then",
          "theorem",
          "codiscreteWithin",
          "Set",
          "topology",
          "codiscrete",
          "Filter",
          "within",
          "DiscreteTopology",
          "simp",
          "has",
          "discreteTopology_subtype_iff",
          "discrete"
        ]
      }
    },
    {
      "id": 4332,
      "before_code": "simp only [mem_codiscrete, disjoint_iff, AccPt, not_neBot]\n\nlemma mem_codiscrete' {S : Set X} :\n    S \u2208 codiscrete X \u2194 IsOpen S \u2227 DiscreteTopology \u2191S\u1d9c := by",
      "suggestion": "    S \u2208 codiscrete X \u2194 IsOpen S \u2227 IsDiscrete S\u1d9c := by\n",
      "body": "```suggestion\n    S \u2208 codiscrete X \u2194 IsOpen S \u2227 IsDiscrete S\u1d9c := by\n```",
      "path": "Mathlib/Topology/DiscreteSubset.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "disjoint_iff",
          "lemma",
          "Set",
          "AccPt",
          "codiscrete",
          "simp",
          "not_neBot",
          "IsOpen",
          "only",
          "mem_codiscrete",
          "DiscreteTopology"
        ]
      }
    },
    {
      "id": 4333,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n  adj : \u2200 \u2983v\u2081\u2984, v\u2081 \u2208 left \u2192 \u2200 \u2983v\u2082\u2984, v\u2082 \u2208 right \u2192 G.Adj v\u2081 v\u2082\r\n",
      "body": "```suggestion\r\n  adj : \u2200 \u2983v\u2081\u2984, v\u2081 \u2208 left \u2192 \u2200 \u2983v\u2082\u2984, v\u2082 \u2208 right \u2192 G.Adj v\u2081 v\u2082\r\n```\r\nsince this is a proof",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 4334,
      "before_code": "end IsBipartite",
      "suggestion": "\r\ntheorem completeBipartiteGraph_isContained_iff :\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194\r\n      \u2203 C : G.CompleteBipartiteSubgraph, C.left.ncard = card \u03b1 \u2227 C.right.ncard = card \u03b2 :=\r\n",
      "body": "... this would become\r\n```suggestion\r\ntheorem completeBipartiteGraph_isContained_iff :\r\n    completeBipartiteGraph \u03b1 \u03b2 \u2291 G \u2194\r\n      \u2203 C : G.CompleteBipartiteSubgraph, C.left.ncard = card \u03b1 \u2227 C.right.ncard = card \u03b2 :=\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 4335,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n    (h : G.IsCompleteBetween left right) : Copy (completeBipartiteGraph \u03b1 \u03b2) G := by\r\n",
      "body": "Can you generalise to\r\n```suggestion\r\n    (h : G.IsCompleteBetween left right) : Copy (completeBipartiteGraph \u03b1 \u03b2) G := by\r\n```\r\n?",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 4336,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n      \u2203 (left right : Finset V), #left = card \u03b1 \u2227 #right = card \u03b2\r\n",
      "body": "```suggestion\r\n      \u2203 (left right : Finset V), #left = card \u03b1 \u2227 #right = card \u03b2\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 4337,
      "before_code": "end IsBipartite",
      "suggestion": "\r\n    \u27e8.completeBipartiteGraph left right card_left card_right h\u27e9\r\n",
      "body": "nit:\r\n```suggestion\r\n    \u27e8.completeBipartiteGraph left right card_left card_right h\u27e9\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 4338,
      "before_code": "end Incidence",
      "suggestion": "\r\ntheorem IsCompleteBetween.disjoint (h : G.IsCompleteBetween s t) : Disjoint s t :=\r\n",
      "body": "```suggestion\r\ntheorem IsCompleteBetween.disjoint (h : G.IsCompleteBetween s t) : Disjoint s t :=\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Incidence",
          "end"
        ]
      }
    },
    {
      "id": 4339,
      "before_code": "end IsBipartite",
      "suggestion": "\r\ntheorem degree_le_between_add (hv : v \u2208 s) :\r\n",
      "body": "```suggestion\r\ntheorem degree_le_between_add (hv : v \u2208 s) :\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Bipartite.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "IsBipartite",
          "end"
        ]
      }
    },
    {
      "id": 4345,
      "before_code": "eqToHom_op, Hom.app_eq_appLE, Category.assoc, \u2190 Spec.map_comp, Hom.appLE_map,\n    toSpec\u0393_naturality_assoc, TopologicalSpace.Opens.map_top, morphismRestrict_appLE, Hom.map_appLE]",
      "suggestion": "\r\n    {X Y : Scheme} (f : X \u27f6 Y) {U : Y.Opens} {V : X.Opens} (hUV) :\r\n",
      "body": "```suggestion\r\n    {X Y : Scheme} (f : X \u27f6 Y) {U : Y.Opens} {V : X.Opens} (hUV) :\r\n```\r\nIf you want.",
      "path": "Mathlib/AlgebraicGeometry/AffineScheme.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "app_eq_appLE",
          "assoc",
          "Spec",
          "TopologicalSpace",
          "map_appLE",
          "map_top",
          "Category",
          "morphismRestrict_appLE",
          "appLE_map",
          "map_comp",
          "eqToHom_op",
          "Opens",
          "Hom"
        ]
      }
    },
    {
      "id": 4346,
      "before_code": "end Int\n\n-- TODO: Do we really need this lemma? This is just `smul_eq_mul`\nlemma zsmul_int_int (a b : \u2124) : a \u2022 b = a * b := rfl",
      "suggestion": "\r\n@[deprecated zsmul_one (since := \"2026-01-05\")]\r\n",
      "body": "```suggestion\r\n@[deprecated zsmul_one (since := \"2026-01-05\")]\r\n```\r\nI thought the standard was to just write the replacement theorem name, if possible.",
      "path": "Mathlib/Algebra/Group/Int/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "This",
          "zsmul_int_int",
          "lemma",
          "end",
          "Int",
          "need",
          "just",
          "this",
          "really",
          "rfl",
          "smul_eq_mul",
          "TODO"
        ]
      }
    },
    {
      "id": 4347,
      "before_code": "Continuous (s.piecewise f g) := by\n  simpa only [piecewise_compl] using hs.isOpen_compl.continuous_piecewise_of_specializes hg hf hspec",
      "suggestion": "\r\ntheorem IsCompact.of_subset_of_specializes {s t : Set X} (hs : IsCompact s) (hts : t \u2286 s)\r\n",
      "body": "```suggestion\r\ntheorem IsCompact.of_subset_of_specializes {s t : Set X} (hs : IsCompact s) (hts : t \u2286 s)\r\n```",
      "path": "Mathlib/Topology/Inseparable.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "continuity",
          "set_theory",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "continuous_piecewise_of_specializes",
          "hspec",
          "piecewise",
          "isOpen_compl",
          "simpa",
          "Continuous",
          "piecewise_compl",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 4350,
      "before_code": "/-\nCopyright (c) 2023 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nmodule\n\npublic import Mathlib.Analysis.Real.Cardinality\npublic import Mathlib.Topology.TietzeExtension\n/-!\n# Not normal topological spaces\n\nIn this file we prove (see `IsClosed.not_normal_of_continuum_le_mk`) that a separable space with a\ndiscrete subspace of cardinality continuum is not a normal topological space.\n-/\n\n@[expose] public section\n\nopen Set Function Cardinal Topology TopologicalSpace\n\nuniverse u\nvariable {X : Type u} [TopologicalSpace X] [SeparableSpace X]\n\n/-- Let `s` be a closed set in a separable normal space. If the induced topology on `s` is discrete,\nthen `s` has cardinality less than continuum.\n\nThe proof follows\nhttps://en.wikipedia.org/wiki/Moore_plane#Proof_that_the_Moore_plane_is_not_normal -/\ntheorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)\n    [DiscreteTopology s] : #s < \ud835\udd20 := by\n  -- Proof by contradiction: assume `\ud835\udd20 \u2264 #s`\n  by_contra! h\n  -- Choose a countable dense set `t : Set X`\n  rcases exists_countable_dense X with \u27e8t, htc, htd\u27e9\n  haveI := htc.to_subtype\n  -- To obtain a contradiction, we will prove `2 ^ \ud835\udd20 \u2264 \ud835\udd20`.\n  refine (Cardinal.cantor \ud835\udd20).not_ge ?_",
      "suggestion": "",
      "body": "Unless you need these for an application, I wouldn't bother adding these:\n```suggestion\n```\n(I'm even a bit dubious about `mk_lt_two_pow_mk_dense`, though I do think it's worth having.)",
      "path": "Mathlib/Topology/Separation/NotNormal.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "obtain",
          "refine"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "refine",
          "obtain"
        ],
        "topics": [
          "algebra",
          "real",
          "norm",
          "topology",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "expose",
          "Topology",
          "subspace",
          "Type",
          "Apache",
          "mk_lt_continuum",
          "open",
          "not_ge",
          "org",
          "Analysis",
          "to_subtype",
          "TopologicalSpace",
          "wikipedia",
          "Proof",
          "Proof_that_the_Moore_plane_is_not_normal",
          "that",
          "than",
          "will",
          "IsClosed",
          "Moore_plane",
          "theorem",
          "continuum",
          "described",
          "proof",
          "haveI",
          "All",
          "import",
          "countable",
          "separable",
          "Function",
          "has",
          "set",
          "topology",
          "closed",
          "prove",
          "see",
          "Cardinal",
          "variable",
          "LICENSE",
          "Choose",
          "htc",
          "cantor",
          "htd",
          "Cardinality",
          "space",
          "topological",
          "Released",
          "DiscreteTopology",
          "Kudryashov",
          "SeparableSpace"
        ]
      }
    },
    {
      "id": 4351,
      "before_code": "public import Mathlib.Algebra.Order.WithTop.Untop0\npublic import Mathlib.Analysis.Analytic.Order\npublic import Mathlib.Analysis.Meromorphic.Basic",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Analysis/Meromorphic/Order.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "import",
          "Mathlib",
          "WithTop",
          "public",
          "Order",
          "Meromorphic",
          "Basic",
          "Untop0",
          "Analytic",
          "Analysis",
          "Algebra"
        ]
      }
    },
    {
      "id": 4352,
      "before_code": "filter_upwards [heq, han.continuousAt.tendsto.eventually_ne hne] with z hz hzne\n    simp only [inv_pow, Function.comp_apply, inv_smul_eq_iff\u2080 (pow_ne_zero r hzne)]\n    rw [\u2190 mul_smul (h z ^ r), mul_comm, pow_mul, \u2190 mul_pow, \u2190 smul_eq_mul, \u2190 hz]",
      "suggestion": "  -- Now write `f = (\u00b7 - g x) ^ r \u2022 F` for `F` analytic and nonzero at `g x`\n",
      "body": "right? This should match the code better I think.\n```suggestion\n  -- Now write `f = (\u00b7 - g x) ^ r \u2022 F` for `F` analytic and nonzero at `g x`\n```",
      "path": "Mathlib/Analysis/Meromorphic/Order.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "continuity",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "pow_mul",
          "inv_pow",
          "Function",
          "continuousAt",
          "filter_upwards",
          "heq",
          "smul_eq_mul",
          "pow_ne_zero",
          "tendsto",
          "hne",
          "comp_apply",
          "mul_comm",
          "simp",
          "only",
          "mul_pow",
          "eventually_ne",
          "han",
          "hzne",
          "mul_smul"
        ]
      }
    },
    {
      "id": 4353,
      "before_code": "Algebra.smul_def (\u2016c\u2016 ^ 2) \u27eaT x, x\u27eb, algebraMap_eq_ofReal]\n\nend ReApplyInnerSelf_Seminormed",
      "suggestion": "This is also sometimes referred to as an outer product of vectors on a Hilbert space.\n",
      "body": "```suggestion\nThis is also sometimes referred to as an outer product of vectors on a Hilbert space.\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/LinearMap.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "smul_def",
          "ReApplyInnerSelf_Seminormed",
          "algebraMap_eq_ofReal",
          "Algebra"
        ]
      }
    },
    {
      "id": 4354,
      "before_code": "rw [he.angle_eq_pi_div_three h\u2081\u2082 h\u2081\u2083 h\u2082\u2083]\n  linarith [Real.pi_pos]",
      "suggestion": "\r\n    dist (s.points i) (s.faceOppositeCentroid i) =\r\n    (n + 1) * dist s.centroid (s.faceOppositeCentroid i) := by\r\n",
      "body": "```suggestion\r\n    dist (s.points i) (s.faceOppositeCentroid i) =\r\n    (n + 1) * dist s.centroid (s.faceOppositeCentroid i) := by\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Simplex.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "linarith"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "linarith"
        ],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "pi_pos",
          "Real",
          "angle_eq_pi_div_three",
          "linarith"
        ]
      }
    },
    {
      "id": 4355,
      "before_code": "(expSeries \ud835\udd42 \ud835\udd38 n fun _ => x) = expSeries \ud835\udd42' \ud835\udd38 n fun _ => x := by\n  rw [expSeries_apply_eq, expSeries_apply_eq, inv_natCast_smul_eq \ud835\udd42 \ud835\udd42']\n\n/-- If a normed ring `\ud835\udd38` is a normed algebra over two fields, then they define the same\nexponential function on `\ud835\udd38`. -/\ntheorem exp_eq_exp : (exp \ud835\udd42 : \ud835\udd38 \u2192 \ud835\udd38) = exp \ud835\udd42' := by\n  ext x\n  rw [exp, exp]\n  refine tsum_congr fun n => ?_\n  rw [expSeries_eq_expSeries \ud835\udd42 \ud835\udd42' \ud835\udd38 n x]\n\ntheorem exp_\u211d_\u2102_eq_exp_\u2102_\u2102 : (exp \u211d : \u2102 \u2192 \u2102) = exp \u2102 :=\n  exp_eq_exp \u211d \u2102 \u2102\n\n/-- A version of `Complex.ofReal_exp` for `NormedSpace.exp` instead of `Complex.exp` -/\n@[simp, norm_cast]\ntheorem of_real_exp_\u211d_\u211d (r : \u211d) : \u2191(exp \u211d r) = exp \u2102 (r : \u2102) :=\n  (map_exp \u211d (algebraMap \u211d \u2102) (continuous_algebraMap _ _) r).trans (congr_fun exp_\u211d_\u2102_eq_exp_\u2102_\u2102 _)",
      "suggestion": "theorem ofReal_exp_\u211d_\u211d (r : \u211d) : \u2191(exp r) = exp (r : \u2102) :=\n",
      "body": "Can you fix this while you're here, and add a deprecation?\n\n```suggestion\ntheorem ofReal_exp_\u211d_\u211d (r : \u211d) : \u2191(exp r) = exp (r : \u2102) :=\n```",
      "path": "Mathlib/Analysis/Normed/Algebra/Exponential.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "ext",
          "rw",
          "simp",
          "ring",
          "norm_cast"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "refine",
          "ext",
          "simp",
          "ring",
          "norm_cast"
        ],
        "topics": [
          "algebra",
          "continuity",
          "real",
          "complex",
          "norm",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "algebra",
          "map_exp",
          "define",
          "tsum_congr",
          "exp",
          "refine",
          "ext",
          "Complex",
          "ofReal_exp",
          "expSeries_apply_eq",
          "for",
          "norm_cast",
          "expSeries",
          "two",
          "normed",
          "expSeries_eq_expSeries",
          "then",
          "over",
          "fields",
          "simp",
          "exp_eq_exp",
          "ring",
          "version",
          "function",
          "theorem",
          "instead",
          "continuous_algebraMap",
          "same",
          "NormedSpace",
          "they",
          "trans",
          "algebraMap",
          "inv_natCast_smul_eq",
          "congr_fun",
          "exponential"
        ]
      }
    },
    {
      "id": 4356,
      "before_code": "derivative^[n] ((X - C c) ^ n) = n.factorial := by\n  rw [iterate_derivative_X_sub_pow, n.sub_self, pow_zero, nsmul_one, n.descFactorial_self]",
      "suggestion": "    k.factorial * \u2211 T \u2208 S.powersetCard (#S - k), \u220f a \u2208 T, (X - C a) := by\n",
      "body": "```suggestion\n    k.factorial * \u2211 T \u2208 S.powersetCard (#S - k), \u220f a \u2208 T, (X - C a) := by\n```",
      "path": "Mathlib/Algebra/Polynomial/Derivative.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "factorial",
          "descFactorial_self",
          "derivative",
          "sub_self",
          "iterate_derivative_X_sub_pow",
          "pow_zero",
          "nsmul_one"
        ]
      }
    },
    {
      "id": 4357,
      "before_code": "simp only [ofDigits, List.alternatingSum, List.map_cons, ofDigits_neg_one t]\n    ring\n\nend Nat",
      "suggestion": "\r\n    \u2211 L : Fin l -> Fin b, \u2211 i, (L i : Nat) = l * b ^ (l - 1) * b.choose 2 := by\r\n",
      "body": "I wonder if this is better as\r\n```suggestion\r\n    \u2211 L : Fin l -> Fin b, \u2211 i, (L i : Nat) = l * b ^ (l - 1) * b.choose 2 := by\r\n```",
      "path": "Mathlib/Data/Nat/Digits/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "ring",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring",
          "simp"
        ],
        "topics": [
          "list",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "ofDigits_neg_one",
          "map_cons",
          "alternatingSum",
          "Nat",
          "ofDigits",
          "simp",
          "List",
          "ring",
          "only"
        ]
      }
    },
    {
      "id": 4358,
      "before_code": "simp\n    \u00b7 simp [IH _ (le_of_lt_succ (div_lt_self' n b)), pow_succ', Nat.div_div_eq_div_mul]\n\nend Nat",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Data/Nat/Digits/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "div_div_eq_div_mul",
          "end",
          "div_lt_self",
          "pow_succ",
          "Nat",
          "simp",
          "le_of_lt_succ"
        ]
      }
    },
    {
      "id": 4359,
      "before_code": "simp\n    \u00b7 simp [IH _ (le_of_lt_succ (div_lt_self' n b)), pow_succ', Nat.div_div_eq_div_mul]\n\nend Nat",
      "suggestion": "theorem card_fixedLengthDigits {b : \u2115} (hb : 1 < b) (l : \u2115) :\n",
      "body": "```suggestion\ntheorem card_fixedLengthDigits {b : \u2115} (hb : 1 < b) (l : \u2115) :\n```",
      "path": "Mathlib/Data/Nat/Digits/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "div_div_eq_div_mul",
          "end",
          "div_lt_self",
          "pow_succ",
          "Nat",
          "simp",
          "le_of_lt_succ"
        ]
      }
    },
    {
      "id": 4360,
      "before_code": "simp\n    \u00b7 simp [IH _ (le_of_lt_succ (div_lt_self' n b)), pow_succ', Nat.div_div_eq_div_mul]\n\nend Nat",
      "suggestion": "theorem Nat.sum_sum_digits_eq {b : \u2115} (hb : 1 < b) (l : \u2115) :\n",
      "body": "```suggestion\ntheorem Nat.sum_sum_digits_eq {b : \u2115} (hb : 1 < b) (l : \u2115) :\n```",
      "path": "Mathlib/Data/Nat/Digits/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "div_div_eq_div_mul",
          "end",
          "div_lt_self",
          "pow_succ",
          "Nat",
          "simp",
          "le_of_lt_succ"
        ]
      }
    },
    {
      "id": 4361,
      "before_code": "simp\n    \u00b7 simp [IH _ (le_of_lt_succ (div_lt_self' n b)), pow_succ', Nat.div_div_eq_div_mul]",
      "suggestion": "\r\n  (b.digits n).rightpad l 0\r\n",
      "body": "```suggestion\r\n  (b.digits n).rightpad l 0\r\n```\r\nthough perhaps this is an argument that digitsAppend need not exist.",
      "path": "Mathlib/Data/Nat/Digits/Lemmas.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "div_div_eq_div_mul",
          "div_lt_self",
          "pow_succ",
          "Nat",
          "simp",
          "le_of_lt_succ"
        ]
      }
    },
    {
      "id": 4363,
      "before_code": "theorem castSucc_ne_zero_of_lt {p i : Fin n} (h : p < i) : castSucc i \u2260 0 := by\n  cases n\n  \u00b7 exact i.elim0\n  \u00b7 rw [castSucc_ne_zero_iff, Ne, Fin.ext_iff]\n    exact ((zero_le _).trans_lt h).ne'",
      "suggestion": "  \u00b7 grind [castSucc_ne_zero_iff]\n",
      "body": "```suggestion\n  \u00b7 grind [castSucc_ne_zero_iff]\n```\nDoes this work?",
      "path": "Mathlib/Data/Fin/SuccPred.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "cases",
          "rw"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact",
          "cases",
          "rw"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "trans_lt",
          "theorem",
          "castSucc_ne_zero_of_lt",
          "ext_iff",
          "zero_le",
          "cases",
          "exact",
          "castSucc_ne_zero_iff",
          "Fin",
          "elim0",
          "castSucc"
        ]
      }
    },
    {
      "id": 4364,
      "before_code": "(Submodule.prod S S').comap (LinearMap.prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _",
      "suggestion": "\r\n    (S.prod S').map (f.prodMap g) = (S.map f).prod (S'.map g) :=\r\n",
      "body": "nit:\r\n```suggestion\r\n    (S.prod S').map (f.prodMap g) = (S.map f).prod (S'.map g) :=\r\n```",
      "path": "Mathlib/LinearAlgebra/Prod.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order",
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "prodMap",
          "prod",
          "LinearMap",
          "SetLike",
          "Set",
          "Submodule",
          "preimage_prod_map_prod",
          "coe_injective",
          "comap"
        ]
      }
    },
    {
      "id": 4366,
      "before_code": "simp only [top_adj, ne_eq, Subtype.mk.injEq, eq_iff_iff] at h2\n    exact h2.1 hne",
      "suggestion": "\r\ntheorem isClique_iff_isChain_adj : G.IsClique s \u2194 IsChain G.Adj s := by\r\n",
      "body": "```suggestion\r\ntheorem isClique_iff_isChain_adj : G.IsClique s \u2194 IsChain G.Adj s := by\r\n```\r\nfor clarity",
      "path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Subtype",
          "top_adj",
          "exact",
          "hne",
          "ne_eq",
          "simp",
          "eq_iff_iff",
          "only",
          "injEq"
        ]
      }
    },
    {
      "id": 4367,
      "before_code": "theorem isIndepSet_iff : G.IsIndepSet s \u2194 s.Pairwise (fun v w \u21a6 \u00acG.Adj v w) :=\n  Iff.rfl",
      "suggestion": "\r\ntheorem isIndepSet_iff_isAntichain_adj : G.IsIndepSet s \u2194 IsAntichain G.Adj s :=\r\n",
      "body": "```suggestion\r\ntheorem isIndepSet_iff_isAntichain_adj : G.IsIndepSet s \u2194 IsAntichain G.Adj s :=\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Adj",
          "theorem",
          "isIndepSet_iff",
          "Iff",
          "IsIndepSet",
          "Pairwise",
          "rfl"
        ]
      }
    },
    {
      "id": 4376,
      "before_code": "by_cases hp\u2083p\u2082 : p\u2083 = p\u2082; \u00b7 simp [hp\u2083p\u2082]\n  simp [hp\u2081p\u2082, hp\u2081p\u2083, Ne.symm hp\u2081p\u2083, Sbtw, hp\u2083p\u2082]",
      "suggestion": "\r\ntheorem _root_.Sbtw.angle_eq_right {p\u2081 p\u2082 p\u2083 p : P} (h : Sbtw \u211d p\u2082 p\u2083 p) :\r\n    \u2220 p\u2081 p\u2082 p\u2083 = \u2220 p\u2081 p\u2082 p :=\r\n  angle_eq_angle_of_angle_eq_pi _ h.angle\u2081\u2082\u2083_eq_pi\r\n",
      "body": "```suggestion\r\ntheorem _root_.Sbtw.angle_eq_right {p\u2081 p\u2082 p\u2083 p : P} (h : Sbtw \u211d p\u2082 p\u2083 p) :\r\n    \u2220 p\u2081 p\u2082 p\u2083 = \u2220 p\u2081 p\u2082 p :=\r\n  angle_eq_angle_of_angle_eq_pi _ h.angle\u2081\u2082\u2083_eq_pi\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "by_cases",
          "Sbtw",
          "symm",
          "simp"
        ]
      }
    },
    {
      "id": 4379,
      "before_code": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq, intervalIntegral.integral_congr_codiscreteWithin hf,\n    \u2190 interval_average_eq]",
      "suggestion": "    \u2203 c \u2208 \u0399 a b, f c = \u2a0d x in \u0399 a b, f x \u2202\u03bc := by\n",
      "body": "```suggestion\n    \u2203 c \u2208 \u0399 a b, f c = \u2a0d x in \u0399 a b, f x \u2202\u03bc := by\n```\nSame thing below.",
      "path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "real",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "intervalIntegral",
          "theorem",
          "integral_congr_codiscreteWithin",
          "interval_average_eq",
          "codiscreteWithin",
          "Filter",
          "intervalAverage_congr_codiscreteWithin"
        ]
      }
    },
    {
      "id": 4384,
      "before_code": "simp only [id_comp, mapDerivedCategoryFactorsh_hom_app, assoc, comp_id,\n        \u2190 Functor.map_comp_assoc, Iso.inv_hom_id_app, map_id, comp_obj])\n\ninstance : F.mapDerivedCategory.IsTriangulated :=\n  Functor.isTriangulated_of_precomp_iso F.mapDerivedCategoryFactorsh",
      "suggestion": "\r\n    DerivedCategory.singleFunctor C\u2081 n \u22d9 F.mapDerivedCategory \u2245\r\n      F \u22d9 DerivedCategory.singleFunctor C\u2082 n :=\r\n  isoWhiskerRight (DerivedCategory.singleFunctorIsoCompQ C\u2081 n) _\r\n",
      "body": "```suggestion\r\n    DerivedCategory.singleFunctor C\u2081 n \u22d9 F.mapDerivedCategory \u2245\r\n      F \u22d9 DerivedCategory.singleFunctor C\u2082 n :=\r\n  isoWhiskerRight (DerivedCategory.singleFunctorIsoCompQ C\u2081 n) _\r\n```\r\n(not tested)",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/ExactFunctor.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "assoc",
          "Functor",
          "mapDerivedCategory",
          "comp_id",
          "inv_hom_id_app",
          "IsTriangulated",
          "id_comp",
          "mapDerivedCategoryFactorsh_hom_app",
          "simp",
          "map_id",
          "comp_obj",
          "Iso",
          "instance",
          "mapDerivedCategoryFactorsh",
          "only",
          "map_comp_assoc",
          "isTriangulated_of_precomp_iso"
        ]
      }
    },
    {
      "id": 4385,
      "before_code": "simp only [id_comp, mapDerivedCategoryFactorsh_hom_app, assoc, comp_id,\n        \u2190 Functor.map_comp_assoc, Iso.inv_hom_id_app, map_id, comp_obj])\n\ninstance : F.mapDerivedCategory.IsTriangulated :=\n  Functor.isTriangulated_of_precomp_iso F.mapDerivedCategoryFactorsh",
      "suggestion": "\r\n        \u226a\u226b associator .. \u226a\u226b (isoWhiskerLeft _ (DerivedCategory.singleFunctorIsoCompQ C\u2082 n)).symm\r\n",
      "body": "```suggestion\r\n        \u226a\u226b associator .. \u226a\u226b (isoWhiskerLeft _ (DerivedCategory.singleFunctorIsoCompQ C\u2082 n)).symm\r\n```",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/ExactFunctor.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "assoc",
          "Functor",
          "mapDerivedCategory",
          "comp_id",
          "inv_hom_id_app",
          "IsTriangulated",
          "id_comp",
          "mapDerivedCategoryFactorsh_hom_app",
          "simp",
          "map_id",
          "comp_obj",
          "Iso",
          "instance",
          "mapDerivedCategoryFactorsh",
          "only",
          "map_comp_assoc",
          "isTriangulated_of_precomp_iso"
        ]
      }
    },
    {
      "id": 4391,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  by_cases! h : \u2200 i, p \u2223 n i\n",
      "body": "```suggestion\n  by_cases! h : \u2200 i, p \u2223 n i\n```\nThis will push the negation for you.",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 4392,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "  by_cases! h : \u2200 i, p \u2223 d i\n",
      "body": "```suggestion\n  by_cases! h : \u2200 i, p \u2223 d i\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 4393,
      "before_code": "rw [Function.mem_support, \u2190 coeff_apply \u03c6, \u2190 coeff_expand_smul p hp, coeff_apply, hc] at hn\u2081\n  contradiction",
      "suggestion": "\r\n\r\n",
      "body": "```suggestion\r\n\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Expand.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "set_theory",
          "order",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "mem_support",
          "Function",
          "contradiction",
          "coeff_apply",
          "coeff_expand_smul"
        ]
      }
    },
    {
      "id": 4394,
      "before_code": "trunc' S n (map f p) = MvPolynomial.map f (trunc' R n p) := by\n  ext m; simp [coeff_trunc', MvPolynomial.coeff_map, apply_ite f]",
      "suggestion": "\r\ntheorem totalDegree_trunc' {n : \u03c3 \u2192\u2080 \u2115} (\u03c6 : MvPowerSeries \u03c3 R) :\r\n",
      "body": "```suggestion\r\ntheorem totalDegree_trunc' {n : \u03c3 \u2192\u2080 \u2115} (\u03c6 : MvPowerSeries \u03c3 R) :\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Trunc.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "MvPolynomial",
          "ext",
          "coeff_trunc",
          "coeff_map",
          "trunc",
          "map",
          "simp",
          "apply_ite"
        ]
      }
    },
    {
      "id": 4395,
      "before_code": "trunc' S n (map f p) = MvPolynomial.map f (trunc' R n p) := by\n  ext m; simp [coeff_trunc', MvPolynomial.coeff_map, apply_ite f]",
      "suggestion": "\r\ntheorem ext'_trunc' {f g : MvPowerSeries \u03c3 R} :\r\n    f = g \u2194 \u2203\u1da0 m in atTop, trunc' R m f = trunc' R m g := by\r\n",
      "body": "```suggestion\r\ntheorem ext'_trunc' {f g : MvPowerSeries \u03c3 R} :\r\n    f = g \u2194 \u2203\u1da0 m in atTop, trunc' R m f = trunc' R m g := by\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Trunc.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "MvPolynomial",
          "ext",
          "coeff_trunc",
          "coeff_map",
          "trunc",
          "map",
          "simp",
          "apply_ite"
        ]
      }
    },
    {
      "id": 4397,
      "before_code": "lemma IsNontrivial.exists_lt_one {\u0393\u2080 : Type*} [LinearOrderedCommGroupWithZero \u0393\u2080]\n    {v : Valuation K \u0393\u2080} [hv : v.IsNontrivial] :\n    \u2203 x : K, v x \u2260 0 \u2227 v x < 1 := by",
      "suggestion": "\r\n    \u2203 x \u2260 0, v x < 1 := by\r\n",
      "body": "```suggestion\r\n    \u2203 x \u2260 0, v x < 1 := by\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "IsNontrivial",
          "Valuation",
          "Type",
          "exists_lt_one",
          "LinearOrderedCommGroupWithZero"
        ]
      }
    },
    {
      "id": 4398,
      "before_code": "\u00b7 use x\u207b\u00b9\n    simp [-map_inv\u2080, \u2190 one_lt_val_iff, hx]\n\ntheorem isNontrivial_iff_exists_lt_one {\u0393\u2080 : Type*}\n    [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation K \u0393\u2080) :\n    v.IsNontrivial \u2194 \u2203 x, x \u2260 0 \u2227 v x < 1 :=",
      "suggestion": "\r\n    (v : Valuation K \u0393\u2080) : v.IsNontrivial \u2194 \u2203 x \u2260 0, v x < 1 :=\r\n",
      "body": "```suggestion\r\n    (v : Valuation K \u0393\u2080) : v.IsNontrivial \u2194 \u2203 x \u2260 0, v x < 1 :=\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "theorem",
          "one_lt_val_iff",
          "IsNontrivial",
          "Valuation",
          "Type",
          "simp",
          "LinearOrderedCommGroupWithZero",
          "use",
          "isNontrivial_iff_exists_lt_one"
        ]
      }
    },
    {
      "id": 4399,
      "before_code": "\u00b7 use x\u207b\u00b9\n    simp [-map_inv\u2080, \u2190 one_lt_val_iff, hx]\n\ntheorem isNontrivial_iff_exists_lt_one {\u0393\u2080 : Type*}\n    [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation K \u0393\u2080) :\n    v.IsNontrivial \u2194 \u2203 x, x \u2260 0 \u2227 v x < 1 :=\n  \u27e8fun h \u21a6 by simpa using h.exists_lt_one (v := v), fun \u27e8x, hx0, hx1\u27e9 \u21a6 \u27e8x, by simp [hx0, hx1.ne]\u27e9\u27e9\n\nlemma IsNontrivial.exists_one_lt {\u0393\u2080 : Type*} [LinearOrderedCommGroupWithZero \u0393\u2080]\n    {v : Valuation K \u0393\u2080} [hv : v.IsNontrivial] :\n    \u2203 x : K, v x \u2260 0 \u2227 1 < v x := by",
      "suggestion": "\r\n    \u2203 x, 1 < v x := by\r\n",
      "body": "```suggestion\r\n    \u2203 x, 1 < v x := by\r\n```",
      "path": "Mathlib/RingTheory/Valuation/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "simp"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "theorem",
          "one_lt_val_iff",
          "IsNontrivial",
          "Valuation",
          "Type",
          "simpa",
          "exists_lt_one",
          "simp",
          "exists_one_lt",
          "hx0",
          "LinearOrderedCommGroupWithZero",
          "use",
          "isNontrivial_iff_exists_lt_one",
          "hx1",
          "using"
        ]
      }
    },
    {
      "id": 4400,
      "before_code": "@[simp] theorem E\u2088_transpose : E\u2088.transpose = E\u2088 := by decide",
      "suggestion": "",
      "body": "These are too trivial given we provide the value of the determinants above.\n```suggestion\n```",
      "path": "Mathlib/Data/Matrix/Cartan.lean",
      "tags": {
        "before_tactics": [
          "decide",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "decide",
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "decide",
          "transpose",
          "simp",
          "theorem"
        ]
      }
    },
    {
      "id": 4401,
      "before_code": "theorem coe_bot : ((\u22a5 : Submonoid M) : Set M) = {1} :=\n  rfl",
      "suggestion": "\r\n    mk toSubsemigroup one_mem' = \u22a5 \u2194 toSubsemigroup = \u22a5 := by\r\n",
      "body": "```suggestion\r\n    mk toSubsemigroup one_mem' = \u22a5 \u2194 toSubsemigroup = \u22a5 := by\r\n```",
      "path": "Mathlib/Algebra/Group/Submonoid/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "coe_bot",
          "theorem",
          "Set",
          "Submonoid",
          "rfl"
        ]
      }
    },
    {
      "id": 4402,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "theorem isAcyclic_add_edge_iff_of_not_reachable (x y : V) (hxy : \u00ac G.Reachable x y) :\n",
      "body": "We might as well use the `G` already available as a `variable`:\n```suggestion\ntheorem isAcyclic_add_edge_iff_of_not_reachable (x y : V) (hxy : \u00ac G.Reachable x y) :\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 4403,
      "before_code": "obtain \u27e8T, hTG, hmin\u27e9 := {H : SimpleGraph V | H.Connected}.toFinite.exists_le_minimal h\n  exact \u27e8T, hTG, isTree_of_minimal_connected hmin\u27e9",
      "suggestion": "",
      "body": "Let's cut this double blank line down to a single\n```suggestion\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isTree_of_minimal_connected",
          "exact",
          "hmin",
          "exists_le_minimal",
          "obtain",
          "Connected",
          "hTG",
          "toFinite",
          "SimpleGraph"
        ]
      }
    },
    {
      "id": 4404,
      "before_code": "Additivise\n-/\n\n@[expose] public section\n\nnoncomputable section\n\nopen TensorProduct\n\nnamespace MonoidAlgebra\nvariable {R M S A B : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S] [CommMonoid M]\nvariable [CommSemiring A] [Algebra R A] [CommSemiring B] [Algebra R B]",
      "suggestion": "\r\n-- Note: Cannot be additivised automatically because of `liftNCAlgHom` and `of`\r\nnoncomputable def _root_.AddMonoidAlgebra.tensorEquiv :\r\n",
      "body": "```suggestion\r\n-- Note: Cannot be additivised automatically because of `liftNCAlgHom` and `of`\r\nnoncomputable def _root_.AddMonoidAlgebra.tensorEquiv :\r\n```",
      "path": "Mathlib/RingTheory/TensorProduct/MonoidAlgebra.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "noncomputable",
          "variable",
          "expose",
          "public",
          "Type",
          "MonoidAlgebra",
          "TensorProduct",
          "CommMonoid",
          "Algebra",
          "open",
          "CommSemiring",
          "section",
          "Additivise",
          "namespace"
        ]
      }
    },
    {
      "id": 4405,
      "before_code": "Additivise\n-/\n\n@[expose] public section\n\nnoncomputable section\n\nopen TensorProduct\n\nnamespace MonoidAlgebra\nvariable {R M S A B : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S] [CommMonoid M]\nvariable [CommSemiring A] [Algebra R A] [CommSemiring B] [Algebra R B]",
      "suggestion": "\r\n-- Note: Cannot be additivised automatically because of the use of `Multiplicative`\r\n-- in `AddMonoidAlgebra.liftNCAlgHom` and `of`\r\n",
      "body": "```suggestion\r\n-- Note: Cannot be additivised automatically because of the use of `Multiplicative`\r\n-- in `AddMonoidAlgebra.liftNCAlgHom` and `of`\r\n```",
      "path": "Mathlib/RingTheory/TensorProduct/MonoidAlgebra.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "noncomputable",
          "variable",
          "expose",
          "public",
          "Type",
          "MonoidAlgebra",
          "TensorProduct",
          "CommMonoid",
          "Algebra",
          "open",
          "CommSemiring",
          "section",
          "Additivise",
          "namespace"
        ]
      }
    },
    {
      "id": 4406,
      "before_code": "Additivise\n-/\n\n@[expose] public section\n\nnoncomputable section\n\nopen TensorProduct\n\nnamespace MonoidAlgebra\nvariable {R M S A B : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S] [CommMonoid M]\nvariable [CommSemiring A] [Algebra R A] [CommSemiring B] [Algebra R B]\n\nvariable (R A B) in\n/-- The base change of `B[M]` to an `R`-algebra `A` is isomorphic to `(A \u2297[R] B)[M]`\nas an `A`-algebra. -/\nnoncomputable def tensorEquiv : A \u2297[R] B[M] \u2243\u2090[A] (A \u2297[R] B)[M] := by\n  refine .ofAlgHom\n    (Algebra.TensorProduct.lift\n      ((IsScalarTower.toAlgHom A (A \u2297[R] B) _).comp Algebra.TensorProduct.includeLeft)\n      (mapRangeAlgHom _ Algebra.TensorProduct.includeRight) fun p n \u21a6 .all ..)\n    (MonoidAlgebra.liftNCAlgHom (Algebra.TensorProduct.map (.id _ _) singleOneAlgHom)\n      (Algebra.TensorProduct.includeRight.toMonoidHom.comp (of B M)) fun _ _ \u21a6 .all ..) ?_ ?_\n  \u00b7 apply AlgHom.toLinearMap_injective\n    ext\n    simp\n  \u00b7 ext : 1\n    \u00b7 ext\n    apply AlgHom.toLinearMap_injective\n    ext\n    simp\n\n@[simp]\nlemma tensorEquiv_tmul (a : A) (p : B[M]) :\n    tensorEquiv R A B (a \u2297\u209c p) = a \u2022 mapRangeAlgHom M Algebra.TensorProduct.includeRight p := by\n  simp [tensorEquiv, Algebra.smul_def]\n\n@[simp]\nlemma tensorEquiv_symm_single (m : M) (a : A) (b : B) :\n    (tensorEquiv R A B).symm (single m (a \u2297\u209c b)) = a \u2297\u209c single m b := by simp [tensorEquiv]",
      "suggestion": "\r\n    (tensorEquiv R A B).symm (single m (a \u2297\u209c b)) = a \u2297\u209c single m b :=\r\n  tensorEquiv.invFun_tmul _ _ _\r\n",
      "body": "```suggestion\r\n    (tensorEquiv R A B).symm (single m (a \u2297\u209c b)) = a \u2297\u209c single m b :=\r\n  tensorEquiv.invFun_tmul _ _ _\r\n```\r\nor similar?",
      "path": "Mathlib/RingTheory/TensorProduct/MonoidAlgebra.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "refine",
          "simp",
          "ext"
        ],
        "topics": [
          "equiv",
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "tensorEquiv",
          "lemma",
          "algebra",
          "expose",
          "Type",
          "single",
          "MonoidAlgebra",
          "change",
          "base",
          "lift",
          "AlgHom",
          "open",
          "section",
          "apply",
          "symm",
          "noncomputable",
          "refine",
          "ext",
          "singleOneAlgHom",
          "isomorphic",
          "map",
          "liftNCAlgHom",
          "tensorEquiv_symm_single",
          "CommSemiring",
          "toAlgHom",
          "Additivise",
          "mapRangeAlgHom",
          "variable",
          "public",
          "def",
          "includeRight",
          "toMonoidHom",
          "TensorProduct",
          "comp",
          "simp",
          "tensorEquiv_tmul",
          "namespace",
          "toLinearMap_injective",
          "IsScalarTower",
          "includeLeft",
          "smul_def",
          "CommMonoid",
          "ofAlgHom",
          "Algebra",
          "all"
        ]
      }
    },
    {
      "id": 4407,
      "before_code": "(f.curry.sum fun a f => f.sum (g a)) = f.sum fun p c => g p.1 p.2 c := by\n  rw [\u2190 sum_uncurry_index', uncurry_curry]\n\n/-- `finsuppProdEquiv` defines the `Equiv` between `((\u03b1 \u00d7 \u03b2) \u2192\u2080 M)` and `(\u03b1 \u2192\u2080 (\u03b2 \u2192\u2080 M))` given by\ncurrying and uncurrying. -/\n@[simps]\ndef finsuppProdEquiv : (\u03b1 \u00d7 \u03b2 \u2192\u2080 M) \u2243 (\u03b1 \u2192\u2080 \u03b2 \u2192\u2080 M) where\n  toFun := Finsupp.curry\n  invFun := Finsupp.uncurry\n  left_inv := uncurry_curry\n  right_inv := curry_uncurry\n\ntheorem filter_curry (f : \u03b1 \u00d7 \u03b2 \u2192\u2080 M) (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    (f.filter fun a : \u03b1 \u00d7 \u03b2 => p a.1).curry = f.curry.filter p := by\n  ext a b\n  simp [filter_apply, apply_ite (DFunLike.coe \u00b7 b)]\n\nend Curry",
      "suggestion": "\r\nvariable [DecidableEq \u03b1] [AddZeroClass M]\r\n",
      "body": "```suggestion\r\nvariable [DecidableEq \u03b1] [AddZeroClass M]\r\n```\r\nto match the order in `curryEquiv` above",
      "path": "Mathlib/Data/Finsupp/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "simp",
          "ext"
        ],
        "topics": [
          "order",
          "equiv",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "finsuppProdEquiv",
          "end",
          "DecidablePred",
          "filter_apply",
          "ext",
          "invFun",
          "sum_uncurry_index",
          "Prop",
          "curry_uncurry",
          "Equiv",
          "sum",
          "apply_ite",
          "Finsupp",
          "def",
          "toFun",
          "right_inv",
          "uncurrying",
          "simps",
          "between",
          "simp",
          "given",
          "Curry",
          "defines",
          "currying",
          "theorem",
          "uncurry_curry",
          "filter",
          "DFunLike",
          "curry",
          "uncurry",
          "left_inv",
          "filter_curry",
          "coe"
        ]
      }
    },
    {
      "id": 4408,
      "before_code": "open WithZeroMulInt\n\nvariable {R K} in",
      "suggestion": "\r\nvariable {R K} {b : \u211d\u22650} (hb : 1 < b) (r : R) (x : K)\r\n",
      "body": "```suggestion\r\nvariable {R K} {b : \u211d\u22650} (hb : 1 < b) (r : R) (x : K)\r\n```\r\nYou might need to open some scope for this.",
      "path": "Mathlib/RingTheory/DedekindDomain/AdicValuation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "open",
          "WithZeroMulInt",
          "variable"
        ]
      }
    },
    {
      "id": 4409,
      "before_code": "exp (g \u2022 a) = g \u2022 exp a :=\n  (map_exp ha (MulSemiringAction.toRingHom G A g)).symm",
      "suggestion": "\r\ntheorem isNilpotent_exp_sub_one {a : A} (ha : IsNilpotent a) : IsNilpotent (exp a - 1) := by\r\n",
      "body": "```suggestion\r\ntheorem isNilpotent_exp_sub_one {a : A} (ha : IsNilpotent a) : IsNilpotent (exp a - 1) := by\r\n```",
      "path": "Mathlib/RingTheory/Nilpotent/Exp.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exp",
          "symm",
          "map_exp",
          "MulSemiringAction",
          "toRingHom"
        ]
      }
    },
    {
      "id": 4410,
      "before_code": "@[ext]\nclass ValuativeRel (R : Type*) [CommRing R] where\n  /-- The relation operator arising from `ValuativeRel`. -/\n  Rel : R \u2192 R \u2192 Prop\n  rel_total (x y) : Rel x y \u2228 Rel y x\n  rel_trans {z y x} : Rel x y \u2192 Rel y z \u2192 Rel x z\n  rel_add {x y z} : Rel x z \u2192 Rel y z \u2192 Rel (x + y) z\n  rel_mul_right {x y} (z) : Rel x y \u2192 Rel (x * z) (y * z)\n  rel_mul_cancel {x y z} : \u00ac Rel z 0 \u2192 Rel (x * z) (y * z) \u2192 Rel x y\n  not_rel_one_zero : \u00ac Rel 1 0",
      "suggestion": "\r\n  VLE : R \u2192 R \u2192 Prop\r\n",
      "body": "```suggestion\r\n  VLE : R \u2192 R \u2192 Prop\r\n```\r\nBecause this is a `Prop`.",
      "path": "Mathlib/RingTheory/Valuation/ValuativeRel/Basic.lean",
      "tags": {
        "before_tactics": [
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "not_rel_one_zero",
          "arising",
          "rel_total",
          "CommRing",
          "ext",
          "relation",
          "Type",
          "rel_trans",
          "Prop",
          "rel_mul_right",
          "class",
          "from",
          "operator",
          "Rel",
          "rel_add",
          "rel_mul_cancel",
          "ValuativeRel"
        ]
      }
    },
    {
      "id": 4411,
      "before_code": "/-- We say that a valuation `v` is `Compatible` if the relation `x \u2264\u1d65 y`\nis equivalent to `v x \u2264 v y`. -/\nclass Compatible [ValuativeRel R] where\n  rel_iff_le (x y : R) : x \u2264\u1d65 y \u2194 v x \u2264 v y\n\nend Valuation\n\n/-- A preorder on a ring is said to be \"valuative\" if it agrees with the\nvaluative relation. -/\nclass ValuativePreorder (R : Type*) [CommRing R] [ValuativeRel R] [Preorder R] where\n  rel_iff_le (x y : R) : x \u2264\u1d65 y \u2194 x \u2264 y\n\nnamespace ValuativeRel\n\nvariable {R : Type*} [CommRing R] [ValuativeRel R] {x y z : R}\n\n/-- The strict version of the valuative relation. -/\ndef SRel (x y : R) : Prop := \u00ac y \u2264\u1d65 x",
      "suggestion": "\r\ndef VLT (x y : R) : Prop := \u00ac y \u2264\u1d65 x\r\n",
      "body": "```suggestion\r\ndef VLT (x y : R) : Prop := \u00ac y \u2264\u1d65 x\r\n```",
      "path": "Mathlib/RingTheory/Valuation/ValuativeRel/Basic.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "valuation",
          "valuative",
          "said",
          "Type",
          "rel_iff_le",
          "class",
          "Compatible",
          "strict",
          "Valuation",
          "Prop",
          "equivalent",
          "preorder",
          "CommRing",
          "variable",
          "def",
          "say",
          "Preorder",
          "that",
          "ring",
          "version",
          "ValuativeRel",
          "namespace",
          "agrees",
          "SRel",
          "relation",
          "ValuativePreorder"
        ]
      }
    },
    {
      "id": 4413,
      "before_code": "(monomial s a).degreeOf i = s i := by\n  classical rw [degreeOf_def, degrees_monomial_eq _ _ ha, Finsupp.count_toMultiset]\n\n-- TODO we can prove equality with `NoZeroDivisors R`",
      "suggestion": "\r\nNote that `degreeOf_prod_eq` proves equality with `NoZeroDivisors R` and nonzero polynomials.\r\n",
      "body": "```suggestion\r\nNote that `degreeOf_prod_eq` proves equality with `NoZeroDivisors R` and nonzero polynomials.\r\n```",
      "path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "can",
          "prove",
          "NoZeroDivisors",
          "count_toMultiset",
          "equality",
          "monomial",
          "degrees_monomial_eq",
          "degreeOf",
          "classical",
          "TODO",
          "degreeOf_def"
        ]
      }
    },
    {
      "id": 4416,
      "before_code": "have : NeZero n := \u27e8hn\u27e9\n  exact nthRoots_one_eq_biUnion_primitiveRoots'",
      "suggestion": "\r\n    (h : e.Coprime r) : (primitiveRoots r R) \u2243 (primitiveRoots r R) := by\r\n",
      "body": "```suggestion\r\n    (h : e.Coprime r) : (primitiveRoots r R) \u2243 (primitiveRoots r R) := by\r\n```",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "have"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "NeZero",
          "have",
          "nthRoots_one_eq_biUnion_primitiveRoots"
        ]
      }
    },
    {
      "id": 4417,
      "before_code": "have : NeZero n := \u27e8hn\u27e9\n  exact nthRoots_one_eq_biUnion_primitiveRoots'",
      "suggestion": "\r\n    rw [hgcd, zpow_sub, zpow_mul]\r\n",
      "body": "```suggestion\r\n    rw [hgcd, zpow_sub, zpow_mul]\r\n```",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "have"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "NeZero",
          "have",
          "nthRoots_one_eq_biUnion_primitiveRoots"
        ]
      }
    },
    {
      "id": 4418,
      "before_code": "have : NeZero n := \u27e8hn\u27e9\n  exact nthRoots_one_eq_biUnion_primitiveRoots'",
      "suggestion": "\r\n    \u00b7 rw [\u2190 Nat.isCoprime_iff_coprime, Int.isCoprime_iff_gcd_eq_one, Int.gcd_natCast_natCast] at h\r\n",
      "body": "```suggestion\r\n    \u00b7 rw [\u2190 Nat.isCoprime_iff_coprime, Int.isCoprime_iff_gcd_eq_one, Int.gcd_natCast_natCast] at h\r\n```",
      "path": "Mathlib/RingTheory/RootsOfUnity/PrimitiveRoots.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "exact",
          "have"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "NeZero",
          "have",
          "nthRoots_one_eq_biUnion_primitiveRoots"
        ]
      }
    },
    {
      "id": 4419,
      "before_code": "variable (M\u2080) in\nlemma isUnit_le_nonZeroDivisors : IsUnit.submonoid M\u2080 \u2264 M\u2080\u2070 := fun _ \u21a6 (\u00b7.mem_nonZeroDivisors)",
      "suggestion": "    x * y \u2208 M\u2080\u2070 :=\n  mem_nonZeroDivisors_iff'.mpr\n    \u27e8mul_mem_nonZeroDivisorsLeft_of_mem_nonZeroDivisorsLeft hx.1 hy.1,\n      mul_mem_nonZeroDivisorsRight_of_mem_nonZeroDivisorsRight hx.2 hy.2\u27e9\n",
      "body": "```suggestion\n    x * y \u2208 M\u2080\u2070 :=\n  mem_nonZeroDivisors_iff'.mpr\n    \u27e8mul_mem_nonZeroDivisorsLeft_of_mem_nonZeroDivisorsLeft hx.1 hy.1,\n      mul_mem_nonZeroDivisorsRight_of_mem_nonZeroDivisorsRight hx.2 hy.2\u27e9\n```",
      "path": "Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "IsUnit",
          "variable",
          "submonoid",
          "mem_nonZeroDivisors",
          "isUnit_le_nonZeroDivisors"
        ]
      }
    },
    {
      "id": 4421,
      "before_code": "namespace Filtration",
      "suggestion": "is inconvenient because `\ud835\udcd5\u208a` is not a `Filtration \u03b9 m` anymore. If the index type\n",
      "body": "```suggestion\nis inconvenient because `\ud835\udcd5\u208a` is not a `Filtration \u03b9 m` anymore. If the index type\n```",
      "path": "Mathlib/Probability/Process/Filtration.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Filtration",
          "namespace"
        ]
      }
    },
    {
      "id": 4422,
      "before_code": "namespace Filtration",
      "suggestion": "noncomputable irreducible_def rightCont [PartialOrder \u03b9] (\ud835\udcd5 : Filtration \u03b9 m) : Filtration \u03b9 m :=\n",
      "body": "```suggestion\nnoncomputable irreducible_def rightCont [PartialOrder \u03b9] (\ud835\udcd5 : Filtration \u03b9 m) : Filtration \u03b9 m :=\n```\nSince it's a complicated definition, better prevent Lean from unfolding it.",
      "path": "Mathlib/Probability/Process/Filtration.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Filtration",
          "namespace"
        ]
      }
    },
    {
      "id": 4427,
      "before_code": "alias \u27e8_, IsIdempotentElem.ext\u27e9 := IsIdempotentElem.ext_iff\n\ntheorem IsIdempotentElem.range_eq_ker {E : Type*} [AddCommGroup E] [Module S E]\n    {p : E \u2192\u2097[S] E} (hp : IsIdempotentElem p) : LinearMap.range p = LinearMap.ker (1 - p) :=\n  le_antisymm\n    (LinearMap.range_le_ker_iff.mpr hp.one_sub_mul_self)\n    fun x hx \u21a6 \u27e8x, by simpa [sub_eq_zero, eq_comm (a := x)] using hx\u27e9",
      "suggestion": "\r\ntheorem IsIdempotentElem.range_eq_ker_one_sub {E : Type*} [AddCommGroup E] [Module S E]\r\n",
      "body": "```suggestion\r\ntheorem IsIdempotentElem.range_eq_ker_one_sub {E : Type*} [AddCommGroup E] [Module S E]\r\n```",
      "path": "Mathlib/LinearAlgebra/Projection.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "ext"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "range_eq_ker",
          "Module",
          "mpr",
          "le_antisymm",
          "Type",
          "alias",
          "eq_comm",
          "ext",
          "LinearMap",
          "IsIdempotentElem",
          "AddCommGroup",
          "one_sub_mul_self",
          "ker",
          "range",
          "sub_eq_zero",
          "range_le_ker_iff",
          "ext_iff",
          "theorem",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 4428,
      "before_code": "alias \u27e8_, IsIdempotentElem.ext\u27e9 := IsIdempotentElem.ext_iff\n\ntheorem IsIdempotentElem.range_eq_ker {E : Type*} [AddCommGroup E] [Module S E]\n    {p : E \u2192\u2097[S] E} (hp : IsIdempotentElem p) : LinearMap.range p = LinearMap.ker (1 - p) :=\n  le_antisymm\n    (LinearMap.range_le_ker_iff.mpr hp.one_sub_mul_self)\n    fun x hx \u21a6 \u27e8x, by simpa [sub_eq_zero, eq_comm (a := x)] using hx\u27e9\n\nopen LinearMap in\ntheorem IsIdempotentElem.ker_eq_range {E : Type*} [AddCommGroup E] [Module S E]\n    {p : E \u2192\u2097[S] E} (hp : IsIdempotentElem p) : LinearMap.ker p = LinearMap.range (1 - p) := by\n  simpa using hp.one_sub.range_eq_ker.symm",
      "suggestion": "\r\ntheorem IsIdempotentElem.ker_eq_range_one_sub {E : Type*} [AddCommGroup E] [Module S E]\r\n",
      "body": "```suggestion\r\ntheorem IsIdempotentElem.ker_eq_range_one_sub {E : Type*} [AddCommGroup E] [Module S E]\r\n```",
      "path": "Mathlib/LinearAlgebra/Projection.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "ext"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "range_eq_ker",
          "ker_eq_range",
          "mpr",
          "Module",
          "le_antisymm",
          "Type",
          "open",
          "alias",
          "eq_comm",
          "symm",
          "ext",
          "LinearMap",
          "IsIdempotentElem",
          "AddCommGroup",
          "one_sub_mul_self",
          "ker",
          "range",
          "sub_eq_zero",
          "range_le_ker_iff",
          "ext_iff",
          "theorem",
          "one_sub",
          "simpa",
          "using"
        ]
      }
    },
    {
      "id": 4429,
      "before_code": "(x y : R\u27e6\u0393\u27e7) : (x * y).cardSupp \u2264 x.cardSupp * y.cardSupp :=\n  (mk_le_mk_of_subset (support_mul_subset ..)).trans mk_add_le",
      "suggestion": "  grw [\u2190 lift_uzero (cardSupp _), \u2190 sum_pow_le_max_aleph0, cardSupp_hsum_le, sum_le_sum]\n  intro i\n",
      "body": "An alternative way to write this, if you like it\n\n```suggestion\n  grw [\u2190 lift_uzero (cardSupp _), \u2190 sum_pow_le_max_aleph0, cardSupp_hsum_le, sum_le_sum]\n  intro i\n```",
      "path": "Mathlib/RingTheory/HahnSeries/Cardinal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "intro"
        ],
        "body_tactics": [
          "intro"
        ],
        "new_tactics": [
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "support_mul_subset",
          "mk_le_mk_of_subset",
          "trans",
          "cardSupp",
          "mk_add_le"
        ]
      }
    },
    {
      "id": 4430,
      "before_code": "end Closed",
      "suggestion": "    [\u2200 i, (F i).LaxMonoidal] :\n    (Functor.pi F).LaxMonoidal where\n",
      "body": "```suggestion\n    [\u2200 i, (F i).LaxMonoidal] :\n    (Functor.pi F).LaxMonoidal where\n```",
      "path": "Mathlib/CategoryTheory/Pi/Monoidal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Closed",
          "end"
        ]
      }
    },
    {
      "id": 4431,
      "before_code": "end Closed",
      "suggestion": "    [\u2200 i, (F i).OplaxMonoidal] :\n    (Functor.pi' F).OplaxMonoidal where\n",
      "body": "```suggestion\n    [\u2200 i, (F i).OplaxMonoidal] :\n    (Functor.pi' F).OplaxMonoidal where\n```",
      "path": "Mathlib/CategoryTheory/Pi/Monoidal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Closed",
          "end"
        ]
      }
    },
    {
      "id": 4432,
      "before_code": "end Closed",
      "suggestion": "    [\u2200 i, (F i).LaxMonoidal] :\n    (Functor.pi' F).LaxMonoidal where\n",
      "body": "```suggestion\n    [\u2200 i, (F i).LaxMonoidal] :\n    (Functor.pi' F).LaxMonoidal where\n```",
      "path": "Mathlib/CategoryTheory/Pi/Monoidal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Closed",
          "end"
        ]
      }
    },
    {
      "id": 4433,
      "before_code": "section BaireTheorem\n\nvariable [TopologicalSpace X] [BaireSpace X]",
      "suggestion": "theorem Set.Finite.dense_sInter {s : Set (Set X)} (hs : s.Finite)\n",
      "body": "```suggestion\ntheorem Set.Finite.dense_sInter {s : Set (Set X)} (hs : s.Finite)\n```",
      "path": "Mathlib/Topology/Baire/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "TopologicalSpace",
          "variable",
          "BaireSpace",
          "BaireTheorem",
          "section"
        ]
      }
    },
    {
      "id": 4436,
      "before_code": "aesop\n\nend OrthonormalBasis",
      "suggestion": "\r\n  __ := (K.prodEquivOfIsCompl K\u15ee isCompl_orthogonal_of_hasOrthogonalProjection).symm\r\n    \u226a\u226b\u2097 (WithLp.linearEquiv 2 _ _).symm\r\n",
      "body": "I think it would be better to use [Submodule.prodEquivOfIsCompl](https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Projection.html#Submodule.prodEquivOfIsCompl)?\r\n```suggestion\r\n  __ := (K.prodEquivOfIsCompl K\u15ee isCompl_orthogonal_of_hasOrthogonalProjection).symm\r\n    \u226a\u226b\u2097 (WithLp.linearEquiv 2 _ _).symm\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean",
      "tags": {
        "before_tactics": [
          "aesop"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "aesop"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "OrthonormalBasis",
          "aesop",
          "end"
        ]
      }
    },
    {
      "id": 4437,
      "before_code": "@[deprecated (since := \"2025-07-29\")] alias linearProjOfIsCompl_eq_self_iff :=\n  IsCompl.projection_eq_self_iff",
      "suggestion": "\r\ntheorem toLinearMap_symm_prodEquivOfIsCompl (hpq : IsCompl p q) (x : E) :\r\n",
      "body": "same here?\r\n```suggestion\r\ntheorem toLinearMap_symm_prodEquivOfIsCompl (hpq : IsCompl p q) (x : E) :\r\n```",
      "path": "Mathlib/LinearAlgebra/Projection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "alias",
          "IsCompl",
          "since",
          "linearProjOfIsCompl_eq_self_iff",
          "projection_eq_self_iff",
          "deprecated"
        ]
      }
    },
    {
      "id": 4438,
      "before_code": "orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero (Submodule.coe_mem _), add_zero]\n\n@[deprecated (since := \"2025-07-11\")] alias orthogonalProjection_eq_linear_proj :=\n  orthogonalProjection_eq_linearProjOfIsCompl\n\ntheorem orthogonalProjection_coe_eq_linearProjOfIsCompl [K.HasOrthogonalProjection] :",
      "suggestion": "theorem toLinearMap_orthogonalProjection_eq_linearProjOfIsCompl [K.HasOrthogonalProjection] :\n",
      "body": "```suggestion\ntheorem toLinearMap_orthogonalProjection_eq_linearProjOfIsCompl [K.HasOrthogonalProjection] :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "add_zero",
          "alias",
          "theorem",
          "orthogonalProjection_eq_linearProjOfIsCompl",
          "orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero",
          "Submodule",
          "since",
          "orthogonalProjection_coe_eq_linearProjOfIsCompl",
          "HasOrthogonalProjection",
          "coe_mem",
          "deprecated",
          "orthogonalProjection_eq_linear_proj"
        ]
      }
    },
    {
      "id": 4439,
      "before_code": "orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero (Submodule.coe_mem _), add_zero]\n\n@[deprecated (since := \"2025-07-11\")] alias orthogonalProjection_eq_linear_proj :=\n  orthogonalProjection_eq_linearProjOfIsCompl\n\ntheorem orthogonalProjection_coe_eq_linearProjOfIsCompl [K.HasOrthogonalProjection] :\n    (K.orthogonalProjection : E \u2192\u2097[\ud835\udd5c] K) =\n      K.linearProjOfIsCompl _ Submodule.isCompl_orthogonal_of_hasOrthogonalProjection :=\n  LinearMap.ext <| orthogonalProjection_eq_linearProjOfIsCompl\n\n@[deprecated (since := \"2025-07-11\")] alias orthogonalProjection_coe_linearMap_eq_linearProj :=\n  orthogonalProjection_coe_eq_linearProjOfIsCompl\n\nopen Submodule in\ntheorem starProjection_coe_eq_isCompl_projection [K.HasOrthogonalProjection] :",
      "suggestion": "theorem toLinearMap_starProjection_eq_isComplProjection [K.HasOrthogonalProjection] :\n",
      "body": "```suggestion\ntheorem toLinearMap_starProjection_eq_isComplProjection [K.HasOrthogonalProjection] :\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Projection/Submodule.lean",
      "tags": {
        "before_tactics": [
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ext"
        ],
        "topics": [
          "set_theory",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "add_zero",
          "orthogonalProjection",
          "since",
          "HasOrthogonalProjection",
          "open",
          "alias",
          "LinearMap",
          "ext",
          "isCompl_orthogonal_of_hasOrthogonalProjection",
          "Submodule",
          "orthogonalProjection_eq_linear_proj",
          "orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero",
          "orthogonalProjection_coe_linearMap_eq_linearProj",
          "orthogonalProjection_coe_eq_linearProjOfIsCompl",
          "linearProjOfIsCompl",
          "theorem",
          "orthogonalProjection_eq_linearProjOfIsCompl",
          "starProjection_coe_eq_isCompl_projection",
          "coe_mem",
          "deprecated"
        ]
      }
    },
    {
      "id": 4440,
      "before_code": "| nil =>\n    exact (hp Walk.Nil.nil).elim\n  | @cons u v w h p ih =>",
      "suggestion": "\r\n  | cons h p ih =>\r\n",
      "body": "The names aren't used anymore\r\n```suggestion\r\n  | cons h p ih =>\r\n```",
      "path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Connected.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "Walk",
          "exact",
          "nil",
          "Nil",
          "cons",
          "elim"
        ]
      }
    },
    {
      "id": 4441,
      "before_code": "rw [lift_unique' F]\n    simp [lift_apply]\n\n/-- If `f : G \u2192 H` is a homomorphism between two magmas, then\n`Finsupp.mapDomain f` is a non-unital algebra homomorphism between their magma algebras. -/\n@[to_additive (dont_translate := k) (attr := simps apply) /--\nIf `f : G \u2192 H` is a homomorphism between two additive magmas, then `Finsupp.mapDomain f` is a\nnon-unital algebra homomorphism between their additive magma algebras. -/]\ndef mapDomainNonUnitalAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A]\n    {G H F : Type*} [Mul G] [Mul H] [FunLike F G H] [MulHomClass F G H] (f : F) :\n    A[G] \u2192\u2099\u2090[k] A[H] :=\n  { (Finsupp.mapDomain.addMonoidHom f : A[G] \u2192+ A[H]) with\n    map_mul' := fun x y => mapDomain_mul f x y\n    map_smul' := fun r x => mapDomain_smul r x }",
      "suggestion": "  map_mul' := mapDomain_mul f\n",
      "body": "```suggestion\n  map_mul' := mapDomain_mul f\n```",
      "path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "rw",
          "simp"
        ],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "map_smul",
          "algebra",
          "mapDomain",
          "Type",
          "mapDomain_smul",
          "Mul",
          "addMonoidHom",
          "mapDomain_mul",
          "to_additive",
          "apply",
          "MulHomClass",
          "dont_translate",
          "map_mul",
          "magma",
          "CommSemiring",
          "Finsupp",
          "two",
          "attr",
          "then",
          "def",
          "Semiring",
          "simps",
          "between",
          "homomorphism",
          "simp",
          "non",
          "their",
          "mapDomainNonUnitalAlgHom",
          "lift_unique",
          "algebras",
          "additive",
          "unital",
          "FunLike",
          "lift_apply",
          "Algebra",
          "magmas"
        ]
      }
    },
    {
      "id": 4446,
      "before_code": "theorem intrinsicStar_rTensor (f : E \u2192\u2097[R] F) : star (rTensor G f) = rTensor G (star f) := by\n  simp [rTensor, TensorProduct.intrinsicStar_map]\n\nend TensorProduct",
      "suggestion": "\r\ntheorem _root_.starLinearEquiv_intrinsicStarLinearMap :\r\n",
      "body": "or\r\n```suggestion\r\ntheorem _root_.starLinearEquiv_intrinsicStarLinearMap :\r\n```",
      "path": "Mathlib/Algebra/Star/LinearMap.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "theorem",
          "intrinsicStar_map",
          "rTensor",
          "TensorProduct",
          "simp",
          "intrinsicStar_rTensor",
          "star"
        ]
      }
    },
    {
      "id": 4447,
      "before_code": "suffices T'.toLinearMap = T\u2097.symm from this \u25b8 T'.continuous\n      simp [LinearMap.ext_iff, \u2190 T\u2097.injective.eq_iff, T', this, hT, hd, T\u2097] }\n  exact \u27e8TL, fun A \u21a6 (ContinuousLinearMap.ext <| this A).symm\u27e9",
      "suggestion": "    Function.Surjective (LinearIsometryEquiv.conjStarAlgEquiv : (V \u2243\u2097\u1d62[\ud835\udd5c] W) \u2192 _) := by\n",
      "body": "You can still phrase this as:\n```suggestion\n    Function.Surjective (LinearIsometryEquiv.conjStarAlgEquiv : (V \u2243\u2097\u1d62[\ud835\udd5c] W) \u2192 _) := by\n```\nand I think Lean shouldn't need you to fill in the `_`.",
      "path": "Mathlib/Analysis/Normed/Operator/ContinuousAlgEquiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp",
          "ext"
        ],
        "topics": [
          "continuity",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "LinearMap",
          "ContinuousLinearMap",
          "ext_iff",
          "exact",
          "suffices",
          "this",
          "continuous",
          "eq_iff",
          "simp",
          "from",
          "toLinearMap",
          "injective"
        ]
      }
    },
    {
      "id": 4448,
      "before_code": "suffices T'.toLinearMap = T\u2097.symm from this \u25b8 T'.continuous\n      simp [LinearMap.ext_iff, \u2190 T\u2097.injective.eq_iff, T', this, hT, hd, T\u2097] }\n  exact \u27e8TL, fun A \u21a6 (ContinuousLinearMap.ext <| this A).symm\u27e9",
      "suggestion": "section auxiliaryDefs\n\nvariable (e : V \u2243L[\ud835\udd5c] W) {\u03b1 \u03b1' : \ud835\udd5c} (h\u03b1 : \u03b1 \u2260 0)\n",
      "body": "```suggestion\nsection auxiliaryDefs\n\nvariable (e : V \u2243L[\ud835\udd5c] W) {\u03b1 \u03b1' : \ud835\udd5c} (h\u03b1 : \u03b1 \u2260 0)\n```",
      "path": "Mathlib/Analysis/Normed/Operator/ContinuousAlgEquiv.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp",
          "ext"
        ],
        "topics": [
          "continuity",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "LinearMap",
          "ContinuousLinearMap",
          "ext_iff",
          "exact",
          "suffices",
          "this",
          "continuous",
          "eq_iff",
          "simp",
          "from",
          "toLinearMap",
          "injective"
        ]
      }
    },
    {
      "id": 4449,
      "before_code": "section Compact",
      "suggestion": "",
      "body": "I think that's the point of this PR.\n```suggestion\n```",
      "path": "Mathlib/Topology/EMetricSpace/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "Compact",
          "section"
        ]
      }
    },
    {
      "id": 4450,
      "before_code": "def IsMulIndecomposable (v : \u03b9 \u2192 M) (s : Set \u03b9) (i : \u03b9) : Prop :=\n  i \u2208 s \u2227 \u2200\u1d49 (j \u2208 s) (k \u2208 s), v i = v j * v k \u2192 v j = 1 \u2228 v k = 1\n\n@[to_additive]\nlemma isMulIndecomposable_id_univ [Subsingleton M\u02e3] {x : M} (hx : x \u2260 1) :\n    IsMulIndecomposable id univ x \u2194 Irreducible x :=\n  \u27e8fun h \u21a6 \u27e8by simpa, by simpa using h\u27e9, fun h \u21a6 by simpa using h.isUnit_or_isUnit\u27e9",
      "suggestion": "In the case that `v` is the set of roots of a crystallographic root system, and `S = \u211a`, this is the\n",
      "body": "```suggestion\nIn the case that `v` is the set of roots of a crystallographic root system, and `S = \u211a`, this is the\n```",
      "path": "Mathlib/Algebra/Group/Irreducible/Indecomposable.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "to_additive",
          "lemma",
          "def",
          "univ",
          "Set",
          "Prop",
          "Irreducible",
          "Subsingleton",
          "simpa",
          "isMulIndecomposable_id_univ",
          "isUnit_or_isUnit",
          "IsMulIndecomposable",
          "using"
        ]
      }
    },
    {
      "id": 4451,
      "before_code": "def IsMulIndecomposable (v : \u03b9 \u2192 M) (s : Set \u03b9) (i : \u03b9) : Prop :=\n  i \u2208 s \u2227 \u2200\u1d49 (j \u2208 s) (k \u2208 s), v i = v j * v k \u2192 v j = 1 \u2228 v k = 1\n\n@[to_additive]\nlemma isMulIndecomposable_id_univ [Subsingleton M\u02e3] {x : M} (hx : x \u2260 1) :\n    IsMulIndecomposable id univ x \u2194 Irreducible x :=\n  \u27e8fun h \u21a6 \u27e8by simpa, by simpa using h\u27e9, fun h \u21a6 by simpa using h.isUnit_or_isUnit\u27e9",
      "suggestion": "def IsMulIndecomposable.baseOf [Monoid S] (v : \u03b9 \u2192 M) (f : M \u2192* S) : Set \u03b9 :=\n  {j | IsMulIndecomposable v {i | 1 < f (v i)} j}\n",
      "body": "Isn't this abusing the defeq between predicates and sets?\n```suggestion\ndef IsMulIndecomposable.baseOf [Monoid S] (v : \u03b9 \u2192 M) (f : M \u2192* S) : Set \u03b9 :=\n  {j | IsMulIndecomposable v {i | 1 < f (v i)} j}\n```",
      "path": "Mathlib/Algebra/Group/Irreducible/Indecomposable.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "to_additive",
          "lemma",
          "def",
          "univ",
          "Set",
          "Prop",
          "Irreducible",
          "Subsingleton",
          "simpa",
          "isMulIndecomposable_id_univ",
          "isUnit_or_isUnit",
          "IsMulIndecomposable",
          "using"
        ]
      }
    },
    {
      "id": 4453,
      "before_code": "@[expose] public section",
      "suggestion": "\r\nassert_not_exists Real.instPow\r\n",
      "body": "```suggestion\r\nassert_not_exists Real.instPow\r\n```",
      "path": "Mathlib/MeasureTheory/Measure/Doubling.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "expose",
          "section",
          "public"
        ]
      }
    },
    {
      "id": 4454,
      "before_code": "@[simp]\ntheorem implicitToOpenPartialHomeomorphOfComplemented_self (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = \u22a4) (hker : (ker f').ClosedComplemented) :",
      "suggestion": "\r\n    (hf' : f'.range = \u22a4) (hker : f'.ker.ClosedComplemented) :\r\n",
      "body": "```suggestion\r\n    (hf' : f'.range = \u22a4) (hker : f'.ker.ClosedComplemented) :\r\n```\r\nand a few more times in the file",
      "path": "Mathlib/Analysis/Calculus/Implicit.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "hker",
          "implicitToOpenPartialHomeomorphOfComplemented_self",
          "HasStrictFDerivAt",
          "range",
          "theorem",
          "ClosedComplemented",
          "simp",
          "ker"
        ]
      }
    },
    {
      "id": 4455,
      "before_code": "rw [\u2190 U.adjoint_subtypeL, adjoint_adjoint]\n\ntheorem orthogonal_ker (T : E \u2192L[\ud835\udd5c] F) :\n    (LinearMap.ker T)\u15ee = (LinearMap.range (T\u2020)).topologicalClosure := by",
      "suggestion": "\r\n    T.ker\u15ee = T\u2020.range.topologicalClosure := by\r\n",
      "body": "Does this work?\r\n```suggestion\r\n    T.ker\u15ee = T\u2020.range.topologicalClosure := by\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Adjoint.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "adjoint_subtypeL",
          "range",
          "adjoint_adjoint",
          "LinearMap",
          "theorem",
          "topologicalClosure",
          "orthogonal_ker",
          "ker"
        ]
      }
    },
    {
      "id": 4456,
      "before_code": "rw [\u2190 U.adjoint_subtypeL, adjoint_adjoint]\n\ntheorem orthogonal_ker (T : E \u2192L[\ud835\udd5c] F) :\n    (LinearMap.ker T)\u15ee = (LinearMap.range (T\u2020)).topologicalClosure := by\n  rw [\u2190 Submodule.orthogonal_orthogonal_eq_closure]\n  apply le_antisymm\n  all_goals refine Submodule.orthogonal_le fun x hx \u21a6 ?_\n  \u00b7 refine ext_inner_left \ud835\udd5c fun y \u21a6 ?_\n    simp [\u2190 T.adjoint_inner_left, hx _ (LinearMap.mem_range_self (T\u2020) y)]\n  \u00b7 rintro _ \u27e8y, rfl\u27e9\n    simp_all [T.adjoint_inner_left]\n\ntheorem orthogonal_range (T : E \u2192L[\ud835\udd5c] F) :\n    (LinearMap.range T)\u15ee = LinearMap.ker (T\u2020) := by\n  rw [\u2190 (LinearMap.ker (T\u2020)).orthogonal_orthogonal, (T\u2020).orthogonal_ker]",
      "suggestion": "\r\ntheorem orthogonal_range (T : E \u2192L[\ud835\udd5c] F) : T.range\u15ee = T\u2020.ker := by\r\n",
      "body": "Same here?\r\n```suggestion\r\ntheorem orthogonal_range (T : E \u2192L[\ud835\udd5c] F) : T.range\u15ee = T\u2020.ker := by\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Adjoint.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "rw",
          "simp_all",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "rw",
          "refine",
          "simp_all",
          "simp"
        ],
        "topics": [
          "set_theory",
          "algebra",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "adjoint_subtypeL",
          "ext_inner_left",
          "orthogonal_le",
          "adjoint_adjoint",
          "le_antisymm",
          "topologicalClosure",
          "rintro",
          "orthogonal_orthogonal_eq_closure",
          "orthogonal_ker",
          "simp_all",
          "apply",
          "refine",
          "LinearMap",
          "all_goals",
          "Submodule",
          "ker",
          "range",
          "simp",
          "orthogonal_range",
          "mem_range_self",
          "rfl",
          "theorem",
          "adjoint_inner_left",
          "orthogonal_orthogonal"
        ]
      }
    },
    {
      "id": 4457,
      "before_code": "This is a version of `LinearMap.submoduleMap` extended to linear isometries. -/\n@[simps!]\ndef submoduleMap (p : Submodule R M) (e : M \u2192\u2097\u1d62[R] M\u2081) :\n    p \u2192\u2097\u1d62[R] (Submodule.map e p) :=",
      "suggestion": "\r\n    p \u2192\u2097\u1d62[R] p.map (e : M \u2192\u2097[R] M\u2081) :=\r\n",
      "body": "```suggestion\r\n    p \u2192\u2097\u1d62[R] p.map (e : M \u2192\u2097[R] M\u2081) :=\r\n```",
      "path": "Mathlib/Analysis/Normed/Operator/LinearIsometry.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "extended",
          "This",
          "LinearMap",
          "def",
          "version",
          "simps",
          "map",
          "Submodule",
          "isometries",
          "submoduleMap",
          "linear"
        ]
      }
    },
    {
      "id": 4458,
      "before_code": "This is a version of `LinearEquiv.submoduleMap` extended to linear isometry equivalences. -/\n@[simps!]\ndef submoduleMap (p : Submodule R M) (e : M \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] M\u2082) :\n    p \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] (Submodule.map e p) :=",
      "suggestion": "\r\n    p \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] p.map (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :=\r\n",
      "body": "```suggestion\r\n    p \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] p.map (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :=\r\n```",
      "path": "Mathlib/Analysis/Normed/Operator/LinearIsometry.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "extended",
          "This",
          "def",
          "version",
          "LinearEquiv",
          "simps",
          "map",
          "Submodule",
          "equivalences",
          "isometry",
          "submoduleMap",
          "linear"
        ]
      }
    },
    {
      "id": 4459,
      "before_code": "both `range f` and `ker f` are invariant under `T`. -/\nlemma IsIdempotentElem.commute_iff {f T : M \u2192L[R] M}\n    (hf : IsIdempotentElem f) :\n    Commute f T \u2194 (LinearMap.range f \u2208 Module.End.invtSubmodule T\n      \u2227 LinearMap.ker f \u2208 Module.End.invtSubmodule T) := by",
      "suggestion": "\r\n    Commute f T \u2194 f.range \u2208 Module.End.invtSubmodule T \u2227 f.ker \u2208 Module.End.invtSubmodule T := by\r\n",
      "body": "```suggestion\r\n    Commute f T \u2194 f.range \u2208 Module.End.invtSubmodule T \u2227 f.ker \u2208 Module.End.invtSubmodule T := by\r\n```",
      "path": "Mathlib/Topology/Algebra/Module/LinearMap.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "range",
          "lemma",
          "LinearMap",
          "IsIdempotentElem",
          "invariant",
          "both",
          "under",
          "invtSubmodule",
          "End",
          "commute_iff",
          "are",
          "Commute",
          "ker"
        ]
      }
    },
    {
      "id": 4460,
      "before_code": "theorem isNoetherianRing_iff_ideal_fg (R : Type*) [Semiring R] :\n    IsNoetherianRing R \u2194 \u2200 I : Ideal R, I.FG :=\n  isNoetherianRing_iff.trans isNoetherian_def",
      "suggestion": "\r\n  IsNoetherian.noetherian _\r\n",
      "body": "```suggestion\r\n  IsNoetherian.noetherian _\r\n```\r\n(not tested)",
      "path": "Mathlib/RingTheory/Noetherian/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Ideal",
          "theorem",
          "isNoetherianRing_iff_ideal_fg",
          "Type",
          "Semiring",
          "isNoetherian_def",
          "trans",
          "isNoetherianRing_iff",
          "IsNoetherianRing"
        ]
      }
    },
    {
      "id": 4461,
      "before_code": "rw [ShortComplex.ab_exact_iff] at this\n  exact this x\u2083 hx\u2083",
      "suggestion": "    Mono (AddCommGrpCat.ofHom <| (Ext.mk\u2080 f).postcomp L (add_zero 0)) :=\n",
      "body": "```suggestion\n    Mono (AddCommGrpCat.ofHom <| (Ext.mk\u2080 f).postcomp L (add_zero 0)) :=\n```",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ShortComplex",
          "exact",
          "this",
          "ab_exact_iff"
        ]
      }
    },
    {
      "id": 4462,
      "before_code": "rw [ShortComplex.ab_exact_iff] at this\n  exact this x\u2083 hx\u2083",
      "suggestion": "    Mono (AddCommGrpCat.ofHom <| (Ext.mk\u2080 g).precomp L (zero_add 0)) :=\n",
      "body": "```suggestion\n    Mono (AddCommGrpCat.ofHom <| (Ext.mk\u2080 g).precomp L (zero_add 0)) :=\n```",
      "path": "Mathlib/Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [
          "ext"
        ],
        "body_tactics": [
          "ext"
        ],
        "new_tactics": [
          "ext"
        ],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ShortComplex",
          "exact",
          "this",
          "ab_exact_iff"
        ]
      }
    },
    {
      "id": 4463,
      "before_code": "\u00b7 simp only [isLittleO_const_left, Int.cast_eq_zero,\n      tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding Int.isClosedEmbedding_coe_real, or_true]\n\nlemma linear_inv_isBigO_right (c : \u2124) (z : \u2102) :\n    (fun (d : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_right c z).inv.isBigO\n\nlemma linear_inv_isBigO_left (d : \u2124) {z : \u2102} (hz : z \u2260 0) :\n    (fun (c : \u2124) \u21a6 (c * z + d)\u207b\u00b9) =O[cofinite] fun n \u21a6 (n : \u211d)\u207b\u00b9 :=\n  (linear_isTheta_left d hz).inv.isBigO",
      "suggestion": "\r\n  grind [neg_zero, (tendsto_zero_inv_linear z (-b)).neg]\r\n",
      "body": "```suggestion\r\n  grind [neg_zero, (tendsto_zero_inv_linear z (-b)).neg]\r\n```\r\n(\"grind\" seems to be good when there are several distinct kinds of automation that need to be used together)",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "list",
          "real",
          "complex",
          "norm",
          "topology",
          "int"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "isBigO",
          "cast_eq_zero",
          "lemma",
          "tendsto_norm_comp_cofinite_atTop_of_isClosedEmbedding",
          "linear_isTheta_right",
          "Int",
          "linear_inv_isBigO_left",
          "or_true",
          "inv",
          "linear_isTheta_left",
          "simp",
          "cofinite",
          "isClosedEmbedding_coe_real",
          "isLittleO_const_left",
          "only",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 4464,
      "before_code": "Summable fun n : \u2124 \u21a6 ((c\u2081 * z - n) * (c\u2082 * z + n))\u207b\u00b9 := by\n  apply summable_inv_of_isBigO_rpow_inv (a := 2) (by norm_cast)\n  simp only [Real.rpow_two, abs_mul_abs_self, pow_two]\n  simpa [sub_eq_add_neg] using (linear_inv_isBigO_right c\u2082 z).mul\n    (linear_inv_isBigO_right c\u2081 z).comp_neg_int",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/Summable.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "apply",
          "simp",
          "norm_cast"
        ],
        "topics": [
          "norm",
          "real",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "only",
          "apply",
          "pow_two",
          "Real",
          "norm_cast",
          "abs_mul_abs_self",
          "simpa",
          "Summable",
          "simp",
          "summable_inv_of_isBigO_rpow_inv",
          "sub_eq_add_neg",
          "using",
          "mul",
          "comp_neg_int",
          "rpow_two",
          "linear_inv_isBigO_right"
        ]
      }
    },
    {
      "id": 4465,
      "before_code": "-/\nmodule\n\npublic import Mathlib.Analysis.SpecificLimits.Normed\npublic import Mathlib.NumberTheory.ArithmeticFunction.Misc",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/NumberTheory/TsumDivisorsAntidiagonal.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "import",
          "Mathlib",
          "public",
          "Normed",
          "ArithmeticFunction",
          "SpecificLimits",
          "module",
          "Misc",
          "NumberTheory",
          "Analysis"
        ]
      }
    },
    {
      "id": 4466,
      "before_code": "norm_mul_self_le x := le_of_eq <| Eq.symm <| norm_adjoint_comp_self x\n\ntheorem isAdjointPair_inner (A : E \u2192L[\ud835\udd5c] F) :\n    LinearMap.IsAdjointPair (sesqFormOfInner : E \u2192\u2097[\ud835\udd5c] E \u2192\u2097\u22c6[\ud835\udd5c] \ud835\udd5c)\n      (sesqFormOfInner : F \u2192\u2097[\ud835\udd5c] F \u2192\u2097\u22c6[\ud835\udd5c] \ud835\udd5c) A (A\u2020) := by",
      "suggestion": "\r\n      (inner\u209b\u2097 \ud835\udd5c (E := F)).flip A (A\u2020) := by\r\n",
      "body": "```suggestion\r\n      (inner\u209b\u2097 \ud835\udd5c (E := F)).flip A (A\u2020) := by\r\n```\r\nuntestet",
      "path": "Mathlib/Analysis/InnerProductSpace/Adjoint.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "sesqFormOfInner",
          "norm_mul_self_le",
          "symm",
          "LinearMap",
          "theorem",
          "le_of_eq",
          "norm_adjoint_comp_self",
          "IsAdjointPair",
          "isAdjointPair_inner"
        ]
      }
    },
    {
      "id": 4467,
      "before_code": "theorem inner_smul_real_right (x y : E) (r : \u211d) : \u27eax, (r : \ud835\udd5c) \u2022 y\u27eb = r \u2022 \u27eax, y\u27eb := by\n  rw [inner_smul_right, Algebra.smul_def]\n\n/-- The inner product as a sesquilinear form.\n\nNote that in the case `\ud835\udd5c = \u211d` this is a bilinear form. -/\n@[simps!]\ndef sesqFormOfInner : E \u2192\u2097[\ud835\udd5c] E \u2192\u2097\u22c6[\ud835\udd5c] \ud835\udd5c :=\n  LinearMap.mk\u2082'\u209b\u2097 (RingHom.id \ud835\udd5c) (starRingEnd _) (fun x y => \u27eay, x\u27eb)\n    (fun _x _y _z => inner_add_right _ _ _) (fun _r _x _y => inner_smul_right _ _ _)\n    (fun _x _y _z => inner_add_left _ _ _) fun _r _x _y => inner_smul_left _ _ _\n\n/-- The real inner product as a bilinear form.\n\nNote that unlike `sesqFormOfInner`, this does not reverse the order of the arguments. -/\n@[simps!]\ndef bilinFormOfRealInner : BilinForm \u211d F := sesqFormOfInner.flip\n\n/-- An inner product with a sum on the left. -/\ntheorem sum_inner {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 E) (x : E) :\n    \u27ea\u2211 i \u2208 s, f i, x\u27eb = \u2211 i \u2208 s, \u27eaf i, x\u27eb :=\n  map_sum (sesqFormOfInner (\ud835\udd5c := \ud835\udd5c) (E := E) x) _ _",
      "suggestion": "\r\n  map_sum ((inner\u209b\u2097 \ud835\udd5c).flip x) _ _\r\n",
      "body": "```suggestion\r\n  map_sum ((inner\u209b\u2097 \ud835\udd5c).flip x) _ _\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw"
        ],
        "topics": [
          "real",
          "finset",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "sesqFormOfInner",
          "real",
          "Type",
          "inner_add_right",
          "form",
          "inner_add_left",
          "LinearMap",
          "sesquilinear",
          "inner_smul_left",
          "Finset",
          "Note",
          "does",
          "flip",
          "case",
          "RingHom",
          "sum",
          "inner_smul_right",
          "bilinear",
          "arguments",
          "product",
          "inner_smul_real_right",
          "BilinForm",
          "def",
          "reverse",
          "simps",
          "that",
          "bilinFormOfRealInner",
          "theorem",
          "starRingEnd",
          "map_sum",
          "smul_def",
          "left",
          "this",
          "sum_inner",
          "inner",
          "order",
          "unlike",
          "Algebra"
        ]
      }
    },
    {
      "id": 4468,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "theorem integrableOn_theta_div_id_mul_log_sq (x : \u211d) :\n",
      "body": "```suggestion\ntheorem integrableOn_theta_div_id_mul_log_sq (x : \u211d) :\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 4469,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "    \u222b x in a..b, 1 / log x  ^ 2 \u2264 (b - a) / log a ^ 2 := by\n",
      "body": "```suggestion\n    \u222b x in a..b, 1 / log x  ^ 2 \u2264 (b - a) / log a ^ 2 := by\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 4470,
      "before_code": "\u00b7 simp [h, vonMangoldt_apply_prime]\n  \u00b7 simp",
      "suggestion": "    \u222b x in a..b, 1 / log x ^ 2 \u2264 (b - a) / log a ^ 2 := by\n",
      "body": "```suggestion\n    \u222b x in a..b, 1 / log x ^ 2 \u2264 (b - a) / log a ^ 2 := by\n```",
      "path": "Mathlib/NumberTheory/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "vonMangoldt_apply_prime",
          "simp"
        ]
      }
    },
    {
      "id": 4471,
      "before_code": "`(PreservesLimit.preserves t).lift (G.mapCone c\u2082) = G.map (t.lift c\u2082)`.\n\nThe duals of these are also given. For functors which preserve (co)limits of specific shapes, see\n`preserves/shapes.lean`.",
      "suggestion": "the files in the directory `Mathlib/CategoryTheory/Limits/Preserves/Shapes/`.\n",
      "body": "```suggestion\nthe files in the directory `Mathlib/CategoryTheory/Limits/Preserves/Shapes/`.\n```",
      "path": "Mathlib/CategoryTheory/Limits/Preserves/Limits.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "preserves",
          "limits",
          "which",
          "lean",
          "these",
          "lift",
          "mapCone",
          "specific",
          "For",
          "map",
          "are",
          "shapes",
          "see",
          "also",
          "PreservesLimit",
          "preserve",
          "given",
          "functors",
          "duals"
        ]
      }
    },
    {
      "id": 4472,
      "before_code": "\u220f' i, (1 + f i) = \u2211' s, \u220f i \u2208 s, f i :=\n  HasProd.tprod_eq <| hasProd_one_add_of_hasSum_prod h.hasSum",
      "suggestion": "\r\ntheorem tprod_one_add_ordered [ContinuousAdd \u03b1]\r\n",
      "body": "```suggestion\r\ntheorem tprod_one_add_ordered [ContinuousAdd \u03b1]\r\n```",
      "path": "Mathlib/Topology/Algebra/InfiniteSum/Ring.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "HasProd",
          "tprod_eq",
          "hasProd_one_add_of_hasSum_prod",
          "hasSum"
        ]
      }
    },
    {
      "id": 4479,
      "before_code": "(fun i j Z gi gj \u21a6 hx gi gj (ofArrows.mk _) (ofArrows.mk _))\n    exact \u27e8t, fun Y f \u27e8i\u27e9 \u21a6 hA i, fun y hy \u21a6 ht y (fun i \u21a6 hy (\u03c0 i) (ofArrows.mk _))\u27e9",
      "suggestion": "of morphisms, this is the map from `P.obj (op B)` to the subtype of compatible\n",
      "body": "```suggestion\nof morphisms, this is the map from `P.obj (op B)` to the subtype of compatible\n```",
      "path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "ofArrows"
        ]
      }
    },
    {
      "id": 4480,
      "before_code": "obtain \u27e8g, hg\u27e9 := exists_fundamental_sequence a.cof.ord\n  exact ord_injective (hf.trans hg).cof_eq.symm\n\nprotected theorem IsNormal.isFundamentalSequence {f : Ordinal.{u} \u2192 Ordinal.{u}} (hf : IsNormal f)",
      "suggestion": "\r\ntheorem isFundamentalSequence.of_isNormal {f : Ordinal.{u} \u2192 Ordinal.{u}} (hf : IsNormal f)\r\n",
      "body": "```suggestion\r\ntheorem isFundamentalSequence.of_isNormal {f : Ordinal.{u} \u2192 Ordinal.{u}} (hf : IsNormal f)\r\n```",
      "path": "Mathlib/SetTheory/Cardinal/Cofinality.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain"
        ],
        "topics": [
          "function",
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "cof_eq",
          "symm",
          "ord",
          "theorem",
          "IsNormal",
          "exact",
          "Ordinal",
          "protected",
          "obtain",
          "exists_fundamental_sequence",
          "cof",
          "trans",
          "isFundamentalSequence",
          "ord_injective"
        ]
      }
    },
    {
      "id": 4481,
      "before_code": "have Hs := enumOrd_strictMono hs\n  refine\n    \u27e8fun h => isClosed_iff_iSup.2 fun {\u03b9} h\u03b9 f hf => ?_, fun h =>\n      (isNormal_iff_strictMono_limit _).2 \u27e8Hs, fun a ha o H => ?_\u27e9\u27e9\n  \u00b7 let g : \u03b9 \u2192 Ordinal.{u} := fun i => (enumOrdOrderIso s hs).symm \u27e8_, hf i\u27e9\n    suffices enumOrd s (\u2a06 i, g i) = \u2a06 i, f i by\n      rw [\u2190 this]\n      exact enumOrd_mem hs _\n    rw [IsNormal.map_iSup h g]",
      "suggestion": "\r\n    rw [h.map_iSup (bddAbove_of_small _)]\r\n",
      "body": "```suggestion\r\n    rw [h.map_iSup (bddAbove_of_small _)]\r\n```\r\nno?",
      "path": "Mathlib/SetTheory/Ordinal/Topology.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "refine",
          "rw",
          "have"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "have",
          "refine"
        ],
        "topics": [
          "norm",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "enumOrdOrderIso",
          "symm",
          "enumOrd_strictMono",
          "refine",
          "enumOrd_mem",
          "IsNormal",
          "exact",
          "Ordinal",
          "isNormal_iff_strictMono_limit",
          "suffices",
          "have",
          "this",
          "isClosed_iff_iSup",
          "enumOrd",
          "map_iSup"
        ]
      }
    },
    {
      "id": 4482,
      "before_code": "universe uK uV\nvariable {K : Type uK} {V : Type uV}",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/LinearAlgebra/Dual/Lemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "universe",
          "Type",
          "variable"
        ]
      }
    },
    {
      "id": 4483,
      "before_code": "/-- In a category `C` equipped with a shift by an additive monoid,\nthis is the type of morphisms `X \u27f6 (Y\u27e6n\u27e7)` for `m : M`. -/\ndef ShiftedHom (X Y : C) (m : M) : Type _ := X \u27f6 (Y\u27e6m\u27e7)\n\ninstance [Preadditive C] (X Y : C) (n : M) : AddCommGroup (ShiftedHom X Y n) :=\n  inferInstanceAs (AddCommGroup (_ \u27f6 _))",
      "suggestion": "abbrev ShiftedHom (X Y : C) (m : M) : Type _ := X \u27f6 Y\u27e6m\u27e7\n",
      "body": "```suggestion\nabbrev ShiftedHom (X Y : C) (m : M) : Type _ := X \u27f6 Y\u27e6m\u27e7\n```",
      "path": "Mathlib/CategoryTheory/Shift/ShiftedHom.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "shift",
          "additive",
          "Preadditive",
          "morphisms",
          "def",
          "category",
          "Type",
          "inferInstanceAs",
          "this",
          "ShiftedHom",
          "AddCommGroup",
          "equipped",
          "monoid",
          "type",
          "instance",
          "for"
        ]
      }
    },
    {
      "id": 4485,
      "before_code": "-FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=\n  rfl",
      "suggestion": "\r\ntheorem mk_add_mk {x y : K} (hx : 0 \u2264 mk x) (hy : 0 \u2264 mk y) :\r\n",
      "body": "```suggestion\r\ntheorem mk_add_mk {x y : K} (hx : 0 \u2264 mk x) (hy : 0 \u2264 mk y) :\r\n```\r\nSame below",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "mk_neg",
          "rwa",
          "FiniteElement"
        ]
      }
    },
    {
      "id": 4486,
      "before_code": "-FiniteElement.mk x h = FiniteElement.mk (-x) (by rwa [mk_neg]) :=\n  rfl",
      "suggestion": "\r\ntheorem mk_lt_mk_iff {x y : K} (hx hy) :\r\n",
      "body": "I would make those explicit for backwards rewriting:\r\n```suggestion\r\ntheorem mk_lt_mk_iff {x y : K} (hx hy) :\r\n```",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "rfl",
          "mk_neg",
          "rwa",
          "FiniteElement"
        ]
      }
    },
    {
      "id": 4487,
      "before_code": "\u00b7 rw [stdPart_of_mk_ne_zero hx, stdPart_of_mk_ne_zero, inv_zero]\n    rwa [mk_inv, neg_ne_zero]\n\ntheorem stdPart_add (hx : 0 \u2264 mk x) (hy : 0 \u2264 mk y) :\n    stdPart (x + y) = stdPart x + stdPart y := by\n  unfold stdPart\n  rw [dif_pos hx, dif_pos hy, dif_pos]\n  exact map_add _ (FiniteElement.mk x hx) (.mk y hy)\n\ntheorem stdPart_sub (hx : 0 \u2264 mk x) (hy : 0 \u2264 mk y) :\n    stdPart (x - y) = stdPart x - stdPart y := by",
      "suggestion": "\r\ntheorem stdPart_add_of_mk_pos_right (hy : 0 < mk y) : stdPart (x + y) = stdPart x := by\r\n",
      "body": "```suggestion\r\ntheorem stdPart_add_of_mk_pos_right (hy : 0 < mk y) : stdPart (x + y) = stdPart x := by\r\n```\r\nor\r\n```suggestion\r\ntheorem stdPart_add_eq_left (hy : 0 < mk y) : stdPart (x + y) = stdPart x := by\r\n```\r\nSame above",
      "path": "Mathlib/Algebra/Order/Ring/StandardPart.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "unfold",
          "mk_inv",
          "rwa",
          "stdPart",
          "FiniteElement",
          "theorem",
          "neg_ne_zero",
          "stdPart_sub",
          "exact",
          "dif_pos",
          "map_add",
          "inv_zero",
          "stdPart_of_mk_ne_zero",
          "stdPart_add"
        ]
      }
    },
    {
      "id": 4488,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "theorem ordProj_self_pow {p k : \u2115} (hp : Prime p) : ordProj[p] (p ^ k) = p ^ k := by\n",
      "body": "```suggestion\ntheorem ordProj_self_pow {p k : \u2115} (hp : Prime p) : ordProj[p] (p ^ k) = p ^ k := by\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 4489,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "theorem ordCompl_self_pow {p k : \u2115} (hp : Prime p) : ordCompl[p] (p ^ k) = 1 := by\n",
      "body": "```suggestion\ntheorem ordCompl_self_pow {p k : \u2115} (hp : Prime p) : ordCompl[p] (p ^ k) = 1 := by\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 4490,
      "before_code": "\u00b7 rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]",
      "suggestion": "theorem ordCompl_self_pow_mul (n k : \u2115) {p : \u2115} (hp : Prime p) :\n",
      "body": "```suggestion\ntheorem ordCompl_self_pow_mul (n k : \u2115) {p : \u2115} (hp : Prime p) :\n```",
      "path": "Mathlib/Data/Nat/Factorization/Basic.lean",
      "tags": {
        "before_tactics": [
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "rw",
          "simp"
        ],
        "topics": [
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Finsupp",
          "factorization",
          "symm",
          "ordProj_dvd",
          "hqp",
          "factorization_div",
          "erase_ne",
          "simp"
        ]
      }
    },
    {
      "id": 4491,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "theorem Dense.upperBounds_image {\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]\n",
      "body": "```suggestion\ntheorem Dense.upperBounds_image {\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 4492,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "theorem Dense.lowerBounds_image {\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]\n",
      "body": "```suggestion\ntheorem Dense.lowerBounds_image {\u03b1 : Type*} [TopologicalSpace \u03b1] [Preorder \u03b1]\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 4493,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "theorem Dense.ciSup {\u03b1 : Type*} [TopologicalSpace \u03b1]\n",
      "body": "```suggestion\ntheorem Dense.ciSup {\u03b1 : Type*} [TopologicalSpace \u03b1]\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 4494,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "theorem Dense.ciInf {\u03b1 : Type*} [TopologicalSpace \u03b1]\n",
      "body": "```suggestion\ntheorem Dense.ciInf {\u03b1 : Type*} [TopologicalSpace \u03b1]\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 4495,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "    \u2a05 i, f i = \u2a05 s : S, f s :=\n  hS.ciSup (\u03b1 := \u03b1\u1d52\u1d48) hf h\n",
      "body": "```suggestion\n    \u2a05 i, f i = \u2a05 s : S, f s :=\n  hS.ciSup (\u03b1 := \u03b1\u1d52\u1d48) hf h\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 4496,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "theorem Dense.ciSup' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n",
      "body": "```suggestion\ntheorem Dense.ciSup' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 4497,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "theorem Dense.ciInf' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n",
      "body": "```suggestion\ntheorem Dense.ciInf' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 4498,
      "before_code": "IsGLB (t \u2229 s) x \u2194 IsGLB t x :=\n  hs.isLUB_inter_iff (\u03b1 := \u03b1\u1d52\u1d48) ht",
      "suggestion": "    \u2a05 i, f i = \u2a05 s : S, f s :=\n  hS.ciSup' (\u03b1 := \u03b1\u1d52\u1d48) hf\n",
      "body": "```suggestion\n    \u2a05 i, f i = \u2a05 s : S, f s :=\n  hS.ciSup' (\u03b1 := \u03b1\u1d52\u1d48) hf\n```",
      "path": "Mathlib/Topology/Order/IsLUB.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "IsGLB",
          "isLUB_inter_iff"
        ]
      }
    },
    {
      "id": 4502,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    Metric.diam (toEuclidean '' (Euclidean.closedBall x r)) = 2 * r := by\r\n",
      "body": "```suggestion\r\n    Metric.diam (toEuclidean '' (Euclidean.closedBall x r)) = 2 * r := by\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 4503,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\n    Metric.diam (Metric.closedBall (toEuclidean x) r) = 2 * r := by\r\n",
      "body": "```suggestion\r\n    Metric.diam (Metric.closedBall (toEuclidean x) r) = 2 * r := by\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 4504,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\ntheorem diam_closedBall_eq_two_mul_radius [Nontrivial G] (x : G) {r : \u211d} (hr : 0 \u2264 r) :\r\n",
      "body": "```suggestion\r\ntheorem diam_closedBall_eq_two_mul_radius [Nontrivial G] (x : G) {r : \u211d} (hr : 0 \u2264 r) :\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 4505,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\ntheorem diam_ball_eq_two_mul_radius [Nontrivial G] (x : G) {r : \u211d} (hr : 0 \u2264 r) :\r\n",
      "body": "```suggestion\r\ntheorem diam_ball_eq_two_mul_radius [Nontrivial G] (x : G) {r : \u211d} (hr : 0 \u2264 r) :\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 4506,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\ntheorem Metric.diam_image_euclideanClosedBall [Nontrivial G] (x : G) {r : \u211d} (hr : 0 \u2264 r) :\r\n    diam (toEuclidean '' Euclidean.closedBall x r) = 2 * r := by\r\n",
      "body": "```suggestion\r\ntheorem Metric.diam_image_euclideanClosedBall [Nontrivial G] (x : G) {r : \u211d} (hr : 0 \u2264 r) :\r\n    diam (toEuclidean '' Euclidean.closedBall x r) = 2 * r := by\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 4507,
      "before_code": "apply ContDiff.dist \u211d\n  exacts [(toEuclidean (E := G)).contDiff.comp hf,\n    (toEuclidean (E := G)).contDiff.comp hg, fun x => toEuclidean.injective.ne (h x)]",
      "suggestion": "\r\ntheorem Metric.diam_image_euclideanBall [Nontrivial G] (x : G) {r : \u211d} (hr : 0 \u2264 r) :\r\n    diam (toEuclidean '' Euclidean.ball x r) = 2 * r := by\r\n",
      "body": "```suggestion\r\ntheorem Metric.diam_image_euclideanBall [Nontrivial G] (x : G) {r : \u211d} (hr : 0 \u2264 r) :\r\n    diam (toEuclidean '' Euclidean.ball x r) = 2 * r := by\r\n```",
      "path": "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean",
      "tags": {
        "before_tactics": [
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply"
        ],
        "topics": [
          "continuity",
          "real",
          "function"
        ],
        "transforms": [],
        "keywords": [
          "apply",
          "ContDiff",
          "dist",
          "contDiff",
          "comp",
          "toEuclidean",
          "injective",
          "exacts"
        ]
      }
    },
    {
      "id": 4508,
      "before_code": "Int.norm_eq_abs, mul_lt_iff_lt_one_left (norm_pos_iff.mpr he), \u2190 @Int.cast_one \u211d _,\n      \u2190 Int.cast_abs, Int.cast_lt, Int.abs_lt_one_iff, smul_eq_zero, or_iff_left he]",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Analysis/Normed/Module/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "real",
          "order",
          "int"
        ],
        "transforms": [],
        "keywords": [
          "or_iff_left",
          "cast_abs",
          "mpr",
          "Int",
          "cast_lt",
          "norm_pos_iff",
          "norm_eq_abs",
          "abs_lt_one_iff",
          "smul_eq_zero",
          "mul_lt_iff_lt_one_left",
          "cast_one"
        ]
      }
    },
    {
      "id": 4509,
      "before_code": "end Filter\n\nend SeminormedAddCommGroup",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Analysis/Normed/Module/Convex.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Filter",
          "end",
          "SeminormedAddCommGroup"
        ]
      }
    },
    {
      "id": 4510,
      "before_code": "# so we explicitly check Batteries as well here.\n          lake env lean4checker/.lake/build/bin/lean4checker Batteries Mathlib",
      "suggestion": "\r\n          echo \"outcome=${OUTCOME}\" | tee -a \"$GITHUB_OUTPUT\"\r\n          echo \"lean4checker_url=${LEAN4CHECKER_URL}\" | tee -a \"$GITHUB_OUTPUT\"\r\n",
      "body": "```suggestion\r\n          echo \"outcome=${OUTCOME}\" | tee -a \"$GITHUB_OUTPUT\"\r\n          echo \"lean4checker_url=${LEAN4CHECKER_URL}\" | tee -a \"$GITHUB_OUTPUT\"\r\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "explicitly",
          "lake",
          "Mathlib",
          "here",
          "well",
          "Batteries",
          "env",
          "build",
          "lean4checker",
          "check",
          "bin"
        ]
      }
    },
    {
      "id": 4511,
      "before_code": "# so we explicitly check Batteries as well here.\n          lake env lean4checker/.lake/build/bin/lean4checker Batteries Mathlib",
      "suggestion": "\r\n          echo \"LATEST_TAG=${LATEST_TAG}\" | tee -a \"$GITHUB_ENV\"\r\n",
      "body": "```suggestion\r\n          echo \"LATEST_TAG=${LATEST_TAG}\" | tee -a \"$GITHUB_ENV\"\r\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "explicitly",
          "lake",
          "Mathlib",
          "here",
          "well",
          "Batteries",
          "env",
          "build",
          "lean4checker",
          "check",
          "bin"
        ]
      }
    },
    {
      "id": 4512,
      "before_code": "use-mathlib-cache: true\n          reinstall-transient-toolchain: true\n\n      - name: Run mathlib_test_executable # make sure this name is consistent with \"Get URLs\"\n        id: mathlib-test\n        continue-on-error: true\n        run: |\n          lake exe mathlib_test_executable",
      "suggestion": "\r\n          echo \"outcome=${OUTCOME}\" | tee -a \"$GITHUB_OUTPUT\"\r\n          echo \"mathlib_test_executable_url=${MATHLIB_TEST_EXECUTABLE_URL}\" | tee -a \"$GITHUB_OUTPUT\"\r\n",
      "body": "```suggestion\r\n          echo \"outcome=${OUTCOME}\" | tee -a \"$GITHUB_OUTPUT\"\r\n          echo \"mathlib_test_executable_url=${MATHLIB_TEST_EXECUTABLE_URL}\" | tee -a \"$GITHUB_OUTPUT\"\r\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "cache",
          "true",
          "run",
          "mathlib_test_executable",
          "make",
          "reinstall",
          "consistent",
          "lake",
          "toolchain",
          "name",
          "continue",
          "exe",
          "sure",
          "test",
          "error",
          "use",
          "transient",
          "Run",
          "this",
          "mathlib",
          "URLs",
          "Get"
        ]
      }
    },
    {
      "id": 4513,
      "before_code": "use-mathlib-cache: true\n          reinstall-transient-toolchain: true\n\n      - name: Run mathlib_test_executable # make sure this name is consistent with \"Get URLs\"\n        id: mathlib-test\n        continue-on-error: true\n        run: |\n          lake exe mathlib_test_executable",
      "suggestion": "\r\n          echo \"LATEST_TAG=${LATEST_TAG}\" | tee -a \"$GITHUB_ENV\"\r\n",
      "body": "```suggestion\r\n          echo \"LATEST_TAG=${LATEST_TAG}\" | tee -a \"$GITHUB_ENV\"\r\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "cache",
          "true",
          "run",
          "mathlib_test_executable",
          "make",
          "reinstall",
          "consistent",
          "lake",
          "toolchain",
          "name",
          "continue",
          "exe",
          "sure",
          "test",
          "error",
          "use",
          "transient",
          "Run",
          "this",
          "mathlib",
          "URLs",
          "Get"
        ]
      }
    },
    {
      "id": 4514,
      "before_code": "# so we explicitly check Batteries as well here.\n          lake env lean4checker/.lake/build/bin/lean4checker Batteries Mathlib\n\n      - name: Post success message for lean4checker on Zulip\n        if: steps.lean4checker.outcome == 'success'",
      "suggestion": "        if: needs.check-lean4checker.result == 'success'\n",
      "body": "```suggestion\n        if: needs.check-lean4checker.result == 'success'\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "explicitly",
          "success",
          "Zulip",
          "Batteries",
          "lean4checker",
          "message",
          "lake",
          "Mathlib",
          "here",
          "name",
          "steps",
          "for",
          "Post",
          "well",
          "env",
          "check",
          "bin",
          "outcome",
          "build"
        ]
      }
    },
    {
      "id": 4515,
      "before_code": "type: 'stream'\n          topic: 'lean4checker'\n          content: |\n            \u2705 lean4checker [succeeded](${{ steps.urls.outputs.lean4checker_url }}) on ${{ github.sha }} (branch: ${{ env.BRANCH_REF }})\n\n      - name: Post failure / cancelled message for lean4checker on Zulip\n        if: steps.lean4checker.outcome == 'failure' || steps.lean4checker.outcome == 'cancelled'",
      "suggestion": "        if: needs.check-lean4checker.result != 'success'\n",
      "body": "```suggestion\n        if: needs.check-lean4checker.result != 'success'\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Zulip",
          "content",
          "github",
          "lean4checker_url",
          "type",
          "lean4checker",
          "succeeded",
          "message",
          "urls",
          "stream",
          "BRANCH_REF",
          "outputs",
          "name",
          "failure",
          "branch",
          "steps",
          "for",
          "Post",
          "sha",
          "cancelled",
          "env",
          "outcome",
          "topic"
        ]
      }
    },
    {
      "id": 4516,
      "before_code": "type: 'stream'\n          topic: 'lean4checker failure'\n          content: |\n            \u274c lean4checker [$${{ steps.lean4checker.outcome }}](${{ steps.urls.outputs.lean4checker_url }}) on ${{ github.sha }} (branch: ${{ env.BRANCH_REF }})",
      "suggestion": "            \u274c lean4checker [${{ needs.check-lean4checker.result }}](${{ steps.get-status.outputs.lean4checker_url }}) on ${{ github.sha }} (branch: ${{ env.BRANCH_REF }})\n",
      "body": "```suggestion\n            \u274c lean4checker [${{ needs.check-lean4checker.result }}](${{ steps.get-status.outputs.lean4checker_url }}) on ${{ github.sha }} (branch: ${{ env.BRANCH_REF }})\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "urls",
          "sha",
          "stream",
          "BRANCH_REF",
          "outputs",
          "content",
          "outcome",
          "lean4checker_url",
          "env",
          "failure",
          "github",
          "type",
          "topic",
          "lean4checker",
          "branch",
          "steps"
        ]
      }
    },
    {
      "id": 4517,
      "before_code": "use-mathlib-cache: true\n          reinstall-transient-toolchain: true\n\n      - name: Run mathlib_test_executable # make sure this name is consistent with \"Get URLs\"\n        id: mathlib-test\n        continue-on-error: true\n        run: |\n          lake exe mathlib_test_executable\n\n      - name: Post success message for mathlib_test_executable on Zulip\n        if: steps.mathlib-test.outcome == 'success'",
      "suggestion": "        if: needs.check-mathlib_test_executable.result == 'success'\n",
      "body": "```suggestion\n        if: needs.check-mathlib_test_executable.result == 'success'\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "success",
          "Zulip",
          "cache",
          "true",
          "run",
          "mathlib_test_executable",
          "make",
          "reinstall",
          "consistent",
          "message",
          "lake",
          "toolchain",
          "name",
          "continue",
          "steps",
          "for",
          "exe",
          "Post",
          "sure",
          "test",
          "error",
          "use",
          "transient",
          "Run",
          "this",
          "outcome",
          "mathlib",
          "URLs",
          "Get"
        ]
      }
    },
    {
      "id": 4518,
      "before_code": "type: 'stream'\n          topic: 'mathlib test executable'\n          content: |\n            \u2705 mathlib_test_executable [succeeded](${{ steps.urls.outputs.mathlib_test_executable_url }}) on ${{ github.sha }} (branch: ${{ env.BRANCH_REF }})\n\n      - name: Post failure / cancelled message for mathlib_test_executable on Zulip\n        if: steps.mathlib-test.outcome == 'failure' || steps.mathlib-test.outcome == 'cancelled'",
      "suggestion": "        if: needs.check-mathlib_test_executable.result != 'success'\n",
      "body": "```suggestion\n        if: needs.check-mathlib_test_executable.result != 'success'\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Zulip",
          "executable",
          "content",
          "mathlib_test_executable",
          "github",
          "type",
          "succeeded",
          "message",
          "urls",
          "stream",
          "BRANCH_REF",
          "outputs",
          "name",
          "failure",
          "branch",
          "steps",
          "for",
          "Post",
          "sha",
          "cancelled",
          "mathlib_test_executable_url",
          "test",
          "env",
          "outcome",
          "mathlib",
          "topic"
        ]
      }
    },
    {
      "id": 4519,
      "before_code": "type: 'stream'\n          topic: 'mathlib test executable failure'\n          content: |\n            \u274c mathlib_test_executable [${{ steps.mathlib-test.outcome }}](${{ steps.urls.outputs.mathlib_test_executable_url }}) on ${{ github.sha }} (branch: ${{ env.BRANCH_REF }})",
      "suggestion": "            \u274c mathlib_test_executable [${{ needs.check-mathlib_test_executable.result }}](${{ steps.get-status.outputs.mathlib_test_executable_url }}) on ${{ github.sha }} (branch: ${{ env.BRANCH_REF }})\n",
      "body": "```suggestion\n            \u274c mathlib_test_executable [${{ needs.check-mathlib_test_executable.result }}](${{ steps.get-status.outputs.mathlib_test_executable_url }}) on ${{ github.sha }} (branch: ${{ env.BRANCH_REF }})\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "executable",
          "content",
          "mathlib_test_executable",
          "github",
          "type",
          "urls",
          "stream",
          "BRANCH_REF",
          "outputs",
          "failure",
          "branch",
          "steps",
          "sha",
          "mathlib_test_executable_url",
          "test",
          "env",
          "outcome",
          "mathlib",
          "topic"
        ]
      }
    },
    {
      "id": 4520,
      "before_code": "# so we explicitly check Batteries as well here.\n          lake env lean4checker/.lake/build/bin/lean4checker Batteries Mathlib",
      "suggestion": "          \n",
      "body": "```suggestion          \n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "explicitly",
          "lake",
          "Mathlib",
          "here",
          "well",
          "Batteries",
          "env",
          "build",
          "lean4checker",
          "check",
          "bin"
        ]
      }
    },
    {
      "id": 4521,
      "before_code": "# so we explicitly check Batteries as well here.\n          lake env lean4checker/.lake/build/bin/lean4checker Batteries Mathlib",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "explicitly",
          "lake",
          "Mathlib",
          "here",
          "well",
          "Batteries",
          "env",
          "build",
          "lean4checker",
          "check",
          "bin"
        ]
      }
    },
    {
      "id": 4522,
      "before_code": "use-mathlib-cache: true\n          reinstall-transient-toolchain: true\n\n      - name: Run mathlib_test_executable # make sure this name is consistent with \"Get URLs\"\n        id: mathlib-test\n        continue-on-error: true\n        run: |\n          lake exe mathlib_test_executable",
      "suggestion": "     \n",
      "body": "```suggestion     \n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "cache",
          "true",
          "run",
          "mathlib_test_executable",
          "make",
          "reinstall",
          "consistent",
          "lake",
          "toolchain",
          "name",
          "continue",
          "exe",
          "sure",
          "test",
          "error",
          "use",
          "transient",
          "Run",
          "this",
          "mathlib",
          "URLs",
          "Get"
        ]
      }
    },
    {
      "id": 4523,
      "before_code": "use-mathlib-cache: true\n          reinstall-transient-toolchain: true\n\n      - name: Run mathlib_test_executable # make sure this name is consistent with \"Get URLs\"\n        id: mathlib-test\n        continue-on-error: true\n        run: |\n          lake exe mathlib_test_executable",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": ".github/workflows/daily.yml",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "cache",
          "true",
          "run",
          "mathlib_test_executable",
          "make",
          "reinstall",
          "consistent",
          "lake",
          "toolchain",
          "name",
          "continue",
          "exe",
          "sure",
          "test",
          "error",
          "use",
          "transient",
          "Run",
          "this",
          "mathlib",
          "URLs",
          "Get"
        ]
      }
    },
    {
      "id": 4524,
      "before_code": "CoeDep (Lp F p \u03bc) f \ud835\udce2'(E, F) where\n  coe := toTemperedDistribution f",
      "suggestion": "theorem toTemperedDistribution_toLp_eq [SecondCountableTopology E] {p : \u211d\u22650\u221e} [hp : Fact (1 \u2264 p)]\n",
      "body": "```suggestion\ntheorem toTemperedDistribution_toLp_eq [SecondCountableTopology E] {p : \u211d\u22650\u221e} [hp : Fact (1 \u2264 p)]\n```",
      "path": "Mathlib/Analysis/Distribution/TemperedDistribution.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "CoeDep",
          "coe",
          "toTemperedDistribution"
        ]
      }
    },
    {
      "id": 4529,
      "before_code": "instance : (J.yoneda).Faithful := (J.yonedaFullyFaithful).faithful",
      "suggestion": "def fullyFaithfulUliftYoneda : (GrothendieckTopology.uliftYoneda.{w} J).FullyFaithful :=\n",
      "body": "```suggestion\ndef fullyFaithfulUliftYoneda : (GrothendieckTopology.uliftYoneda.{w} J).FullyFaithful :=\n```",
      "path": "Mathlib/CategoryTheory/Sites/Canonical.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Faithful",
          "yonedaFullyFaithful",
          "yoneda",
          "instance",
          "faithful"
        ]
      }
    },
    {
      "id": 4530,
      "before_code": "(Hg : g =\u1da0[l] g') : (fun x => h (f x) (g x)) =\u1da0[l] fun x => h (f' x) (g' x) :=\n  (Hf.prodMk Hg).fun_comp (uncurry h)",
      "suggestion": "\r\n-- TODO: can't use `to_additive` and `to_fun` simultaneously?\r\n",
      "body": "```suggestion\r\n-- TODO: can't use `to_additive` and `to_fun` simultaneously?\r\n```",
      "path": "Mathlib/Order/Filter/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "uncurry",
          "fun_comp",
          "prodMk"
        ]
      }
    },
    {
      "id": 4531,
      "before_code": "# Schwartz space\n\nThis file defines the Schwartz space. Usually, the Schwartz space is defined as the set of smooth\nfunctions `f : \u211d^n \u2192 \u2102` such that there exists `C_{\u03b1\u03b2} > 0` with `|x^\u03b1 \u2202^\u03b2 f(x)| < C_{\u03b1\u03b2}` for\nall `x \u2208 \u211d^n` and for all multiindices `\u03b1`, `\u03b2`.",
      "suggestion": "functions $f : \u211d^n \u2192 \u2102$ such that there exists $C_{\u03b1\u03b2} > 0$ with $|x^\u03b1 \u2202^\u03b2 f(x)| < C_{\u03b1\u03b2}$ for\n",
      "body": "```suggestion\nfunctions $f : \u211d^n \u2192 \u2102$ such that there exists $C_{\u03b1\u03b2} > 0$ with $|x^\u03b1 \u2202^\u03b2 f(x)| < C_{\u03b1\u03b2}$ for\n```\nOr was this intentionally meant to be a displaymath formula?\n\nFeel free to reject this one.",
      "path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real",
          "complex"
        ],
        "transforms": [],
        "keywords": [
          "file",
          "Schwartz",
          "This",
          "functions",
          "multiindices",
          "space",
          "Usually",
          "set",
          "that",
          "all",
          "exists",
          "there",
          "defines",
          "smooth",
          "such",
          "defined",
          "for"
        ]
      }
    },
    {
      "id": 4532,
      "before_code": "alias \u27e8_, pow_nthRoot_le\u27e9 := pow_nthRoot_le_iff",
      "suggestion": "    a \u2264 ((a ^ (n + 1) / b ^ n) + n * b) / (n + 1) := by\n",
      "body": "```suggestion\n    a \u2264 ((a ^ (n + 1) / b ^ n) + n * b) / (n + 1) := by\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Pow/NthRootLemmas.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "pow_nthRoot_le",
          "alias",
          "pow_nthRoot_le_iff"
        ]
      }
    },
    {
      "id": 4534,
      "before_code": "\u2203 K, \u2203 t \u2208 \ud835\udcdd x, LipschitzOnWith K f t :=\n  (hf.hasStrictFDerivAt le_rfl).exists_lipschitzOnWith\n\n/-- If `f` is `C^1`, it is locally Lipschitz. -/\nlemma ContDiff.locallyLipschitz {f : E' \u2192 F'} (hf : ContDiff \ud835\udd42 1 f) : LocallyLipschitz f := by\n  intro x\n  rcases hf.contDiffAt.exists_lipschitzOnWith with \u27e8K, t, ht, hf\u27e9\n  use K, t\n\n/-- A `C^1` function with compact support is Lipschitz. -/",
      "suggestion": "    (hn : n \u2260 0) (hs : Convex \u211d s) (hs' : IsCompact s) :\n",
      "body": "As of #33131 we slightly prefer:\n```suggestion\n    (hn : n \u2260 0) (hs : Convex \u211d s) (hs' : IsCompact s) :\n```",
      "path": "Mathlib/Analysis/Calculus/ContDiff/RCLike.lean",
      "tags": {
        "before_tactics": [
          "cases",
          "intro"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "cases",
          "intro"
        ],
        "topics": [
          "continuity",
          "order",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "LipschitzOnWith",
          "ContDiff",
          "lemma",
          "support",
          "le_rfl",
          "function",
          "contDiffAt",
          "locally",
          "compact",
          "locallyLipschitz",
          "rcases",
          "intro",
          "Lipschitz",
          "LocallyLipschitz",
          "hasStrictFDerivAt",
          "use",
          "exists_lipschitzOnWith"
        ]
      }
    },
    {
      "id": 4535,
      "before_code": "instance instCoeTCContinuousLinearMap : CoeTC (E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (E \u2192SL[\u03c3\u2081\u2082] E\u2082) :=\n  \u27e8fun e => \u2191(e : E \u2243SL[\u03c3\u2081\u2082] E\u2082)\u27e9",
      "suggestion": "\r\ndef toContinuousLinearMap (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : E \u2192SL[\u03c3\u2081\u2082] E\u2082 := (e : E \u2192SL[\u03c3\u2081\u2082] E\u2082)\r\n",
      "body": "alternatively,\r\n```suggestion\r\ndef toContinuousLinearMap (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : E \u2192SL[\u03c3\u2081\u2082] E\u2082 := (e : E \u2192SL[\u03c3\u2081\u2082] E\u2082)\r\n```\r\nbut would need more API in other files",
      "path": "Mathlib/Analysis/Normed/Operator/LinearIsometry.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "CoeTC",
          "instCoeTCContinuousLinearMap",
          "instance"
        ]
      }
    },
    {
      "id": 4536,
      "before_code": "/-- Reinterpret a `LinearIsometryEquiv` as a `ContinuousLinearEquiv`. -/\ninstance instCoeTCContinuousLinearEquiv : CoeTC (E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (E \u2243SL[\u03c3\u2081\u2082] E\u2082) :=\n  \u27e8fun e => \u27e8e.toLinearEquiv, e.continuous, e.toIsometryEquiv.symm.continuous\u27e9\u27e9\n\ninstance instCoeTCContinuousLinearMap : CoeTC (E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (E \u2192SL[\u03c3\u2081\u2082] E\u2082) :=\n  \u27e8fun e => \u2191(e : E \u2243SL[\u03c3\u2081\u2082] E\u2082)\u27e9\n\n@[simp]\ntheorem coe_coe : \u21d1(e : E \u2243SL[\u03c3\u2081\u2082] E\u2082) = e :=\n  rfl",
      "suggestion": "theorem toContinuousLinearMap_toLinearIsometry :\n",
      "body": "the `_eq_coe` makes me wonder what the coercion is, and I don't think it's really adding anything. The alternative is spelling out the right-hand side.\n```suggestion\ntheorem toContinuousLinearMap_toLinearIsometry :\n```",
      "path": "Mathlib/Analysis/Normed/Operator/LinearIsometry.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [
          "continuity",
          "set_theory",
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "LinearIsometryEquiv",
          "CoeTC",
          "ContinuousLinearEquiv",
          "symm",
          "theorem",
          "instCoeTCContinuousLinearEquiv",
          "Reinterpret",
          "continuous",
          "coe_coe",
          "instCoeTCContinuousLinearMap",
          "toLinearEquiv",
          "simp",
          "rfl",
          "instance",
          "toIsometryEquiv"
        ]
      }
    },
    {
      "id": 4540,
      "before_code": "export ProperlyDiscontinuousSMul (finite_disjoint_inter_image)\nexport ProperlyDiscontinuousVAdd (finite_disjoint_inter_image)",
      "suggestion": "variable (\u0393 : Type*) {T : Type*}\n  [TopologicalSpace T] [SMul \u0393 T] [ProperlyDiscontinuousSMul \u0393 T] (x : T)\n",
      "body": "The current line generates a shadowed `T`. Admittedly this is harmless but let's change to:\n```suggestion\nvariable (\u0393 : Type*) {T : Type*}\n  [TopologicalSpace T] [SMul \u0393 T] [ProperlyDiscontinuousSMul \u0393 T] (x : T)\n```",
      "path": "Mathlib/Topology/Algebra/ConstMulAction.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "ProperlyDiscontinuousSMul",
          "ProperlyDiscontinuousVAdd",
          "finite_disjoint_inter_image",
          "export"
        ]
      }
    },
    {
      "id": 4541,
      "before_code": "end DescentData\n\n/-- The functor `F.obj (.mk (op S)) \u2964 F.DescentData f`. -/\ndef toDescentData : F.obj (.mk (op S)) \u2964 F.DescentData f where\n  obj M := .ofObj M\n  map {M M'} \u03c6 := { hom i := (F.map (f i).op.toLoc).map \u03c6 }",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/CategoryTheory/Sites/Descent/DescentData.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ofObj",
          "hom",
          "end",
          "def",
          "functor",
          "toDescentData",
          "map",
          "DescentData",
          "toLoc",
          "obj"
        ]
      }
    },
    {
      "id": 4542,
      "before_code": "end DescentData\n\n/-- The functor `F.obj (.mk (op S)) \u2964 F.DescentData f`. -/\ndef toDescentData : F.obj (.mk (op S)) \u2964 F.DescentData f where\n  obj M := .ofObj M\n  map {M M'} \u03c6 := { hom i := (F.map (f i).op.toLoc).map \u03c6 }",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/CategoryTheory/Sites/Descent/DescentData.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "ofObj",
          "hom",
          "end",
          "def",
          "functor",
          "toDescentData",
          "map",
          "DescentData",
          "toLoc",
          "obj"
        ]
      }
    },
    {
      "id": 4543,
      "before_code": "* When `f : Module.Dual R V` and `v : V`,\n  `LinearMap.transvection f v` is the linear map given by `x \u21a6 x + f x \u2022 v`,",
      "suggestion": "",
      "body": "This is now waiting till the next PR I think\n```suggestion\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "When",
          "Module",
          "LinearMap",
          "transvection",
          "map",
          "given",
          "Dual",
          "linear"
        ]
      }
    },
    {
      "id": 4544,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "",
      "body": "I don't think you use this:\n```suggestion\n```\n(it would be available via [nontrivial_of_invariantBasisNumber](https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/InvariantBasisNumber.html#nontrivial_of_invariantBasisNumber) if you did btw)",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 4545,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "open Module in\ntheorem eq_id_of_finrank_le_one [Free R V] [Module.Finite R V] [StrongRankCondition R]\n    {f : Dual R V} {v : V}\n    (hfv : f v = 0) (h1 : finrank R V \u2264 1) :\n",
      "body": "```suggestion\nopen Module in\ntheorem eq_id_of_finrank_le_one [Free R V] [Module.Finite R V] [StrongRankCondition R]\n    {f : Dual R V} {v : V}\n    (hfv : f v = 0) (h1 : finrank R V \u2264 1) :\n```\nand then we can drop many `Module.` in the proof",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 4546,
      "before_code": "ext\n  simp [transvection]",
      "suggestion": "    grind\n",
      "body": "```suggestion\n    grind\n```",
      "path": "Mathlib/LinearAlgebra/Transvection.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "transvection",
          "simp",
          "ext"
        ]
      }
    },
    {
      "id": 4553,
      "before_code": "whenPPOption getPPNotation <| withOverApp 5 do\n  let #[_, _, _, _, f] := (\u2190 getExpr).getAppArgs | failure\n  guard f.isLambda\n  let ppDomain \u2190 getPPOption getPPFunBinderTypes",
      "suggestion": "\r\n  let ppDomain \u2190 withAppArg <| getPPOption getPPFunBinderTypes\r\n",
      "body": "I think this is the same as\r\n```suggestion\r\n  let ppDomain \u2190 withAppArg <| getPPOption getPPFunBinderTypes\r\n```",
      "path": "Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "getPPFunBinderTypes",
          "ppDomain",
          "whenPPOption",
          "getAppArgs",
          "guard",
          "getExpr",
          "isLambda",
          "failure",
          "getPPOption",
          "getPPNotation",
          "withOverApp"
        ]
      }
    },
    {
      "id": 4554,
      "before_code": "end Map",
      "suggestion": "\r\n coefficients of `p`, return the corresponding multivariate formal power series\r\n",
      "body": "```suggestion\r\n coefficients of `p`, return the corresponding multivariate formal power series\r\n```",
      "path": "Mathlib/RingTheory/MvPowerSeries/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Map",
          "end"
        ]
      }
    },
    {
      "id": 4555,
      "before_code": "end Semiring",
      "suggestion": "\r\n coefficients of `p`, return the corresponding formal power series\r\n",
      "body": "```suggestion\r\n coefficients of `p`, return the corresponding formal power series\r\n```",
      "path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end",
          "Semiring"
        ]
      }
    },
    {
      "id": 4558,
      "before_code": "\u00b7 exact hpn.symm\n  simpa [\u2190 ZMod.intCast_eq_intCast_iff] using ZMod.pow_card_sub_one_eq_one this",
      "suggestion": "\r\ntheorem Int.prime_dvd_pow_self_sub {p : \u2115} (hp : Nat.Prime p) {n : \u2124} :\r\n",
      "body": "```suggestion\r\ntheorem Int.prime_dvd_pow_self_sub {p : \u2115} (hp : Nat.Prime p) {n : \u2124} :\r\n```",
      "path": "Mathlib/FieldTheory/Finite/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "exact"
        ],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "hpn",
          "exact",
          "ZMod",
          "pow_card_sub_one_eq_one",
          "this",
          "simpa",
          "intCast_eq_intCast_iff",
          "using"
        ]
      }
    },
    {
      "id": 4560,
      "before_code": "throwError \"`to_fun` can only be used as a global attribute\"\n    addRelatedDecl src \"fun_\" \"\" ref stx? (docstringPrefix? := s!\"Eta-expanded form of `{src}`\")\n      fun value levels => do\n      let r \u2190 Push.pullCore .lambda (\u2190 inferType value) none",
      "suggestion": "\r\n        throwError \"`@[to_fun]` failed to eta-expand any part of `{.ofConstName src}`.\"\r\n",
      "body": "```suggestion\r\n        throwError \"`@[to_fun]` failed to eta-expand any part of `{.ofConstName src}`.\"\r\n```",
      "path": "Mathlib/Tactic/ToFun.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "levels",
          "form",
          "Eta",
          "Push",
          "pullCore",
          "stx",
          "inferType",
          "to_fun",
          "lambda",
          "addRelatedDecl",
          "can",
          "used",
          "throwError",
          "expanded",
          "none",
          "global",
          "src",
          "docstringPrefix",
          "attribute",
          "only",
          "fun_",
          "ref",
          "value"
        ]
      }
    },
    {
      "id": 4561,
      "before_code": "grw [\u2190 H2]\n  ring_nf; rfl",
      "suggestion": "\r\n  \u00b7 grind [Real.sin_zero, zero_smul, eq_of_norm_eq_of_angle_eq_zero]\r\n",
      "body": "```suggestion\r\n  \u00b7 grind [Real.sin_zero, zero_smul, eq_of_norm_eq_of_angle_eq_zero]\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "ring_nf"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "ring_nf"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "rfl",
          "grw",
          "ring_nf"
        ]
      }
    },
    {
      "id": 4562,
      "before_code": "ring\n  field_simp; exact H2\n\nlemma inner_ortho_right_eq_sin_angle {x y : V} (hx : \u2016x\u2016 = 1) (hy : \u2016y\u2016 = 1) :\n    \u27eax, normalize (ortho y x)\u27eb = Real.sin (angle x y) := by\n  have H : \u27eax, normalize (ortho y x)\u27eb ^ 2 = Real.sin (angle x y) ^ 2 := by\n    simp [Real.sin_sq, \u2190 inner_eq_cos_angle_of_norm_eq_one hx hy,\n      \u2190 inner_normalized_ortho_sq_add_inner_sq_eq_one hx hy]\n  rw [sq_eq_sq_iff_abs_eq_abs, abs_of_nonneg (sin_angle_nonneg x y)] at H\n  have H0 : 0 \u2264 \u27eax, normalize (ortho y x)\u27eb := by\n    rw [NormedSpace.normalize, real_inner_smul_right]\n    exact Left.mul_nonneg (inv_nonneg_of_nonneg (norm_nonneg (ortho y x)))\n      (inner_ortho_nonneg_of_norm_eq_one hx hy)\n  simp_all [abs_of_nonneg H0]\n\nlemma angle_le_angle_add_angle_aux {x y : V} (Hx : \u2016x\u2016 = 1) (Hy : \u2016y\u2016 = 1) :\n    x = Real.cos (angle x y) \u2022 y + Real.sin (angle x y) \u2022 normalize (ortho y x) := by\n  rw [\u2190 inner_ortho_right_eq_sin_angle Hx Hy, \u2190 inner_eq_cos_angle_of_norm_eq_one Hx Hy,\n    ortho, Submodule.starProjection_unit_singleton _ Hy]\n  by_cases hxy : x - \u27eax, y\u27eb \u2022 y = 0\n  \u00b7 simp [hxy, real_inner_comm, \u2190 sub_eq_zero]\n  rw [NormedSpace.normalize, real_inner_smul_right, inner_sub_right, real_inner_smul_right,\n    real_inner_self_eq_norm_sq, Hx, real_inner_comm y, \u2190 sq, mul_smul, \u2190 smul_assoc]\n  norm_num\n  have H : 1 - \u27eax, y\u27eb ^ 2 \u2260 0 := by\n    rw [sub_ne_zero, ne_comm, sq_ne_one_iff]\n    constructor <;> contrapose! hxy\n    \u00b7 rw [inner_eq_one_iff_of_norm_eq_one Hx Hy] at hxy\n      simp [Hy, hxy]\n    \u00b7 rw [inner_eq_neg_one_iff_of_norm_eq_one Hx Hy] at hxy\n      simp [Hy, hxy]\n  rw [\u2190 smul_assoc, smul_eq_mul]\n  field_simp\n  rw [\u2190 real_inner_self_eq_norm_sq]\n  have H0 : \u27eax - \u27eax, y\u27eb \u2022 y, x - \u27eax, y\u27eb \u2022 y\u27eb = 1 - \u27eax, y\u27eb ^ 2 := by\n    rw [inner_sub_left, inner_sub_right, inner_sub_right, inner_self_eq_one_of_norm_eq_one Hx,\n      real_inner_smul_right, \u2190 sq, real_inner_smul_left, real_inner_smul_left,\n      real_inner_smul_right, inner_self_eq_one_of_norm_eq_one Hy, real_inner_comm y x]\n    ring\n  rw [real_inner_comm x,",
      "suggestion": "\r\ninclude hz in\r\n",
      "body": "```suggestion\r\ninclude hz in\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "field_simp",
          "exact",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp",
          "constructor",
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "norm_num",
          "field_simp",
          "exact",
          "cases",
          "have",
          "rw",
          "simp_all",
          "simp",
          "constructor",
          "ring"
        ],
        "topics": [
          "algebra",
          "list",
          "real",
          "norm",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "real_inner_comm",
          "sin_sq",
          "real_inner_self_eq_norm_sq",
          "inner_ortho_right_eq_sin_angle",
          "inner_eq_one_iff_of_norm_eq_one",
          "ne_comm",
          "sq_ne_one_iff",
          "rcases",
          "simp_all",
          "mul_nonneg",
          "inner_ortho_nonneg_of_norm_eq_one",
          "lt_or_ge",
          "normalize",
          "inner_eq_neg_one_iff_of_norm_eq_one",
          "sin",
          "smul_assoc",
          "contrapose",
          "inner_sub_right",
          "cos",
          "by_cases",
          "have",
          "real_inner_smul_right",
          "abs_of_nonneg",
          "inner_normalized_ortho_sq_add_inner_sq_eq_one",
          "sin_angle_nonneg",
          "Submodule",
          "hxy",
          "constructor",
          "angle_le_angle_add_angle_of_norm_eq_one",
          "smul_eq_mul",
          "ortho",
          "real_inner_smul_left",
          "norm_num",
          "angle_le_angle_add_angle_aux",
          "starProjection_unit_singleton",
          "inner_self_eq_one_of_norm_eq_one",
          "sq_eq_sq_iff_abs_eq_abs",
          "Real",
          "inner_eq_cos_angle_of_norm_eq_one",
          "Left",
          "simp",
          "ring",
          "sub_ne_zero",
          "sub_eq_zero",
          "inv_nonneg_of_nonneg",
          "field_simp",
          "exact",
          "norm_nonneg",
          "NormedSpace"
        ]
      }
    },
    {
      "id": 4563,
      "before_code": "grw [\u2190 H2]\n  ring_nf; rfl",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "ring_nf"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring_nf"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "rfl",
          "grw",
          "ring_nf"
        ]
      }
    },
    {
      "id": 4564,
      "before_code": "grw [\u2190 H2]\n  ring_nf; rfl",
      "suggestion": "\r\ninclude hz in\r\n",
      "body": "```suggestion\r\ninclude hz in\r\n```",
      "path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/TriangleInequality.lean",
      "tags": {
        "before_tactics": [
          "ring_nf"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring_nf"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "rfl",
          "grw",
          "ring_nf"
        ]
      }
    },
    {
      "id": 4565,
      "before_code": "iff_of_false ((Sentence.realize_not M).1 (h\u03c6n.realize_sentence M))\n        ((h.models_not_iff \u03c6).1 h\u03c6n)",
      "suggestion": "\r\ntheorem eq_complete_theory (h : T.IsComplete) (M : Type*) [L.Structure M] [M \u22a8 T] [Nonempty M] :\r\n",
      "body": "```suggestion\r\ntheorem eq_complete_theory (h : T.IsComplete) (M : Type*) [L.Structure M] [M \u22a8 T] [Nonempty M] :\r\n```",
      "path": "Mathlib/ModelTheory/Satisfiability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "realize_not",
          "iff_of_false",
          "realize_sentence",
          "models_not_iff",
          "Sentence"
        ]
      }
    },
    {
      "id": 4566,
      "before_code": "iff_of_false ((Sentence.realize_not M).1 (h\u03c6n.realize_sentence M))\n        ((h.models_not_iff \u03c6).1 h\u03c6n)",
      "suggestion": "\r\n  rw [ElementarilyEquivalent, \u2190 h.eq_complete_theory, \u2190 h.eq_complete_theory]\r\n",
      "body": "```suggestion\r\n  rw [ElementarilyEquivalent, \u2190 h.eq_complete_theory, \u2190 h.eq_complete_theory]\r\n```\r\nThis finishes the proof. You can also use this result to prove one direction of `isComplete_iff_models_elementarily_equivalent`.",
      "path": "Mathlib/ModelTheory/Satisfiability.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "realize_not",
          "iff_of_false",
          "realize_sentence",
          "models_not_iff",
          "Sentence"
        ]
      }
    },
    {
      "id": 4567,
      "before_code": "set_option linter.unusedVariables false in\n@[nolint unusedArguments]\nlemma lie_f_pow_toEnd_f (P : HasPrimitiveVectorWith t m \u03bc) (n : \u2115) :\n    \u2045f, \u03c8 n\u2046 = \u03c8 (n + 1) := by",
      "suggestion": "    \u2045f, \u03c8 n\u2046 = \u03c8 (n + 1) := by\n",
      "body": "I think all these with `\u03c8` are wrong. It's essentially function application, so we use a space for that.\n```suggestion\n    \u2045f, \u03c8 n\u2046 = \u03c8 (n + 1) := by\n```",
      "path": "Mathlib/Algebra/Lie/Sl2.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "set_theory",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "lemma",
          "unusedArguments",
          "lie_f_pow_toEnd_f",
          "HasPrimitiveVectorWith",
          "linter",
          "false",
          "nolint",
          "unusedVariables",
          "set_option"
        ]
      }
    },
    {
      "id": 4568,
      "before_code": "ring\n\nlemma lie_e_pow_succ_toEnd_f (n : \u2115) :\n    \u2045e, \u03c8 (n + 1)\u2046 = ((n + 1) * (\u03bc - n)) \u2022 \u03c8 n := by",
      "suggestion": "    \u2045e, \u03c8 (n + 1)\u2046 = ((n + 1) * (\u03bc - n)) \u2022 \u03c8 n := by\n",
      "body": "idem\n```suggestion\n    \u2045e, \u03c8 (n + 1)\u2046 = ((n + 1) * (\u03bc - n)) \u2022 \u03c8 n := by\n```",
      "path": "Mathlib/Algebra/Lie/Sl2.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "nat",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "ring",
          "lemma",
          "lie_e_pow_succ_toEnd_f"
        ]
      }
    },
    {
      "id": 4569,
      "before_code": "exact \u27e8_, inferInstance, inferInstance,\n    (pres.bind pres').reindex (ShrinkHoms.equivalence _).inverse, fun k \u21a6 by simp [hp]\u27e9",
      "suggestion": "\r\nfactors via an object satisfying `P`. -/\r\n",
      "body": "```suggestion\r\nfactors via an object satisfying `P`. -/\r\n```",
      "path": "Mathlib/CategoryTheory/ObjectProperty/Ind.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp"
        ],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "inferInstance",
          "bind",
          "exact",
          "ShrinkHoms",
          "equivalence",
          "reindex",
          "pres",
          "simp",
          "inverse"
        ]
      }
    },
    {
      "id": 4571,
      "before_code": "When `G` is generated by `g` and `A` is the left regular representation `k[G]`, this chain complex\nis a projective resolution of `k` as a trivial representation, which we prove here.\n\nIn the file `Mathlib/RepresentationTheory/Homological/GroupHomology/FiniteCyclic.lean`, we use\nthis resolution to compute the group homology of representations of finite cyclic groups.",
      "suggestion": "In the file `RepresentationTheory/Homological/GroupCohomology/FiniteCyclic.lean`, we use\n",
      "body": "The file path reference is incorrect. It should be `RepresentationTheory/Homological/GroupCohomology/FiniteCyclic.lean` instead of `RepresentationTheory/HomologicalComplex/GroupCohomology/FiniteCyclic.lean`. The actual file being added in this PR is located at `Mathlib/RepresentationTheory/Homological/GroupCohomology/FiniteCyclic.lean`.\n```suggestion\nIn the file `RepresentationTheory/Homological/GroupCohomology/FiniteCyclic.lean`, we use\n```",
      "path": "Mathlib/RepresentationTheory/Homological/FiniteCyclic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "file",
          "which",
          "lean",
          "complex",
          "representation",
          "cyclic",
          "resolution",
          "GroupHomology",
          "finite",
          "representations",
          "projective",
          "When",
          "FiniteCyclic",
          "Mathlib",
          "here",
          "chain",
          "prove",
          "groups",
          "trivial",
          "homology",
          "compute",
          "generated",
          "Homological",
          "group",
          "use",
          "left",
          "this",
          "regular",
          "RepresentationTheory"
        ]
      }
    },
    {
      "id": 4572,
      "before_code": "simp [sub_val_of_le hij, Nat.sub_lt_sub_right hij j.isLt]\n\nlemma castLT_sub_nezero {n : \u2115} {i j : Fin n} (hij : i < j) :\n    letI : NeZero (n - i.1) := neZero_iff.mpr (by lia)\n    (j - i).castLT (sub_val_lt_sub (Fin.le_of_lt hij)) \u2260 0 := by\n  refine Ne.symm (ne_of_val_ne ?_)\n  simpa [coe_sub_iff_le.mpr (Fin.le_of_lt hij)] using by lia\n\nlemma one_le_of_ne_zero {n : \u2115} [NeZero n] {k : Fin n} (hk : k \u2260 0) : 1 \u2264 k := by",
      "suggestion": "\r\n    (hk : k \u2260 0) \u2192 1 \u2264 k := by\r\n",
      "body": "It might be desirable to preserve the binder name:\r\n```suggestion\r\n    (hk : k \u2260 0) \u2192 1 \u2264 k := by\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "refine",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "simp",
          "refine"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "lemma",
          "hij",
          "sub_val_lt_sub",
          "castLT",
          "le_of_lt",
          "symm",
          "refine",
          "Nat",
          "sub_lt_sub_right",
          "sub_val_of_le",
          "castLT_sub_nezero",
          "lia",
          "neZero_iff",
          "isLt",
          "simp",
          "letI",
          "NeZero",
          "ne_of_val_ne",
          "simpa",
          "one_le_of_ne_zero",
          "Fin",
          "coe_sub_iff_le",
          "using"
        ]
      }
    },
    {
      "id": 4573,
      "before_code": "simp [sub_val_of_le hij, Nat.sub_lt_sub_right hij j.isLt]\n\nlemma castLT_sub_nezero {n : \u2115} {i j : Fin n} (hij : i < j) :\n    letI : NeZero (n - i.1) := neZero_iff.mpr (by lia)\n    (j - i).castLT (sub_val_lt_sub (Fin.le_of_lt hij)) \u2260 0 := by\n  refine Ne.symm (ne_of_val_ne ?_)\n  simpa [coe_sub_iff_le.mpr (Fin.le_of_lt hij)] using by lia\n\nlemma one_le_of_ne_zero {n : \u2115} [NeZero n] {k : Fin n} (hk : k \u2260 0) : 1 \u2264 k := by\n  obtain \u27e8n, rfl\u27e9 := Nat.exists_eq_succ_of_ne_zero (NeZero.ne n)\n  cases n with\n  | zero => simp only [Fin.isValue, Fin.zero_le]\n  | succ n => rwa [Fin.le_iff_val_le_val, Fin.val_one, Nat.one_le_iff_ne_zero, val_ne_zero_iff]\n\nlemma val_sub_one_of_ne_zero [NeZero n] {i : Fin n} (hi : i \u2260 0) : (i - 1).val = i - 1 := by",
      "suggestion": "\r\n    (hi : i \u2260 0) \u2192 (i - 1).val = i - 1 := by\r\n",
      "body": "and here too\r\n```suggestion\r\n    (hi : i \u2260 0) \u2192 (i - 1).val = i - 1 := by\r\n```",
      "path": "Mathlib/Data/Fin/Basic.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "cases",
          "simpa",
          "obtain",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "obtain",
          "refine",
          "simp",
          "cases"
        ],
        "topics": [
          "order",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "mpr",
          "lemma",
          "rwa",
          "hij",
          "zero_le",
          "succ",
          "obtain",
          "sub_val_lt_sub",
          "castLT",
          "le_iff_val_le_val",
          "le_of_lt",
          "symm",
          "refine",
          "val_one",
          "Nat",
          "cases",
          "sub_lt_sub_right",
          "sub_val_of_le",
          "castLT_sub_nezero",
          "lia",
          "val_ne_zero_iff",
          "neZero_iff",
          "isLt",
          "isValue",
          "simp",
          "rfl",
          "zero",
          "val",
          "only",
          "letI",
          "one_le_iff_ne_zero",
          "val_sub_one_of_ne_zero",
          "NeZero",
          "ne_of_val_ne",
          "simpa",
          "one_le_of_ne_zero",
          "Fin",
          "exists_eq_succ_of_ne_zero",
          "coe_sub_iff_le",
          "using"
        ]
      }
    },
    {
      "id": 4577,
      "before_code": "rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h",
      "suggestion": "theorem X_pow_sub_C_separable_iff {n : \u2115} (x : F) (hn : 0 < n) (hx : x \u2260 0) :\n",
      "body": "```suggestion\ntheorem X_pow_sub_C_separable_iff {n : \u2115} (x : F) (hn : 0 < n) (hx : x \u2260 0) :\n```\n - We avoid using `>` and prefer `<` in mathlib. \n - Since we are already in `[F : Field]`, != 0 looks more natural than IsUnit",
      "path": "Mathlib/FieldTheory/Separable.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "exact",
          "C_0",
          "isCoprime_zero_right",
          "not_isUnit_X_pow_sub_one",
          "zero_mul"
        ]
      }
    },
    {
      "id": 4578,
      "before_code": "exact I.2.choose_spec.2 a ha\n\n/-- The linear equivalence between the fractional ideal `I` and the integral ideal `I.num`\ndefined by mapping `x` to `den I \u2022 x`. -/\nnoncomputable def equivNum [Nontrivial P] [NoZeroSMulDivisors R P]\n    {I : FractionalIdeal S P} (h_nz : (I.den : R) \u2260 0) : I \u2243\u2097[R] I.num := by\n  refine LinearEquiv.trans\n    (LinearEquiv.ofBijective ((DistribMulAction.toLinearMap R P I.den).restrict fun _ hx \u21a6 ?_)\n      \u27e8fun _ _ hxy \u21a6 ?_, fun \u27e8y, hy\u27e9 \u21a6 ?_\u27e9)\n    (Submodule.equivMapOfInjective (Algebra.linearMap R P)\n      (FaithfulSMul.algebraMap_injective R P) (num I)).symm\n  \u00b7 rw [\u2190 den_mul_self_eq_num]\n    exact Submodule.smul_mem_pointwise_smul _ _ _ hx\n  \u00b7 simp_rw [LinearMap.restrict_apply, DistribMulAction.toLinearMap_apply, Subtype.mk.injEq] at hxy\n    rwa [Submonoid.smul_def, Submonoid.smul_def, smul_right_inj h_nz, SetCoe.ext_iff] at hxy\n  \u00b7 rw [\u2190 den_mul_self_eq_num] at hy\n    obtain \u27e8x, hx, hxy\u27e9 := hy\n    exact \u27e8\u27e8x, hx\u27e9, by simp_rw [LinearMap.restrict_apply, Subtype.ext_iff, \u2190 hxy]; rfl\u27e9",
      "suggestion": "\r\nand the integral ideal `I.num`. -/\r\n",
      "body": "```suggestion\r\nand the integral ideal `I.num`. -/\r\n```",
      "path": "Mathlib/RingTheory/FractionalIdeal/Basic.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "obtain",
          "rw",
          "refine"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "obtain",
          "rw",
          "refine"
        ],
        "topics": [
          "equiv",
          "set_theory",
          "function",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Subtype",
          "rwa",
          "Nontrivial",
          "DistribMulAction",
          "toLinearMap_apply",
          "algebraMap_injective",
          "smul_right_inj",
          "obtain",
          "smul_mem_pointwise_smul",
          "toLinearMap",
          "den",
          "restrict",
          "symm",
          "SetCoe",
          "noncomputable",
          "refine",
          "LinearMap",
          "ofBijective",
          "equivalence",
          "h_nz",
          "FaithfulSMul",
          "Submodule",
          "Submonoid",
          "restrict_apply",
          "ideal",
          "hxy",
          "simp_rw",
          "linear",
          "equivNum",
          "choose_spec",
          "num",
          "def",
          "FractionalIdeal",
          "equivMapOfInjective",
          "linearMap",
          "den_mul_self_eq_num",
          "between",
          "rfl",
          "defined",
          "fractional",
          "ext_iff",
          "integral",
          "exact",
          "LinearEquiv",
          "smul_def",
          "mapping",
          "trans",
          "NoZeroSMulDivisors",
          "Algebra",
          "injEq"
        ]
      }
    },
    {
      "id": 4579,
      "before_code": "end IsOpenCover",
      "suggestion": "\r\ntheorem IrreducibleSpace.of_isOpenCover {X \u03b9 : Type*} [TopologicalSpace X] [h\u03b9 : Nonempty \u03b9]\r\n",
      "body": "```suggestion\r\ntheorem IrreducibleSpace.of_isOpenCover {X \u03b9 : Type*} [TopologicalSpace X] [h\u03b9 : Nonempty \u03b9]\r\n```",
      "path": "Mathlib/Topology/Sets/OpenCover.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "IsOpenCover"
        ]
      }
    },
    {
      "id": 4580,
      "before_code": "end IsOpenCover",
      "suggestion": "\r\n    (hn : Pairwise ((\u00ac Disjoint \u00b7 \u00b7) on U))\r\n",
      "body": "```suggestion\r\n    (hn : Pairwise ((\u00ac Disjoint \u00b7 \u00b7) on U))\r\n```\r\nThis might be a better spelling?",
      "path": "Mathlib/Topology/Sets/OpenCover.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "end",
          "IsOpenCover"
        ]
      }
    },
    {
      "id": 4583,
      "before_code": "end Zero",
      "suggestion": "",
      "body": "I suggest inlining this into the body of the `invFun` term where it is needed\n```suggestion\n```\n(similarly below)",
      "path": "Mathlib/Topology/FiberBundle/Trivialization.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Zero",
          "end"
        ]
      }
    },
    {
      "id": 4584,
      "before_code": "/-!\n\n# Subpresheaf of types\n\nWe define the subpresheaf of a type-valued presheaf.",
      "suggestion": "\r\nWe define subfunctors of a type-valued functor.\r\n",
      "body": "```suggestion\r\nWe define subfunctors of a type-valued functor.\r\n```",
      "path": "Mathlib/CategoryTheory/Subfunctor/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "subpresheaf",
          "presheaf",
          "Subpresheaf",
          "types",
          "valued",
          "type",
          "define"
        ]
      }
    },
    {
      "id": 4585,
      "before_code": "/-!\n\n# Subpresheaf of types\n\nWe define the subpresheaf of a type-valued presheaf.\n\n## Main results\n\n- `CategoryTheory.Subpresheaf` :\n  A subpresheaf of a presheaf of types.",
      "suggestion": "\r\n  A subfunctor of a functor of types.\r\n",
      "body": "```suggestion\r\n  A subfunctor of a functor of types.\r\n```",
      "path": "Mathlib/CategoryTheory/Subfunctor/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "subpresheaf",
          "presheaf",
          "results",
          "Subpresheaf",
          "types",
          "CategoryTheory",
          "valued",
          "Main",
          "type",
          "define"
        ]
      }
    },
    {
      "id": 4586,
      "before_code": "map := by simp }\n  le_top _ _ := le_top\n\nnamespace Subpresheaf\n\nlemma le_def (S T : Subpresheaf F) : S \u2264 T \u2194 \u2200 U, S.obj U \u2264 T.obj U := Iff.rfl\n\nvariable (F)\n\n@[simp] lemma top_obj (i : C\u1d52\u1d56) : (\u22a4 : Subpresheaf F).obj i = \u22a4 := rfl\n@[simp] lemma bot_obj (i : C\u1d52\u1d56) : (\u22a5 : Subpresheaf F).obj i = \u22a5 := rfl\n\nvariable {F}\n\nlemma sSup_obj (S : Set (Subpresheaf F)) (U : C\u1d52\u1d56) :\n    (sSup S).obj U = sSup (Set.image (fun T \u21a6 T.obj U) S) := rfl\n\nlemma sInf_obj (S : Set (Subpresheaf F)) (U : C\u1d52\u1d56) :\n    (sInf S).obj U = sInf (Set.image (fun T \u21a6 T.obj U) S) := rfl\n\n@[simp]\nlemma iSup_obj {\u03b9 : Type*} (S : \u03b9 \u2192 Subpresheaf F) (U : C\u1d52\u1d56) :\n    (\u2a06 i, S i).obj U = \u22c3 i, (S i).obj U := by\n  simp [iSup, sSup_obj]\n\n@[simp]\nlemma iInf_obj {\u03b9 : Type*} (S : \u03b9 \u2192 Subpresheaf F) (U : C\u1d52\u1d56) :\n    (\u2a05 i, S i).obj U = \u22c2 i, (S i).obj U := by\n  simp [iInf, sInf_obj]\n\n@[simp]\nlemma max_obj (S T : Subpresheaf F) (i : C\u1d52\u1d56) :\n    (S \u2294 T).obj i = S.obj i \u222a T.obj i := rfl\n\n@[simp]\nlemma min_obj (S T : Subpresheaf F) (i : C\u1d52\u1d56) :\n    (S \u2293 T).obj i = S.obj i \u2229 T.obj i := rfl\n\nlemma max_min (S\u2081 S\u2082 T : Subpresheaf F) :\n    (S\u2081 \u2294 S\u2082) \u2293 T = (S\u2081 \u2293 T) \u2294 (S\u2082 \u2293 T) := by\n  aesop\n\nlemma iSup_min {\u03b9 : Type*} (S : \u03b9 \u2192 Subpresheaf F) (T : Subpresheaf F) :\n    (\u2a06 i, S i) \u2293 T = \u2a06 i, S i \u2293 T := by\n  aesop\n\ninstance : Nonempty (Subpresheaf F) :=\n  inferInstance\n\n/-- The subpresheaf as a presheaf. -/\n@[simps!]\ndef toPresheaf : C\u1d52\u1d56 \u2964 Type w where",
      "suggestion": "\r\ndef toFunctor : C \u2964 Type w where\r\n",
      "body": "```suggestion\r\ndef toFunctor : C \u2964 Type w where\r\n```\r\n\r\n+ the relevant deprecation",
      "path": "Mathlib/CategoryTheory/Subfunctor/Basic.lean",
      "tags": {
        "before_tactics": [
          "aesop",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "aesop",
          "simp"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "sSup",
          "inferInstance",
          "presheaf",
          "lemma",
          "min_obj",
          "max_obj",
          "iSup_min",
          "Type",
          "iInf",
          "Iff",
          "sInf",
          "subpresheaf",
          "le_def",
          "max_min",
          "sSup_obj",
          "le_top",
          "map",
          "iSup_obj",
          "sInf_obj",
          "toPresheaf",
          "iInf_obj",
          "aesop",
          "image",
          "variable",
          "def",
          "bot_obj",
          "simps",
          "simp",
          "rfl",
          "obj",
          "namespace",
          "Nonempty",
          "Subpresheaf",
          "Set",
          "iSup",
          "top_obj",
          "instance"
        ]
      }
    },
    {
      "id": 4589,
      "before_code": "ext\n  exact (e.inverse.functorPushforward_mem_iff K J).symm",
      "suggestion": "    [e.functor.IsCocontinuous J K] [e.inverse.IsCocontinuous K J] :\n    e.inverse.IsDenseSubsite K J :=\n",
      "body": "```suggestion\n    [e.functor.IsCocontinuous J K] [e.inverse.IsCocontinuous K J] :\n    e.inverse.IsDenseSubsite K J :=\n```",
      "path": "Mathlib/CategoryTheory/Sites/Equivalence.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "ext"
        ],
        "topics": [
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "symm",
          "ext",
          "exact",
          "functorPushforward_mem_iff",
          "inverse"
        ]
      }
    },
    {
      "id": 4590,
      "before_code": "finrank_le_finrank_of_rank_le_rank (lift_rank_bot_le_lift_rank_of_isScalarTower R S T)\n    (Module.rank_lt_aleph0 _ _)",
      "suggestion": "theorem strongRankCondition_iff_forall_rank_lt_aleph0 [Nontrivial R] :\n    StrongRankCondition R \u2194 \u2200 (n : \u2115), Module.rank R (Fin n \u2192 R) < \u2135\u2080 := by\n",
      "body": "How about instead:\n```suggestion\ntheorem strongRankCondition_iff_forall_rank_lt_aleph0 [Nontrivial R] :\n    StrongRankCondition R \u2194 \u2200 (n : \u2115), Module.rank R (Fin n \u2192 R) < \u2135\u2080 := by\n```",
      "path": "Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "finrank_le_finrank_of_rank_le_rank",
          "rank_lt_aleph0",
          "lift_rank_bot_le_lift_rank_of_isScalarTower"
        ]
      }
    },
    {
      "id": 4591,
      "before_code": "finrank_le_finrank_of_rank_le_rank (lift_rank_bot_le_lift_rank_of_isScalarTower R S T)\n    (Module.rank_lt_aleph0 _ _)",
      "suggestion": "theorem strongRankCondition_iff_forall_zero_lt_finrank [Nontrivial R] :\n    StrongRankCondition R \u2194 \u2200 n > 0, 0 < finrank R (Fin n \u2192 R) := by\n",
      "body": "How about:\n```suggestion\ntheorem strongRankCondition_iff_forall_zero_lt_finrank [Nontrivial R] :\n    StrongRankCondition R \u2194 \u2200 n > 0, 0 < finrank R (Fin n \u2192 R) := by\n```",
      "path": "Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "finrank_le_finrank_of_rank_le_rank",
          "rank_lt_aleph0",
          "lift_rank_bot_le_lift_rank_of_isScalarTower"
        ]
      }
    },
    {
      "id": 4592,
      "before_code": "variable {R M N P : Type*} [Semiring R] [AddCommMonoid M] [Module R M] [IsNoetherian R M]\n\nlemma Submodule.finite_ne_bot_of_iSupIndep {\u03b9 : Type*} {N : \u03b9 \u2192 Submodule R M}\n    (h : iSupIndep N) :\n    Set.Finite {i | N i \u2260 \u22a5} :=\n  WellFoundedGT.finite_ne_bot_of_iSupIndep h\n\n/-- A linearly-independent family of vectors in a module over a non-trivial ring must be finite if\nthe module is Noetherian. -/\ntheorem LinearIndependent.finite_of_isNoetherian [Nontrivial R] {\u03b9} {v : \u03b9 \u2192 M}\n    (hv : LinearIndependent R v) : Finite \u03b9 := by\n  refine WellFoundedGT.finite_of_iSupIndep\n    hv.iSupIndep_span_singleton\n    fun i contra => ?_\n  apply hv.ne_zero i\n  have : v i \u2208 R \u2219 v i := Submodule.mem_span_singleton_self (v i)\n  rwa [contra, Submodule.mem_bot] at this",
      "suggestion": "theorem IsNoetherian.subsingleton_of_injective {P : Type*} [AddCommMonoid P] [Module R P]\n    {f : P \u00d7 M \u2192\u2097[R] M} (inj : Injective f) : Subsingleton P := by\n",
      "body": "As elsewhere I think the contrapositive is the more useful statement:\n```suggestion\ntheorem IsNoetherian.subsingleton_of_injective {P : Type*} [AddCommMonoid P] [Module R P]\n    {f : P \u00d7 M \u2192\u2097[R] M} (inj : Injective f) : Subsingleton P := by\n```",
      "path": "Mathlib/RingTheory/Noetherian/Basic.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "ring",
          "refine",
          "have"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "ring",
          "refine",
          "have"
        ],
        "topics": [
          "set_theory",
          "order",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "independent",
          "lemma",
          "rwa",
          "Nontrivial",
          "Type",
          "family",
          "finite",
          "apply",
          "refine",
          "iSupIndep",
          "Noetherian",
          "have",
          "Submodule",
          "IsNoetherian",
          "contra",
          "trivial",
          "variable",
          "vectors",
          "mem_span_singleton_self",
          "module",
          "over",
          "Semiring",
          "iSupIndep_span_singleton",
          "ne_zero",
          "mem_bot",
          "non",
          "finite_of_isNoetherian",
          "must",
          "finite_ne_bot_of_iSupIndep",
          "ring",
          "linearly",
          "finite_of_iSupIndep",
          "Finite",
          "AddCommMonoid",
          "theorem",
          "Set",
          "this",
          "LinearIndependent",
          "WellFoundedGT"
        ]
      }
    },
    {
      "id": 4593,
      "before_code": "StrongRankCondition R \u2194\n      \u2200 (n : \u2115) (f : (Fin (n + 1) \u2192 R) \u2192\u2097[R] Fin n \u2192 R), \u00acFunction.Injective f := by\n  refine \u27e8fun h n => fun f hf => ?_, fun h => \u27e8@fun n m f hf => ?_\u27e9\u27e9\n  \u00b7 letI : StrongRankCondition R := h\n    exact Nat.not_succ_le_self n (le_of_fin_injective R f hf)\n  \u00b7 by_contra H\n    exact\n      h m (f.comp (Function.ExtendByZero.linearMap R (Fin.castLE (not_le.1 H))))\n        (hf.comp (Function.extend_injective (Fin.strictMono_castLE _).injective _))",
      "suggestion": "",
      "body": "Is this really worth adding, I'm a bit dubious:\n```suggestion\n```",
      "path": "Mathlib/LinearAlgebra/InvariantBasisNumber.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "refine"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "refine"
        ],
        "topics": [
          "order",
          "function",
          "nat"
        ],
        "transforms": [],
        "keywords": [
          "extend_injective",
          "le_of_fin_injective",
          "Function",
          "refine",
          "not_le",
          "Nat",
          "injective",
          "by_contra",
          "StrongRankCondition",
          "ExtendByZero",
          "linearMap",
          "comp",
          "castLE",
          "Injective",
          "letI",
          "strictMono_castLE",
          "not_succ_le_self",
          "exact",
          "Fin"
        ]
      }
    },
    {
      "id": 4594,
      "before_code": "coe X := X.carrier\n\n/-- forgetful functor to `TopCat` is the same as coercion -/\nunif_hint forgetToTop_obj_eq_coe (X : Scheme) where \u22a2\n  forgetToTop.obj X \u225f (X : TopCat)",
      "suggestion": "\r\nunif_hint forgetToTop_obj_eq_coe (X : Scheme) where \u22a2 forgetToTop.obj X \u225f (X : TopCat)\r\n",
      "body": "```suggestion\r\nunif_hint forgetToTop_obj_eq_coe (X : Scheme) where \u22a2 forgetToTop.obj X \u225f (X : TopCat)\r\n```\r\nalso below",
      "path": "Mathlib/AlgebraicGeometry/Scheme.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "forgetToTop",
          "forgetful",
          "functor",
          "Scheme",
          "same",
          "coercion",
          "carrier",
          "forgetToTop_obj_eq_coe",
          "unif_hint",
          "coe",
          "TopCat",
          "obj"
        ]
      }
    },
    {
      "id": 4595,
      "before_code": "## Main statements\n\n* `isTightMeasureSet_singleton_of_innerRegularWRT`: every finite, inner-regular measure is tight.\n\n-/\n\n@[expose] public section\n\nopen Filter Set\n\nopen scoped ENNReal NNReal Topology\n\nnamespace MeasureTheory\n\nvariable {\ud835\udce7 \ud835\udce8 : Type*} [TopologicalSpace \ud835\udce7] {m\ud835\udce7 : MeasurableSpace \ud835\udce7}\n  {\u03bc \u03bd : Measure \ud835\udce7} {S T : Set (Measure \ud835\udce7)}",
      "suggestion": "variable [TopologicalSpace \ud835\udce7]\n",
      "body": "```suggestion\nvariable [TopologicalSpace \ud835\udce7]\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "measurability",
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "Topology",
          "expose",
          "Type",
          "finite",
          "Main",
          "open",
          "section",
          "isTightMeasureSet_singleton_of_innerRegularWRT",
          "statements",
          "scoped",
          "Measure",
          "Filter",
          "TopologicalSpace",
          "variable",
          "public",
          "tight",
          "MeasurableSpace",
          "namespace",
          "ENNReal",
          "every",
          "Set",
          "MeasureTheory",
          "measure",
          "regular",
          "inner",
          "NNReal"
        ]
      }
    },
    {
      "id": 4596,
      "before_code": "exact subset_preimage_image f K\n\nend IsTightMeasureSet",
      "suggestion": "  suffices \u2200\u1da0 n : \u2115 in atTop, False from this.exists.choose_spec\n",
      "body": "```suggestion\n  suffices \u2200\u1da0 n : \u2115 in atTop, False from this.exists.choose_spec\n```",
      "path": "Mathlib/MeasureTheory/Measure/Tight.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "exact",
          "IsTightMeasureSet",
          "end",
          "subset_preimage_image"
        ]
      }
    },
    {
      "id": 4602,
      "before_code": "- `Real.arcosh`: An inverse function of `Real.cosh` as a function from [0, \u221e) to [1, \u221e).\n\n- `Real.coshPartialEquiv`: `Real.cosh` as a `PartialEquiv`.",
      "suggestion": "- `Real.coshPartialEquiv`: `Real.cosh` and `Real.arcosh` bundled as a `PartialEquiv` from [0, \u221e) to [1, \u221e).\n",
      "body": "```suggestion\n- `Real.coshPartialEquiv`: `Real.cosh` and `Real.arcosh` bundled as a `PartialEquiv` from [0, \u221e) to [1, \u221e).\n```",
      "path": "Mathlib/Analysis/SpecialFunctions/Arcosh.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "real"
        ],
        "transforms": [],
        "keywords": [
          "function",
          "PartialEquiv",
          "cosh",
          "Real",
          "from",
          "coshPartialEquiv",
          "arcosh",
          "inverse"
        ]
      }
    },
    {
      "id": 4603,
      "before_code": "theorem degree_add (a b : \u03c3 \u2192\u2080 R) : (a + b).degree = a.degree + b.degree :=\n  sum_add_index' (h := fun _ \u21a6 id) (congrFun rfl) fun _ _ \u21a6 congrFun rfl",
      "suggestion": "  intro a s hs hs'\n  rw [Finset.sum_insert hs, Finset.sum_insert hs, degree_add, hs']\n",
      "body": "```suggestion\n  intro a s hs hs'\n  rw [Finset.sum_insert hs, Finset.sum_insert hs, degree_add, hs']\n```",
      "path": "Mathlib/Data/Finsupp/Weight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [
          "rw",
          "intro"
        ],
        "body_tactics": [
          "rw",
          "intro"
        ],
        "new_tactics": [
          "rw",
          "intro"
        ],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "degree_add",
          "theorem",
          "sum_add_index",
          "congrFun",
          "rfl",
          "degree"
        ]
      }
    },
    {
      "id": 4604,
      "before_code": "theorem degree_add (a b : \u03c3 \u2192\u2080 R) : (a + b).degree = a.degree + b.degree :=\n  sum_add_index' (h := fun _ \u21a6 id) (congrFun rfl) fun _ _ \u21a6 congrFun rfl",
      "suggestion": "\r\ntheorem degree_sum {\u03b9 : Type*} [DecidableEq \u03b9] {s : Finset \u03b9} (f : \u03b9 \u2192 \u03c3 \u2192\u2080 \u2115) :\r\n    (\u2211 i \u2208 s, f i).degree = \u2211 i \u2208 s, (f i).degree := by\r\n",
      "body": "```suggestion\r\ntheorem degree_sum {\u03b9 : Type*} [DecidableEq \u03b9] {s : Finset \u03b9} (f : \u03b9 \u2192 \u03c3 \u2192\u2080 \u2115) :\r\n    (\u2211 i \u2208 s, f i).degree = \u2211 i \u2208 s, (f i).degree := by\r\n```\r\nI think we usually use `\u03b9` for indexing types.",
      "path": "Mathlib/Data/Finsupp/Weight.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "degree_add",
          "theorem",
          "sum_add_index",
          "congrFun",
          "rfl",
          "degree"
        ]
      }
    },
    {
      "id": 4605,
      "before_code": "end",
      "suggestion": "\r\nvariable {C C' : Type u'} [Category.{v'} C] [Category.{v'} C'] {J : GrothendieckTopology C}\r\n",
      "body": "```suggestion\r\nvariable {C C' : Type u'} [Category.{v'} C] [Category.{v'} C'] {J : GrothendieckTopology C}\r\n```\r\nthings work as is if C and C'  are not u'-small.",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 4606,
      "before_code": "end",
      "suggestion": "\r\n  (\u03b7 : F.obj (unit R) \u2245 unit S)\r\n",
      "body": "```suggestion\r\n  (\u03b7 : F.obj (unit R) \u2245 unit S)\r\n```\r\nuntested, but it looks like `I` is no longer needed here.",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 4607,
      "before_code": "end",
      "suggestion": "\r\ndef Presentation.mapGenerators : free P.generators.I \u27f6 F.obj M :=\r\n",
      "body": "```suggestion\r\ndef Presentation.mapGenerators : free P.generators.I \u27f6 F.obj M :=\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 4608,
      "before_code": "end",
      "suggestion": "\r\nsheaves of `R`-modules `f : free \u03b9 \u27f6 free \u03c3` and `g : free \u03c3 \u27f6 M` satisfying `H : f \u226b g = 0`\r\n",
      "body": "```suggestion\r\nsheaves of `R`-modules `f : free \u03b9 \u27f6 free \u03c3` and `g : free \u03c3 \u27f6 M` satisfying `H : f \u226b g = 0`\r\n```",
      "path": "Mathlib/Algebra/Category/ModuleCat/Sheaf/Quasicoherent.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "end"
        ]
      }
    },
    {
      "id": 4615,
      "before_code": "Int.negOnePow_sub]\n    ring",
      "suggestion": "    (T R n).leadingCoeff = 2 ^ (n.natAbs - 1) := by\n",
      "body": "```suggestion\n    (T R n).leadingCoeff = 2 ^ (n.natAbs - 1) := by\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "negOnePow_sub",
          "ring",
          "Int"
        ]
      }
    },
    {
      "id": 4616,
      "before_code": "T.induct motive zero one add_two fun n hn hnm => by\n    simpa only [Int.negSucc_eq, neg_add] using neg_add_one n hn hnm",
      "suggestion": "    (add_two : \u2200 (n : \u2115), motive \u2191n \u2192 motive (\u2191n + 1) \u2192 motive (\u2191n + 2))\n",
      "body": "Is this the natural order? I would've expected\n```suggestion\n    (add_two : \u2200 (n : \u2115), motive \u2191n \u2192 motive (\u2191n + 1) \u2192 motive (\u2191n + 2))\n```\nbut of course it doesn't matter too much.",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "int"
        ],
        "transforms": [],
        "keywords": [
          "one",
          "motive",
          "neg_add",
          "neg_add_one",
          "Int",
          "hnm",
          "zero",
          "simpa",
          "add_two",
          "negSucc_eq",
          "induct",
          "only",
          "using"
        ]
      }
    },
    {
      "id": 4617,
      "before_code": "norm_num\n    ring",
      "suggestion": "\r\ntheorem degree_U_of_ne_neg_one [IsDomain R] [NeZero (2 : R)] (n : \u2124) (hn : n \u2260 -1) :\r\n",
      "body": "```suggestion\r\ntheorem degree_U_of_ne_neg_one [IsDomain R] [NeZero (2 : R)] (n : \u2124) (hn : n \u2260 -1) :\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "norm_num",
          "ring"
        ],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "norm_num",
          "ring"
        ]
      }
    },
    {
      "id": 4618,
      "before_code": "norm_num\n    ring",
      "suggestion": "\r\n    (U R n).leadingCoeff = 2 ^ n := by\r\n",
      "body": "```suggestion\r\n    (U R n).leadingCoeff = 2 ^ n := by\r\n```",
      "path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
      "tags": {
        "before_tactics": [
          "norm_num",
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "norm_num",
          "ring"
        ],
        "topics": [
          "norm",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "norm_num",
          "ring"
        ]
      }
    },
    {
      "id": 4619,
      "before_code": "lemma add_modEq_right : a + n \u2261 a [MOD n] := by simp",
      "suggestion": "theorem modEq_iff_exists_eq_add (h : a \u2264 b) : a \u2261 b [MOD n] \u2194 \u2203 (t : \u2115), b = a + n * t := by\n",
      "body": "```suggestion\ntheorem modEq_iff_exists_eq_add (h : a \u2264 b) : a \u2261 b [MOD n] \u2194 \u2203 (t : \u2115), b = a + n * t := by\n```",
      "path": "Mathlib/Data/Nat/ModEq.lean",
      "tags": {
        "before_tactics": [
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "add_modEq_right",
          "MOD",
          "lemma",
          "simp"
        ]
      }
    },
    {
      "id": 4620,
      "before_code": "/-- The monoid homomorphism corresponding to the action of `G` onto `V : FDRep R G`. -/\ndef \u03c1 (V : FDRep R G) : G \u2192* V \u2192\u2097[R] V :=\n  (ModuleCat.endRingEquiv _).toMonoidHom.comp (Action.\u03c1 V)\n\n@[simp]\nlemma endRingEquiv_symm_comp_\u03c1 (V : FDRep R G) :\n    (MonoidHomClass.toMonoidHom (ModuleCat.endRingEquiv V.V.obj).symm).comp (\u03c1 V) =\n      (Action.\u03c1 V) :=\n  rfl\n\n@[simp]\nlemma endRingEquiv_comp_\u03c1 (V : FDRep R G) :\n    (MonoidHomClass.toMonoidHom (ModuleCat.endRingEquiv V.V.obj)).comp (Action.\u03c1 V) = \u03c1 V := rfl\n\n@[simp]\nlemma hom_action_\u03c1 (V : FDRep R G) (g : G) : (Action.\u03c1 V g).hom = \u03c1 V g := rfl\n\n/-- The underlying `LinearEquiv` of an isomorphism of representations. -/\ndef isoToLinearEquiv {V W : FDRep R G} (i : V \u2245 W) : V \u2243\u2097[R] W :=\n  FGModuleCat.isoToLinearEquiv ((Action.forget (FGModuleCat R) G).mapIso i)\n\ntheorem Iso.conj_\u03c1 {V W : FDRep R G} (i : V \u2245 W) (g : G) :\n    W.\u03c1 g = (FDRep.isoToLinearEquiv i).conj (V.\u03c1 g) := by\n  rw [FDRep.isoToLinearEquiv, \u2190 hom_action_\u03c1 V, \u2190 FGModuleCat.Iso.conj_hom_eq_conj, Iso.conj_apply,\n      \u2190 ModuleCat.hom_ofHom (W.\u03c1 g), \u2190 ModuleCat.hom_ext_iff,\n      Iso.eq_inv_comp ((Action.forget (FGModuleCat R) G).mapIso i)]\n  exact (i.hom.comm g).symm",
      "suggestion": "  cat_disch\n",
      "body": "```suggestion\n  cat_disch\n```",
      "path": "Mathlib/RepresentationTheory/FDRep.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "rw",
          "simp"
        ],
        "topics": [
          "equiv",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "isoToLinearEquiv",
          "lemma",
          "isomorphism",
          "representations",
          "ModuleCat",
          "Action",
          "symm",
          "hom_ofHom",
          "corresponding",
          "mapIso",
          "forget",
          "conj_hom_eq_conj",
          "conj",
          "Iso",
          "action",
          "def",
          "toMonoidHom",
          "underlying",
          "FDRep",
          "endRingEquiv",
          "FGModuleCat",
          "comp",
          "homomorphism",
          "simp",
          "monoid",
          "rfl",
          "comm",
          "obj",
          "MonoidHomClass",
          "conj_apply",
          "theorem",
          "exact",
          "LinearEquiv",
          "hom_ext_iff",
          "onto",
          "eq_inv_comp"
        ]
      }
    },
    {
      "id": 4621,
      "before_code": "def limitConeIsLimit {J : Type v} [SmallCategory J] (F : J \u2964 CompHaus.{max v u}) :\n    Limits.IsLimit.{v} (limitCone.{v,u} F) :=\n  letI FF : J \u2964 TopCat := F \u22d9 compHausToTop\n  { lift := fun S => (TopCat.limitConeIsLimit FF).lift (compHausToTop.mapCone S)\n    fac := fun S => (TopCat.limitConeIsLimit FF).fac (compHausToTop.mapCone S)\n    uniq := fun S => (TopCat.limitConeIsLimit FF).uniq (compHausToTop.mapCone S) }",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Topology/Category/CompHaus/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "fac",
          "letI",
          "Limits",
          "def",
          "uniq",
          "Type",
          "SmallCategory",
          "IsLimit",
          "lift",
          "limitCone",
          "CompHaus",
          "mapCone",
          "max",
          "compHausToTop",
          "TopCat",
          "limitConeIsLimit"
        ]
      }
    },
    {
      "id": 4622,
      "before_code": "instance : HasLimit (cospan f g) where\n  exists_limit := \u27e8\u27e8pullback.cone f g, pullback.isLimit f g\u27e9\u27e9",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Topology/Category/CompHausLike/Limits.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "isLimit",
          "HasLimit",
          "cospan",
          "cone",
          "exists_limit",
          "pullback",
          "instance"
        ]
      }
    },
    {
      "id": 4623,
      "before_code": "\u2200 {V W : Pairwise \u03b9}, (V \u27f6 W) \u2192 (pairwiseToOpensLeCoverObj U V \u27f6 pairwiseToOpensLeCoverObj U W)\n  | _, _, id_single _ => \ud835\udfd9 _\n  | _, _, id_pair _ _ => \ud835\udfd9 _\n  | _, _, left _ _ => homOfLE inf_le_left\n  | _, _, right _ _ => homOfLE inf_le_right",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Topology/Sheaves/SheafCondition/PairwiseIntersections.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "homOfLE",
          "right",
          "id_single",
          "inf_le_right",
          "id_pair",
          "left",
          "Pairwise",
          "inf_le_left",
          "pairwiseToOpensLeCoverObj"
        ]
      }
    },
    {
      "id": 4624,
      "before_code": "rintro S \u27e8V, i, hV\u27e9\n    dsimp [forget, opensLeCoverCocone]\n    ext \u27e8_, x, f\u27e9\n    simp only [comp_obj, StructuredArrow.proj_obj, Category.assoc, limit.lift_\u03c0, lowerCone_pt,\n      lowerCone_\u03c0_app, const_obj_obj, projSup_obj, StructuredArrow.map_obj_right, op_obj,\n      ObjectProperty.\u03b9_obj, pointwiseRightKanExtension_obj]",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Topology/Sheaves/Alexandrov.lean",
      "tags": {
        "before_tactics": [
          "simp",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simp",
          "ext"
        ],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "lowerCone_pt",
          "pointwiseRightKanExtension_obj",
          "rintro",
          "proj_obj",
          "StructuredArrow",
          "ObjectProperty",
          "map_obj_right",
          "opensLeCoverCocone",
          "assoc",
          "limit",
          "ext",
          "forget",
          "projSup_obj",
          "op_obj",
          "simp",
          "dsimp",
          "only",
          "const_obj_obj",
          "Category",
          "comp_obj"
        ]
      }
    },
    {
      "id": 4625,
      "before_code": "rintro S \u27e8V, i, hV\u27e9\n    dsimp [forget, opensLeCoverCocone]\n    ext \u27e8_, x, f\u27e9\n    simp only [comp_obj, StructuredArrow.proj_obj, Category.assoc, limit.lift_\u03c0, lowerCone_pt,\n      lowerCone_\u03c0_app, const_obj_obj, projSup_obj, StructuredArrow.map_obj_right, op_obj,\n      ObjectProperty.\u03b9_obj, pointwiseRightKanExtension_obj]\n    have e : principalOpen x \u2264 V := f.unop.le\n    let VV : (ObjectProperty.FullSubcategory fun V => \u2203 i, V \u2264 Us i) := \u27e8V, i, hV\u27e9\n    let xx : (ObjectProperty.FullSubcategory fun V => \u2203 i, V \u2264 Us i) :=\n      \u27e8principalOpen x, i, le_trans e hV\u27e9\n    let ee : xx \u27f6 VV := e.hom\n    rw [\u2190 S.w ee.op, Category.assoc]\n    congr 1\n    simp only [comp_obj, op_obj, ObjectProperty.\u03b9_obj, pointwiseRightKanExtension_obj,\n      Functor.comp_map, op_map, Quiver.Hom.unop_op,\n      pointwiseRightKanExtension_map, limit.lift_\u03c0, xx, VV]\n    congr\n  uniq := by\n    intro S m hm\n    dsimp\n    symm\n    ext \u27e8_, x, f\u27e9\n    simp only [lowerCone_pt, comp_obj, limit.lift_\u03c0, lowerCone_\u03c0_app, const_obj_obj, projSup_obj,\n      op_obj, ObjectProperty.\u03b9_obj, pointwiseRightKanExtension_obj]\n    specialize hm \u27e8principalOpen x, ?_\u27e9\n    \u00b7 apply exists_le_of_le_sup\n      exact f.unop.le\n    \u00b7 rw [\u2190 hm]\n      simp only [mapCone_pt, Cocone.op_pt, pointwiseRightKanExtension_obj,\n        const_obj_obj, comp_obj, op_obj, ObjectProperty.\u03b9_obj, mapCone_\u03c0_app, Cocone.op_\u03c0,\n        NatTrans.op_app, pointwiseRightKanExtension_map, Category.assoc, limit.lift_\u03c0]",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/Topology/Sheaves/Alexandrov.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "ext",
          "exact",
          "have",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "ext",
          "exact",
          "have",
          "rw",
          "simp",
          "intro",
          "congr"
        ],
        "topics": [
          "list",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "hom",
          "lowerCone_pt",
          "Quiver",
          "pointwiseRightKanExtension_obj",
          "exists_le_of_le_sup",
          "rintro",
          "proj_obj",
          "StructuredArrow",
          "Cocone",
          "unop",
          "ObjectProperty",
          "map_obj_right",
          "apply",
          "opensLeCoverCocone",
          "assoc",
          "limit",
          "comp_map",
          "ext",
          "symm",
          "NatTrans",
          "specialize",
          "have",
          "forget",
          "pointwiseRightKanExtension_map",
          "projSup_obj",
          "intro",
          "op_obj",
          "Functor",
          "unop_op",
          "op_pt",
          "simp",
          "mapCone_pt",
          "congr",
          "dsimp",
          "only",
          "op_map",
          "principalOpen",
          "const_obj_obj",
          "exact",
          "Category",
          "FullSubcategory",
          "uniq",
          "Hom",
          "comp_obj",
          "le_trans",
          "op_app"
        ]
      }
    },
    {
      "id": 4626,
      "before_code": "[SigmaFinite (\u03bc.trim (h\u03c4.min h\u03c3).measurableSpace_le)] :\n    \u03bc[f|(h\u03c4.min h\u03c3).measurableSpace] =\u1d50[\u03bc.restrict {x | \u03c4 x \u2264 \u03c3 x}] \u03bc[f|h\u03c4.measurableSpace] := by\n  have : SigmaFinite (\u03bc.trim h\u03c4.measurableSpace_le) :=\n    haveI h_le : (h\u03c4.min h\u03c3).measurableSpace \u2264 h\u03c4.measurableSpace := by\n      rw [IsStoppingTime.measurableSpace_min]\n      \u00b7 exact inf_le_left\n      \u00b7 simp_all only\n    sigmaFiniteTrim_mono _ h_le\n  refine (condExp_ae_eq_restrict_of_measurableSpace_eq_on h\u03c4.measurableSpace_le\n    (h\u03c4.min h\u03c3).measurableSpace_le (h\u03c4.measurableSet_le_stopping_time h\u03c3) fun t => ?_).symm\n  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_le_iff]; simp_all only",
      "suggestion": "\r\n  rw [Set.inter_comm _ t, h\u03c4.measurableSet_inter_le_iff h\u03c3]\r\n",
      "body": "same thing here, this should work:\r\n```suggestion\r\n  rw [Set.inter_comm _ t, h\u03c4.measurableSet_inter_le_iff h\u03c3]\r\n```",
      "path": "Mathlib/Probability/Process/Stopping.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "exact",
          "have",
          "rw",
          "simp_all"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "simp_all",
          "have",
          "refine"
        ],
        "topics": [
          "measurability",
          "set_theory"
        ],
        "transforms": [],
        "keywords": [
          "condExp_ae_eq_restrict_of_measurableSpace_eq_on",
          "simp_all",
          "measurableSpace_le",
          "measurableSpace",
          "inter_comm",
          "trim",
          "restrict",
          "symm",
          "refine",
          "have",
          "SigmaFinite",
          "measurableSpace_min",
          "h_le",
          "sigmaFiniteTrim_mono",
          "only",
          "measurableSet_le_stopping_time",
          "IsStoppingTime",
          "exact",
          "min",
          "Set",
          "inf_le_left",
          "measurableSet_inter_le_iff",
          "haveI"
        ]
      }
    },
    {
      "id": 4627,
      "before_code": "[SigmaFinite (\u03bc.trim (h\u03c4.min h\u03c3).measurableSpace_le)] :\n    \u03bc[f|(h\u03c4.min h\u03c3).measurableSpace] =\u1d50[\u03bc.restrict {x | \u03c4 x \u2264 \u03c3 x}] \u03bc[f|h\u03c4.measurableSpace] := by\n  have : SigmaFinite (\u03bc.trim h\u03c4.measurableSpace_le) :=\n    haveI h_le : (h\u03c4.min h\u03c3).measurableSpace \u2264 h\u03c4.measurableSpace := by\n      rw [IsStoppingTime.measurableSpace_min]\n      \u00b7 exact inf_le_left\n      \u00b7 simp_all only\n    sigmaFiniteTrim_mono _ h_le",
      "suggestion": "\r\n    sigmaFiniteTrim_mono _ (h\u03c4.measurableSpace_min h\u03c3 \u25b8 inf_le_left)\r\n",
      "body": "```suggestion\r\n    sigmaFiniteTrim_mono _ (h\u03c4.measurableSpace_min h\u03c3 \u25b8 inf_le_left)\r\n```",
      "path": "Mathlib/Probability/Process/Stopping.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "have",
          "rw",
          "simp_all"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "have",
          "rw",
          "simp_all"
        ],
        "topics": [
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "restrict",
          "h_le",
          "IsStoppingTime",
          "exact",
          "min",
          "have",
          "sigmaFiniteTrim_mono",
          "inf_le_left",
          "simp_all",
          "measurableSpace_le",
          "measurableSpace",
          "SigmaFinite",
          "measurableSpace_min",
          "only",
          "trim",
          "haveI"
        ]
      }
    },
    {
      "id": 4628,
      "before_code": "If `C : Type u` is a category (with `[Category.{v} C]`), and\n`W : MorphismProperty C`, then the constructed localized\ncategory `W.Localization` is in `Type u` (the objects are\nessentially the same as that of `C`), but the morphisms\nare in `Type (max u v)`. In particular situations, it\nmay happen that there is a localized category for `W`\nwhose morphisms are in a lower universe like `v`: it shall",
      "suggestion": "whose morphisms are in a lower universe like `v`: it shall\n",
      "body": "```suggestion\nwhose morphisms are in a lower universe like `v`: it shall\n```",
      "path": "Mathlib/CategoryTheory/Localization/HasLocalization.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "list"
        ],
        "transforms": [],
        "keywords": [
          "morphisms",
          "essentially",
          "category",
          "Type",
          "happen",
          "objects",
          "but",
          "there",
          "Localization",
          "constructed",
          "universe",
          "like",
          "are",
          "lower",
          "max",
          "situations",
          "for",
          "then",
          "that",
          "localized",
          "particular",
          "whose",
          "Category",
          "same",
          "may",
          "shall",
          "MorphismProperty"
        ]
      }
    },
    {
      "id": 4629,
      "before_code": "\u00b7 apply zero_smul\n  \u00b7 rintro \u27e8x, rfl\u27e9; exact x.2",
      "suggestion": "  IsOpen.ae_eq_zero_of_integral_contMDiff_smul_eq_zero'\n",
      "body": "```suggestion\n  IsOpen.ae_eq_zero_of_integral_contMDiff_smul_eq_zero'\n```",
      "path": "Mathlib/Analysis/Distribution/AEEqOfIntegralContDiff.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "apply"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "apply"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "apply",
          "exact",
          "zero_smul",
          "rintro",
          "rfl"
        ]
      }
    },
    {
      "id": 4630,
      "before_code": "haveI := hU.locallyCompactSpace\n  haveI := I.secondCountableTopology\n  haveI := ChartedSpace.secondCountable_of_sigmaCompact H M\n  hU.ae_eq_zero_of_integral_smooth_smul_eq_zero' _\n    (isSigmaCompact_iff_sigmaCompactSpace.mpr inferInstance) hf h",
      "suggestion": "  IsOpen.ae_eq_zero_of_integral_contMDiff_smul_eq_zero\n",
      "body": "```suggestion\n  IsOpen.ae_eq_zero_of_integral_contMDiff_smul_eq_zero\n```",
      "path": "Mathlib/Analysis/Distribution/AEEqOfIntegralContDiff.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "topology"
        ],
        "transforms": [],
        "keywords": [
          "inferInstance",
          "mpr",
          "ae_eq_zero_of_integral_smooth_smul_eq_zero",
          "secondCountable_of_sigmaCompact",
          "secondCountableTopology",
          "isSigmaCompact_iff_sigmaCompactSpace",
          "ChartedSpace",
          "locallyCompactSpace",
          "haveI"
        ]
      }
    },
    {
      "id": 4631,
      "before_code": "have h_x_in_Umap_j : x \u2208 W j := interior_subset (h\u03c1U j h_x_in_tsupport_\u03c1j)\n  exact h_mem_t j x h_x_in_Umap_j\n\n/-- Let `V` be a vector bundle over a \u03c3-compact Hausdorff finite-dimensional topological manifold\n`M`. Let `t : M \u2192 Set (V x)` be a family of convex sets in the fibers of `V`.\nSuppose that for each point `x\u2080 : M` there exists a neighborhood `U_x\u2080` of `x\u2080` and a local\nsection `s_loc : M \u2192 V x` such that `s_loc` is $C^\u221e$ smooth on `U_x\u2080` (when viewed as a map to\nthe total space of the bundle) and `s_loc y \u2208 t y` for all `y \u2208 U_x\u2080`.\nThen there exists a global smooth section `s : C\u209b^\u221e\u27eeI_M; F_fiber, V\u27ef` such that\n`s x \u2208 t x` for all `x : M`.\n-/\ntheorem exists_smooth_section_forall_mem_convex_of_local\n    {F_fiber : Type*} [NormedAddCommGroup F_fiber] [NormedSpace \u211d F_fiber]\n    (V : M \u2192 Type*) [\u2200 x, NormedAddCommGroup (V x)] [\u2200 x, Module \u211d (V x)]\n    [TopologicalSpace (TotalSpace F_fiber V)] [FiberBundle F_fiber V] [VectorBundle \u211d F_fiber V]\n    (t : \u2200 x, Set (V x)) (ht_conv : \u2200 x, Convex \u211d (t x))\n    (Hloc :\n      \u2200 x\u2080 : M, \u2203 U_x\u2080 \u2208 \ud835\udcdd x\u2080, \u2203 (s_loc : (x : M) \u2192 V x),\n        (ContMDiffOn I (I.prod \ud835\udcd8(\u211d, F_fiber)) \u221e (fun x \u21a6 TotalSpace.mk' F_fiber x (s_loc x)) U_x\u2080) \u2227\n        (\u2200 y \u2208 U_x\u2080, s_loc y \u2208 t y)) :\n    \u2203 s : C\u209b^\u221e\u27eeI; F_fiber, V\u27ef, \u2200 x : M, s x \u2208 t x :=\n      exists_contMDiffOn_section_forall_mem_convex_of_local I V t ht_conv Hloc\n\n/-- Let `M` be a \u03c3-compact Hausdorff finite-dimensional topological manifold. Let `t : M \u2192 Set F`\nbe a family of convex sets. Suppose that for each point `x : M` there exists a neighborhood\n`U \u2208 \ud835\udcdd x` and a function `g : M \u2192 F` such that `g` is $C^n$ smooth on `U` and `g y \u2208 t y` for all\n`y \u2208 U`. Then there exists a $C^n$ smooth function `g : C^n\u27eeI, M; \ud835\udcd8(\u211d, F), F\u27ef` such that `g x \u2208 t x`\nfor all `x`.\n\nThis is a special case of `exists_contMDiffOn_section_forall_mem_convex_of_local` where `V` is the\ntrivial bundle. See also `exists_smooth_forall_mem_convex_of_local` and\n`exists_smooth_forall_mem_convex_of_local_const`. -/\ntheorem exists",
      "suggestion": "  Emetric.exists_contMDiffMap_forall_closedBall_subset\n",
      "body": "```suggestion\n  Emetric.exists_contMDiffMap_forall_closedBall_subset\n```",
      "path": "Mathlib/Geometry/Manifold/PartitionOfUnity.lean",
      "tags": {
        "before_tactics": [
          "simpa",
          "exact",
          "have"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "exact",
          "have"
        ],
        "topics": [
          "algebra",
          "list",
          "real",
          "topology",
          "norm",
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mpr",
          "exists_smooth_forall_closedBall_subset",
          "exists_smooth_forall_mem_convex_of_local",
          "Type",
          "family",
          "s_loc",
          "interior_subset",
          "open",
          "F_fiber",
          "have",
          "forall_and",
          "such",
          "also",
          "TopologicalSpace",
          "trivial",
          "exists_smooth_section_forall_mem_convex_of_local",
          "See",
          "that",
          "h_x_in_Umap_j",
          "distance",
          "IsClosed",
          "extended",
          "theorem",
          "contMDiffAt_section",
          "Then",
          "vector",
          "any",
          "mem_iInter",
          "hgs",
          "Bundle",
          "ofReal",
          "bundle",
          "when",
          "hKU",
          "viewed",
          "point",
          "closed",
          "NormedAddCommGroup",
          "special",
          "Suppose",
          "SigmaCompactSpace",
          "hfin",
          "sets",
          "global",
          "positive",
          "dimensional",
          "convex",
          "neighborhood",
          "space"
        ]
      }
    },
    {
      "id": 4632,
      "before_code": "have h_x_in_Umap_j : x \u2208 W j := interior_subset (h\u03c1U j h_x_in_tsupport_\u03c1j)\n  exact h_mem_t j x h_x_in_Umap_j\n\n/-- Let `V` be a vector bundle over a \u03c3-compact Hausdorff finite-dimensional topological manifold\n`M`. Let `t : M \u2192 Set (V x)` be a family of convex sets in the fibers of `V`.\nSuppose that for each point `x\u2080 : M` there exists a neighborhood `U_x\u2080` of `x\u2080` and a local\nsection `s_loc : M \u2192 V x` such that `s_loc` is $C^\u221e$ smooth on `U_x\u2080` (when viewed as a map to\nthe total space of the bundle) and `s_loc y \u2208 t y` for all `y \u2208 U_x\u2080`.\nThen there exists a global smooth section `s : C\u209b^\u221e\u27eeI_M; F_fiber, V\u27ef` such that\n`s x \u2208 t x` for all `x : M`.\n-/\ntheorem exists_smooth_section_forall_mem_convex_of_local\n    {F_fiber : Type*} [NormedAddCommGroup F_fiber] [NormedSpace \u211d F_fiber]\n    (V : M \u2192 Type*) [\u2200 x, NormedAddCommGroup (V x)] [\u2200 x, Module \u211d (V x)]\n    [TopologicalSpace (TotalSpace F_fiber V)] [FiberBundle F_fiber V] [VectorBundle \u211d F_fiber V]\n    (t : \u2200 x, Set (V x)) (ht_conv : \u2200 x, Convex \u211d (t x))\n    (Hloc :\n      \u2200 x\u2080 : M, \u2203 U_x\u2080 \u2208 \ud835\udcdd x\u2080, \u2203 (s_loc : (x : M) \u2192 V x),\n        (ContMDiffOn I (I.prod \ud835\udcd8(\u211d, F_fiber)) \u221e (fun x \u21a6 TotalSpace.mk' F_fiber x (s_loc x)) U_x\u2080) \u2227\n        (\u2200 y \u2208 U_x\u2080, s_loc y \u2208 t y)) :\n    \u2203 s : C\u209b^\u221e\u27eeI; F_fiber, V\u27ef, \u2200 x : M, s x \u2208 t x :=\n      exists_contMDiffOn_section_forall_mem_convex_of_local I V t ht_conv Hloc\n\n/-- Let `M` be a \u03c3-compact Hausdorff finite-dimensional topological manifold. Let `t : M \u2192 Set F`\nbe a family of convex sets. Suppose that for each point `x : M` there exists a neighborhood\n`U \u2208 \ud835\udcdd x` and a function `g : M \u2192 F` such that `g` is $C^n$ smooth on `U` and `g y \u2208 t y` for all\n`y \u2208 U`. Then there exists a $C^n$ smooth function `g : C^n\u27eeI, M; \ud835\udcd8(\u211d, F), F\u27ef` such that `g x \u2208 t x`\nfor all `x`.\n\nThis is a special case of `exists_contMDiffOn_section_forall_mem_convex_of_local` where `V` is the\ntrivial bundle. See also `exists_smooth_forall_mem_convex_of_local` and\n`exists_smooth_forall_mem_convex_of_local_const`. -/\ntheorem exists",
      "suggestion": "  Metric.exists_contMDiffMap_forall_closedBall_subset\n",
      "body": "```suggestion\n  Metric.exists_contMDiffMap_forall_closedBall_subset\n```",
      "path": "Mathlib/Geometry/Manifold/PartitionOfUnity.lean",
      "tags": {
        "before_tactics": [
          "refine",
          "exact",
          "cases",
          "have",
          "simpa",
          "rw"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa",
          "rw",
          "refine",
          "exact",
          "cases",
          "have"
        ],
        "topics": [
          "algebra",
          "list",
          "real",
          "topology",
          "norm",
          "set_theory",
          "order"
        ],
        "transforms": [],
        "keywords": [
          "Module",
          "mpr",
          "exists_smooth_forall_closedBall_subset",
          "exists_smooth_forall_mem_convex_of_local",
          "Type",
          "family",
          "s_loc",
          "interior_subset",
          "open",
          "F_fiber",
          "have",
          "forall_and",
          "such",
          "emetric_closedBall",
          "also",
          "TopologicalSpace",
          "trivial",
          "exists_smooth_section_forall_mem_convex_of_local",
          "See",
          "that",
          "h_x_in_Umap_j",
          "distance",
          "IsClosed",
          "support",
          "extended",
          "theorem",
          "contMDiffAt_section",
          "Then",
          "vector",
          "any",
          "mem_iInter",
          "hgs",
          "Bundle",
          "ofReal",
          "bundle",
          "when",
          "hKU",
          "viewed",
          "point",
          "closed",
          "NormedAddCommGroup",
          "special",
          "Suppose",
          "SigmaCompactSpace",
          "hfin",
          "ContMDiff",
          "sets",
          "global",
          "positive",
          "dimensional"
        ]
      }
    },
    {
      "id": 4635,
      "before_code": "-/\nmodule\n\npublic import Mathlib.Algebra.GroupWithZero.Indicator\npublic import Mathlib.Topology.Piecewise\npublic import Mathlib.Topology.Instances.ENNReal.Lemmas\n\n/-!\n# Semicontinuous maps",
      "suggestion": "# Lower and Upper Semicontinuity\n",
      "body": "This reads a bit weirdly?\n```suggestion\n# Lower and Upper Semicontinuity\n```",
      "path": "Mathlib/Topology/Semicontinuity/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "continuity",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Indicator",
          "maps",
          "Instances",
          "ENNReal",
          "import",
          "Mathlib",
          "public",
          "Topology",
          "module",
          "Piecewise",
          "Semicontinuous",
          "Lemmas",
          "Algebra",
          "GroupWithZero"
        ]
      }
    },
    {
      "id": 4636,
      "before_code": "* <https://en.wikipedia.org/wiki/Closed_convex_function>\n* <https://en.wikipedia.org/wiki/Semi-continuity>",
      "suggestion": "+ lower and upper semicontinuity correspond to `r := (f \u00b7 > \u00b7)` and `r := (f \u00b7 < \u00b7)`;\n",
      "body": "Let's save a future PR from Harald:\n```suggestion\n+ lower and upper semicontinuity correspond to `r := (f \u00b7 > \u00b7)` and `r := (f \u00b7 < \u00b7)`;\n```",
      "path": "Mathlib/Topology/Semicontinuity/Basic.lean",
      "tags": {
        "before_tactics": [
          "continuity"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "continuity"
        ],
        "topics": [],
        "transforms": [],
        "keywords": [
          "https",
          "wikipedia",
          "continuity",
          "Closed_convex_function",
          "Semi",
          "wiki",
          "org"
        ]
      }
    },
    {
      "id": 4643,
      "before_code": "def of (C : Type u) [Category.{v} C] : Cat.{v, u} :=\n  Bundled.of C",
      "suggestion": "\r\n  id_comp \u03b7 := congrArg (NatTrans.toCatHom\u2082) (Category.id_comp \u03b7.toNatTrans)\r\n  comp_id \u03b7 := congrArg (NatTrans.toCatHom\u2082) (Category.comp_id \u03b7.toNatTrans)\r\n  assoc \u03b7\u2081 \u03b7\u2082 \u03b7\u2083 :=\r\n    congrArg (NatTrans.toCatHom\u2082) (Category.assoc \u03b7\u2081.toNatTrans \u03b7\u2082.toNatTrans \u03b7\u2083.toNatTrans)\r\n",
      "body": "```suggestion\r\n  id_comp \u03b7 := congrArg (NatTrans.toCatHom\u2082) (Category.id_comp \u03b7.toNatTrans)\r\n  comp_id \u03b7 := congrArg (NatTrans.toCatHom\u2082) (Category.comp_id \u03b7.toNatTrans)\r\n  assoc \u03b7\u2081 \u03b7\u2082 \u03b7\u2083 :=\r\n    congrArg (NatTrans.toCatHom\u2082) (Category.assoc \u03b7\u2081.toNatTrans \u03b7\u2082.toNatTrans \u03b7\u2083.toNatTrans)\r\n```\r\nDoes this not work?",
      "path": "Mathlib/CategoryTheory/Category/Cat.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "def",
          "Category",
          "Cat",
          "Type",
          "Bundled"
        ]
      }
    },
    {
      "id": 4644,
      "before_code": "def of (C : Type u) [Category.{v} C] : Cat.{v, u} :=\n  Bundled.of C",
      "suggestion": "\r\n  hom_inv_id := congrArg NatTrans.toCatHom\u2082 e.hom_inv_id\r\n  inv_hom_id := congrArg NatTrans.toCatHom\u2082 e.inv_hom_id\r\n",
      "body": "```suggestion\r\n  hom_inv_id := congrArg NatTrans.toCatHom\u2082 e.hom_inv_id\r\n  inv_hom_id := congrArg NatTrans.toCatHom\u2082 e.inv_hom_id\r\n```\r\nagain",
      "path": "Mathlib/CategoryTheory/Category/Cat.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "def",
          "Category",
          "Cat",
          "Type",
          "Bundled"
        ]
      }
    },
    {
      "id": 4645,
      "before_code": "add_smul _ _ _ := ext fun _ \u21a6 add_mul _ _ _\n  zero_smul _ := ext fun _ \u21a6 zero_mul _\n\n@[simp] lemma zero_apply (x : \u211d) : (0 : StieltjesFunction) x = 0 := rfl\n\n@[simp] lemma add_apply (f g : StieltjesFunction) (x : \u211d) : (f + g) x = f x + g x := rfl\n\n/-- If a function `f : \u211d \u2192 \u211d` is monotone, then the function mapping `x` to the right limit of `f`\nat `x` is a Stieltjes function, i.e., it is monotone and right-continuous. -/\nnoncomputable def _root_.Monotone.stieltjesFunction {f : \u211d \u2192 \u211d} (hf : Monotone f) :\n    StieltjesFunction where\n  toFun := rightLim f\n  mono' _ _ hxy := hf.rightLim hxy\n  right_continuous' := by\n    intro x s hs\n    obtain \u27e8l, u, hlu, lus\u27e9 : \u2203 l u : \u211d, rightLim f x \u2208 Ioo l u \u2227 Ioo l u \u2286 s :=\n      mem_nhds_iff_exists_Ioo_subset.1 hs\n    obtain \u27e8y, xy, h'y\u27e9 : \u2203 (y : \u211d), x < y \u2227 Ioc x y \u2286 f \u207b\u00b9' Ioo l u :=\n      mem_nhdsGT_iff_exists_Ioc_subset.1 (hf.tendsto_rightLim x (Ioo_mem_nhds hlu.1 hlu.2))\n    change \u2200\u1da0 y in \ud835\udcdd[\u2265] x, rightLim f y \u2208 s\n    filter_upwards [Ico_mem_nhdsGE xy] with z hz\n    apply lus\n    refine \u27e8hlu.1.trans_le (hf.rightLim hz.1), ?_\u27e9\n    obtain \u27e8a, za, ay\u27e9 : \u2203 a : \u211d, z < a \u2227 a < y := exists_between hz.2\n    calc\n      rightLim f z \u2264 f a := hf.rightLim_le za\n      _ < u := (h'y \u27e8hz.1.trans_lt za, ay.le\u27e9).2\n\ntheorem _root_.Monotone.stieltjesFunction_eq {f : \u211d \u2192 \u211d} (hf : Monotone f) (x : \u211d) :\n    hf.stieltjesFunction x = rightLim f x :=\n  rfl\n\ntheorem countable_leftLim_ne (f : StieltjesFunction) : Set.Countable { x | leftLim f x \u2260 f x } := by\n  refine Countable.mono ?_ f.mono.countable_not_continuousAt\n  intro x hx h'x\n  apply hx\n  exact tendsto_nhds_unique (f.mono.tendsto_leftLim x) (h'x.tendsto.mono_left nhdsWithin_le_nhds)\n\n/-! ### The outer measure associated to a Stieltjes function -/\n\n\n/-- Length of an interval. This is the largest monotone function which correctly measures all\nintervals. -/\ndef length (s : Set \u211d) : \u211d\u22650\u221e :=\n  \u2a05 (a) (b) (_ : s \u2286 Ioc a b), ofReal (f b - f a)\n\n@[simp]\ntheorem length_empty : f.length \u2205 = 0 :=\n  nonpos_",
      "suggestion": "To be able to handle also the top element if there is one, we use `Iotop` instead of `Ioo` in the\n",
      "body": "```suggestion\nTo be able to handle also the top element if there is one, we use `Iotop` instead of `Ioo` in the\n```",
      "path": "Mathlib/MeasureTheory/Measure/Stieltjes.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "refine",
          "ext",
          "exact",
          "cases",
          "obtain",
          "rw",
          "simp",
          "intro",
          "induction"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "refine",
          "ext",
          "exact",
          "cases",
          "obtain",
          "rw",
          "simp",
          "intro",
          "induction"
        ],
        "topics": [
          "function",
          "nat",
          "continuity",
          "real",
          "topology",
          "set_theory",
          "order",
          "measurability"
        ],
        "transforms": [],
        "keywords": [
          "nonpos_iff_eq_zero",
          "ofFunction_le",
          "calc",
          "ofFunction",
          "which",
          "toNNReal_le_toNNReal",
          "iInf_mono",
          "open",
          "limit",
          "add_apply",
          "monotone",
          "reduce",
          "intro",
          "mem_nhds_iff_exists_Ioo_subset",
          "stieltjesFunction_eq",
          "tendsto_leftLim",
          "argue",
          "tendsto",
          "def",
          "length_Ioc",
          "mono_left",
          "that",
          "simp",
          "le_iInf",
          "rfl",
          "length",
          "theorem",
          "statement",
          "Stieltjes",
          "tendsto_nhds_unique",
          "trans",
          "stieltjesFunction",
          "outer",
          "Countable",
          "ofReal",
          "nhdsWithin_le_nhds",
          "compactness",
          "Ico_mem_nhdsGE",
          "apply",
          "ext",
          "_root_",
          "rightLim_le",
          "Subset",
          "mem_nhdsGT_iff_exists_Ioc_subset",
          "set",
          "point",
          "hxy",
          "sum",
          "prove",
          "coe_le_coe"
        ]
      }
    },
    {
      "id": 4648,
      "before_code": "(by exact Cocones.ext (Iso.refl _)))\n    (hY.whiskerEquivalence (CostructuredArrow.mapNatIso e.symm))\n\n/-- If `F : C \u2964 D` is dense at `Y : D`, then so is `G \u22d9 F` if `G` is an equivalence. -/\nnoncomputable def DenseAt.precompEquivalence\n    {C' : Type*} [Category* C'] (G : C' \u2964 C) [G.IsEquivalence] :",
      "suggestion": "  Functor.Final.isColimitWhiskerEquiv (CostructuredArrow.pre G F Y)\n    ((LeftExtension.mk (\ud835\udfed D) F.rightUnitor.inv).coconeAt Y)\n",
      "body": "```suggestion\n  Functor.Final.isColimitWhiskerEquiv (CostructuredArrow.pre G F Y)\n    ((LeftExtension.mk (\ud835\udfed D) F.rightUnitor.inv).coconeAt Y)\n```",
      "path": "Mathlib/CategoryTheory/Functor/KanExtension/DenseAt.lean",
      "tags": {
        "before_tactics": [
          "exact",
          "ext"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "exact",
          "ext"
        ],
        "topics": [
          "equiv"
        ],
        "transforms": [],
        "keywords": [
          "Type",
          "refl",
          "symm",
          "noncomputable",
          "ext",
          "equivalence",
          "precompEquivalence",
          "CostructuredArrow",
          "IsEquivalence",
          "DenseAt",
          "Iso",
          "whiskerEquivalence",
          "then",
          "def",
          "dense",
          "exact",
          "Category",
          "Cocones",
          "mapNatIso"
        ]
      }
    },
    {
      "id": 4649,
      "before_code": "__ := instAddCommMonoid r\n  __ := instMonoidWithZero r\n\n-- can't be irreducible, causes diamonds in \u2124-algebras\nprivate def intCast {R : Type uR} [Ring R] (r : R \u2192 R \u2192 Prop) (z : \u2124) : RingQuot r :=\n  \u27e8Quot.mk _ z\u27e9",
      "suggestion": "",
      "body": "This option is now globally false, so I think you can drop this line\n```suggestion\n```",
      "path": "Mathlib/Algebra/RingQuot.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "int",
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "can",
          "algebras",
          "Quot",
          "def",
          "irreducible",
          "Ring",
          "private",
          "Type",
          "intCast",
          "diamonds",
          "instMonoidWithZero",
          "Prop",
          "RingQuot",
          "causes",
          "instAddCommMonoid"
        ]
      }
    },
    {
      "id": 4650,
      "before_code": "variable [Zero M]\n\nprivate irreducible_def onFinset_support (s : Finset \u03b1) (f : \u03b1 \u2192 M) : Finset \u03b1 :=\n  haveI := Classical.decEq M\n  {a \u2208 s | f a \u2260 0}",
      "suggestion": "",
      "body": "Idem dito\n```suggestion\n```",
      "path": "Mathlib/Data/Finsupp/Defs.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [
          "order",
          "finset"
        ],
        "transforms": [],
        "keywords": [
          "Classical",
          "variable",
          "private",
          "Finset",
          "onFinset_support",
          "irreducible_def",
          "decEq",
          "Zero",
          "haveI"
        ]
      }
    },
    {
      "id": 4651,
      "before_code": "instance finCategoryDiscreteOfFintype (J : Type v) [Fintype J] : FinCategory (Discrete J) where",
      "suggestion": "",
      "body": "```suggestion\n```",
      "path": "Mathlib/CategoryTheory/FinCategory/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Discrete",
          "Type",
          "Fintype",
          "FinCategory",
          "finCategoryDiscreteOfFintype",
          "instance"
        ]
      }
    },
    {
      "id": 4652,
      "before_code": "| refl : ReflGen r a a\n  | single {b} : r a b \u2192 ReflGen r a b",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Logic/Relation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "single",
          "refl",
          "ReflGen"
        ]
      }
    },
    {
      "id": 4653,
      "before_code": "| symm x y : EqvGen x y \u2192 EqvGen y x\n  | trans x y z : EqvGen x y \u2192 EqvGen y z \u2192 EqvGen x z",
      "suggestion": "\r\n",
      "body": "```suggestion\r\n```",
      "path": "Mathlib/Logic/Relation.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "EqvGen",
          "symm",
          "trans"
        ]
      }
    },
    {
      "id": 4654,
      "before_code": "| single h => exact TransGen.single h\n  | tail _ hbc ih => exact ih.head hbc",
      "suggestion": "\r\n@[grind =]\r\n",
      "body": "This one is surprising to me, it'll fire any time it sees `TransGen r a b`, which I think is too general. I think this is much more reasonable:\r\n```suggestion\r\n@[grind =]\r\n```",
      "path": "Mathlib/Logic/Relation.lean",
      "tags": {
        "before_tactics": [
          "exact"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "exact"
        ],
        "topics": [
          "list"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "exact",
          "head",
          "TransGen",
          "single",
          "tail",
          "hbc"
        ]
      }
    },
    {
      "id": 4657,
      "before_code": "mk (f x) = 0 := by\n  simpa using mk_map_of_archimedean f.toOrderAddMonoidHom h",
      "suggestion": "\r\ntheorem mk_le_mk_add_of_archimedean [Archimedean S] (f : S \u2192+*o R) (x : R) (y : S) :\r\n    0 \u2264 mk (f y) := by\r\n",
      "body": "Why is this different to \r\n```suggestion\r\ntheorem mk_le_mk_add_of_archimedean [Archimedean S] (f : S \u2192+*o R) (x : R) (y : S) :\r\n    0 \u2264 mk (f y) := by\r\n```\r\n?",
      "path": "Mathlib/Algebra/Order/Ring/Archimedean.lean",
      "tags": {
        "before_tactics": [
          "simpa"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "simpa"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "simpa",
          "using",
          "mk_map_of_archimedean",
          "toOrderAddMonoidHom"
        ]
      }
    },
    {
      "id": 4659,
      "before_code": "theorem house_mul_le (\u03b1 \u03b2 : K) : house (\u03b1 * \u03b2) \u2264 house \u03b1 * house \u03b2 := by\n  simp only [house, map_mul]; apply norm_mul_le",
      "suggestion": "",
      "body": "Idem dito\n```suggestion\n```",
      "path": "Mathlib/NumberTheory/NumberField/House.lean",
      "tags": {
        "before_tactics": [
          "apply",
          "simp"
        ],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [
          "apply",
          "simp"
        ],
        "topics": [
          "norm"
        ],
        "transforms": [],
        "keywords": [
          "house",
          "apply",
          "theorem",
          "map_mul",
          "simp",
          "house_mul_le",
          "only",
          "norm_mul_le"
        ]
      }
    },
    {
      "id": 4660,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "    \u00b7 specialize hn hij.symm\n      grind [mul_nonneg_iff, mul_nonpos_iff]\n",
      "body": "```suggestion\n    \u00b7 specialize hn hij.symm\n      grind [mul_nonneg_iff, mul_nonpos_iff]\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "grind"
        ],
        "body_tactics": [
          "grind"
        ],
        "new_tactics": [
          "grind"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [
          "use_grind"
        ],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 4661,
      "before_code": "end Ring\n\nend QuadraticForm",
      "suggestion": "    rw [\u2190 hc, hx\u2080] at hy\n",
      "body": "```suggestion\n    rw [\u2190 hc, hx\u2080] at hy\n```",
      "path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean",
      "tags": {
        "before_tactics": [
          "ring"
        ],
        "suggestion_tactics": [
          "rw"
        ],
        "body_tactics": [
          "rw"
        ],
        "new_tactics": [
          "rw"
        ],
        "removed_tactics": [
          "ring"
        ],
        "topics": [
          "algebra"
        ],
        "transforms": [],
        "keywords": [
          "Ring",
          "QuadraticForm",
          "end"
        ]
      }
    },
    {
      "id": 4662,
      "before_code": "end Cauchy",
      "suggestion": "",
      "body": "Let's drop this here and instead add it as the first line of the proof (since it is needed only for the proof and not the statement)\n```suggestion\n```",
      "path": "Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean",
      "tags": {
        "before_tactics": [],
        "suggestion_tactics": [],
        "body_tactics": [],
        "new_tactics": [],
        "removed_tactics": [],
        "topics": [],
        "transforms": [],
        "keywords": [
          "Cauchy",
          "end"
        ]
      }
    }
  ],
  "stats": {
    "total_examples": 1905,
    "tactics": [
      "have",
      "refine",
      "simp",
      "rw",
      "apply",
      "grind",
      "simpa",
      "exact",
      "intro",
      "obtain",
      "induction",
      "gcongr",
      "cases",
      "congr",
      "ext",
      "fun_prop",
      "aesop",
      "norm_num",
      "omega",
      "measurability",
      "norm_cast",
      "positivity",
      "linarith",
      "simp_all",
      "field_simp",
      "ring",
      "decide",
      "fin_cases",
      "funext",
      "ring_nf",
      "push_cast",
      "constructor",
      "continuity"
    ],
    "topics": [
      "list",
      "set_theory",
      "nat",
      "continuity",
      "order",
      "function",
      "algebra",
      "finset",
      "real",
      "complex",
      "norm",
      "differentiability",
      "int",
      "equiv",
      "measurability",
      "topology"
    ],
    "transforms": [
      "use_simpa",
      "use_aesop",
      "use_grind",
      "cleanup_simp",
      "use_fun_prop",
      "term_mode",
      "use_omega",
      "use_ring",
      "use_linarith",
      "remove_redundant",
      "use_simp",
      "line_break",
      "naming"
    ]
  }
}